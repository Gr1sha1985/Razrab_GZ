// Обеспечивает выполнение Стандарта обмена данными с программами типа "Клиент банка"
// См. http://v8.1c.ru/edi/edi_stnd/100

#Область ПрограммныйИнтерфейс

// Возвращает резудьтат чтения из временного файла, в коллекцию НовыйДанныеИзБанка()
// При этом в начале чтение происходит с переданным значением параметра ОдиночныйРазделительСтрок,
// а если чтение не удалось, то параметр варьируется,
// чтобы гарантированно прочитать файл в случае использования в нем любого разделителя.
//
// Параметры:
//  ИмяФайла	 - Строка - Имя временного файла на компьютере, на котором расположен сервер 1С:Предприятия. Файл должен существовать и быть пригодным для чтения.
//  Кодировка	 - КодировкаТекста - Кодировка временного файла. Допускается КодировкаТекста.OEM или КодировкаТекста.ANSI
//  ОдиночныйРазделительСтрок - Булево - Истина, если строки файла разделены одним символом ПС (LF); Ложь, если строки файла разделены двумя символами ВК+ПС (CR+LF)
// 
// Возвращаемое значение:
//  Структура - содержит ключи
//   * ДанныеИзБанка - НовыйДанныеИзБанка()       - коллекция прочитанных данных
//   * Протокол      - НовыйПротоколЧтенияФайла() - протокол, по которому можно оценить соответствие прочитанного файла стандарту
//
Функция РезультатЧтенияФайла(ИмяФайла, Кодировка, ОдиночныйРазделительСтрок = Ложь) Экспорт
	
	Результат = ПрочитатьФайл(ИмяФайла, Кодировка, ОдиночныйРазделительСтрок);
	
	Если Не ОдиночныйРазделительСтрок Тогда
		// Данные могут быть прочитаны неверно, если файл фактически содержит одиночный разделитель
		ДанныеФайлаПовреждены =
			(Результат.Протокол.Найти("ФайлСодержитНачальныйТег", "КодСобытия") = Неопределено)
			И (Результат.Протокол.Найти("ФайлСодержитСтрокиДоНачальногоТега", "КодСобытия") <> Неопределено);
		Если ДанныеФайлаПовреждены Тогда
			// Предпримем попытку прочитать файл с одиночным разделителем строк
			ОдиночныйРазделительСтрок = Истина;
			Результат = ПрочитатьФайл(ИмяФайла, Кодировка, ОдиночныйРазделительСтрок);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Помещает данные, прочитанные из временного файла, в коллекцию НовыйДанныеИзБанка()
//
// Параметры:
//  ИмяФайла	 - Строка - Имя временного файла на компьютере, на котором расположен сервер 1С:Предприятия. Файл должен существовать и быть пригодным для чтения.
//  Кодировка	 - КодировкаТекста - Кодировка временного файла. Допускается КодировкаТекста.OEM или КодировкаТекста.ANSI
//  ОдиночныйРазделительСтрок - Булево - Истина, если строки файла разделены одним символом ПС (LF); Ложь, если строки файла разделены двумя символами ВК+ПС (CR+LF)
// 
// Возвращаемое значение:
//  Структура - содержит ключи
//   * ДанныеИзБанка - НовыйДанныеИзБанка()       - коллекция прочитанных данных
//   * Протокол      - НовыйПротоколЧтенияФайла() - протокол, по которому можно оценить соответствие прочитанного файла стандарту
//
Функция ПрочитатьФайл(ИмяФайла, Кодировка, ОдиночныйРазделительСтрок)
	
	РезультатРазбораФайла = Новый Структура;
	РезультатРазбораФайла.Вставить("ДанныеИзБанка",    НовыйДанныеИзБанка());
	РезультатРазбораФайла.Вставить("Протокол",         НовыйПротоколЧтенияФайла());
	
	ОписаниеФайлаОбмена = ОписаниеФайлаОбмена(); // Из каких частей, секций, тегов должен состоять файл
	
	// Тип файла передаем в виде строки, чтобы обеспечить корректное чтение файла в нелокализованных средах
	// (Linux, англоязычная Windows + англоязычный MS SQL и др.)
	Если Кодировка = Неопределено Тогда
		ТипФайла = ТипФайла(ИмяФайла);
	ИначеЕсли Кодировка = КодировкаТекста.OEM Тогда
		ТипФайла = "cp866";
	Иначе
		ТипФайла = "windows-1251";
	КонецЕсли;
	
	Если ТипФайла = "cp866" Тогда
		ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, ТипФайла,,,Ложь);
	Иначе
		// Если в файле строки разделены CR+LF, то одиночные LF не разделяют логические строки файла, а содержится в прикладных данных.
		// При этом в отдельных полях (многострочных) они разделяют подстроки,
		// а в остальных, как правило, содержатся по ошибке и должны быть проигнорированы.
		//
		// Чтобы отличить ошибочные одиночные LF от корректных разделителей CR+LF,
		// при чтении файла используем только двухсимвольный разделитель (CR+LF),
		// а если необходимо избавиться от ошибочных LF (Символы.ПС), то делаем это после чтения строк (перед помещением данных в Секция.Данные).
		//
		// Если же в файле строки разделены одиночным LF, то отличить ошибочные LF от корректных нельзя.
		// Поэтому при чтении файла используем обычный набор разделителей. При этом ошибочно отделенные элементы строк могут быть проигнорированы.
		ДвухсимвольныйРазделительСтрок = Символы.ВК + Символы.ПС;
		Если ОдиночныйРазделительСтрок Тогда
			// Значения по умолчанию. В конструктор их следует передать явно, так как значение пятого параметра указано явно.
			РазделительСтрок               = Символы.ПС;
			КонвертируемыйРазделительСтрок = ДвухсимвольныйРазделительСтрок;
		Иначе
			РазделительСтрок               = ДвухсимвольныйРазделительСтрок;
			КонвертируемыйРазделительСтрок = "";
		КонецЕсли;
		ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, ТипФайла, РазделительСтрок, КонвертируемыйРазделительСтрок, Ложь);
	КонецЕсли;
	
	// Файл состоит из секций. См. ОписаниеФайлаОбмена.Секции
	// Секции могут быть вложенными (2 уровня) и последовательными (например, на каждый документ - отдельная секция).
	// При обходе файла будем отмечать, к какой секции относится конкретная строка файла, и накапливать все данные, относящиеся к этой секции.
	// Когда из данных файла будет понятно, что секция закончилась, 
	// то перельем накопленные данные по этой секции в общую коллекцию с данными файла - см. ПеренестиВДанныеБанка().
	// Файл может содержать строки с разделителями - многострочный текст.
	// При этом логически единые данные будут прочитаны как разные строки файла.
	// Накапливать данные важно, чтобы не потерять части значений таких строк.
	СтекСекций = Новый ТаблицаЗначений;      // Секция Файл содержит секции Остатки, Документы, Условия.РасчСчет, Условия.Документ
	СтекСекций.Колонки.Добавить("Описание"); // Ссылка на строку таблицы значений ОписаниеФайлаОбмена.Секции
	СтекСекций.Колонки.Добавить("Данные",            Новый ОписаниеТипов("Структура"));
	СтекСекций.Колонки.Добавить("ПредыдущийЭлемент", Новый ОписаниеТипов("Строка"));// К нему можем прицепить строку, если она похожа на часть многострочного текста.
	
	НомерСтрокиФайла = 0;
	
	Пока Истина Цикл
		
		ТекстСтрокиФайла = ЧтениеТекста.ПрочитатьСтроку();
		
		Если ТекстСтрокиФайла = Неопределено Тогда 
			Пока ЗначениеЗаполнено(СтекСекций) Цикл
				ПеренестиВДанныеБанка(РезультатРазбораФайла.ДанныеИзБанка, СтекСекций, ОписаниеФайлаОбмена);// Данные недочитанных секции поместим в ДанныеИзБанка
			КонецЦикла;
			Прервать; // Также цикл может быть прерван, если прочитали конечный тег файла
		КонецЕсли;
		
		НомерСтрокиФайла = НомерСтрокиФайла + 1;
		
		Если ПустаяСтрока(ТекстСтрокиФайла) Тогда
			ЗаписатьВПротокол(РезультатРазбораФайла.Протокол, НомерСтрокиФайла, "ПустаяСтрока");
			Продолжить;
		КонецЕсли;
		
		Тег              = "";
		Значение         = Неопределено;
		РазделитьСтрокуФайла(ТекстСтрокиФайла, Тег, Значение);
		
		Если Не ЗначениеЗаполнено(СтекСекций) Тогда
			// Допускается только начало секции "Файл"
			НачалоСекции = ОписаниеФайлаОбмена.Секции.Найти(Тег, "НачальныйТег");
			Если НачалоСекции = Неопределено Или НачалоСекции.Имя <> "Файл" Тогда
				ЗаписатьВПротокол(РезультатРазбораФайла.Протокол, НомерСтрокиФайла, "ФайлСодержитСтрокиДоНачальногоТега");
			Иначе
				ЗаписатьВПротокол(РезультатРазбораФайла.Протокол, НомерСтрокиФайла, "ФайлСодержитНачальныйТег");
				Секция = СтекСекций.Вставить(0);
				Секция.Описание = НачалоСекции;
			КонецЕсли;
			Продолжить;
		КонецЕсли;
		
		Секция = СтекСекций[0];
		
		Если Секция.Описание.Элементы[Тег] <> Неопределено // Прочитан валидный тег с данными
			И Не Секция.Данные.Свойство(Тег) Тогда         // Для этой секции такой тег ранее не был прочитан
			
			Если Секция.Описание.МногострочныеЭлементы[Тег] <> Неопределено Тогда
				// При чтении следующей строки можем дополнить значение этого элемента
				Секция.ПредыдущийЭлемент = Тег;
			Иначе
				Секция.ПредыдущийЭлемент = "";
				Значение = СтрЗаменить(Значение, Символы.ПС, "");// однострочные элементы не должны содержать разделителей строк
			КонецЕсли;
			
			Если Не ПустаяСтрока(Значение) Тогда
				Секция.Данные.Вставить(Тег, Значение);
			КонецЕсли;
			
			Продолжить;
			
		КонецЕсли;
		
		// Переход между секциями
		КонецСекции = ОписаниеФайлаОбмена.Секции.Найти(Тег, "КонечныйТег");
		Если КонецСекции <> Неопределено Тогда
			
			Если КонецСекции.Имя = "Файл" Тогда
				// Закончили чтение файла.
				ЗаписатьВПротокол(РезультатРазбораФайла.Протокол, НомерСтрокиФайла, "ФайлСодержитКонечныйТег");
				ПеренестиВДанныеБанка(РезультатРазбораФайла.ДанныеИзБанка, СтекСекций, ОписаниеФайлаОбмена);
				Если ЧтениеТекста.ПрочитатьСтроку() <> Неопределено Тогда
					ЗаписатьВПротокол(РезультатРазбораФайла.Протокол, НомерСтрокиФайла, "ФайлСодержитСтрокиПослеКонечногоТега");
				КонецЕсли;
				Прервать;
			ИначеЕсли Секция.Описание.Имя = КонецСекции.Имя Тогда
				// Закончили чтение секции
				ПеренестиВДанныеБанка(РезультатРазбораФайла.ДанныеИзБанка, СтекСекций, ОписаниеФайлаОбмена);
				// Готовы читать тег начала следующей секции
				Продолжить;
			КонецЕсли;
			
		КонецЕсли;
		
		НачалоСекции = ОписаниеФайлаОбмена.Секции.Найти(Тег, "НачальныйТег");
		Если НачалоСекции <> Неопределено Тогда
			
			Если СтекСекций.Количество() > 1 Тогда
				// Началась секция на том же уровне. Всего может быть два уровня.
				ЗаписатьВПротокол(РезультатРазбораФайла.Протокол, НомерСтрокиФайла, "ПропущенКонечныйТегСекции");
				ПеренестиВДанныеБанка(РезультатРазбораФайла.ДанныеИзБанка, СтекСекций, ОписаниеФайлаОбмена);
			ИначеЕсли ЗначениеЗаполнено(СтекСекций) Тогда
				Секция.ПредыдущийЭлемент = ""; // Секция Файл разбита другой секцией. По окончании другой секции может следовать новый тег, но не продолжение элемента.
			КонецЕсли;
			Секция = СтекСекций.Вставить(0);
			Секция.Описание = НачалоСекции;
			
			// Начальный тег секции может содержать значение
			Если Секция.Описание.Элементы[Тег] <> Неопределено Тогда
				Если Секция.Описание.МногострочныеЭлементы[Тег] = Неопределено Тогда
					Значение = СтрЗаменить(Значение, Символы.ПС, "");// однострочные элементы не должны содержать разделителей строк
				КонецЕсли;
				Секция.Данные.Вставить(Тег, Значение);
			КонецЕсли;
			
			// Начальный тег может быть и конечным
			Если Секция.Описание.НачальныйТег = Секция.Описание.КонечныйТег Тогда
				ПеренестиВДанныеБанка(РезультатРазбораФайла.ДанныеИзБанка, СтекСекций, ОписаниеФайлаОбмена);
				Продолжить;
			КонецЕсли;
			
		ИначеЕсли Не ПустаяСтрока(Секция.ПредыдущийЭлемент) Тогда
			// Тег в этой строке неизвестен.
			// Но эта строка может быть продолжением многострочного текста.
			Секция.Данные[Секция.ПредыдущийЭлемент] = Секция.Данные[Секция.ПредыдущийЭлемент] + Символы.ПС + ТекстСтрокиФайла;
			ЗаписатьВПротокол(РезультатРазбораФайла.Протокол, НомерСтрокиФайла, "ТекстСтрокиДобавленВПредыдущийТег");
		Иначе
			// Тег в этой строке неизвестен или отсутствует вовсе.
			// Данные этой строки не могут быть обработаны
			ЗаписатьВПротокол(РезультатРазбораФайла.Протокол, НомерСтрокиФайла, "ДанныеНеМогутБытьОбработаны");
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат РезультатРазбораФайла;
	
КонецФункции

#КонецОбласти

#Область ТребованияСтандарта

// Описывает коллекцию, предназначенную для хранения данных файла в формате обмена 1С с системами "Клиент банка"
Функция НовыйДанныеИзБанка(ВерсияФормата = "1.03") Экспорт
	
	ДанныеИзБанка = Новый Структура;
	ДанныеИзБанка.Вставить("Заголовок", Новый Структура);
	ДанныеИзБанка.Вставить("Условия",   Новый Структура);
	ДанныеИзБанка.Вставить("Остатки",   Новый ТаблицаЗначений);
	ДанныеИзБанка.Вставить("Документы", Новый ТаблицаЗначений);
	
	// соглашения
	ТипСумма          = ОбщегоНазначения.ОписаниеТипаЧисло(15,2);
	ТипДатаБезВремени = ОбщегоНазначения.ОписаниеТипаДата(ЧастиДаты.Дата);
	ТипСтрока         = Новый ОписаниеТипов("Строка");
	ТипНомерСчета     = БанковскиеПравила.ТипНомерСчета();
	ТипНомерКорСчета  = БанковскиеПравила.ТипМеждународныйНомерСчета(); // Допускается передавать номер счета контрагента в национальном или международном формате
	// Коллекции с таблицами значений, колонки которых имеют тип "Структура", 
	// не должны содержать в полях типа "Структура" ключи с незаполненными значениями.
	
	// ЗАГОЛОВОК
	ДанныеИзБанка.Заголовок.Вставить("ВерсияФормата", ВерсияФормата);
	ДанныеИзБанка.Заголовок.Вставить("Кодировка",     "");           // Как передано в файле
	ДанныеИзБанка.Заголовок.Вставить("Отправитель",   "");           // Как передано в файле
	ДанныеИзБанка.Заголовок.Вставить("Получатель",    "");           // Как передано в файле
	ДанныеИзБанка.Заголовок.Вставить("ДатаСоздания",  '0001-01-01'); // Дата (включает время)
	
	// УСЛОВИЯ
	ДанныеИзБанка.Условия.Вставить("ДатаНачала", '0001-01-01'); // Дата
	ДанныеИзБанка.Условия.Вставить("ДатаКонца",  '0001-01-01'); // Дата
	ДанныеИзБанка.Условия.Вставить("РасчСчет",   Новый Массив); // Строки - номера счетов
	ДанныеИзБанка.Условия.Вставить("Документ",   Новый Массив); // Строки - имена документов, как описано в стандарте
	
	// ОСТАТКИ
	ДанныеИзБанка.Остатки.Колонки.Добавить("ДатаНачала",       ТипДатаБезВремени);
	ДанныеИзБанка.Остатки.Колонки.Добавить("ДатаКонца",        ТипДатаБезВремени);
	ДанныеИзБанка.Остатки.Колонки.Добавить("РасчСчет",         ТипНомерСчета);
	ДанныеИзБанка.Остатки.Колонки.Добавить("НачальныйОстаток", ТипСумма);
	ДанныеИзБанка.Остатки.Колонки.Добавить("ВсегоПоступило",   ТипСумма);
	ДанныеИзБанка.Остатки.Колонки.Добавить("ВсегоСписано",     ТипСумма);
	ДанныеИзБанка.Остатки.Колонки.Добавить("КонечныйОстаток",  ТипСумма);
	
	// ДОКУМЕНТЫ
	// Идентификация платежа
	ДанныеИзБанка.Документы.Колонки.Добавить("Идентификатор", ЗагрузкаВыпискиПоБанковскомуСчету.ТипИдентификатор()); // Должен быть уникальным в рамках коллекции
	ДанныеИзБанка.Документы.Колонки.Добавить("Номер",         ТипСтрока);
	ДанныеИзБанка.Документы.Колонки.Добавить("Дата",          ТипДатаБезВремени);
	ДанныеИзБанка.Документы.Колонки.Добавить("ВидОплаты",     ОбщегоНазначения.ОписаниеТипаЧисло(2, 0, ДопустимыйЗнак.Неотрицательный)); // вид операции
	ДанныеИзБанка.Документы.Колонки.Добавить("Код",           ТипСтрока);
	
	// Сумма
	ДанныеИзБанка.Документы.Колонки.Добавить("Сумма", ТипСумма);
	
	// Идентификация дебитора и кредитора
	ДанныеИзБанка.Документы.Колонки.Добавить("ПлательщикСчет", ТипНомерКорСчета);
	ДанныеИзБанка.Документы.Колонки.Добавить("ПлательщикИНН",  ТипСтрока);
	ДанныеИзБанка.Документы.Колонки.Добавить("ПлательщикРеквизиты", Новый ОписаниеТипов("Структура")); // См. ЭлементыРеквизитовУчастника()
	
	ДанныеИзБанка.Документы.Колонки.Добавить("ПолучательСчет", ТипНомерКорСчета);
	ДанныеИзБанка.Документы.Колонки.Добавить("ПолучательИНН",  ТипСтрока);
	ДанныеИзБанка.Документы.Колонки.Добавить("ПолучательРеквизиты", Новый ОписаниеТипов("Структура")); // См. ЭлементыРеквизитовУчастника()
	
	// Назначение платежа
	ДанныеИзБанка.Документы.Колонки.Добавить("НазначениеПлатежа",                  ТипСтрока); // Строка, может содержать разделители строки
	ДанныеИзБанка.Документы.Колонки.Добавить("РеквизитыПлатежаВБюджет",            Новый ОписаниеТипов("Структура")); // См. ЭлементыРеквизитовПлатежаВБюджет()
	ДанныеИзБанка.Документы.Колонки.Добавить("СтруктурированноеНазначениеПлатежа", Новый ОписаниеТипов("Структура")); // См. ЭлементыСтруктурированногоНазначенияПлатежа() 
	
	// Исполнение документа банком
	ДанныеИзБанка.Документы.Колонки.Добавить("Вид",           ТипСтрока);
	ДанныеИзБанка.Документы.Колонки.Добавить("ДатаСписано",   ТипДатаБезВремени);
	ДанныеИзБанка.Документы.Колонки.Добавить("ДатаПоступило", ТипДатаБезВремени);
	ДанныеИзБанка.Документы.Колонки.Добавить("Квитанция",     Новый ОписаниеТипов("Структура")); 
	ДанныеИзБанка.Документы.Колонки.Добавить("ВидПлатежа",    ТипСтрока);
	ДанныеИзБанка.Документы.Колонки.Добавить("Очередность",   ОбщегоНазначения.ОписаниеТипаЧисло(2, 0, ДопустимыйЗнак.Неотрицательный));
	ДанныеИзБанка.Документы.Колонки.Добавить("КодНазПлатежа", ТипСтрока);
	
	ДанныеИзБанка.Документы.Индексы.Добавить("Идентификатор");
	
	Возврат ДанныеИзБанка;
	
КонецФункции

// Описывает структуру (формат) файла обмена данными - см. http://v8.1c.ru/edi/edi_stnd/100/101.htm
Функция ОписаниеФайлаОбмена()

	Описание = Новый Структура();
	Описание.Вставить("Секции",                             Новый ТаблицаЗначений);
	Описание.Вставить("ПравилаРазмещенияДанныхОДокументах", Новый ТаблицаЗначений);
	
	Описание.Секции.Колонки.Добавить("Имя",                   Новый ОписаниеТипов("Строка"));
	Описание.Секции.Колонки.Добавить("НачальныйТег",          Новый ОписаниеТипов("Строка"));
	Описание.Секции.Колонки.Добавить("КонечныйТег",           Новый ОписаниеТипов("Строка"));
	Описание.Секции.Колонки.Добавить("Элементы",              Новый ОписаниеТипов("Соответствие")); // Теги вложенных элементов. Должны соответствовать требованиям к ключам структуры. Приводятся к верхнему регистру чтобы обеспечить регистронезависимое сравнение.
	Описание.Секции.Колонки.Добавить("МногострочныеЭлементы", Новый ОписаниеТипов("Соответствие")); // Некоторые из вложенных элементов, текст которых может содержать строки с разделителями.
	Описание.Секции.Индексы.Добавить("НачальныйТег");
	Описание.Секции.Индексы.Добавить("КонечныйТег");
	
	Описание.ПравилаРазмещенияДанныхОДокументах.Колонки.Добавить("Тег",                  Новый ОписаниеТипов("Строка"));
	Описание.ПравилаРазмещенияДанныхОДокументах.Колонки.Добавить("РазделДанных",         Новый ОписаниеТипов("Строка"));
	Описание.ПравилаРазмещенияДанныхОДокументах.Колонки.Добавить("ИмяЭлемента",          Новый ОписаниеТипов("Строка"));
	Описание.ПравилаРазмещенияДанныхОДокументах.Колонки.Добавить("ДополнительнаяСтрока", Новый ОписаниеТипов("Булево")); // Дополняет предыдущую строку с этим элементом
	Описание.ПравилаРазмещенияДанныхОДокументах.Индексы.Добавить("Тег");
	
	// ФАЙЛ
	ОписаниеСекции = Описание.Секции.Добавить();
	ОписаниеСекции.Имя           = "Файл"; // Это секция верхнего уровня. Она может быть только одна.
	ОписаниеСекции.НачальныйТег  = "1CClientBankExchange";
	ОписаниеСекции.КонечныйТег   = "КонецФайла";
	ЭлементыСекции = Новый Массив;
	// Общие сведения
	ЭлементыСекции.Добавить("ВерсияФормата");
	ЭлементыСекции.Добавить("Кодировка");
	ЭлементыСекции.Добавить("Отправитель");
	ЭлементыСекции.Добавить("Получатель");
	ЭлементыСекции.Добавить("ДатаСоздания");
	ЭлементыСекции.Добавить("ВремяСоздания");// В текущей реализации игнорируется
	// Условия
	ЭлементыСекции.Добавить("ДатаНачала");
	ЭлементыСекции.Добавить("ДатаКонца");
	ДобавитьЭлементыВОписаниеСекции(ОписаниеСекции, ЭлементыСекции);
	// УСЛОВИЯ.РАСЧСЧЕТ
	ОписаниеСекции = Описание.Секции.Добавить(); // Может быть несколько счетов
	ОписаниеСекции.Имя          = "Условия.РасчСчет";
	ОписаниеСекции.НачальныйТег = "РасчСчет";
	ОписаниеСекции.КонечныйТег  = "РасчСчет";// секция состоит из одной строки
	ДобавитьЭлементыВОписаниеСекции(ОписаниеСекции, ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("РасчСчет"));
	// УСЛОВИЯ.ДОКУМЕНТ
	ОписаниеСекции = Описание.Секции.Добавить(); // Может быть несколько видов документов
	ОписаниеСекции.Имя          = "Условия.Документ";
	ОписаниеСекции.НачальныйТег = "Документ";
	ОписаниеСекции.КонечныйТег  = "Документ";// секция состоит из одной строки
	ДобавитьЭлементыВОписаниеСекции(ОписаниеСекции, ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("Документ"));
	
	// ОСТАТКИ
	ОписаниеСекции = Описание.Секции.Добавить();
	ОписаниеСекции.Имя          = "Остатки";
	ОписаниеСекции.НачальныйТег = "СекцияРасчСчет";
	ОписаниеСекции.КонечныйТег  = "КонецРасчСчет";
	ЭлементыСекции = Новый Массив;
	ЭлементыСекции.Добавить("РасчСчет");
	ЭлементыСекции.Добавить("ДатаНачала");
	ЭлементыСекции.Добавить("ДатаКонца");
	ЭлементыСекции.Добавить("РасчСчет");
	ЭлементыСекции.Добавить("Документ");
	ЭлементыСекции.Добавить("НачальныйОстаток");
	ЭлементыСекции.Добавить("ВсегоПоступило");
	ЭлементыСекции.Добавить("ВсегоСписано");
	ЭлементыСекции.Добавить("КонечныйОстаток");
	ДобавитьЭлементыВОписаниеСекции(ОписаниеСекции, ЭлементыСекции);
	
	// ДОКУМЕНТ
	ОписаниеСекции = Описание.Секции.Добавить();
	ОписаниеСекции.Имя          = "Документ";
	ОписаниеСекции.НачальныйТег = "СекцияДокумент";
	ОписаниеСекции.КонечныйТег  = "КонецДокумента";
	ЭлементыСекции = Новый Массив;
	ЭлементыСекции.Добавить("СекцияДокумент"); // Содержит значение - вид документа
	ЭлементыСекции.Добавить("Номер");
	ЭлементыСекции.Добавить("Дата");
	ЭлементыСекции.Добавить("ВидОплаты");
	ЭлементыСекции.Добавить("Код");
	ЭлементыСекции.Добавить("Сумма");
	ЭлементыСекции.Добавить("ПлательщикСчет");
	ЭлементыСекции.Добавить("ПлательщикИНН");
	ЭлементыСекции.Добавить("ПолучательСчет");
	ЭлементыСекции.Добавить("ПолучательИНН");
	ЭлементыСекции.Добавить("НазначениеПлатежа");
	ЭлементыСекции.Добавить("КодНазПлатежа");
	ЭлементыСекции.Добавить("ДатаСписано");
	ЭлементыСекции.Добавить("ДатаПоступило");
	ЭлементыСекции.Добавить("ВидПлатежа");
	ЭлементыСекции.Добавить("Очередность");
	ДобавитьЭлементыВОписаниеСекции(ОписаниеСекции, ЭлементыСекции);
	
	// Эта секция содержит и другие вложенные элементы, данные из которых требуют дополнительных преобразований.
	// Сначала опишем эти преобразования, а затем по данным о преобразованиях дозаполним ОписаниеСекции.Элементы
	
	// Исполнение платежа банком
	Правило = Описание.ПравилаРазмещенияДанныхОДокументах.Добавить();
	Правило.Тег          = "СекцияДокумент"; // Значение содержится в строке с начальным тегом
	Правило.РазделДанных = "";
	Правило.ИмяЭлемента  = "Вид";
	
	// Идентификатор платежа (УИН, УИП, УИК)
	Правило = Описание.ПравилаРазмещенияДанныхОДокументах.Добавить();
	Правило.Тег          = "КОД";
	Правило.РазделДанных = "";
	Правило.ИмяЭлемента  = "Код";
	
	Для Каждого ИмяЭлемента Из ЭлементыКвитанции() Цикл
		Правило = Описание.ПравилаРазмещенияДанныхОДокументах.Добавить();
		Правило.Тег          = "Квитанция" + ИмяЭлемента;
		Правило.РазделДанных = "Квитанция";
		Правило.ИмяЭлемента  = ИмяЭлемента;
	КонецЦикла;
	
	// Назначение платежа
	Для НомерПодстроки = 1 По 6 Цикл
		Правило = Описание.ПравилаРазмещенияДанныхОДокументах.Добавить();
		Правило.Тег                  = "НазначениеПлатежа" + НомерПодстроки;
		Правило.РазделДанных         = "";
		Правило.ИмяЭлемента          = "НазначениеПлатежа";
		Правило.ДополнительнаяСтрока = (НомерПодстроки > 1);
	КонецЦикла;
	
	// Реквизиты плательщика и получателя
	Участники = Новый Массив;
	Участники.Добавить("Плательщик");
	Участники.Добавить("Получатель");
	
	ЭлементыДанныхОбУчастниках = ЭлементыРеквизитовУчастника();
	Для Каждого Участник Из Участники Цикл
		
		РазделДанных = Участник + "Реквизиты";
		
		Для Каждого ИмяЭлемента Из ЭлементыДанныхОбУчастниках Цикл
			Если ИмяЭлемента = "НаименованиеРасширенное" Тогда
				Правило = Описание.ПравилаРазмещенияДанныхОДокументах.Добавить();
				Правило.Тег          = Участник;
				Правило.РазделДанных = РазделДанных;
				Правило.ИмяЭлемента  = ИмяЭлемента;
			ИначеЕсли ИмяЭлемента = "НаименованиеДетально" Тогда
				Для НомерПодстроки = 1 По 4 Цикл
					Правило = Описание.ПравилаРазмещенияДанныхОДокументах.Добавить();
					Правило.Тег                  = Участник + НомерПодстроки;
					Правило.РазделДанных         = РазделДанных;
					Правило.ИмяЭлемента          = ИмяЭлемента;
					Правило.ДополнительнаяСтрока = (НомерПодстроки > 1);
				КонецЦикла;
			ИначеЕсли ИмяЭлемента = "Банк" Тогда
				Правило = Описание.ПравилаРазмещенияДанныхОДокументах.Добавить();
				Правило.Тег            = Участник + "Банк1";
				Правило.РазделДанных   = РазделДанных;
				Правило.ИмяЭлемента    = ИмяЭлемента;
			ИначеЕсли ИмяЭлемента = "ГородБанка" Тогда
				Правило = Описание.ПравилаРазмещенияДанныхОДокументах.Добавить();
				Правило.Тег            = Участник + "Банк2";
				Правило.РазделДанных   = РазделДанных;
				Правило.ИмяЭлемента    = ИмяЭлемента;
			Иначе
				Правило = Описание.ПравилаРазмещенияДанныхОДокументах.Добавить();
				Правило.Тег            = Участник + ИмяЭлемента;
				Правило.РазделДанных   = РазделДанных;
				Правило.ИмяЭлемента    = ИмяЭлемента;
			КонецЕсли;
		КонецЦикла;
		
	КонецЦикла;
		
	// Реквизиты платежа в бюджет
	Для Каждого ИмяЭлемента Из ЭлементыРеквизитовПлатежаВБюджет() Цикл
		Правило = Описание.ПравилаРазмещенияДанныхОДокументах.Добавить();
		Правило.Тег          = ИмяЭлемента;
		Правило.РазделДанных = "РеквизитыПлатежаВБюджет";
		Правило.ИмяЭлемента  = ИмяЭлемента;
	КонецЦикла;
	
	// Исполнение платежа банком
	Правило = Описание.ПравилаРазмещенияДанныхОДокументах.Добавить();
	Правило.Тег          = "СекцияДокумент"; // Значение содержится в строке с начальным тегом
	Правило.РазделДанных = "";
	Правило.ИмяЭлемента  = "Вид";
	
	// Структурированное назначение платежа (Дополнительные реквизиты для отдельных видов документов)
	Для Каждого ИмяЭлемента Из ЭлементыСтруктурированногоНазначенияПлатежа() Цикл
		Правило = Описание.ПравилаРазмещенияДанныхОДокументах.Добавить();
		Правило.Тег          = ИмяЭлемента;
		Правило.РазделДанных = "СтруктурированноеНазначениеПлатежа";
		Правило.ИмяЭлемента  = ИмяЭлемента;
	КонецЦикла;
	
	// Приведем теги в колонках таблиц значений к верхнему регистру, чтобы обеспечить регистронезависимый поиск
	Для Каждого Секция Из Описание.Секции Цикл
		Секция.НачальныйТег = ВРег(Секция.НачальныйТег);
		Секция.КонечныйТег  = ВРег(Секция.КонечныйТег);
	КонецЦикла;
	
	Для Каждого Правило Из Описание.ПравилаРазмещенияДанныхОДокументах Цикл
		Правило.Тег = ВРег(Правило.Тег);
	КонецЦикла;
	
	// Дозаполним ОписаниеСекции.Элементы по Описание.ПравилаРазмещенияДанныхОДокументах
	ДобавитьЭлементыВОписаниеСекции(ОписаниеСекции, Описание.ПравилаРазмещенияДанныхОДокументах.ВыгрузитьКолонку("Тег"));
	
	МногострочныеЭлементы = Новый Массив;
	МногострочныеЭлементы.Добавить("Плательщик");
	МногострочныеЭлементы.Добавить("Плательщик1");
	МногострочныеЭлементы.Добавить("Получатель");
	МногострочныеЭлементы.Добавить("Получатель1");
	МногострочныеЭлементы.Добавить("НазначениеПлатежа");
	МногострочныеЭлементы.Добавить("НазначениеПлатежа1");
	ДобавитьЭлементыВОписаниеСекции(ОписаниеСекции, МногострочныеЭлементы, "МногострочныеЭлементы");
	
	Возврат Описание;
	
КонецФункции

Функция ЭлементыРеквизитовУчастника()
	
	ЭлементыРеквизитовУчастника = Новый Массив;
	ЭлементыРеквизитовУчастника.Добавить("Наименование");
	ЭлементыРеквизитовУчастника.Добавить("НаименованиеРасширенное"); // может содержать ИНН
	ЭлементыРеквизитовУчастника.Добавить("КПП");
	ЭлементыРеквизитовУчастника.Добавить("НаименованиеДетально");// может содержать разделители строк - собирается из реквизитов файла Плательщик1, Плательщик2, Плательщик3, Плательщик4
	
	Для Каждого ЭлементРеквизитовСчетаУчастника Из ЭлементыРеквизитовСчетаУчастника() Цикл
		ЭлементыРеквизитовУчастника.Добавить(ЭлементРеквизитовСчетаУчастника);
	КонецЦикла;
	
	Возврат ЭлементыРеквизитовУчастника;
	
КонецФункции

Функция ЭлементыРеквизитовСчетаУчастника() Экспорт
	
	ЭлементыРеквизитовСчетаУчастника = Новый Массив;
	
	ЭлементыРеквизитовСчетаУчастника.Добавить("БИК");
	ЭлементыРеквизитовСчетаУчастника.Добавить("КорСчет");
	ЭлементыРеквизитовСчетаУчастника.Добавить("Банк");       // ПлательщикБанк1, ПолучательБанк1
	ЭлементыРеквизитовСчетаУчастника.Добавить("ГородБанка"); // ПлательщикБанк2, ПолучательБанк2
	ЭлементыРеквизитовСчетаУчастника.Добавить("РасчСчет");
	
	Возврат ЭлементыРеквизитовСчетаУчастника;
	
КонецФункции

Функция ЭлементыРеквизитовПлатежаВБюджет()
	
	// Секция "Дополнительные реквизиты для платежей в бюджетную систему Российской Федерации"
	
	ЭлементыРеквизитовПлатежаВБюджет = Новый Массив;
	ЭлементыРеквизитовПлатежаВБюджет.Добавить("ПлательщикКПП");
	ЭлементыРеквизитовПлатежаВБюджет.Добавить("ПолучательКПП");
	ЭлементыРеквизитовПлатежаВБюджет.Добавить("СтатусСоставителя");
	ЭлементыРеквизитовПлатежаВБюджет.Добавить("ПоказательКБК");
	ЭлементыРеквизитовПлатежаВБюджет.Добавить("ОКАТО");
	ЭлементыРеквизитовПлатежаВБюджет.Добавить("ПоказательОснования");
	ЭлементыРеквизитовПлатежаВБюджет.Добавить("ПоказательПериода");
	ЭлементыРеквизитовПлатежаВБюджет.Добавить("ПоказательНомера");
	ЭлементыРеквизитовПлатежаВБюджет.Добавить("ПоказательДаты");
	ЭлементыРеквизитовПлатежаВБюджет.Добавить("ПоказательТипа");
	
	Возврат ЭлементыРеквизитовПлатежаВБюджет;
	
КонецФункции

Функция ЭлементыКвитанции()
	
	ЭлементыКвитанции = Новый Массив;
	ЭлементыКвитанции.Добавить("Дата");
	ЭлементыКвитанции.Добавить("Время");
	ЭлементыКвитанции.Добавить("Содержание");
	
	Возврат ЭлементыКвитанции;
	
КонецФункции

Функция ЭлементыСтруктурированногоНазначенияПлатежа()
	
	// См. секцию "Дополнительные реквизиты для отдельных видов документов", кроме поля Очередность
	ЭлементыСтруктурированногоНазначенияПлатежа = Новый Массив;
	ЭлементыСтруктурированногоНазначенияПлатежа.Добавить("СрокАкцепта");
	ЭлементыСтруктурированногоНазначенияПлатежа.Добавить("ВидАккредитива");
	ЭлементыСтруктурированногоНазначенияПлатежа.Добавить("СрокПлатежа");
	ЭлементыСтруктурированногоНазначенияПлатежа.Добавить("УсловиеОплаты1");
	ЭлементыСтруктурированногоНазначенияПлатежа.Добавить("УсловиеОплаты2");
	ЭлементыСтруктурированногоНазначенияПлатежа.Добавить("УсловиеОплаты3");
	ЭлементыСтруктурированногоНазначенияПлатежа.Добавить("ПлатежПоПредст");
	ЭлементыСтруктурированногоНазначенияПлатежа.Добавить("ДополнУсловия");
	ЭлементыСтруктурированногоНазначенияПлатежа.Добавить("НомерСчетаПоставщика");
	ЭлементыСтруктурированногоНазначенияПлатежа.Добавить("ДатаОтсылкиДок");
	Возврат ЭлементыСтруктурированногоНазначенияПлатежа;
	
КонецФункции

// Служебная, не содержит сведений о стандарте
Процедура ДобавитьЭлементыВОписаниеСекции(ОписаниеСекции, ЭлементыСекции, ИмяСвойстваПриемника = "Элементы")
	
	Для Каждого ИмяЭлемента Из ЭлементыСекции Цикл
		ОписаниеСекции[ИмяСвойстваПриемника].Вставить(ВРег(ИмяЭлемента), ИмяЭлемента);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область ЧтениеФайла

Процедура ПеренестиВДанныеБанка(ДанныеИзБанка, СтекСекций, ОписаниеФайлаОбмена)
	
	Секция = СтекСекций[0];
	
	ОписаниеТипаСтрока = Новый ОписаниеТипов("Строка");
	
	Если Секция.Описание.Имя = "Файл" Тогда
		
		РазделыДанных = Новый Массив;
		РазделыДанных.Добавить("Заголовок");
		РазделыДанных.Добавить("Условия");
		Для Каждого ИмяРазделаДанных Из РазделыДанных Цикл
			РазделДанных = ДанныеИзБанка[ИмяРазделаДанных];
			Для Каждого ЭлементДанных Из РазделДанных Цикл
				Если Секция.Данные.Свойство(ЭлементДанных.Ключ) Тогда
					ТипЗначения = Новый ОписаниеТипов(ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ТипЗнч(ЭлементДанных.Значение)));
					РазделДанных[ЭлементДанных.Ключ] = ОбщегоНазначенияБПКлиентСервер.ПривестиСтроку(Секция.Данные[ЭлементДанных.Ключ], ТипЗначения);
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
			
	ИначеЕсли Секция.Описание.Имя = "Условия.РасчСчет" Тогда
		
		ДанныеИзБанка.Условия.РасчСчет.Добавить(Секция.Данные.РасчСчет);
		
	ИначеЕсли Секция.Описание.Имя = "Условия.Документ" Тогда
		
		ДанныеИзБанка.Условия.Документ.Добавить(Секция.Данные.Документ);
		
	ИначеЕсли Секция.Описание.Имя = "Остатки" Тогда
			
		СтрокаДанныхИзБанка = ДанныеИзБанка.Остатки.Добавить();
		
		Для Каждого Колонка Из ДанныеИзБанка.Остатки.Колонки Цикл
			Если Секция.Данные.Свойство(Колонка.Имя) Тогда
				СтрокаДанныхИзБанка[Колонка.Имя] = ОбщегоНазначенияБПКлиентСервер.ПривестиСтроку(Секция.Данные[Колонка.Имя], Колонка.ТипЗначения);
			КонецЕсли;
		КонецЦикла;
		
	ИначеЕсли Секция.Описание.Имя = "Документ" Тогда
		
		СтрокаДанныхИзБанка = ДанныеИзБанка.Документы.Добавить();
		СтрокаДанныхИзБанка.Идентификатор = XMLСтрока(ДанныеИзБанка.Документы.Индекс(СтрокаДанныхИзБанка));
		
		// Исправим частую ошибку, которую банки допускают при подготовке файла:
		// путают обязательный и опциональный реквизиты
		Участники = Новый Массив;
		Участники.Добавить("Получатель");
		Участники.Добавить("Плательщик");
		Для Каждого Участник Из Участники Цикл
			ОбязательныйРеквизит = Участник + "Счет";
			ОпциональныйРеквизит = Участник + "РасчСчет";
			Если (Не Секция.Данные.Свойство(ОбязательныйРеквизит) Или ПустаяСтрока(Секция.Данные[ОбязательныйРеквизит]))
				И (Секция.Данные.Свойство(ОпциональныйРеквизит) И Не ПустаяСтрока(Секция.Данные[ОпциональныйРеквизит])) Тогда
				Секция.Данные.Вставить(ОбязательныйРеквизит, Секция.Данные[ОпциональныйРеквизит]);
			КонецЕсли;
		КонецЦикла;
		
		// Часть данных помещаем в одноименные колонки
		Для Каждого Колонка Из ДанныеИзБанка.Документы.Колонки Цикл
			Если Секция.Данные.Свойство(Колонка.Имя) Тогда
				СтрокаДанныхИзБанка[Колонка.Имя] = Секция.Данные[Колонка.Имя]; // Неявное приведение типов быстрее, но в отдельных случаях недостаточно надежно.
				Если СтрокаДанныхИзБанка[Колонка.Имя] <> Секция.Данные[Колонка.Имя]
					И Не ЗначениеЗаполнено(СтрокаДанныхИзБанка[Колонка.Имя]) Тогда
					// Возможно, неявное (платформенное) приведение типов не позволило получить данные.
					СтрокаДанныхИзБанка[Колонка.Имя] = ОбщегоНазначенияБПКлиентСервер.ПривестиСтроку(Секция.Данные[Колонка.Имя], Колонка.ТипЗначения);
				КонецЕсли;
				ОчиститьТолькоНулиВСтроке(СтрокаДанныхИзБанка[Колонка.Имя]);
			КонецЕсли;
		КонецЦикла;
		
		// Часть данных размещаем особым образом в соответствии с требованиями к коллекции - "упаковываем", помещаем в колонки с другими именами
		Для Каждого РазмещениеРеквизита Из ОписаниеФайлаОбмена.ПравилаРазмещенияДанныхОДокументах Цикл
			
			Если Не Секция.Данные.Свойство(РазмещениеРеквизита.Тег) Тогда
				Продолжить;
			КонецЕсли;
			
			Если ПустаяСтрока(РазмещениеРеквизита.РазделДанных) Тогда
				КоллекцияРазделаДанных = СтрокаДанныхИзБанка;
				ТипЗначения = ДанныеИзБанка.Документы.Колонки[РазмещениеРеквизита.ИмяЭлемента].ТипЗначения;
			Иначе
				ТипЗначения = ОписаниеТипаСтрока;
				КоллекцияРазделаДанных = СтрокаДанныхИзБанка[РазмещениеРеквизита.РазделДанных];
				Если Не КоллекцияРазделаДанных.Свойство(РазмещениеРеквизита.ИмяЭлемента) Тогда
					КоллекцияРазделаДанных.Вставить(РазмещениеРеквизита.ИмяЭлемента, "");
				КонецЕсли;
			КонецЕсли;
			
			ЗначениеСтрокой = Секция.Данные[РазмещениеРеквизита.Тег];
			Значение = ТипЗначения.ПривестиЗначение(ЗначениеСтрокой); // Платформенное приведение типов быстрое, но в некоторых случаях недостаточно надежное.
			Если ЗначениеСтрокой <> Значение И Не ЗначениеЗаполнено(Значение) Тогда
				// Возможно, платформенное приведение типов не позволило получить данные.
				Значение = ОбщегоНазначенияБПКлиентСервер.ПривестиСтроку(ЗначениеСтрокой, ТипЗначения);
			КонецЕсли;
			
			ОчиститьТолькоНулиВСтроке(Значение);
			
			Если Не РазмещениеРеквизита.ДополнительнаяСтрока Тогда
				КоллекцияРазделаДанных[РазмещениеРеквизита.ИмяЭлемента] = Значение;
			Иначе
				КоллекцияРазделаДанных[РазмещениеРеквизита.ИмяЭлемента] = 
					КоллекцияРазделаДанных[РазмещениеРеквизита.ИмяЭлемента]
					+ Символы.ПС 
					+ Значение;
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого Участник Из Участники Цикл
			
			РеквизитыУчастника = СтрокаДанныхИзБанка[Участник + "Реквизиты"];
			
			// Устаревшее программное обеспечение в поле ИНН может передавать и КПП, отделенный специальным символом
			ИНН = СтрокаДанныхИзБанка[Участник + "ИНН"];// не следует использовать за пределами условия ниже
			Если Не ПустаяСтрока(ИНН) И Не РеквизитыУчастника.Свойство("КПП") Тогда
				Если СтрДлина(ИНН) > ИдентификационныеНомераНалогоплательщиков.МинимальнаяДлинаИНН() 
					И Не ИдентификационныеНомераНалогоплательщиков.ЭтоИННФизическогоЛица(ИНН)
					И Не ИдентификационныеНомераНалогоплательщиков.ЭтоИННЮридическогоЛица(ИНН) Тогда
					// Возможно, в составе ИНН передан и КПП тоже
					ЭлементыКода = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов(ИНН, ",/|\~");
					Если ЭлементыКода.Количество() > 1 Тогда
						СтрокаДанныхИзБанка[Участник + "ИНН"] = ЭлементыКода[0];
						РеквизитыУчастника.Вставить("КПП", ЭлементыКода[1]);
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
			// Наименование контрагента может не поставляться в файле в готовом виде и его требуется определять
			Наименование = "";
			Если РеквизитыУчастника.Свойство("НаименованиеДетально") И Не ПустаяСтрока(РеквизитыУчастника.НаименованиеДетально) Тогда
				ЭлементыНаименования = СтрРазделить(РеквизитыУчастника.НаименованиеДетально, Символы.ПС, Истина);
				Наименование = ЭлементыНаименования[0];
			ИначеЕсли РеквизитыУчастника.Свойство("НаименованиеРасширенное") Тогда
				Наименование = РеквизитыУчастника.НаименованиеРасширенное;
				// Может содержать ИНН, который здесь не нужен
				ИНН = СтрокаДанныхИзБанка[Участник + "ИНН"];
				ИдентификационныеНомераНалогоплательщиков.УдалитьИзНаименованияИНН(Наименование, ИНН);
			КонецЕсли;
			Если Не ПустаяСтрока(Наименование) Тогда
				РеквизитыУчастника.Вставить("Наименование", Наименование);
			КонецЕсли;
			
		КонецЦикла;
		
		ИсправитьОшибкиПлательщикСчет(СтрокаДанныхИзБанка);
		
		// Формат не предполагает указывать отрицательные суммы, однако отдельные банки указывают, причем для всех расходных или для всех кредитовых операций.
		// Поэтому считаем указание отрицательной суммы ошибкой, которую можем исправить.
		Если СтрокаДанныхИзБанка.Сумма < 0 Тогда
			СтрокаДанныхИзБанка.Сумма = - СтрокаДанныхИзБанка.Сумма;
		КонецЕсли;
		
	КонецЕсли;
		
	СтекСекций.Удалить(0);
	
КонецПроцедуры

// Разделяет строку на элементы, предусмотренные файлом обмена
// Параметры:
//  Строка - Строка - Текстовая строка, прочитанная из файла
// Возвращаемые параметры:
//  Тег      - Строка - имя элемента файла - часть строки до символа "=", приведенная к верхнему регистру
//  Значение - Строка - значение элемента - часть строки после символа "="
// Возвращаемые параметры используются вместо возвращаемого значения из соображений производительности:
// метод нужно вызывать многократно - для каждой строки файла, а конструирование коллекции для возвращаемого значения - относительно затратная операция.
//
Процедура РазделитьСтрокуФайла(Строка, Тег, Значение)
	
	ПозицияРавно = СтрНайти(Строка, "=");
	Если ПозицияРавно = 0 Тогда
		Тег      = ВРег(СокрЛП(Строка));
		Значение = Строка;
	Иначе
		Тег      = ВРег(СокрЛП(Лев(Строка,  ПозицияРавно - 1)));
		Значение = СокрЛП(Сред(Строка, ПозицияРавно + 1));
	КонецЕсли;
	
	Если Не ПустаяСтрока(Значение) Тогда
		// Недопустимые символы встречаются редко, а поиск существенно быстрее, чем замена, так как при замене строка передается по значению.
		// Поэтому оптимальнее искать до вызова УдалитьНедопустимыеСимволыXML, даже если в случае недопустимого символа придется искать еще раз.
		Если НайтиНедопустимыеСимволыXML(Значение) <> 0 Тогда 
			Значение = ОбщегоНазначенияКлиентСервер.УдалитьНедопустимыеСимволыXML(Значение);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Процедура ОчиститьТолькоНулиВСтроке(Значение)
	// Часто для соблюдения формальных требований о заполнении поля, его заполняют нулями (например, "0" или "000000000000").
	// Такие значения следует считать незаполненными
	Если ТипЗнч(Значение) = Тип("Строка") Тогда
		Если СтрНайти(Значение, "0") > 0 // Для оптимизации делаем лишний поиск в строке: он очень быстрый, а нули встречаются не всегда
			И ОбщегоНазначенияБПКлиентСервер.ТолькоНулиВСтроке(Значение) Тогда
			Значение = "";
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

Процедура ИсправитьОшибкиПлательщикСчет(СтрокаДанныхИзБанка)
	
	// Исправим ошибки, которые допускают некоторые банки:
	// указывают информацию не в предназначенных для этого полях, а в поле с наименованием плательщика.
	// В частности:
	// 1. теряют информацию о полном номере банковского счета плательщика,
	//    если расчеты выполнялись через кор.счета филиальной сети банка плательщика
	// 2. не указывают в предназначенных для этого полях информацию о номере банковского счета плательщика,
	//    открытого в банке-нерезиденте, и банке, в котором открыт счет.
	
	Если Не БанковскиеПравила.СтрокаСоответствуетФорматуБанковскогоСчета(СтрокаДанныхИзБанка.ПлательщикСчет)
		Или Не СтрокаДанныхИзБанка.ПлательщикРеквизиты.Свойство("Наименование") Тогда
		Возврат;
	КонецЕсли;
		
	БалансовыйСчет = БанковскиеПравила.БалансовыйСчет(СтрокаДанныхИзБанка.ПлательщикСчет);
	Если БанковскиеПравила.ЭтоСчетРасчетовФилиалаБанкаСКлиентамиБанка(БалансовыйСчет) Тогда
		Проблема = "РасчетыФилиалаБанкаСКлиентамиБанка";
	ИначеЕсли БанковскиеПравила.ЭтоКорсчетБанкаНерезидента(БалансовыйСчет) Тогда
		Проблема = "РасчетыЧерезБанкНерезидент";
	ИначеЕсли БанковскиеПравила.ЭтоКорСчетКредитныхОрганизацийКорреспондентов(БалансовыйСчет)
		Или БанковскиеПравила.ЭтоКорсчетВКредитнойОрганизацииКорреспонденте(БалансовыйСчет) Тогда
		Проблема = "РасчетыЧерезБанкКорреспондент";
	Иначе
		Возврат;
	КонецЕсли;
	
	СловаПлательщика = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов(СтрокаДанныхИзБанка.ПлательщикРеквизиты.Наименование);
	
	НомерСчета = "";
	Для Каждого ВозможныйНомерСчета Из СловаПлательщика Цикл
		
		Если Проблема = "РасчетыФилиалаБанкаСКлиентамиБанка" Или Проблема = "РасчетыЧерезБанкКорреспондент" Тогда
			
			Если БанковскиеПравила.СтрокаСоответствуетФорматуБанковскогоСчета(ВозможныйНомерСчета) Тогда
				НомерСчета = ВозможныйНомерСчета;
				Прервать;
			КонецЕсли;
			
		ИначеЕсли Проблема = "РасчетыЧерезБанкНерезидент" Тогда
			
			ВозможныйНомерСчета = СтрЗаменить(ВозможныйНомерСчета, "/", "");
			
			Если БанковскиеПравила.СтрокаСоответствуетФорматуIBAN(ВозможныйНомерСчета)
				И БанковскиеПравила.ПроверитьКонтрольныйКлючIBAN(ВозможныйНомерСчета) Тогда
				НомерСчета = ВозможныйНомерСчета;
				Прервать;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ЗначениеЗаполнено(НомерСчета) Тогда
		Возврат;
	КонецЕсли;
	
	СтрокаДанныхИзБанка.ПлательщикСчет = НомерСчета;
	// Если есть проблема с номером счета, то вероятна и проблема с БИК банка.
	// Например, в ситуации с отражением расчетов с филиалом, часто в файле содержится "головной" БИК банка,
	// а не того банка, где открыт счет с этим номером
	СтрокаДанныхИзБанка.ПлательщикРеквизиты.Удалить("БИК"); 
		
КонецПроцедуры

#Область ОпределитьТипФайла

// Функция возвращает тип файла после прочтения первых 5 строк
// Определяем кодировку
Функция ТипФайла(ИмяФайла)
	
	Текст              = Новый ЧтениеТекста(ИмяФайла, "windows-1251");
	СтрокаТекста       = Текст.ПрочитатьСтроку();
	НомерТекущейСтроки = 0;
	
	Пока СтрокаТекста <> Неопределено Цикл
		// Проверяем кодировку файла
		Если НЕ ОбменСБанкомКлиентСервер.ТолькоСимволыВСтроке(СтрокаТекста) Тогда
			Возврат "cp866";
			Прервать;
		КонецЕсли;
		// Читаем первые пять строк, этого должно быть достаточно,
		// чтобы определить кодировку
		Если НомерТекущейСтроки > 5 Тогда 
			Прервать;
		КонецЕсли;
		НомерТекущейСтроки = НомерТекущейСтроки + 1;
		СтрокаТекста       = Текст.ПрочитатьСтроку();
	КонецЦикла;
	
	Возврат "windows-1251";
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область ПротоколЧтенияФайла

Функция НовыйПротоколЧтенияФайла()
	
	Протокол = Новый ТаблицаЗначений;
	Протокол.Колонки.Добавить("НомерСтроки", Новый ОписаниеТипов("Число"));  // Нумеруются с 1; 0 означает, что запись относится к файлу в целом
	Протокол.Колонки.Добавить("КодСобытия",  Новый ОписаниеТипов("Строка")); // Для анализа в коде. Регистрируемые события не обязательно свидетельствуют об ошибках.
	Возврат Протокол;
	
КонецФункции

Процедура ЗаписатьВПротокол(Протокол, НомерСтрокиФайла, КодСобытия)
	
	Запись = Протокол.Добавить();
	Запись.НомерСтроки = НомерСтрокиФайла;
	Запись.КодСобытия  = КодСобытия;
	
КонецПроцедуры

#КонецОбласти
