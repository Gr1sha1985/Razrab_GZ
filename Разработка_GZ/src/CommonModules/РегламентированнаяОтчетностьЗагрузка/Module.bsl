////////////////////////////////////////////////////////////////////////////////
// Модуль содержит общие процедуры и функции для загрузки данных в формы
// регламентированной отчетности из файлов электронных представлений.
//
////////////////////////////////////////////////////////////////////////////////

#Область ПрограммныйИнтерфейс

// Заполняет данными из файлов электронных представлений сохраненный документ
// переданной формы регламентированного отчета, записывает его в информационную базу.
//
// Параметры:
//  ФормаОтчета        - Форма клиентского приложения - Форма регламентированного отчета.
//  ПараметрыОтчета    - Структура                    - Параметры отчета из формы для подстановки в дерево загрузки.
//  ДанныеДляЗагрузки  - Структура                    - Данные, полученные в результате анализа загружаемых файлов
//                                                      электронных представлений регламентированных отчетов.
//  ДеревоДляЗагрузки  - Дерево значений              - Текущая схема выгрузки формы отчета в виде дерева значений.
//
// Возвращаемое значение:
//   Булево  - Истина, если загрузка данных в документ регламентированного отчета прошла успешно.
//
Функция ЗагрузкаОтчетаИзФайла(ФормаОтчета, ПараметрыОтчета, ДанныеДляЗагрузки, ДеревоДляЗагрузки) Экспорт
	
	Перем НастройкиЗагрузки;
	Перем ТекстыПравилЗагрузки; // тип - соответствие (ключ - имя области, значение - текст обработчика)
	
	Если РегламентированнаяОтчетностьКлиентСервер.СвойствоОпределено(ФормаОтчета, "мДанныеОтчета") Тогда
		ФормаОтчета.мДанныеОтчета = Новый Структура;
	КонецЕсли;
	
	СообщениеОбОшибке = Новый Структура("Способ,ТекстСообщения", "СообщениеПоУмолчанию", "");
	ДанныеДляЗагрузки.Вставить("СообщениеОбОшибке", СообщениеОбОшибке);
	
	ОсновнойФайл = Неопределено;
	ДанныеДляЗагрузки.Свойство("СвойстваОсновногоФайла", ОсновнойФайл);
	Если ОсновнойФайл = Неопределено ИЛИ НЕ ЭтоАдресВременногоХранилища(ОсновнойФайл.АдресТекста) Тогда
		ОбщегоНазначения.СообщитьПользователю(НСтр("ru = 'Не удалось открыть файл выгрузки!'"));
		Возврат Ложь;
	КонецЕсли;
	
	РазрешитьЗагрузку = Неопределено;
	ПравилаЗагрузки = РегламентированнаяОтчетностьВызовСервера.ПравилаЗагрузкиДляФормы(ФормаОтчета.ИмяФормы, НастройкиЗагрузки);
	Если ТипЗнч(НастройкиЗагрузки) <> Тип("Структура")
		ИЛИ НЕ НастройкиЗагрузки.Свойство("РазрешитьЗагрузку", РазрешитьЗагрузку) ИЛИ РазрешитьЗагрузку <> Истина Тогда
		СообщениеОбОшибке.Способ = "Предупреждение";
		СообщениеОбОшибке.ТекстСообщения = СтрШаблон(
			НСтр("ru = 'Возможность загрузки из файла отчета ""%1"" за выбранный период не поддерживается.'"),
			ДанныеДляЗагрузки.ВидОтчета);
		Возврат Ложь;
	КонецЕсли;
	
	ТекстыПравилЗагрузки = СодержимоеОбластейПравилЗагрузки(ПравилаЗагрузки, НастройкиЗагрузки);
	
	Если ТипЗнч(ДеревоДляЗагрузки) <> Тип("ДеревоЗначений") И ТипЗнч(ДеревоДляЗагрузки) <> Тип("Структура") Тогда
		СообщениеОбОшибке.Способ = "Предупреждение";
		СообщениеОбОшибке.ТекстСообщения = СтрШаблон(
			НСтр("ru = 'Возможность загрузки из файла отчета ""%1"" не реализована.'"),
			ДанныеДляЗагрузки.ВидОтчета);
		Возврат Ложь;
	КонецЕсли;
	
	Если ДанныеДляЗагрузки.Организация = Неопределено ИЛИ ДанныеДляЗагрузки.Организация.Пустая() Тогда
		ПараметрыОтчета.Вставить("ОрганизацияВыбранаПриЗагрузке", Ложь);
	Иначе
		ПараметрыОтчета.Вставить("ОрганизацияВыбранаПриЗагрузке", Истина);
	КонецЕсли;
	
	ХранилищеТекстаОсновногоФайла = ПолучитьИзВременногоХранилища(ОсновнойФайл.АдресТекста);
	ТекстОсновногоФайла = ХранилищеТекстаОсновногоФайла.Получить();
	РазмерТекстаОсновногоФайла = ОсновнойФайл.РазмерТекста;
	
	// Особая обработка видов и типов регламентированных отчетов.
	Если ДанныеДляЗагрузки.ВидОтчета = Справочники.ВидыОтправляемыхДокументов.НДС Тогда
		
		СообщениеОбОшибке = Неопределено;
		Возврат Ложь; // используем консолидацию отчетности по НДС
		
	ИначеЕсли ДанныеДляЗагрузки.ТипДокумента = Перечисления.ТипыОтправляемыхДокументов.БухгалтерскаяОтчетность Тогда
		
		ИменаКлючевыхСвойств = "КНД,ВерсФорм,Период,ОКЕИ";
		СвойстваОсновногоФайла = СвойстваФайлаЗагрузки(ТекстОсновногоФайла, 15, Истина, ,Истина);
		ДобавитьВПараметрыОтчетаКлючевыеСвойства(ПараметрыОтчета, СвойстваОсновногоФайла, ИменаКлючевыхСвойств);
		
		ПараметрыОтчета.Вставить("ВключитьОФР",  Истина);
		ПараметрыОтчета.Вставить("ВключитьОИК",  Истина);
		ПараметрыОтчета.Вставить("ВключитьОДДС", Истина);
		ПараметрыОтчета.Вставить("ВключитьОЦИС", Истина);
		
		ПараметрыОтчета.Вставить("ЕстьПояснительнаяЗаписка",       Истина);
		ПараметрыОтчета.Вставить("ЕстьАудиторскоеЗаключение",      Истина);
		ПараметрыОтчета.Вставить("ЕстьЗаявлениеРевизионногоСоюза", Истина);
		
		ПолучитьДеревоДляЗагрузкиПоФормату(ФормаОтчета, ДеревоДляЗагрузки, НастройкиЗагрузки, СвойстваОсновногоФайла["ВерсФорм"]);
		
	ИначеЕсли ДанныеДляЗагрузки.ТипДокумента = Перечисления.ТипыОтправляемыхДокументов.ПрочаяОтчетностьФНС
		  ИЛИ ДанныеДляЗагрузки.ТипДокумента = Перечисления.ТипыОтправляемыхДокументов.ЗаявлениеОВвозеТоваров
		  ИЛИ ДанныеДляЗагрузки.ТипДокумента = Перечисления.ТипыОтправляемыхДокументов.УведомлениеОРозничныхЦенахНаТабак Тогда
		
		Если ЭлектронныйДокументооборотСКонтролирующимиОрганамиКлиентСервер.ЭтоФайлВыгрузкиРеестраНДС(ОсновнойФайл.ИмяФайла)
		 ИЛИ СтрНайти(ОсновнойФайл.ИмяФайла, "ON_RRCHEKTF") = 1 // файл отчета "Реестр по НДС: Документы для компенсации налога"
		 ИЛИ СтрНайти(ОсновнойФайл.ИмяФайла, "KO_RRTDCN23") = 1 // файл отчета "Реестр по НДС: Декларации, таможенные декларации CN 23"
		 ИЛИ СтрНайти(ОсновнойФайл.ИмяФайла, "KO_RRDTEG")   = 1 // файл отчета "Реестр по НДС: Декларации на товары для экспресс-грузов"
		Тогда 
			Если ТипЗнч(ДеревоДляЗагрузки) = Тип("Структура") Тогда
				ВыбранноеДеревоДляЗагрузки = Неопределено;
				Если СтрНайти(ОсновнойФайл.ИмяФайла, ".2_") > 0 Тогда // это файл сведений
					ДеревоДляЗагрузки.Свойство("ДеревоЗагрузкиСведений", ВыбранноеДеревоДляЗагрузки);
				Иначе
					ДеревоДляЗагрузки.Свойство("ДеревоЗагрузкиРеестра", ВыбранноеДеревоДляЗагрузки);
				КонецЕсли;
				Если ВыбранноеДеревоДляЗагрузки = Неопределено Тогда
					СообщениеОбОшибке.Способ = "Предупреждение";
					СообщениеОбОшибке.ТекстСообщения = НСтр("ru = 'Не определена схема для загрузки реестра НДС из файла.'");
					Возврат Ложь;
				КонецЕсли;
				ДеревоДляЗагрузки = ВыбранноеДеревоДляЗагрузки;
			КонецЕсли;
			
			ПараметрыОтчета.Вставить("СтруктураМногострочныхЧастей", ФормаОтчета.СтруктураРеквизитовФормы.СтруктураМногострочныхЧастей);
		ИначеЕсли ЭлектронныйДокументооборотСКонтролирующимиОрганамиКлиентСервер.ЭтоФайлВыгрузкиРеестраАкцизов(ОсновнойФайл.ИмяФайла) Тогда
			Если ТипЗнч(ДеревоДляЗагрузки) = Тип("Структура") Тогда
				ВыбранноеДеревоДляЗагрузки = Неопределено;
				Если СтрНайти(ОсновнойФайл.ИмяФайла, ".2_") > 0 Тогда // это файл сведений
					ДеревоДляЗагрузки.Свойство("ДеревоЗагрузкиСведений", ВыбранноеДеревоДляЗагрузки);
				Иначе
					ДеревоДляЗагрузки.Свойство("ДеревоЗагрузкиРеестра", ВыбранноеДеревоДляЗагрузки);
				КонецЕсли;
				Если ВыбранноеДеревоДляЗагрузки = Неопределено Тогда
					СообщениеОбОшибке.Способ = "Предупреждение";
					СообщениеОбОшибке.ТекстСообщения = НСтр("ru = 'Не определена схема для загрузки реестра по акцизам из файла.'");
					Возврат Ложь;
				КонецЕсли;
				ДеревоДляЗагрузки = ВыбранноеДеревоДляЗагрузки;
			КонецЕсли;
			
			ПараметрыОтчета.Вставить("СтруктураМногострочныхЧастей", ФормаОтчета.СтруктураРеквизитовФормы.СтруктураМногострочныхЧастей);
		КонецЕсли;
		
		ИменаКлючевыхСвойств = "КНД,ВерсФорм";
		СвойстваОсновногоФайла = СвойстваФайлаЗагрузки(ТекстОсновногоФайла, 10, Истина, ,Истина);
		ДобавитьВПараметрыОтчетаКлючевыеСвойства(ПараметрыОтчета, СвойстваОсновногоФайла, ИменаКлючевыхСвойств);
		
		ПолучитьДеревоДляЗагрузкиПоФормату(ФормаОтчета, ДеревоДляЗагрузки, НастройкиЗагрузки, СвойстваОсновногоФайла["ВерсФорм"]);
		
	ИначеЕсли ДанныеДляЗагрузки.ТипДокумента = Перечисления.ТипыОтправляемыхДокументов.ОтчетФСРАРОпт
		  ИЛИ ДанныеДляЗагрузки.ТипДокумента = Перечисления.ТипыОтправляемыхДокументов.ОтчетФСРАРРозница Тогда
		
		ИменаКлючевыхСвойств = "НомФорм,ВерсФорм";
		СвойстваОсновногоФайла = СвойстваФайлаЗагрузки(ТекстОсновногоФайла, 10, Истина, ,Истина);
		ДобавитьВПараметрыОтчетаКлючевыеСвойства(ПараметрыОтчета, СвойстваОсновногоФайла, ИменаКлючевыхСвойств);
		
		ПолучитьДеревоДляЗагрузкиПоФормату(ФормаОтчета, ДеревоДляЗагрузки, НастройкиЗагрузки, СвойстваОсновногоФайла["ВерсФорм"]);
		
	ИначеЕсли ДанныеДляЗагрузки.ТипДокумента = Перечисления.ТипыОтправляемыхДокументов.КомплектОтчетностиПФР Тогда
		
		СообщениеОбОшибке.Способ = "Предупреждение";
		СообщениеОбОшибке.ТекстСообщения = НСтр("ru = 'Возможность загрузки из файла отчетов ПФР не поддерживается.'");
		Возврат Ложь;
		
	ИначеЕсли ДанныеДляЗагрузки.ТипДокумента = Перечисления.ТипыОтправляемыхДокументов.Отчет4ФСС
		  ИЛИ ДанныеДляЗагрузки.ТипДокумента = Перечисления.ТипыОтправляемыхДокументов.Отчет4аФСС
		  ИЛИ ДанныеДляЗагрузки.ТипДокумента = Перечисления.ТипыОтправляемыхДокументов.ПрочаяОтчетностьФСС Тогда
		
		СвойстваОсновногоФайла = СвойстваФайлаЗагрузки(ТекстОсновногоФайла, 10, Истина, ,Истина);
		
	ИначеЕсли ДанныеДляЗагрузки.ТипДокумента = Перечисления.ТипыОтправляемыхДокументов.ОтчетФСГС Тогда
		
		СвойстваОсновногоФайла = СвойстваФайлаЗагрузки(ТекстОсновногоФайла, 10, Истина, Истина, Истина);
		
		Если ДанныеДляЗагрузки.ВидОтчета = Справочники.ВидыОтправляемыхДокументов.СтатистикаБухОтчетность Тогда
			
			СообщениеОбОшибке.Способ = "Предупреждение";
			СообщениеОбОшибке.ТекстСообщения = НСтр(
				"ru = 'Возможность загрузки из файла отчета ""Бухгалтерская (финансовая) отчетность в Росстат"" не поддерживается.
					  |Выберите соответствующий вид отчета ""Бухгалтерская отчетность..."" для ФНС.'");
			Возврат Ложь;
			
		КонецЕсли;
		
	ИначеЕсли ДанныеДляЗагрузки.ТипДокумента = Перечисления.ТипыОтправляемыхДокументов.ОтчетностьВМинобороны Тогда
		
		СвойстваОсновногоФайла = СвойстваФайлаЗагрузки(ТекстОсновногоФайла, 10, Истина, , Истина);
		
	Иначе
		
		Возврат Ложь;
		
	КонецЕсли; // особая обработка видов и типов регламентированных отчетов
	
	СохраненныйДок = ФормаОтчета.СтруктураРеквизитовФормы.мСохраненныйДок;
	РазблокироватьДанныеДляРедактирования(СохраненныйДок, ФормаОтчета.УникальныйИдентификатор);
	
	КонтекстФормыОтчета = Новый Структура("ТаблицаСообщений");
	ЗаполнитьЗначенияСвойств(КонтекстФормыОтчета, ФормаОтчета);
	Если КонтекстФормыОтчета.ТаблицаСообщений <> Неопределено Тогда
		КонтекстФормыОтчета.ТаблицаСообщений = КонтекстФормыОтчета.ТаблицаСообщений.Выгрузить();
	КонецЕсли;
	
	СтруктураДанныхДляЗагрузки = Новый Структура("Версия,СообщениеОбОшибке", ДанныеДляЗагрузки.Версия, СообщениеОбОшибке);
	
	ПараметрыВыполнения = Новый Структура;
	ПараметрыВыполнения.Вставить("ДеревоДляЗагрузки",             ДеревоДляЗагрузки);
	ПараметрыВыполнения.Вставить("ПараметрыОтчета",               ПараметрыОтчета);
	ПараметрыВыполнения.Вставить("ТекстыПравилЗагрузки",          ТекстыПравилЗагрузки);
	ПараметрыВыполнения.Вставить("ХранилищеТекстаОсновногоФайла", ХранилищеТекстаОсновногоФайла);
	ПараметрыВыполнения.Вставить("РазмерТекстаОсновногоФайла",    РазмерТекстаОсновногоФайла);
	ПараметрыВыполнения.Вставить("ДанныеДляЗагрузки",             СтруктураДанныхДляЗагрузки);
	ПараметрыВыполнения.Вставить("КонтекстФормыОтчета",           КонтекстФормыОтчета);
	ПараметрыВыполнения.Вставить("СохраненныйДок",                СохраненныйДок);
	
	ПараметрыЗапуска = ДлительныеОперации.ПараметрыВыполненияВФоне(ФормаОтчета.УникальныйИдентификатор);
	ПараметрыЗапуска.НаименованиеФоновогоЗадания = НСтр("ru = 'Загрузка регламентированного отчета из файла электронного представления'");
	ПараметрыЗапуска.ОжидатьЗавершение = 0;
	
	ИмяПроцедуры = "РегламентированнаяОтчетностьЗагрузка.ЗагрузкаОтчетаИзФайлаДлительнаяОперация";
	РезультатДлительнойОперации = ДлительныеОперации.ВыполнитьВФоне(ИмяПроцедуры, ПараметрыВыполнения, ПараметрыЗапуска);
	
	ДанныеДляЗагрузки.Вставить("РезультатДлительнойОперации", РезультатДлительнойОперации);
	Возврат Истина;
	
КонецФункции

// Выполняется в фоновом задании.
Процедура ЗагрузкаОтчетаИзФайлаДлительнаяОперация(ПараметрыПроцедуры, АдресРезультата) Экспорт
	
	ДеревоДляЗагрузки             = ПараметрыПроцедуры.ДеревоДляЗагрузки;
	ПараметрыОтчета               = ПараметрыПроцедуры.ПараметрыОтчета;
	ТекстыПравилЗагрузки          = ПараметрыПроцедуры.ТекстыПравилЗагрузки;
	ХранилищеТекстаОсновногоФайла = ПараметрыПроцедуры.ХранилищеТекстаОсновногоФайла;
	РазмерТекстаОсновногоФайла    = ПараметрыПроцедуры.РазмерТекстаОсновногоФайла;
	КонтекстФормыОтчета           = ПараметрыПроцедуры.КонтекстФормыОтчета;
	СохраненныйДок                = ПараметрыПроцедуры.СохраненныйДок;
	ДанныеДляЗагрузки             = ПараметрыПроцедуры.ДанныеДляЗагрузки;
	
	Попытка
		// Выполняем обработчик перед загрузкой данных из файла в дерево (можно изменить дерево загрузки).
		ПараметрыОбработчика = Новый Структура("ДеревоДляЗагрузки,ПараметрыОтчета", ДеревоДляЗагрузки, ПараметрыОтчета);
		ВыполнитьАлгоритмВБезопасномРежиме(ТекстОбработчикаПоИмени(ТекстыПравилЗагрузки, "ПередЗагрузкой"), ПараметрыОбработчика);
		
		ЗаполнитьДаннымиДерево(ДеревоДляЗагрузки, ХранилищеТекстаОсновногоФайла, РазмерТекстаОсновногоФайла);
	Исключение
		ОписаниеОшибки = ИнформацияОбОшибке().Описание;
		ОбщегоНазначения.СообщитьПользователю(
			СтрШаблон(НСтр("ru = 'Не удалось заполнить схему данных из файла! %1'"), ОписаниеОшибки));
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Загрузка данных регламентированного отчета'"),
			УровеньЖурналаРегистрации.Ошибка,,, ОписаниеОшибки);
			
		ПоместитьВоВременноеХранилище(Ложь, АдресРезультата);
		Возврат;
	КонецПопытки;
	
	ТекстСообщения = НСтр("ru='
		|Обработка загруженных данных'");
	ДлительныеОперации.СообщитьПрогресс(, ТекстСообщения);
	
	ПрименитьПараметрыСократитьДерево(ДеревоДляЗагрузки, ПараметрыОтчета);
	ОбработатьУсловныеЭлементы(КонтекстФормыОтчета, ПараметрыОтчета, ДеревоДляЗагрузки);
	
	ТекстСообщения = НСтр("ru='
		|Заполнение отчета данными'");
	ДлительныеОперации.СообщитьПрогресс(, ТекстСообщения);
	
	Попытка
		ЗаполнитьДаннымиСохраненныйДокумент(СохраненныйДок, ДеревоДляЗагрузки, ПараметрыОтчета, ДанныеДляЗагрузки, ТекстыПравилЗагрузки);
	Исключение
		ОписаниеОшибки = ИнформацияОбОшибке().Описание;
		ОбщегоНазначения.СообщитьПользователю(
			СтрШаблон(НСтр("ru = 'Не удалось заполнить и сохранить документ отчета! %1'"), ОписаниеОшибки));
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Загрузка данных регламентированного отчета'"),
			УровеньЖурналаРегистрации.Ошибка,,, ОписаниеОшибки);
		ПоместитьВоВременноеХранилище(Ложь, АдресРезультата);
		Возврат;
	КонецПопытки;
	
	ПоместитьВоВременноеХранилище(Истина, АдресРезультата);
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ЗаполнениеДокументаДанными

Процедура ПолучитьДеревоДляЗагрузкиПоФормату(ФормаОтчета, ДеревоДляЗагрузки, Настройки, ВерсияФормата)
	
	Перем ФорматыСхемВыгрузки;
	
	Если ПустаяСтрока(ВерсияФормата) ИЛИ ТипЗнч(Настройки) <> Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ Настройки.Свойство("ФорматыСхемВыгрузки", ФорматыСхемВыгрузки)
		ИЛИ ТипЗнч(ФорматыСхемВыгрузки) <> Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	
	ИмяМакетаСхемыВыгрузки = "";
	Для Каждого ЭлементФорматаСхемыВыгрузки Из ФорматыСхемВыгрузки Цикл
		Если ВерсияФормата = ЭлементФорматаСхемыВыгрузки.Значение Тогда
			ИмяМакетаСхемыВыгрузки = ЭлементФорматаСхемыВыгрузки.Ключ;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ПустаяСтрока(ИмяМакетаСхемыВыгрузки) Тогда
		Возврат;
	КонецЕсли;
	
	Попытка
		НовоеДеревоДляЗагрузки = РегламентированнаяОтчетность.ИзвлечьСтруктуруXML(ФормаОтчета.ИмяФормы, ИмяМакетаСхемыВыгрузки);
		
		Если ТипЗнч(НовоеДеревоДляЗагрузки) = Тип("ДеревоЗначений") Тогда
			ДеревоДляЗагрузки = НовоеДеревоДляЗагрузки;
		КонецЕсли;
	Исключение
		ОбщегоНазначения.СообщитьПользователю(
			СтрШаблон(НСтр("ru = 'Не удалось получить схему загрузки для версии данных %1. Используется схема по умолчанию.'"), ВерсияФормата));
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Получение схемы для загрузки'"),
			УровеньЖурналаРегистрации.Ошибка,,, ИнформацияОбОшибке().Описание);
	КонецПопытки;
	
КонецПроцедуры

Процедура ЗаполнитьДаннымиДерево(ДеревоДляЗагрузки, ИмяФайла, РазмерТекста = 0);
	
	// Создаем копию дерева загрузки для использования его узлов в качестве
	// прототипов для создания новых множественных узлов текущего дерева загрузки.
	ДеревоДляЗагрузки.Колонки.Добавить("Прототип");
	ДеревоДляЗагрузкиПрототипы = ДеревоДляЗагрузки.Скопировать();
	ЗаполнитьПрототипыУзлов(ДеревоДляЗагрузки, ДеревоДляЗагрузкиПрототипы);
	
	ДопПараметры = Новый Структура;
	ДопПараметры.Вставить("ЗагруженоСимволов", Мин(РазмерТекста, 46)); // длина заголовка
	ДопПараметры.Вставить("ОбработаноУзлов", 0);
	ДопПараметры.Вставить("РазмерТекста", РазмерТекста);
	ДопПараметры.Вставить("Процент", 0);
	ДопПараметры.Вставить("ТипУзла");
	ДопПараметры.Вставить("ИмяУзла");
	
	ОбъектЧтениеXML = Новый ЧтениеXML;
	Если ТипЗнч(ИмяФайла) = Тип("ХранилищеЗначения") Тогда
		ОбъектЧтениеXML.УстановитьСтроку(ИмяФайла.Получить());
	Иначе
		ОбъектЧтениеXML.ОткрытьФайл(ИмяФайла);
	КонецЕсли;
	ОбъектЧтениеXML.ИгнорироватьПробелы = Ложь;
	
	АтрибутыУзлаДерева = Новый СписокЗначений;
	ЭлементыУзлаДерева = ВсеЭлементыИАтрибутыУзла(ДеревоДляЗагрузки, АтрибутыУзлаДерева);
	
	НетКорневогоЭлемента = Ложь;
	Если ЭлементыУзлаДерева.Количество() > 1 ИЛИ АтрибутыУзлаДерева.Количество() > 0 Тогда
		ЭлементыУзлаДерева.Очистить();
		НетКорневогоЭлемента = Истина;
	КонецЕсли;
	
	Попытка
		ЗаполнитьУзелДерева(ОбъектЧтениеXML, ДеревоДляЗагрузки, ЭлементыУзлаДерева, ДопПараметры, НетКорневогоЭлемента);
	Исключение
		ОбъектЧтениеXML.Закрыть();
		ВызватьИсключение СтрШаблон(НСтр("ru = 'Ошибка чтения XML: %1.'"), ИнформацияОбОшибке().Описание);
	КонецПопытки;
	
	ОбъектЧтениеXML.Закрыть();
	
КонецПроцедуры

Функция ЗаполнитьУзелДерева(ОбъектЧтениеXML, УзелДерева, ЭлементыРодительскогоУзлаДерева, ДопПараметры = Неопределено, ЭлементаНетВДереве = Ложь);
	
	Если ДопПараметры = Неопределено Тогда
		Счетчики = Новый Структура(
			"ЗагруженоСимволов,ОбработаноУзлов,РазмерТекста,Процент,ТипУзла,ИмяУзла", 0, 0, 0, 0);
	Иначе
		Счетчики = ДопПараметры;
	КонецЕсли;
	
	ПредыдущийДочернийУзелДерева = Неопределено;
	
	ЕстьДочерниеУзлы = Ложь;
	
	Пока ОбъектЧтениеXML.Прочитать() Цикл
		
		Если ОбъектЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			
			ЕстьДочерниеУзлы = Истина;
			
			ИмяТекущегоЭлемента = ОбъектЧтениеXML.Имя;
			
			Счетчики.ЗагруженоСимволов = Счетчики.ЗагруженоСимволов + СтрДлина(ИмяТекущегоЭлемента) + 2; // подсчет символов
			Счетчики.ОбработаноУзлов = Счетчики.ОбработаноУзлов + 1; // подсчет узлов
			Счетчики.ТипУзла = ОбъектЧтениеXML.ТипУзла;
			Счетчики.ИмяУзла = ИмяТекущегоЭлемента;
			
			Если ЭлементаНетВДереве Тогда
				СлужебныйЭлемент = ЭлементыРодительскогоУзлаДерева.Добавить();
				СлужебныйЭлемент.Код = ИмяТекущегоЭлемента;
				СлужебныйЭлемент.СтрокаДерева = УзелДерева;
			КонецЕсли;
			
			СтрокиДереваЭлементы = ЭлементыРодительскогоУзлаДерева.НайтиСтроки(Новый Структура("Код", ИмяТекущегоЭлемента));
			
			Если СтрокиДереваЭлементы.Количество() = 0
				И ПредыдущийДочернийУзелДерева <> Неопределено
				И ПредыдущийДочернийУзелДерева.Код = ИмяТекущегоЭлемента Тогда // здесь добавляем новые дочерние узлы
				
				Если ПредыдущийДочернийУзелДерева.Прототип = Неопределено Тогда // предусмотрим и такой вариант
					ПрототипДобавляемогоУзла = ПредыдущийДочернийУзелДерева;
					НовыйУзелИзПрототипа = СкопированныйУзел(УзелДерева, ПрототипДобавляемогоУзла);
				Иначе
					ПрототипДобавляемогоУзла = ПредыдущийДочернийУзелДерева.Прототип;
					НовыйУзелИзПрототипа = СкопированныйУзел(УзелДерева, ПрототипДобавляемогоУзла, "Прототип", ПрототипДобавляемогоУзла);
					// Очищаем прототип в предыдущем узле, чтобы в массиве узлов оставалась единственная ссылка для последующего поиска.
					ПредыдущийДочернийУзелДерева.Прототип = Неопределено;
				КонецЕсли;
				
				СкопированныйЭлемент = ЭлементыРодительскогоУзлаДерева.Добавить();
				СкопированныйЭлемент.Код = ИмяТекущегоЭлемента;
				СкопированныйЭлемент.СтрокаДерева = НовыйУзелИзПрототипа;
				
				СтрокиДереваЭлементы.Добавить(СкопированныйЭлемент);
			КонецЕсли;
			
			АтрибутыУзлаXML = Новый СписокЗначений;
			Если СтрокиДереваЭлементы.Количество() > 0 Тогда
				Пока ОбъектЧтениеXML.ПрочитатьАтрибут() Цикл
					
					Счетчики.ЗагруженоСимволов = Счетчики.ЗагруженоСимволов +
						СтрДлина(ОбъектЧтениеXML.Имя) + СтрДлина(ОбъектЧтениеXML.Значение) + 4; // подсчет символов
					
					Если НЕ СтрНачинаетсяС(ОбъектЧтениеXML.Имя, "xmlns") И СтрНайти(ОбъектЧтениеXML.Имя, ":") = 0 Тогда
						АтрибутыУзлаXML.Добавить(ОбъектЧтениеXML.Значение, ОбъектЧтениеXML.Имя);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			
			ЭлементНайден = Ложь;
			
			Для НомПопытки = 1 По 2 Цикл
				
				МаксИндекс = СтрокиДереваЭлементы.ВГраница();
				Для Инд = 0 По МаксИндекс Цикл
					СтрокаДереваЭлемент = СтрокиДереваЭлементы[Инд];
					АтрибутыУзлаДерева = Новый Соответствие;
					ЭлементыУзлаДерева = ВсеЭлементыИАтрибутыУзла(СтрокаДереваЭлемент.СтрокаДерева, АтрибутыУзлаДерева);
					
					// Если не удалось найти и установить все атрибуты узла из XML-файла,
					// тогда пропускаем узел и пытаемся обработать следующий одноименный.
					Если НЕ УстановитьВсеАтрибуты(АтрибутыУзлаДерева, АтрибутыУзлаXML) Тогда
						Продолжить;
					КонецЕсли;
					
					Если ЗаполнитьУзелДерева(ОбъектЧтениеXML, СтрокаДереваЭлемент.СтрокаДерева, ЭлементыУзлаДерева, ДопПараметры) Тогда
						Возврат Истина; // возврат из функции если достигнут конец файла
					КонецЕсли;
					
					ПредыдущийДочернийУзелДерева = СтрокаДереваЭлемент.СтрокаДерева;
					
					СтрокиДереваЭлементы.Удалить(Инд);
					ЭлементыРодительскогоУзлаДерева.Удалить(СтрокаДереваЭлемент); // элемент обработан - удаляем из таблицы
					ЭлементНайден = Истина;
					Прервать;
				КонецЦикла;
				
				Если НЕ ЭлементНайден И НомПопытки = 1
					И СтрокиДереваЭлементы.Количество() > 0
					И ПредыдущийДочернийУзелДерева <> Неопределено
					И ПредыдущийДочернийУзелДерева.Код = ИмяТекущегоЭлемента Тогда
					
					АтрибутыУзлаДерева = Новый Соответствие;
					ЭлементыУзлаДерева = ВсеЭлементыИАтрибутыУзла(ПредыдущийДочернийУзелДерева, АтрибутыУзлаДерева);
					Если ПроверитьВсеАтрибуты(АтрибутыУзлаДерева, АтрибутыУзлаXML)
					   И ПредыдущийДочернийУзелДерева.Прототип <> Неопределено Тогда
						// Добавляем новый дочерний узел после проверки и совпадения атрибутов.
						ПрототипДобавляемогоУзла = ПредыдущийДочернийУзелДерева.Прототип;
						НовыйУзелИзПрототипа = СкопированныйУзел(УзелДерева, ПрототипДобавляемогоУзла, "Прототип", ПрототипДобавляемогоУзла);
						// Очищаем прототип в предыдущем узле, чтобы в массиве узлов оставалась единственная ссылка для последующего поиска.
						ПредыдущийДочернийУзелДерева.Прототип = Неопределено;
					
						СкопированныйЭлемент = ЭлементыРодительскогоУзлаДерева.Добавить();
						СкопированныйЭлемент.Код = ИмяТекущегоЭлемента;
						СкопированныйЭлемент.СтрокаДерева = НовыйУзелИзПрототипа;
						
						СтрокиДереваЭлементы.Вставить(0, СкопированныйЭлемент);
						
						Продолжить; // выполняем вторую попытку
					КонецЕсли;
				КонецЕсли;
				
				Прервать; // вторая попытка не требуется
				
			КонецЦикла;
			
			Если НЕ ЭлементНайден Тогда
				
				ТекстСообщения = СтрШаблон(НСтр("ru = 'В схеме загрузки не найден узел с именем ""%1""!'"), ИмяТекущегоЭлемента);
				ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
				ОбъектЧтениеXML.Пропустить();
				
				Счетчики.ЗагруженоСимволов = Счетчики.ЗагруженоСимволов + СтрДлина(ИмяТекущегоЭлемента) + 4; // подсчет символов
				
			КонецЕсли;
			
		ИначеЕсли ОбъектЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
			
			Счетчики.ЗагруженоСимволов = Счетчики.ЗагруженоСимволов + СтрДлина(ОбъектЧтениеXML.Значение); // подсчет символов
			Счетчики.ТипУзла = ОбъектЧтениеXML.ТипУзла;
			Счетчики.ИмяУзла = ОбъектЧтениеXML.Имя;
			
			Если НЕ ЭлементаНетВДереве И ТипЗнч(УзелДерева) <> Тип("ДеревоЗначений") Тогда
				Если ЕстьДочерниеУзлы Тогда
					УзелДерева.Значение = Неопределено;
				Иначе
					УзелДерева.Значение = ОбъектЧтениеXML.Значение;
				КонецЕсли;
			КонецЕсли;
			
		ИначеЕсли ОбъектЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			
			Если Счетчики.ТипУзла = ТипУзлаXML.НачалоЭлемента
			   И Счетчики.ИмяУзла = ОбъектЧтениеXML.Имя Тогда
				ЗагруженоСимволов = 1; // пустой узел
			Иначе
				ЗагруженоСимволов = СтрДлина(ОбъектЧтениеXML.Имя) + 3;
			КонецЕсли;
			
			Счетчики.ЗагруженоСимволов = Счетчики.ЗагруженоСимволов + ЗагруженоСимволов; // подсчет символов
			Счетчики.ТипУзла = ОбъектЧтениеXML.ТипУзла;
			Счетчики.ИмяУзла = ОбъектЧтениеXML.Имя;
			
			Возврат Ложь; // конец файла не достигнут
			
		Иначе
			
			Счетчики.ЗагруженоСимволов = Счетчики.ЗагруженоСимволов
				+ ?(ОбъектЧтениеXML.ИмеетИмя, СтрДлина(ОбъектЧтениеXML.Имя) + 4, 0)
				+ ?(ОбъектЧтениеXML.ИмеетЗначение, СтрДлина(ОбъектЧтениеXML.Значение), 0); // подсчет символов
			
		КонецЕсли;
		
		Если Счетчики.РазмерТекста > 0 Тогда
			Процент = Мин(Окр(100 * Счетчики.ЗагруженоСимволов / Счетчики.РазмерТекста), 100);
			Если Счетчики.Процент < Процент Тогда
				ТекстСообщения = СтрШаблон(НСтр("ru='загружено элементов %1'"), Формат(Счетчики.ОбработаноУзлов, "ЧГ="));
				ДлительныеОперации.СообщитьПрогресс(Процент, ТекстСообщения);
				Счетчики.Процент = Процент;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция ВсеЭлементыИАтрибутыУзла(Узел, Атрибуты = Неопределено)
	
	ЭлементыУзла = Новый ТаблицаЗначений; // важен порядок элементов
	ЭлементыУзла.Колонки.Добавить("Код", Новый ОписаниеТипов("Строка"));
	ЭлементыУзла.Колонки.Добавить("СтрокаДерева");
	
	Если ТипЗнч(Атрибуты) <> Тип("Соответствие") Тогда
		Атрибуты = Новый Соответствие;
	КонецЕсли;
	
	Для Каждого ПодчиненныйУзел Из Узел.Строки Цикл
		Если ПодчиненныйУзел.Тип = "С" ИЛИ ПодчиненныйУзел.Тип = "C" // учтем оба варианта: кириллицу и латиницу
			ИЛИ ПодчиненныйУзел.Тип = "Э" ИЛИ ПодчиненныйУзел.Тип = "П" Тогда
			ЭлементСтрока = ЭлементыУзла.Добавить();
			ЭлементСтрока.Код = ПодчиненныйУзел.Код;
			ЭлементСтрока.СтрокаДерева = ПодчиненныйУзел;
		ИначеЕсли ПодчиненныйУзел.Тип = "А" ИЛИ ПодчиненныйУзел.Тип = "A" Тогда // учтем оба варианта: кириллицу и латиницу
			Атрибуты.Вставить(ПодчиненныйУзел.Код, ПодчиненныйУзел);
		Иначе
			ТекстСообщения = СтрШаблон(НСтр("ru = 'В схеме загрузки не распознан тип узла ""%1""!'"), ПодчиненныйУзел.Код);
			ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
		КонецЕсли;
	КонецЦикла;
	
	ЭлементыУзла.Индексы.Добавить("Код");
	
	Возврат ЭлементыУзла;
	
КонецФункции

Функция УстановитьВсеАтрибуты(АтрибутыУзлаПриемника, АтрибутыУзлаИсточника)
	
	СтрокиДереваИЗначения = Новый СписокЗначений;
		
	Для Каждого АтрибутУзлаИсточника Из АтрибутыУзлаИсточника Цикл
		
		СтрокаДерева = АтрибутыУзлаПриемника[АтрибутУзлаИсточника.Представление];
		
		Если СтрокаДерева = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
		
		// Для правильного чтения файлов выгрузки отчетов статистики.
		Если НЕ ПустаяСтрока(СтрокаДерева.ЗначениеПоУмолчанию)
			И Лев(СтрокаДерева.ЗначениеПоУмолчанию, 1) <> "&"
			И СокрЛП(СтрокаДерева.ЗначениеПоУмолчанию) <> СокрЛП(АтрибутУзлаИсточника.Значение) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		СтрокиДереваИЗначения.Добавить(СтрокаДерева, АтрибутУзлаИсточника.Значение);
		
	КонецЦикла;
	
	Для Каждого ЭлементСтрокаДереваИЗначение Из СтрокиДереваИЗначения Цикл
		
		СтрокаДерева      = ЭлементСтрокаДереваИЗначение.Значение;
		ТекстовоеЗначение = ЭлементСтрокаДереваИЗначение.Представление;
		
		СтрокаДерева.Значение = ТекстовоеЗначение;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция ПроверитьВсеАтрибуты(АтрибутыУзлаПриемника, АтрибутыУзлаИсточника)
	
	Для Каждого АтрибутУзлаИсточника Из АтрибутыУзлаИсточника Цикл
		
		СтрокаДерева = АтрибутыУзлаПриемника[АтрибутУзлаИсточника.Представление];
		
		Если СтрокаДерева = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
		
		// Для корректной загрузки файлов выгрузки отчетов статистики.
		Если НЕ ПустаяСтрока(СтрокаДерева.ЗначениеПоУмолчанию)
			И Лев(СтрокаДерева.ЗначениеПоУмолчанию, 1) <> "&"
			И СокрЛП(СтрокаДерева.ЗначениеПоУмолчанию) <> СокрЛП(АтрибутУзлаИсточника.Значение) Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

Функция СкопированныйУзел(Родитель, Узел, ПолеПоиска = "", ЗначениеПоиска = Неопределено)
	
	УзелРодитель = Узел.Родитель;
	Если УзелРодитель = Неопределено Тогда
		УзелРодитель = Узел.Владелец();
	КонецЕсли;
	
	ИндексКопируемогоУзла = УзелРодитель.Строки.Индекс(Узел);
	
	Если ЗначениеПоиска <> Неопределено Тогда
		// Используем поиск единственного значения для ускорения
		// при добавлении большого количества одинаковых узлов.
		СтрокиСТемЖеКодом = Новый Массив;
		НайденнаяСтрока = Родитель.Строки.Найти(ЗначениеПоиска, ПолеПоиска, Ложь);
		Если НайденнаяСтрока <> Неопределено И НайденнаяСтрока.Код = Узел.Код Тогда
			СтрокиСТемЖеКодом.Добавить(НайденнаяСтрока);
		КонецЕсли;
	Иначе
		СтрокиСТемЖеКодом = Родитель.Строки.НайтиСтроки(Новый Структура("Код", Узел.Код), Ложь);
	КонецЕсли;
	
	МаксИндекс = -1;
	
	// Находим узел в максимальным индексом с тем же кодом,
	// что и у копируемого и добавляем его сразу после найденного элемента.
	МаксИндексМассиваСтрок = СтрокиСТемЖеКодом.ВГраница();
	Если МаксИндексМассиваСтрок >= 0 Тогда
		ИндексПоследнейСтроки = Родитель.Строки.Индекс(СтрокиСТемЖеКодом[МаксИндексМассиваСтрок]);
		Если ИндексПоследнейСтроки >= (МаксИндексМассиваСтрок + ИндексКопируемогоУзла) Тогда
			МаксИндекс = ИндексПоследнейСтроки;
		Иначе
			Для Каждого СтрокаСТемЖеКодом Из СтрокиСТемЖеКодом Цикл
				ТекИндекс = Родитель.Строки.Индекс(СтрокаСТемЖеКодом);
				Если ТекИндекс > МаксИндекс Тогда
					МаксИндекс = ТекИндекс;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	ИндексСоздаваемогоУзла = МаксИндекс + 1;
	
	// Если аналогичный узел не найден или найденный узел - последний.
	Если ИндексСоздаваемогоУзла >= Родитель.Строки.Количество() ИЛИ ИндексСоздаваемогоУзла = 0 Тогда
		НовыйУзел = Родитель.Строки.Добавить();
	Иначе
		НовыйУзел = Родитель.Строки.Вставить(ИндексСоздаваемогоУзла);
	КонецЕсли;
	
	ЗаполнитьЗначенияСвойств(НовыйУзел, Узел, , "Родитель, Строки, Значение");
	НовыйУзел.Значение = Неопределено;
	
	Для Каждого Стр Из Узел.Строки Цикл
		СкопированныйУзел(НовыйУзел, Стр);
	КонецЦикла;
	
	Возврат НовыйУзел;
	
КонецФункции

Функция СкопированныйУзелМУР(Родитель, Узел, ОчищатьЗначения = Истина)
	
	НовыйУзел = Родитель.Строки.Добавить();
	
	// Копируем узел многоуровневого раздела.
	
	ЗаполнитьЗначенияСвойств(НовыйУзел, Узел, , "Родитель, Строки");
	
	КоличествоКолонок = НовыйУзел.Владелец().Колонки.Количество();
	Для Инд = 0 По КоличествоКолонок - 1 Цикл
		
		ЗначениеКолонкиУзла = НовыйУзел[Инд];
		
		Если ТипЗнч(ЗначениеКолонкиУзла) = Тип("Структура") Тогда
			НовыйУзел[Инд] = СкопированнаяСтруктура(ЗначениеКолонкиУзла, ОчищатьЗначения);
		ИначеЕсли ТипЗнч(ЗначениеКолонкиУзла) = Тип("ДеревоЗначений") Тогда
			СкопированноеДерево = СкопироватьКолонкиДерева(Узел);
			Для Каждого УзелПервогоУровня Из ЗначениеКолонкиУзла.Строки Цикл
				СкопированныйУзелМУР(СкопированноеДерево, УзелПервогоУровня, ОчищатьЗначения);
			КонецЦикла;
			НовыйУзел[Инд] = СкопированноеДерево;
		КонецЕсли;
		
	КонецЦикла;
	
	Для Каждого ПодчиненныйУзел Из Узел.Строки Цикл
		
		СкопированныйУзелМУР(НовыйУзел, ПодчиненныйУзел, ОчищатьЗначения);
		
	КонецЦикла;
	
	Возврат НовыйУзел;
	
КонецФункции

Функция СкопированнаяСтруктура(Источник, ОчищатьЗначения = Ложь) Экспорт
	
	Приемник = Новый Структура;
	
	Если ТипЗнч(Источник) = Тип("Структура") Тогда
		
		Для Каждого Элемент Из Источник Цикл
			Если Элемент.Значение = Неопределено Тогда
				Приемник.Вставить(Элемент.Ключ);
			ИначеЕсли ТипЗнч(Элемент.Значение) = Тип("ДеревоЗначений") Тогда
				СкопированноеДерево = СкопироватьКолонкиДерева(Элемент.Значение);
				Для Каждого СтрокаДерева Из Элемент.Значение.Строки Цикл
					СкопированныйУзелМУР(СкопированноеДерево, СтрокаДерева, ОчищатьЗначения);
				КонецЦикла;
				Приемник.Вставить(Элемент.Ключ, СкопированноеДерево);
			Иначе
				ЗначениеЭлемента = Элемент.Значение;
				Если ОчищатьЗначения Тогда
					Типы = Новый Массив;
					Типы.Добавить(ТипЗнч(ЗначениеЭлемента));
					ОписаниеТиповЗначения = Новый ОписаниеТипов(Типы);
					ЗначениеЭлемента = ОписаниеТиповЗначения.ПривестиЗначение();
				КонецЕсли;
				Приемник.Вставить(Элемент.Ключ, ЗначениеЭлемента);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Приемник;
	
КонецФункции

Функция СкопированныйМассив(Источник, ОчищатьЗначения = Ложь)
	
	Приемник = Новый Массив;
	
	Если ТипЗнч(Источник) = Тип("Массив") Тогда
		
		Для Каждого Элемент Из Источник Цикл
			Если Элемент = Неопределено Тогда
				Приемник.Добавить();
			ИначеЕсли ТипЗнч(Элемент) = Тип("Структура") Тогда
				Приемник.Добавить(СкопированнаяСтруктура(Элемент, ОчищатьЗначения));
			ИначеЕсли ТипЗнч(Элемент) = Тип("ДеревоЗначений") Тогда
				СкопированноеДерево = СкопироватьКолонкиДерева(Элемент);
				Для Каждого СтрокаДерева Из Элемент.Строки Цикл
					СкопированныйУзелМУР(СкопированноеДерево, СтрокаДерева, ОчищатьЗначения);
				КонецЦикла;
				Приемник.Добавить(СкопированноеДерево);
			Иначе
				Если ОчищатьЗначения Тогда
					Типы = Новый Массив;
					Типы.Добавить(ТипЗнч(Элемент));
					ОписаниеТиповЗначения = Новый ОписаниеТипов(Типы);
					Элемент = ОписаниеТиповЗначения.ПривестиЗначение();
				КонецЕсли;
				Приемник.Добавить(Элемент);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Приемник;
	
КонецФункции

Функция СкопироватьКолонкиДерева(Источник)
	
	Приемник = Новый ДеревоЗначений;
	
	Если ТипЗнч(Источник) = Тип("ДеревоЗначений") Тогда
		КолонкиИсточника = Источник.Колонки;
	Иначе
		КолонкиИсточника = Источник.Владелец().Колонки;
	КонецЕсли;
	
	Для Каждого КолонкаИсточника Из КолонкиИсточника Цикл
		Приемник.Колонки.Добавить(КолонкаИсточника.Имя,
								  КолонкаИсточника.ТипЗначения,
								  КолонкаИсточника.Заголовок,
								  КолонкаИсточника.Ширина);
	КонецЦикла;
	
	Возврат Приемник;
	
КонецФункции

Функция ЗначениеПоказателяИзXML(Узел, Значение = Неопределено)
	
	Перем ЗначениеПоказателя;
	
	// Если параметр "Значение" пропущен - используем значение узла.
	ЗначениеПоказателяXML = СокрЛП(?(Значение = Неопределено, Узел.Значение, Значение));
	
	МинШирина = Узел.МинРазмерность;
	МаксШирина = Узел.МаксРазмерность;
	
	Если Узел.Формат = "T" ИЛИ Узел.Формат = "Т" Тогда      // учтем оба варианта: кириллицу и латиницу
		Если ЗначениеЗаполнено(ЗначениеПоказателяXML) Тогда
			ЗначениеПоказателя = ?(МаксШирина < СтрДлина(ЗначениеПоказателяXML), СокрЛП(Лев(ЗначениеПоказателяXML, МаксШирина)), ЗначениеПоказателяXML);
		Иначе
			ЗначениеПоказателя = "";
		КонецЕсли;
	ИначеЕсли Узел.Формат = "B" ИЛИ Узел.Формат = "В" Тогда // учтем оба варианта: кириллицу и латиницу
		Если ЗначениеПоказателяXML = "1" ИЛИ ЗначениеПоказателяXML = "0"
			ИЛИ НРег(ЗначениеПоказателяXML) = "true" ИЛИ НРег(ЗначениеПоказателяXML) = "false" Тогда
			ЗначениеПоказателя = XMLЗначение(Тип("Булево"), ЗначениеПоказателяXML);
		Иначе
			ЗначениеПоказателя = Ложь;
		КонецЕсли;
	ИначеЕсли Узел.Формат = "N" Тогда
		Если ЗначениеЗаполнено(ЗначениеПоказателяXML) Тогда
			ЗначениеПоказателя = XMLЗначение(Тип("Число"), " " + ЗначениеПоказателяXML);
		Иначе
			ЗначениеПоказателя = 0;
		КонецЕсли;
	ИначеЕсли Узел.Формат = "D" Тогда
		Если ЗначениеЗаполнено(ЗначениеПоказателяXML) Тогда
			ЗначениеПоказателя = ДатаИзСтрокиЛюбогоФормата(ЗначениеПоказателяXML);
		Иначе
			ЗначениеПоказателя = '00010101';
		КонецЕсли;
	ИначеЕсли Узел.Формат = "gYear" Тогда
		Если ПустаяСтрока(ЗначениеПоказателяXML) Тогда
			ЗначениеПоказателя = 0;
		ИначеЕсли СтрДлина(ЗначениеПоказателяXML) = 4 Тогда
			ЗначениеПоказателя = XMLЗначение(Тип("Число"), " " + ЗначениеПоказателяXML);
		Иначе
			ЗначениеПоказателя = Год(ДатаИзСтрокиЛюбогоФормата(ЗначениеПоказателяXML));
		КонецЕсли;
	Иначе
		ЗначениеПоказателя = ЗначениеПоказателяXML;
	КонецЕсли;
	
	Возврат ЗначениеПоказателя;
	
КонецФункции

Функция УзелНеЗаполнялся(Узел)

	Для Каждого Стр из Узел.Строки Цикл
		Если НЕ УзелНеЗаполнялся(Стр) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
		
	Возврат Узел.Значение = Неопределено;
	
КонецФункции

Функция ЧислоИзСтроки(Стр)
	
	Если ЗначениеЗаполнено(Стр) Тогда
		Значение = XMLЗначение(Тип("Число"), " " + СокрЛП(СтрЗаменить(СтрЗаменить(Стр, Символы.НПП, ""), ",", ".")));
	Иначе
		Значение = 0;
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

Функция ДатаИзСтрокиЛюбогоФормата(СтрДата) Экспорт 
	
	Разделители = "-.,/:";
	
	ДлинаСтроки = СтрДлина(СтрДата);
	
	МассивПолей = Новый Массив;
	МассивПолей.Добавить("");
	
	Для НС = 1 По ДлинаСтроки Цикл
		Сим = Сред(СтрДата, НС, 1);
		Если Найти(Разделители, Сим) > 0 Тогда
			МассивПолей.Добавить("");
		ИначеЕсли (Сим = "T" ИЛИ Сим = " ") И МассивПолей.ВГраница() < 3 Тогда
			МассивПолей.Вставить(3, "");
		ИначеЕсли Найти("0123456789", Сим) > 0 Тогда
			МассивПолей[МассивПолей.ВГраница()] = МассивПолей[МассивПолей.ВГраница()] + Сим;
		КонецЕсли;
	КонецЦикла;
	
	Поле1 = Макс(1, XMLЗначение(Тип("Число"), " " + СокрЛП(МассивПолей[0])));
	Поле2 = Макс(1, XMLЗначение(Тип("Число"), " " + ?(МассивПолей.ВГраница() < 1, "1", СокрЛП(МассивПолей[1]))));
	Поле3 = Макс(1, XMLЗначение(Тип("Число"), " " + ?(МассивПолей.ВГраница() < 2, "1", СокрЛП(МассивПолей[2]))));
	
	Если СтрДлина(МассивПолей[0]) = 8 ИЛИ СтрДлина(МассивПолей[0]) = 14 Тогда
		
		Возврат Дата(МассивПолей[0]);
		
	ИначеЕсли СтрДлина(МассивПолей[0]) = 4 Тогда
		Год   = Мин(3999, Поле1);
		Месяц = Мин(12,   Поле2);
		День  = Мин(31,   Поле3);
	ИначеЕсли МассивПолей.ВГраница() > 0
		И СтрДлина(МассивПолей[1]) = 4 Тогда
		Год   = Мин(3999, Поле2);
		Месяц = Мин(12,   Поле1);
		День  = Мин(31,   Поле3);
	Иначе
		Год   = Мин(3999, Поле3);
		Месяц = Мин(12,   Поле2);
		День  = Мин(31,   Поле1);
	КонецЕсли;
	
	Час = Мин(23, XMLЗначение(Тип("Число"), " " + ?(МассивПолей.ВГраница() < 3, "0", СокрЛП(МассивПолей[3]))));
	Мин = Мин(59, XMLЗначение(Тип("Число"), " " + ?(МассивПолей.ВГраница() < 4, "0", СокрЛП(МассивПолей[4]))));
	Сек = Мин(59, XMLЗначение(Тип("Число"), " " + ?(МассивПолей.ВГраница() < 5, "0", СокрЛП(МассивПолей[5]))));
	
	Возврат Дата(Год, Месяц, День, Час, Мин, Сек);
	
КонецФункции

Функция СтроковыйКлючУзла(Узел)
	
	КлючУзла = Узел.Код + ";" + РазделУзла(Узел);
	
	Для Каждого ПодчиненныйУзел Из Узел.Строки Цикл
		Если ПодчиненныйУзел.Тип = "С" ИЛИ ПодчиненныйУзел.Тип = "C" // учтем оба варианта: кириллицу и латиницу
			ИЛИ ПодчиненныйУзел.Тип = "Э" Тогда
			Прервать;
		ИначеЕсли ПодчиненныйУзел.Тип = "А" ИЛИ ПодчиненныйУзел.Тип = "A" Тогда // учтем оба варианта: кириллицу и латиницу
			Если НЕ ПустаяСтрока(ПодчиненныйУзел.ЗначениеПоУмолчанию) Тогда
				КлючУзла = КлючУзла + ";" + ПодчиненныйУзел.Код + "=" + ПодчиненныйУзел.ЗначениеПоУмолчанию;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат КлючУзла;
	
КонецФункции

Функция МногостраничностьУзла(Узел)
	
	Если Узел.Многостраничность Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если СтрНайти(Узел.Тип, "П") <> 0 ИЛИ Узел.Многострочность Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если МножественныйУзел(Узел) Тогда
		
		Если Узел.Родитель = Неопределено Тогда
			РодительскийУзел = Узел.Владелец();
		Иначе
			РодительскийУзел = Узел.Родитель;
		КонецЕсли;
		
		УзелДляСравнения = Неопределено;
		ИндексУзла = РодительскийУзел.Строки.Индекс(Узел);
		
		Если ИндексУзла = 0 Тогда
			Если Узел.Родитель <> Неопределено Тогда
				УзелДляСравнения = РодительскийУзел;
			КонецЕсли;
		Иначе
			УзелДляСравнения = РодительскийУзел.Строки.Получить(ИндексУзла - 1);
		КонецЕсли;
		
		Если УзелДляСравнения <> Неопределено И РазделУзла(УзелДляСравнения)= РазделУзла(Узел) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		Возврат Истина;
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция МногострочностьУзла(Узел)
	
	Если Узел.Многострочность ИЛИ СтрНайти(Узел.Тип, "П") <> 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Узел.Многостраничность Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если МножественныйУзел(Узел) Тогда
		
		Если Узел.Родитель = Неопределено Тогда
			РодительскийУзел = Узел.Владелец();
		Иначе
			РодительскийУзел = Узел.Родитель;
		КонецЕсли;
		
		УзелДляСравнения = Неопределено;
		ИндексУзла = РодительскийУзел.Строки.Индекс(Узел);
		
		Если ИндексУзла = 0 Тогда
			Если Узел.Родитель <> Неопределено Тогда
				УзелДляСравнения = РодительскийУзел;
			КонецЕсли;
		Иначе
			УзелДляСравнения = РодительскийУзел.Строки.Получить(ИндексУзла - 1);
		КонецЕсли;
		
		Если УзелДляСравнения <> Неопределено И РазделУзла(УзелДляСравнения)= РазделУзла(Узел) Тогда
			Возврат Истина;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция МногоуровневыйУзел(Узел)
	
	Если ТипЗнч(Узел) <> Тип("ДеревоЗначений") Тогда
		
		Если Узел.Владелец().Колонки.Найти("МнУр") <> Неопределено Тогда
			
			Возврат (Узел.МнУр = Истина);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция МножественныйУзел(Узел)
	
	Возврат (СтрНайти(Узел.Обязательность, "М") <> 0 ИЛИ СтрНайти(Узел.Обязательность, "M") <> 0);
	
КонецФункции

Функция РазделУзла(Узел)
	
	РазделУзла   = Узел.Раздел;
	РодительУзла = Узел.Родитель;
	
	Пока ПустаяСтрока(РазделУзла) И РодительУзла <> Неопределено Цикл
		
		РазделУзла   = РодительУзла.Раздел;
		РодительУзла = РодительУзла.Родитель;
		
	КонецЦикла;
	
	Возврат РазделУзла;
	
КонецФункции

Процедура ПрименитьПараметрыСократитьДерево(Узел, ПараметрыОтчета)
	
	ЭтоСтрокаДереваЗначений = (ТипЗнч(Узел) <> Тип("ДеревоЗначений"));
	
	Если ЭтоСтрокаДереваЗначений Тогда
		Если НЕ ПустаяСтрока(Узел.ЗначениеПоУмолчанию) Тогда
			
			Если Лев(Узел.ЗначениеПоУмолчанию, 1) = "&" Тогда
				
				Ключ = Сред(Узел.ЗначениеПоУмолчанию, 2);
				
				НайденКлюч = Истина;
				КлючВыгрузки = Строка(Ключ);
				ПозицияТочки = СтрНайти(КлючВыгрузки, ".");
				
				СтруктураПараметровОтчета = ПараметрыОтчета;
				
				Пока ПозицияТочки > 0 Цикл
					
					ПромежуточныйКлюч = Лев(КлючВыгрузки, ПозицияТочки - 1);
					КлючВыгрузки = Сред(КлючВыгрузки, ПозицияТочки + 1);
					
					Если СтруктураПараметровОтчета.Свойство(ПромежуточныйКлюч) Тогда
						СтруктураПараметровОтчета = СтруктураПараметровОтчета[ПромежуточныйКлюч];
					Иначе
						НайденКлюч = Ложь;
						Прервать;
					КонецЕсли;
					
					ПозицияТочки = СтрНайти(КлючВыгрузки, ".");
					
				КонецЦикла;
				
				Если НайденКлюч Тогда   
					Если Узел.Значение = Неопределено Тогда
						ЗначениеПараметра = Неопределено;
						СтруктураПараметровОтчета.Свойство(КлючВыгрузки, ЗначениеПараметра);
						Узел.Значение = ЗначениеПараметра;
					Иначе
						СтруктураПараметровОтчета.Вставить(КлючВыгрузки, Узел.Значение);
					КонецЕсли;
				КонецЕсли;
				
			Иначе
				Если Узел.Значение = Неопределено Тогда
					Узел.Значение = СокрЛП(Узел.ЗначениеПоУмолчанию);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(Узел.Ключ) Тогда
			Если НЕ Узел.Многострочность И НЕ Узел.Многостраничность Тогда
				ЗначениеПараметра = Неопределено;
				Если ПараметрыОтчета.Свойство(Узел.Ключ, ЗначениеПараметра) Тогда
					Если НЕ ЗначениеЗаполнено(ЗначениеПараметра) ИЛИ ЗначениеПараметра = '00010101' Тогда
						ПараметрыОтчета[Узел.Ключ] = ЗначениеПоказателяИзXML(Узел);
					КонецЕсли;
				Иначе
					ПараметрыОтчета.Вставить(Узел.Ключ, ЗначениеПоказателяИзXML(Узел));
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	КоличествоСтрок = Узел.Строки.Количество();
	Для Инд = 1 По КоличествоСтрок Цикл
		Стр = Узел.Строки.Получить(КоличествоСтрок - Инд);
		ПрименитьПараметрыСократитьДерево(Стр, ПараметрыОтчета);
	КонецЦикла;
	
	Если ЭтоСтрокаДереваЗначений Тогда
		Если (СтрНайти(Узел.Обязательность, "Н") <> 0 ИЛИ СтрНайти(Узел.Обязательность, "H") <> 0) И УзелНеЗаполнялся(Узел) Тогда // учтем оба варианта: кириллицу и латиницу
			РегламентированнаяОтчетность.УдалитьУзел(Узел);
		ИначеЕсли (СтрНайти(Узел.Обязательность, "М") <> 0 ИЛИ СтрНайти(Узел.Обязательность, "M") <> 0) И УзелНеЗаполнялся(Узел)  // учтем оба варианта: кириллицу и латиницу
			И ?(СтрНайти(Узел.Обязательность, "О") <> 0 ИЛИ СтрНайти(Узел.Обязательность, "O") <> 0, РегламентированнаяОтчетность.ИмеютсяАналогичныеСоседниеУзлыКлюч(Узел), Истина) Тогда
			РегламентированнаяОтчетность.УдалитьУзел(Узел);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьУсловныеЭлементы(Форма, ПараметрыОтчета, Узел)
	
	Если ТипЗнч(Узел) <> Тип("ДеревоЗначений") Тогда
		ИмяКлючевогоУзлаСодержательнойЧасти = Неопределено;
		ПараметрыОтчета.Свойство("ИмяКлючевогоУзлаСодержательнойЧасти", ИмяКлючевогоУзлаСодержательнойЧасти);
		Если Узел.Код = ИмяКлючевогоУзлаСодержательнойЧасти Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	КоличествоСтрок = Узел.Строки.Количество();
	Для Инд = 1 По КоличествоСтрок Цикл
		ТекСтр = Узел.Строки.Получить(КоличествоСтрок - Инд);
		Если НЕ ПустаяСтрока(ТекСтр.Условие) Тогда
			Если НЕ РегламентированнаяОтчетность.УсловиеВыполнено(Форма, ПараметрыОтчета, ТекСтр.Условие) Тогда
				Узел.Строки.Удалить(ТекСтр);
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		ОбработатьУсловныеЭлементы(Форма, ПараметрыОтчета, ТекСтр);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьПрототипыУзлов(ДеревоПриемник, ДеревоИсточник, ИмяКолонкиПрототип = "Прототип")
	
	КоличествоСтрокПриемник = ДеревоПриемник.Строки.Количество();
	КоличествоСтрокИсточник = ДеревоИсточник.Строки.Количество();
	
	Для Инд = 0 По КоличествоСтрокПриемник - 1 Цикл
		Если Инд < КоличествоСтрокИсточник Тогда
			УзелДереваИсточник = ДеревоИсточник.Строки.Получить(Инд);
			УзелДереваИсточник[ИмяКолонкиПрототип] = УзелДереваИсточник; // нужно для копирования свойств
			УзелДереваПриемник = ДеревоПриемник.Строки.Получить(Инд);
			УзелДереваПриемник[ИмяКолонкиПрототип] = УзелДереваИсточник;
			
			ЗаполнитьПрототипыУзлов(УзелДереваПриемник, УзелДереваИсточник, ИмяКолонкиПрототип);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ЗаполнитьДаннымиСохраненныйДокумент(СохраненныйДок, ДеревоДляЗагрузки, ПараметрыОтчета, ДанныеДляЗагрузки, ТекстыПравилЗагрузки)
	
	Перем АвторасчетОтключен;
	
	СохраненныйДокОбъект = СохраненныйДок.ПолучитьОбъект();
	СохраненныйДокОбъект.Прочитать();
	
	// Извлекаем структуру сохраненных данных отчета
	СтруктураДанныхОтчета = СохраненныйДокОбъект.ДанныеОтчета.Получить();
	
	ДанныеОтчета = Новый Структура;
	ДанныеОтчета.Вставить("ПоказателиОтчета");
	ДанныеОтчета.Вставить("ДанныеМногострочныхРазделов");
	ДанныеОтчета.Вставить("ДанныеМногостраничныхРазделов");
	ДанныеОтчета.Вставить("ДанныеМногоуровневыхРазделов");
	ДанныеОтчета.Вставить("ДанныеВариантовАвтоЗаполнения");
	ДанныеОтчета.Вставить("СтруктураМногострочныхЧастей"); // используется в бухотчетности
	ДанныеОтчета.Вставить("СоставДополнительныхСтрок");    // используется в бухотчетности
	
	ДанныеОтчета.Вставить("ДеревоНастройкиСтраниц");
	
	ЗаполнитьЗначенияСвойств(ДанныеОтчета, СтруктураДанныхОтчета);
	ДанныеОтчета.ДеревоНастройкиСтраниц = СохраненныйДокОбъект.ДеревоНастройкиСтраниц.Получить();
	
	ДанныеОтчета.Вставить("СтруктураДанныхОтчета", СтруктураДанныхОтчета);
	ДанныеОтчета.Вставить("СписокЗаполненныхРазделов", Новый СписокЗначений);
	ДанныеОтчета.Вставить("ДокументОтчетаОбъект", СохраненныйДокОбъект);
	ДанныеОтчета.Вставить("ДокументОтчета", СохраненныйДок);
	
	ПараметрыОтчета.Вставить("НомерКорректировки", ДанныеДляЗагрузки.Версия);
	
	СохраненныйДокОбъект.Вид               = ДанныеДляЗагрузки.Версия;
	СохраненныйДокОбъект.ПредставлениеВида = РегламентированнаяОтчетность.ПредставлениеВидаДокумента(ДанныеДляЗагрузки.Версия);
	
	ДополнитьПараметрыШаблонамиДанныхМультиРазделов(ДанныеОтчета, ПараметрыОтчета);
	
	ИмяКлючевогоУзлаДляЗаполнения = Неопределено; // если заполнено, то обрабатываем только ключевой узел
	ИмяКлючевогоУзлаСодержательнойЧасти = Неопределено;
	ПараметрыОтчета.Свойство("ИмяКлючевогоУзлаСодержательнойЧасти", ИмяКлючевогоУзлаСодержательнойЧасти);
	Если ИмяКлючевогоУзлаСодержательнойЧасти <> Неопределено И ПараметрыОтчета.ОрганизацияВыбранаПриЗагрузке Тогда
		ИмяКлючевогоУзлаДляЗаполнения = ИмяКлючевогоУзлаСодержательнойЧасти;
	КонецЕсли;
	
	ИмяКлючевогоУзлаДляЗаполнения = Неопределено; // обрабатываем все узлы
	ЗаполнитьДаннымиСохраненныйДокументИзДереваДляЗагрузки(ДеревоДляЗагрузки, ДанныеОтчета, ПараметрыОтчета, ИмяКлючевогоУзлаДляЗаполнения);
	
	// Выполняем обработчик после загрузки данных из дерева в структуру данных документа (можно выполнить дополнительные расчеты показателей).
	ПараметрыОбработчика = Новый Структура("ДанныеОтчета,ДеревоДляЗагрузки,ПараметрыОтчета", ДанныеОтчета, ДеревоДляЗагрузки, ПараметрыОтчета);
	ВыполнитьАлгоритмВБезопасномРежиме(ТекстОбработчикаПоИмени(ТекстыПравилЗагрузки, "ПослеЗагрузки"), ПараметрыОбработчика);
	
	ЗаполнитьДанныеМногострочныхРазделовИзПоказателейРазделов(ДанныеОтчета);
	ОбновитьСоставДополнительныхСтрокИзПоказателейРазделов(ДанныеОтчета);
	
	СтруктураДанныхОтчета.Свойство("АвторасчетОтключен", АвторасчетОтключен);
	Если АвторасчетОтключен = Неопределено Тогда
		СтруктураДанныхОтчета.Свойство("Автозаполнение", АвторасчетОтключен);
		Если АвторасчетОтключен = Неопределено Тогда
			СтруктураДанныхОтчета.Свойство("Авторасчет", АвторасчетОтключен);
			Если АвторасчетОтключен = Неопределено Тогда
				СтруктураДанныхОтчета.Свойство("АвторасчетПоказателей", АвторасчетОтключен);
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если АвторасчетОтключен <> Неопределено Тогда
		ОбработатьДанныеВариантовАвтозаполнения(ДанныеОтчета, АвторасчетОтключен <> Истина);
	КонецЕсли;
	
	Если ВключитьЗаполненныеСтраницыВДеревеНастройкиСтраниц(ДанныеОтчета) Тогда
		ХранилищеДанныхДерева = Новый ХранилищеЗначения(ДанныеОтчета.ДеревоНастройкиСтраниц);
		СохраненныйДокОбъект.ДеревоНастройкиСтраниц = ХранилищеДанныхДерева;
	КонецЕсли;
	
	СтруктураДанныхОтчета.Вставить("УспешноеАвтозаполнение", Истина);
	
	// Сохраняем структуру данных отчета.
	ХранилищеДанных = Новый ХранилищеЗначения(СтруктураДанныхОтчета);
	СохраненныйДокОбъект.ДанныеОтчета = ХранилищеДанных;
	
	Попытка
		СохраненныйДокОбъект.Записать();
	Исключение
		ВызватьИсключение СтрШаблон(НСтр("ru = 'Ошибка записи заполненного документа отчета: %1.'"),
			РегламентированнаяОтчетностьКлиентСервер.СформироватьТекстСообщения(ИнформацияОбОшибке().Описание));
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции

Процедура ДополнитьПараметрыШаблонамиДанныхМультиРазделов(ДанныеОтчета, ПараметрыОтчета)
	
	ДанныеМногостраничныхРазделов = ДанныеОтчета.ДанныеМногостраничныхРазделов;
	ДанныеМногоуровневыхРазделов  = ДанныеОтчета.ДанныеМногоуровневыхРазделов;
	
	ШаблоныДанныхМногостраничныхРазделов = Новый Структура;
	ШаблоныДанныхМногоуровневыхРазделов  = Новый Структура;
	
	// Добавить в параметры отчета шаблоны из данных многостраничные разделы.
	Если ТипЗнч(ДанныеМногостраничныхРазделов) = Тип("Структура") Тогда
		
		Для Каждого Раздел Из ДанныеМногостраничныхРазделов Цикл
			
			СтраницыРаздела = Раздел.Значение;
			
			Если СтраницыРаздела.Количество() > 0 Тогда
				
				ДанныеШаблон = Новый ФиксированнаяСтруктура(СкопированнаяСтруктура(СтраницыРаздела[0].Данные));
				
				ШаблоныДанныхМногостраничныхРазделов.Вставить(Раздел.Ключ, ДанныеШаблон);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	// Добавить в параметры отчета шаблоны из данных многоуровневых разделов.
	Если ТипЗнч(ДанныеМногоуровневыхРазделов) = Тип("Структура") Тогда
		
		ШаблоныДанныхМногоуровневыхРазделов = СкопированнаяСтруктура(ДанныеМногоуровневыхРазделов);
		
	КонецЕсли;
	
	ПараметрыОтчета.Вставить("ШаблоныДанныхМногостраничныхРазделов", ШаблоныДанныхМногостраничныхРазделов);
	ПараметрыОтчета.Вставить("ШаблоныДанныхМногоуровневыхРазделов",  ШаблоныДанныхМногоуровневыхРазделов);
	
КонецПроцедуры

Процедура ЗаполнитьДанныеМногострочныхРазделовИзПоказателейРазделов(ДанныеОтчета)
	
	ДанныеУникальныхРазделов      = ДанныеОтчета.ПоказателиОтчета;
	ДанныеМногострочныхРазделов   = ДанныеОтчета.ДанныеМногострочныхРазделов;
	ДанныеМногостраничныхРазделов = ДанныеОтчета.ДанныеМногостраничныхРазделов;
	ДанныеМногоуровневыхРазделов  = ДанныеОтчета.ДанныеМногоуровневыхРазделов;
	СтруктураМногострочныхЧастей  = ДанныеОтчета.СтруктураМногострочныхЧастей;
	
	ЭтоСтруктураМногострочныхЧастей = Ложь;
	
	Если ТипЗнч(СтруктураМногострочныхЧастей) = Тип("Структура") Тогда
		ДанныеМногострочныхРазделов = СтруктураМногострочныхЧастей;
		ЭтоСтруктураМногострочныхЧастей = Истина; // есть в бухотчетности
	ИначеЕсли ТипЗнч(ДанныеМногострочныхРазделов) <> Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого ГруппаСтрокРаздела Из ДанныеМногострочныхРазделов Цикл
		
		ИмяРазделаДляГруппы = "";
		Если ЭтоСтруктураМногострочныхЧастей Тогда
			ИмяРазделаДляГруппы = ГруппаСтрокРаздела.Значение.ИмяПоляТабличногоДокумента;
			ГруппаСтрок = ГруппаСтрокРаздела.Значение.Состав;
		Иначе
			ГруппаСтрок = ГруппаСтрокРаздела.Значение;
		КонецЕсли;
		
		ДанныеСтроки = Новый Структура;
		Для Каждого Колонка Из ГруппаСтрок.Колонки Цикл
			ДанныеСтроки.Вставить(Колонка.Имя);
		КонецЦикла;
		
		ИмяПоказателяДляПоиска = ГруппаСтрок.Колонки[0].Имя + "_1";
		
		ГруппаНайдена = Ложь;
		
		Для Каждого ДанныеРаздела Из ДанныеУникальныхРазделов Цикл
			Если НЕ ПустаяСтрока(ИмяРазделаДляГруппы) И ИмяРазделаДляГруппы <> ДанныеРаздела.Ключ Тогда
				Продолжить;
			КонецЕсли;
			ПоказателиРаздела = ДанныеРаздела.Значение;
			Если ПоказателиРаздела.Свойство(ИмяПоказателяДляПоиска) Тогда // требуемый многострочный раздел найден
				ГруппаНайдена = Истина;
				
				НомерСтроки = 1;
				НайденыПоказателиСтроки = Истина;
				
				Пока НайденыПоказателиСтроки Цикл // заполняем таблицу многострочной группы
					НайденыПоказателиСтроки = Ложь;
					
					Для Каждого ЭлементДанных Из ДанныеСтроки Цикл
						ЗначениеПоказателя = Неопределено;
						ИмяПоказателя = ЭлементДанных.Ключ + "_" + Формат(НомерСтроки, "ЧГ=");
						Если ПоказателиРаздела.Свойство(ИмяПоказателя, ЗначениеПоказателя) Тогда
							ДанныеСтроки[ЭлементДанных.Ключ] = ЗначениеПоказателя;
							НайденыПоказателиСтроки = Истина;
						Иначе
							ДанныеСтроки[ЭлементДанных.Ключ] = Неопределено;
						КонецЕсли;
					КонецЦикла;
					
					Если НайденыПоказателиСтроки Тогда // заполняем строку таблицы
						СтрокаГруппы = ?(НомерСтроки <= ГруппаСтрок.Количество(), ГруппаСтрок[НомерСтроки - 1], ГруппаСтрок.Добавить());
						ЗаполнитьЗначенияСвойств(СтрокаГруппы, ДанныеСтроки);
						// Заполним недостающие показатели многострочной части.
						ЗаполнитьЗначенияСвойств(ДанныеСтроки, СтрокаГруппы);
						Для Каждого ЭлементДанных Из ДанныеСтроки Цикл
							ИмяПоказателя = ЭлементДанных.Ключ + "_" + Формат(НомерСтроки, "ЧГ=");
							Если НЕ ПоказателиРаздела.Свойство(ИмяПоказателя) Тогда
								ПоказателиРаздела.Вставить(ИмяПоказателя, ЭлементДанных.Значение);
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
					
					НомерСтроки = НомерСтроки + 1;
				КонецЦикла;
				
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если НЕ ГруппаНайдена И ДанныеМногостраничныхРазделов <> Неопределено Тогда
			Для Каждого Раздел Из ДанныеМногостраничныхРазделов Цикл
				
				СтраницыРаздела = Раздел.Значение;
				
				Если СтраницыРаздела.Колонки.Найти("ДанныеДопСтрок") = Неопределено ИЛИ СтраницыРаздела.Количество() = 0 Тогда
					Продолжить;
				КонецЕсли;
				Если ТипЗнч(СтраницыРаздела[0].ДанныеДопСтрок) = Тип("Структура")
					И СтраницыРаздела[0].ДанныеДопСтрок.Свойство(ГруппаСтрокРаздела.Ключ) Тогда
					ХранениеДопСтрокВСтруктуре = Истина;
				ИначеЕсли ТипЗнч(СтраницыРаздела[0].ДанныеДопСтрок) = Тип("ТаблицаЗначений")
					И СтраницыРаздела[0].ДанныеДопСтрок.Колонки.Найти(ГруппаСтрок.Колонки[0].Имя) <> Неопределено Тогда
					ХранениеДопСтрокВСтруктуре = Ложь;
				Иначе
					Продолжить;
				КонецЕсли;
				
				ГруппаНайдена = Истина;
				
				КоличествоСтраниц = СтраницыРаздела.Количество();
				Для НомСтр = 1 По КоличествоСтраниц Цикл
					ПоказателиСтраницы     = СтраницыРаздела[КоличествоСтраниц - НомСтр].Данные;
					ДанныеДопСтрокСтраницы = СтраницыРаздела[КоличествоСтраниц - НомСтр].ДанныеДопСтрок;
					Если ХранениеДопСтрокВСтруктуре Тогда
						ДанныеДопСтрокСтраницы = ДанныеДопСтрокСтраницы[ГруппаСтрокРаздела.Ключ];
					КонецЕсли;
					
					ГруппаСтрок.Очистить();
					ГруппаСтрок.Добавить();
					
					НомерСтроки = 1;
					НайденыПоказателиСтроки = Истина;
					Пока НайденыПоказателиСтроки Цикл // заполняем таблицу многострочной группы
						НайденыПоказателиСтроки = Ложь;
						Для Каждого ЭлементДанных Из ДанныеСтроки Цикл
							ЗначениеПоказателя = Неопределено;
							ИмяПоказателя = ЭлементДанных.Ключ + "_" + Формат(НомерСтроки, "ЧГ=");
							Если ПоказателиСтраницы.Свойство(ИмяПоказателя, ЗначениеПоказателя) Тогда
								ДанныеСтроки[ЭлементДанных.Ключ] = ЗначениеПоказателя;
								НайденыПоказателиСтроки = Истина;
							Иначе
								ДанныеСтроки[ЭлементДанных.Ключ] = Неопределено;
							КонецЕсли;
						КонецЦикла;
						
						Если НайденыПоказателиСтроки Тогда // заполняем строки таблиц
							Если НомСтр = КоличествоСтраниц Тогда
								СтрокаГруппы = ?(НомерСтроки <= ГруппаСтрок.Количество(), ГруппаСтрок[НомерСтроки - 1], ГруппаСтрок.Добавить());
								ЗаполнитьЗначенияСвойств(СтрокаГруппы, ДанныеСтроки);
							КонецЕсли;
							СтрокаГруппыСтраницы = ?(НомерСтроки <= ДанныеДопСтрокСтраницы.Количество(),
								ДанныеДопСтрокСтраницы[НомерСтроки - 1], ДанныеДопСтрокСтраницы.Добавить());
							ЗаполнитьЗначенияСвойств(СтрокаГруппыСтраницы, ДанныеСтроки);
							// Заполним недостающие показатели многострочной части.
							ЗаполнитьЗначенияСвойств(ДанныеСтроки, СтрокаГруппыСтраницы);
							Для Каждого ЭлементДанных Из ДанныеСтроки Цикл
								ИмяПоказателя = ЭлементДанных.Ключ + "_" + Формат(НомерСтроки, "ЧГ=");
								Если НЕ ПоказателиСтраницы.Свойство(ИмяПоказателя) Тогда
									ПоказателиСтраницы.Вставить(ИмяПоказателя, ЭлементДанных.Значение);
								КонецЕсли;
							КонецЦикла;
						КонецЕсли;
						
						НомерСтроки = НомерСтроки + 1;
					КонецЦикла;
				КонецЦикла;
				
				Прервать;
			КонецЦикла;
		КонецЕсли;
		
		Если НЕ ГруппаНайдена И ДанныеМногоуровневыхРазделов <> Неопределено Тогда
			Для Каждого Раздел Из ДанныеМногоуровневыхРазделов Цикл
				
				ДеревоРаздела = Раздел.Значение;
				
				Если ГруппаНайдена ИЛИ ДеревоРаздела.Строки.Количество() = 0
					ИЛИ ДеревоРаздела.Колонки.Найти("ДанныеМногострочныхЧастей") <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				ИмяСлужебнойКолонки = "_Отбор";
				ДобавитьКолонкуВДеревоЕслиНеНайдена(ДеревоРаздела, ИмяСлужебнойКолонки);
				СтраницыРаздела = ДеревоРаздела.Строки.НайтиСтроки(Новый Структура(ИмяСлужебнойКолонки, Ложь), Истина);
				ДеревоРаздела.Колонки.Удалить(ДеревоРаздела.Колонки.Найти(ИмяСлужебнойКолонки));
				
				КоличествоСтраниц = СтраницыРаздела.Количество();
				Для НомСтр = 1 По КоличествоСтраниц Цикл
					
					ПоказателиСтраницы = СтраницыРаздела[КоличествоСтраниц - НомСтр].Данные;
					
					ГруппаСтрок.Очистить();
					ГруппаСтрок.Добавить();
					
					ДобавлялисьСтроки = Ложь;
					
					НомерСтроки = 1;
					НайденыПоказателиСтроки = Истина;
					Пока НайденыПоказателиСтроки Цикл // заполняем таблицу многострочной группы
						НайденыПоказателиСтроки = Ложь;
						
						Для Каждого ЭлементДанных Из ДанныеСтроки Цикл
							ЗначениеПоказателя = Неопределено;
							ИмяПоказателя = ЭлементДанных.Ключ + "_" + Формат(НомерСтроки, "ЧГ=");
							Если ПоказателиСтраницы.Свойство(ИмяПоказателя, ЗначениеПоказателя) Тогда
								ДанныеСтроки[ЭлементДанных.Ключ] = ЗначениеПоказателя;
								НайденыПоказателиСтроки = Истина;
							Иначе
								ДанныеСтроки[ЭлементДанных.Ключ] = Неопределено;
							КонецЕсли;
						КонецЦикла;
						
						Если НайденыПоказателиСтроки Тогда // заполняем строки таблиц
							ГруппаНайдена = Истина;
							СтрокаГруппы = ?(НомерСтроки <= ГруппаСтрок.Количество(), ГруппаСтрок[НомерСтроки - 1], ГруппаСтрок.Добавить());
							ЗаполнитьЗначенияСвойств(СтрокаГруппы, ДанныеСтроки);
							
							// Заполним недостающие показатели многострочной части.
							ЗаполнитьЗначенияСвойств(ДанныеСтроки, СтрокаГруппы);
							Для Каждого ЭлементДанных Из ДанныеСтроки Цикл
								ИмяПоказателя = ЭлементДанных.Ключ + "_" + Формат(НомерСтроки, "ЧГ=");
								Если НЕ ПоказателиСтраницы.Свойство(ИмяПоказателя) Тогда
									ПоказателиСтраницы.Вставить(ИмяПоказателя, ЭлементДанных.Значение);
								КонецЕсли;
							КонецЦикла;
							
							ДобавлялисьСтроки = Истина;
						КонецЕсли;
						
						НомерСтроки = НомерСтроки + 1;
					КонецЦикла;
					
					Если ДобавлялисьСтроки Тогда
						ГруппаСтрок = ГруппаСтрок.Скопировать();
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбновитьСоставДополнительныхСтрокИзПоказателейРазделов(ДанныеОтчета)
	
	Перем СтруктураСоставов;
	
	СоставДополнительныхСтрок = ДанныеОтчета.СоставДополнительныхСтрок;
	
	Если ТипЗнч(СоставДополнительныхСтрок) = Тип("Структура") Тогда
		Если НЕ СоставДополнительныхСтрок.Свойство("СтруктураСоставов", СтруктураСоставов)
			ИЛИ ТипЗнч(СтруктураСоставов) <> Тип("Структура") Тогда
			Возврат;
		КонецЕсли;
	Иначе
		Возврат;
	КонецЕсли;
	
	Для Каждого СоставДопСтрок Из СтруктураСоставов Цикл
		
		ИмяРаздела = "ПолеТабличногоДокумента" + СоставДопСтрок.Ключ;
		
		РазделОтчета = Неопределено;
		ДанныеОтчета.ПоказателиОтчета.Свойство(ИмяРаздела, РазделОтчета);
		Если РазделОтчета <> Неопределено И СоставДопСтрок.Значение <> Неопределено Тогда
			Для Каждого СтрокаУровня1 Из СоставДопСтрок.Значение.Строки Цикл
				Если СтрокаУровня1.Строки.Количество() > 0 Тогда
					Для Каждого СтрокаУровня2 Из СтрокаУровня1.Строки Цикл
						ИмяОбластиДопСтроки = СтрокаУровня2.ИмяОбластиДопСтроки;
						ИмяОснЧастиПок = "П00010" + СтрЗаменить(ИмяОбластиДопСтроки, "ДопСтрока", "");
						ИмяПоказателя = ИмяОснЧастиПок + "01";
						ЗначениеПоказателя = Неопределено;
						Если РазделОтчета.Свойство(ИмяПоказателя, ЗначениеПоказателя) Тогда
							ИмяПоказателя04 = ИмяОснЧастиПок + "04";
							ИмяПоказателя05 = ИмяОснЧастиПок + "05";
							ИмяПоказателя06 = ИмяОснЧастиПок + "06";
							ВключатьВОтчет = ЗначениеЗаполнено(ЗначениеПоказателя);
							ВключатьВОтчет = ВключатьВОтчет
								ИЛИ (РазделОтчета.Свойство(ИмяПоказателя04, ЗначениеПоказателя) И ЗначениеЗаполнено(ЗначениеПоказателя));
							ВключатьВОтчет = ВключатьВОтчет
								ИЛИ (РазделОтчета.Свойство(ИмяПоказателя05, ЗначениеПоказателя) И ЗначениеЗаполнено(ЗначениеПоказателя));
							ВключатьВОтчет = ВключатьВОтчет
								ИЛИ (РазделОтчета.Свойство(ИмяПоказателя06, ЗначениеПоказателя) И ЗначениеЗаполнено(ЗначениеПоказателя));
							СтрокаУровня2.ВключатьВОтчет = ВключатьВОтчет;
						КонецЕсли;
					КонецЦикла;
				Иначе
					ИмяПоказателя = "П100100" + СтрокаУровня1.Код + "01" + "_1";
					ЗначениеПоказателя = Неопределено;
					Если РазделОтчета.Свойство(ИмяПоказателя, ЗначениеПоказателя) И ЗначениеЗаполнено(ЗначениеПоказателя) Тогда
						СтрокаУровня1.ВключатьВОтчет = Истина;
						Продолжить;
					КонецЕсли;
					Для НомСтроки = 1 По 3 Цикл
						ИмяОбластиДопСтроки = СтрокаУровня1.ИмяОбластиДопСтроки + Формат(НомСтроки, "ЧГ=");
						ИмяПоказателя = "П00010" + СтрокаУровня1.Код + Формат(НомСтроки, "ЧГ=") + "01";
						ЗначениеПоказателя = Неопределено;
						Если РазделОтчета.Свойство(ИмяПоказателя, ЗначениеПоказателя) И ЗначениеЗаполнено(ЗначениеПоказателя) Тогда
							СтрокаУровня2 = СтрокаУровня1.Строки.Добавить();
							ЗаполнитьЗначенияСвойств(СтрокаУровня2, СтрокаУровня1);
							СтрокаУровня2.ИмяОбластиДопСтроки = ИмяОбластиДопСтроки;
							СтрокаУровня2.ВключатьВОтчет = Истина;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ОбработатьДанныеВариантовАвтозаполнения(ДанныеОтчета, АвторасчетВключен = Истина)
	
	Если ТипЗнч(ДанныеОтчета.ДанныеВариантовАвтозаполнения) <> Тип("Структура") Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого ЭлементДанныхВариантовАвтозаполнения Из ДанныеОтчета.ДанныеВариантовАвтозаполнения Цикл // цикл по элементам структуры
		Для Каждого ТаблицаВариантовАвтозаполнения Из ЭлементДанныхВариантовАвтозаполнения.Значение Цикл // цикл по элементам массива
			Для Каждого СтрокаТаблицы Из ТаблицаВариантовАвтозаполнения Цикл // цикл по строкам таблицы значений вариантов автозаполнения
				Если АвторасчетВключен Тогда
					Если СтрокаТаблицы.ВариантЗаполнения = 0 Тогда
						СтрокаТаблицы.ВариантЗаполнения = 4
					КонецЕсли;
				Иначе
					Если СтрокаТаблицы.ВариантЗаполнения = 4 Тогда
						СтрокаТаблицы.ВариантЗаполнения = 0
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьДаннымиСохраненныйДокументИзДереваДляЗагрузки(Узел, ДанныеОтчета, ПараметрыОтчета,
																 ИмяКлючевогоУзла = Неопределено,
																 НомерСтраницы = 0, НомерСтроки = 0) Экспорт
	ИмяКлючевогоУзлаДляЗаполнения = ИмяКлючевогоУзла;
	
	Если ТипЗнч(Узел) <> Тип("ДеревоЗначений") Тогда
		Если ИмяКлючевогоУзлаДляЗаполнения <> Неопределено И Узел.Код = ИмяКлючевогоУзлаДляЗаполнения Тогда
			ИмяКлючевогоУзлаДляЗаполнения = Неопределено; // все подчиненные узлы будут заполнены
		КонецЕсли;
		Если ИмяКлючевогоУзлаДляЗаполнения = Неопределено И НЕ ПустаяСтрока(Узел.Ключ) Тогда
			ЗаполнитьПоказательДокументаИзУзлаДерева(Узел, ДанныеОтчета, ПараметрыОтчета, НомерСтраницы, НомерСтроки);
		КонецЕсли;
	КонецЕсли;
	
	КлючиМногостраничныхУзлов = Новый Соответствие;
	КлючиМногострочныхУзлов   = Новый Соответствие;
	
	КоличествоСтрок = Узел.Строки.Количество();
	Для Инд = 0 По КоличествоСтрок - 1 Цикл
		
		ДочернийУзел = Узел.Строки.Получить(Инд);
		
		Если СтрЗаканчиваетсяНа(ДочернийУзел.Обязательность, "П") Тогда
			Продолжить;
		КонецЕсли;
		
		Если МногоуровневыйУзел(ДочернийУзел) Тогда
			
			Если ТипЗнч(НомерСтраницы) = Тип("Массив") Тогда
				НомСтраницы = СкопированныйМассив(НомерСтраницы);
			Иначе
				НомСтраницы = Новый Массив;
			КонецЕсли;
			Если ТипЗнч(НомерСтроки) = Тип("Массив") Тогда
				НомСтроки = СкопированныйМассив(НомерСтроки);
			Иначе
				НомСтроки = Новый Массив;
			КонецЕсли;
				
			Если МножественныйУзел(ДочернийУзел) И МногостраничностьУзла(ДочернийУзел) Тогда
				
				КлючУзла = "Страницы;" + РазделУзла(ДочернийУзел);
				СчетчикМногостраничныхУзлов = КлючиМногостраничныхУзлов[КлючУзла];
				Если ЗначениеЗаполнено(СчетчикМногостраничныхУзлов) Тогда
					НомСтраницы = СчетчикМногостраничныхУзлов;
					НомСтраницы[НомСтраницы.ВГраница()] = НомСтраницы[НомСтраницы.ВГраница()] + 1;
				Иначе
					НомСтраницы.Добавить(1);
				КонецЕсли;
				КлючиМногостраничныхУзлов.Вставить(КлючУзла, НомСтраницы);
				
			ИначеЕсли МножественныйУзел(ДочернийУзел) И МногострочностьУзла(ДочернийУзел) Тогда
				
				КлючУзла = "Строки;" + РазделУзла(ДочернийУзел);
				СчетчикМногострочныхУзлов = КлючиМногострочныхУзлов[КлючУзла];
				Если ЗначениеЗаполнено(СчетчикМногострочныхУзлов) Тогда
					НомСтроки = СчетчикМногострочныхУзлов;
					НомСтроки[НомСтроки.ВГраница()] = НомСтроки[НомСтроки.ВГраница()] + 1;
				Иначе
					НомСтроки.Добавить(1);
				КонецЕсли;
				КлючиМногострочныхУзлов.Вставить(КлючУзла, НомСтроки);
				
			КонецЕсли;
			
		Иначе
			
			НомСтраницы = НомерСтраницы;
			НомСтроки = НомерСтроки;
			
			Если (МногостраничностьУзла(ДочернийУзел) И НомерСтраницы = 0)
			   И (МногострочностьУзла(ДочернийУзел) И НомерСтроки = 0) Тогда
				
				КлючУзла = СтроковыйКлючУзла(ДочернийУзел);
				
				СчетчикМногостраничныхУзлов = КлючиМногостраничныхУзлов[КлючУзла];
				НомСтраницы = ?(ЗначениеЗаполнено(СчетчикМногостраничныхУзлов), СчетчикМногостраничныхУзлов, 0);
				СчетчикМногострочныхУзлов = КлючиМногострочныхУзлов[КлючУзла];
				НомСтроки = ?(ЗначениеЗаполнено(СчетчикМногострочныхУзлов), СчетчикМногострочныхУзлов, 0);
				
				Если НомСтроки % 3 = 0 Тогда // в "3-НДФЛ" максимум 3 строки на страницу
					НомСтраницы = НомСтраницы + 1;
					КлючиМногостраничныхУзлов.Вставить(КлючУзла, НомСтраницы);
					НомСтроки = 0;
				КонецЕсли;
				
				НомСтроки = НомСтроки + 1;
				КлючиМногострочныхУзлов.Вставить(КлючУзла, НомСтроки);
				
			ИначеЕсли МногостраничностьУзла(ДочернийУзел) И НомерСтраницы = 0 Тогда
				
				КлючУзла = СтроковыйКлючУзла(ДочернийУзел);
				СчетчикМногостраничныхУзлов = КлючиМногостраничныхУзлов[КлючУзла];
				НомСтраницы = 1 + ?(ЗначениеЗаполнено(СчетчикМногостраничныхУзлов), СчетчикМногостраничныхУзлов, 0);
				КлючиМногостраничныхУзлов.Вставить(КлючУзла, НомСтраницы);
				
			ИначеЕсли МногострочностьУзла(ДочернийУзел) И НомерСтроки = 0 Тогда
				
				КлючУзла = СтроковыйКлючУзла(ДочернийУзел);
				СчетчикМногострочныхУзлов = КлючиМногострочныхУзлов[КлючУзла];
				НомСтроки = 1 + ?(ЗначениеЗаполнено(СчетчикМногострочныхУзлов), СчетчикМногострочныхУзлов, 0);
				КлючиМногострочныхУзлов.Вставить(КлючУзла, НомСтроки);
				
			КонецЕсли;
			
		КонецЕсли;
		
		ЗаполнитьДаннымиСохраненныйДокументИзДереваДляЗагрузки(ДочернийУзел, ДанныеОтчета, ПараметрыОтчета,
															   ИмяКлючевогоУзлаДляЗаполнения,
															   НомСтраницы, НомСтроки);
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьПоказательДокументаИзУзлаДерева(Узел, ДанныеОтчета, ПараметрыОтчета, НомерСтраницы = 0, НомерСтроки = 0)
	
	Префикс = "ПолеТабличногоДокумента";
	
	Раздел = РазделУзла(Узел);
	
	СтраницаРаздела = Неопределено;
	
	// Будет присвоено значение "Истина", если раздел многоуровневый многострочный
	// и есть колонка "ДанныеМногострочныхЧастей" в дереве многоуровневого раздела.
	ЕстьДанныеМногострочныхЧастейМнУр = Неопределено;
	
	Если ТипЗнч(НомерСтраницы) = Тип("Массив") Тогда // раздел многоуровневый (многостраничный)
		
		Если ДанныеОтчета.ДанныеМногоуровневыхРазделов = Неопределено Тогда
			ВызватьИсключение СтрШаблон(НСтр("ru = 'Не найдены данные многоуровневой части документа отчета. Ошибка в разделе: ""%1"".'"), Раздел);
		КонецЕсли;
		
		МногоуровневыйРаздел = Неопределено;
		ИмяРаздела = СтрЗаменить(Раздел, Префикс, "");
		ДанныеОтчета.ДанныеМногоуровневыхРазделов.Свойство(ИмяРаздела, МногоуровневыйРаздел);
		
		Если ТипЗнч(МногоуровневыйРаздел) <> Тип("ДеревоЗначений") ИЛИ МногоуровневыйРаздел.Строки.Количество() = 0 Тогда
			ОбщегоНазначения.СообщитьПользователю(
				СтрШаблон(НСтр("ru = 'В данных документа отчета не найден многоуровневый раздел ""%1"" для показателя ""%2"".'"),
				Раздел, Узел.Ключ));
			Возврат;
		КонецЕсли;
		
		Если НомерСтраницы.Количество() = 0 Тогда
			НомСтраницы = Новый Массив;
			НомСтраницы.Добавить(1); // хотя бы одна страница в разделе должна присутствовать
		Иначе
			НомСтраницы = НомерСтраницы;
		КонецЕсли;
		
		ВетвьДерева  = МногоуровневыйРаздел;
		ВетвьШаблона = ПараметрыОтчета.ШаблоныДанныхМногоуровневыхРазделов[ИмяРаздела];
		Для Каждого НомСтраницыЭлемент Из НомСтраницы Цикл
			НомерСтрокиШаблона = Мин(ВетвьШаблона.Строки.Количество(), НомСтраницыЭлемент);
			ВетвьШаблона = ВетвьШаблона.Строки[НомерСтрокиШаблона - 1];
			
			Если ВетвьШаблона.Данные = Неопределено Тогда // это группа - перешагнем ее
				ВетвьДерева = ВетвьДерева.Строки[НомерСтрокиШаблона - 1];
				Если НомСтраницыЭлемент = НомерСтрокиШаблона Тогда
					НомСтраницыЭлемент = 1;
				КонецЕсли;
				НомерСтрокиШаблона = Мин(ВетвьШаблона.Строки.Количество(), НомСтраницыЭлемент);
				ВетвьШаблона = ВетвьШаблона.Строки[НомерСтрокиШаблона - 1];
			КонецЕсли;
			
			КоличествоСтрокВетви = ВетвьДерева.Строки.Количество();
			Если НомСтраницыЭлемент > КоличествоСтрокВетви Тогда
				СкопированнаяВетвьДерева = ВетвьДерева.Строки[КоличествоСтрокВетви - 1];
				Для Индекс = КоличествоСтрокВетви По НомСтраницыЭлемент - 1 Цикл
					СкопированнаяВетвьДерева = СкопированныйУзелМУР(ВетвьДерева, ВетвьШаблона);
				КонецЦикла;
				ВетвьДерева = СкопированнаяВетвьДерева;
			Иначе
				ВетвьДерева = ВетвьДерева.Строки[НомСтраницыЭлемент - 1];
			КонецЕсли;
		КонецЦикла;
		
		Если ВетвьДерева = МногоуровневыйРаздел Тогда
			ОбщегоНазначения.СообщитьПользователю(
				СтрШаблон(НСтр("ru = 'В данных документа отчета не найдена страница многоуровневого раздела ""%1"" для показателя ""%2"".'"),
				Раздел, Узел.Ключ));
			Возврат;
		КонецЕсли;
		
		СтраницаРаздела = ВетвьДерева.Данные;
		
		Если ЗначениеЗаполнено(НомерСтроки) Тогда // массив не пустой - определена многоуровневая многострочность в разделе
			Если МногоуровневыйРаздел.Колонки.Найти("ДанныеМногострочныхЧастей") <> Неопределено Тогда
				ЕстьДанныеМногострочныхЧастейМнУр = Истина;
				
				КлючМногострочнойЧасти = Новый Массив;
				ДанныеМногострочнойЧастиШаблонаМассив = Новый Массив;
				КлючИДанныеМногострочнойЧастиМУР(ВетвьШаблона, Узел.Ключ, КлючМногострочнойЧасти, ДанныеМногострочнойЧастиШаблонаМассив);
				
				Если ЗначениеЗаполнено(ДанныеМногострочнойЧастиШаблонаМассив) Тогда
					МаксИндКлюч = КлючМногострочнойЧасти.ВГраница();
					
					МаксИндЭлемент = НомерСтроки.ВГраница();
					Для ИндЭлемент = 0 По МаксИндЭлемент Цикл
						НомерСтрокиЭлемент = НомерСтроки[ИндЭлемент];
						
						ИндКлюч = Мин(ИндЭлемент, МаксИндКлюч);
						КлючМногострочнойЧастиЭлемент = КлючМногострочнойЧасти[ИндКлюч];
						
						ДанныеМногострочнойЧастиШаблона = ДанныеМногострочнойЧастиШаблонаМассив[ИндКлюч]; // в массиве результат рекурсивного поиска
						ДанныеМногострочнойЧасти = ВетвьДерева.ДанныеМногострочныхЧастей[КлючМногострочнойЧастиЭлемент];
						
						НомерСтрокиШаблона = Мин(ДанныеМногострочнойЧастиШаблона.Строки.Количество(), НомерСтрокиЭлемент);
						СтрокаМногострочнойЧастиШаблона = ДанныеМногострочнойЧастиШаблона.Строки[НомерСтрокиШаблона - 1];
						
						КоличествоСтрокМногострочнойЧасти = ДанныеМногострочнойЧасти.Строки.Количество();
						Если НомерСтрокиЭлемент > КоличествоСтрокМногострочнойЧасти Тогда
							СкопированнаяВетвьДерева = ДанныеМногострочнойЧасти.Строки[КоличествоСтрокМногострочнойЧасти - 1];
							Для Индекс = КоличествоСтрокМногострочнойЧасти По НомерСтрокиЭлемент - 1 Цикл
								СкопированнаяВетвьДерева = СкопированныйУзелМУР(ДанныеМногострочнойЧасти, СтрокаМногострочнойЧастиШаблона);
							КонецЦикла;
							ВетвьДерева = СкопированнаяВетвьДерева;
						Иначе
							ВетвьДерева = ДанныеМногострочнойЧасти.Строки[НомерСтрокиЭлемент - 1];
						КонецЕсли;
					КонецЦикла;
					
					СтраницаРаздела = ВетвьДерева.Данные;
				КонецЕсли;
			Иначе
				ЕстьДанныеМногострочныхЧастейМнУр = Ложь;
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли НомерСтраницы > 0 Тогда // раздел многостраничный
		
		Если ДанныеОтчета.ДанныеМногостраничныхРазделов = Неопределено Тогда
			ВызватьИсключение СтрШаблон(НСтр("ru = 'Не найдены данные многостраничной части документа отчета. Ошибка в разделе: ""%1"".'"), Раздел);
		КонецЕсли;
		
		МногостраничныйРаздел = Неопределено;
		ИмяРаздела = СтрЗаменить(Раздел, Префикс, "");
		ДанныеОтчета.ДанныеМногостраничныхРазделов.Свойство(ИмяРаздела, МногостраничныйРаздел);
		
		Если ТипЗнч(МногостраничныйРаздел) <> Тип("ТаблицаЗначений") ИЛИ МногостраничныйРаздел.Количество() = 0 Тогда
			ОбщегоНазначения.СообщитьПользователю(
				СтрШаблон(НСтр("ru = 'В данных документа отчета не найден многостраничный раздел ""%1"" для показателя ""%2"".'"),
				Раздел, Узел.Ключ));
			Возврат;
		КонецЕсли;
		
		Если НомерСтраницы > МногостраничныйРаздел.Количество() Тогда // добавляем страницу или страницы
			Если НомерСтраницы = 2 Тогда
				МногостраничныйРаздел[0].Представление = "Страница N 1";
				МногостраничныйРаздел[0].АктивнаяСтраница = Ложь;
			КонецЕсли;
			
			СтраницаРаздела = Новый Структура(ПараметрыОтчета.ШаблоныДанныхМногостраничныхРазделов[ИмяРаздела]);
			
			СвойстваСтраницы = МногостраничныйРаздел.Добавить();
			ЗаполнитьЗначенияСвойств(СвойстваСтраницы, МногостраничныйРаздел[0]);
			СвойстваСтраницы.Представление = "Страница N " + Формат(НомерСтраницы, "ЧН=; ЧГ=0");
			СвойстваСтраницы.Данные = СтраницаРаздела;
			СвойстваСтраницы.АктивнаяСтраница = Ложь;
			
			Если МногостраничныйРаздел.Колонки.Найти("ДанныеДопСтрок") <> Неопределено Тогда
				ТипДанныхДопСтрок = ТипЗнч(СвойстваСтраницы.ДанныеДопСтрок);
				Если ТипДанныхДопСтрок = Тип("Структура") Тогда
					ДанныеДопСтрок = Новый Структура;
					
					Для Каждого ЭлементДанныхДопСтрок Из СвойстваСтраницы.ДанныеДопСтрок Цикл
						Если ТипЗнч(ЭлементДанныхДопСтрок.Значение) = Тип("ТаблицаЗначений") Тогда
							ТаблицаДанныеДопСтрок = ЭлементДанныхДопСтрок.Значение.СкопироватьКолонки();
							ТаблицаДанныеДопСтрок.Добавить();
							ДанныеДопСтрок.Вставить(ЭлементДанныхДопСтрок.Ключ, ТаблицаДанныеДопСтрок);
						КонецЕсли;
					КонецЦикла;
					
					СвойстваСтраницы.ДанныеДопСтрок = ДанныеДопСтрок;
				ИначеЕсли ТипДанныхДопСтрок = Тип("ТаблицаЗначений") Тогда
					СвойстваСтраницы.ДанныеДопСтрок = СвойстваСтраницы.ДанныеДопСтрок.СкопироватьКолонки();
					СвойстваСтраницы.ДанныеДопСтрок.Добавить();
				Иначе
					СвойстваСтраницы.ДанныеДопСтрок = Новый Структура;
				КонецЕсли;
			КонецЕсли;
		Иначе
			СтраницаРаздела = МногостраничныйРаздел[НомерСтраницы - 1].Данные;
		КонецЕсли;
		
	Иначе // обычный (одностраничный) раздел
		
		Если СтрНачинаетсяС(Раздел, Префикс) Тогда
			ДанныеОтчета.ПоказателиОтчета.Свойство(Раздел, СтраницаРаздела);
			Если СтраницаРаздела = Неопределено Тогда
				ДанныеОтчета.ПоказателиОтчета.Свойство(СтрЗаменить(Раздел, Префикс, ""), СтраницаРаздела);
			КонецЕсли;
		Иначе
			ДанныеОтчета.ПоказателиОтчета.Свойство(Префикс + Раздел, СтраницаРаздела);
			Если СтраницаРаздела = Неопределено Тогда
				ДанныеОтчета.ПоказателиОтчета.Свойство(Раздел, СтраницаРаздела);
			КонецЕсли;
		КонецЕсли;
		Если ТипЗнч(СтраницаРаздела) <> Тип("Структура") Тогда
			ОбщегоНазначения.СообщитьПользователю(
				СтрШаблон(НСтр("ru = 'В данных документа отчета не найден раздел ""%1"" для показателя ""%2"".'"),
				Раздел, Узел.Ключ));
			Возврат;
		КонецЕсли;
		
	КонецЕсли;
	
	ЗначениеПоказателя = Неопределено;
	
	Если НомерСтроки = 0 ИЛИ (ТипЗнч(НомерСтроки) = Тип("Массив") И ЕстьДанныеМногострочныхЧастейМнУр <> Ложь) Тогда // обычные и многоуровневые разделы
		Если СтраницаРаздела.Свойство(Узел.Ключ, ЗначениеПоказателя) Тогда
			НовоеЗначениеПоказателя = ?(ТипЗнч(ЗначениеПоказателя) = Тип("Число"), ЧислоИзСтроки(Узел.Значение),
									  ?(ТипЗнч(ЗначениеПоказателя) = Тип("Дата"),  ДатаИзСтрокиЛюбогоФормата(Узел.Значение),
									  СокрЛП(ЗначениеПоказателяИзXML(Узел))));
			СтраницаРаздела[Узел.Ключ] = ОбработанноеЗначениеПоказателя(Узел.Ключ, ПараметрыОтчета, НовоеЗначениеПоказателя);
			Если ЗначениеЗаполнено(Узел.Значение) И ДанныеОтчета.СписокЗаполненныхРазделов.НайтиПоЗначению(Раздел) = Неопределено Тогда
				ДанныеОтчета.СписокЗаполненныхРазделов.Добавить(Раздел, Раздел);
			КонецЕсли;
		КонецЕсли;
	Иначе
		НомСтроки = ?(ТипЗнч(НомерСтроки) = Тип("Массив"), НомерСтроки[НомерСтроки.ВГраница()], НомерСтроки);
		КодПоказателя = Узел.Ключ + "_" + Формат(НомСтроки, "ЧГ=");
		КодПоказателяДляПоиска = Узел.Ключ + "_1";
		Если СтраницаРаздела.Свойство(КодПоказателяДляПоиска, ЗначениеПоказателя)
			ИЛИ ПоказательНайденАльтернативнымСпособом(
					СтраницаРаздела, КодПоказателяДляПоиска, КодПоказателя, ЗначениеПоказателя, ПараметрыОтчета) Тогда
			НовоеЗначениеПоказателя = ?(ТипЗнч(ЗначениеПоказателя) = Тип("Число"), ЧислоИзСтроки(Узел.Значение),
									  ?(ТипЗнч(ЗначениеПоказателя) = Тип("Дата"),  ДатаИзСтрокиЛюбогоФормата(Узел.Значение),
									  СокрЛП(ЗначениеПоказателяИзXML(Узел))));
			СтраницаРаздела.Вставить(КодПоказателя, ОбработанноеЗначениеПоказателя(Узел.Ключ, ПараметрыОтчета, НовоеЗначениеПоказателя));
			Если ЗначениеЗаполнено(Узел.Значение) И ДанныеОтчета.СписокЗаполненныхРазделов.НайтиПоЗначению(Раздел) = Неопределено Тогда
				ДанныеОтчета.СписокЗаполненныхРазделов.Добавить(Раздел, Раздел);
			КонецЕсли;
		Иначе
			ОбщегоНазначения.СообщитьПользователю(
				СтрШаблон(НСтр("ru = 'В данных раздела ""%1"" документа отчета не найден показатель ""%2"" многострочной части.'"),
				Раздел, Узел.Ключ));
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Процедура КлючИДанныеМногострочнойЧастиМУР(СтраницаМУР, КлючДляПоиска, КлючМногострочнойЧасти, ДанныеМногострочнойЧасти)
	
	// Тип параметра КлючМногострочнойЧасти   - массив.
	// Тип параметра ДанныеМногострочнойЧасти - массив.
	
	Для Каждого ГруппаМногострочнойЧасти Из СтраницаМУР.ДанныеМногострочныхЧастей Цикл
		
		ТекущиеДанныеМногострочнойЧасти = ГруппаМногострочнойЧасти.Значение;
		
		Если ТипЗнч(ТекущиеДанныеМногострочнойЧасти) = Тип("ДеревоЗначений")
			И ТекущиеДанныеМногострочнойЧасти.Строки.Количество() > 0 Тогда
			
			Если ТекущиеДанныеМногострочнойЧасти.Строки[0].Данные.Свойство(КлючДляПоиска) Тогда
				КлючМногострочнойЧасти.Добавить(ГруппаМногострочнойЧасти.Ключ);
				ДанныеМногострочнойЧасти.Добавить(ТекущиеДанныеМногострочнойЧасти);
				Прервать;
			Иначе
				КлючИДанныеМногострочнойЧастиМУР(ТекущиеДанныеМногострочнойЧасти.Строки[0],
					КлючДляПоиска, КлючМногострочнойЧасти, ДанныеМногострочнойЧасти);
				
				Если ЗначениеЗаполнено(ДанныеМногострочнойЧасти) Тогда
					КлючМногострочнойЧасти.Вставить(0, ГруппаМногострочнойЧасти.Ключ);
					ДанныеМногострочнойЧасти.Вставить(0, ТекущиеДанныеМногострочнойЧасти);
					Прервать;
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьВПараметрыОтчетаКлючевыеСвойства(ПараметрыОтчета, СвойстваОсновногоФайла, ИменаКлючевыхСвойств)
	
	ИменаСвойств = СтрРазделить(ИменаКлючевыхСвойств, ",");
	Для Каждого ИмяСвойства Из ИменаСвойств Цикл
		Если СвойстваОсновногоФайла[ИмяСвойства] <> Неопределено Тогда
			ПараметрыОтчета.Вставить(ИмяСвойства, СвойстваОсновногоФайла[ИмяСвойства]);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция ПоказательНайденАльтернативнымСпособом(СтраницаРаздела,
											   КодПоказателяДляПоиска,
											   КодПоказателя,
											   ЗначениеПоказателя,
											   ПараметрыОтчета)
	Перем КНД;
	
	// Сюда попадаем, если ранее не найдено свойство по указанному имени.
	Если ПараметрыОтчета.Свойство("КНД", КНД) Тогда
		Если КНД = "0710099"
		 ИЛИ КНД = "0710098"
		 ИЛИ КНД = "0710097"
		 ИЛИ КНД = "0710096"
		 ИЛИ КНД = "0710095"
		 ИЛИ КНД = "0710094" Тогда // только для бухотчетности
			Если Лев(КодПоказателяДляПоиска, 2) = "П2" Тогда
				Если СтраницаРаздела.Свойство("П1" + Сред(КодПоказателяДляПоиска, 3), ЗначениеПоказателя) Тогда
					КодПоказателя = "П1" + Сред(КодПоказателя, 3);
					Возврат Истина;
				ИначеЕсли СтраницаРаздела.Свойство("П0" + Сред(КодПоказателяДляПоиска, 3), ЗначениеПоказателя) Тогда
					КодПоказателя = "П0" + Сред(КодПоказателя, 3);
					Возврат Истина;
				Иначе
					ПозРазделителя = СтрНайти(КодПоказателя, "_", НаправлениеПоиска.СКонца);
					Если ПозРазделителя > 0 Тогда
						КодПоказателяБезСчетчика = "П0" + Сред(КодПоказателя, 3, ПозРазделителя - 3);
						КодСчетчика = Сред(КодПоказателя, ПозРазделителя + 1);
						КодПоказателяДляПоиска = Лев(КодПоказателяБезСчетчика, СтрДлина(КодПоказателяБезСчетчика) - 2)
							+ КодСчетчика + "01";
						КодПоказателяДляПоиска = СтрЗаменить(КодПоказателяДляПоиска, "П00010", "П0001");
						ЗначениеПоказателя = 0;
						Если СтраницаРаздела.Свойство(КодПоказателяДляПоиска) Тогда
							КодПоказателя = Лев(КодПоказателяДляПоиска, СтрДлина(КодПоказателяДляПоиска) - 2) + Прав(КодПоказателяБезСчетчика, 2);
							СтраницаРаздела.Свойство(КодПоказателя, ЗначениеПоказателя);
							Возврат Истина;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция ОбработанноеЗначениеПоказателя(КодПоказателя, ПараметрыОтчета, Знач ЗначениеПоказателя)
	
	Перем КНД;
	Перем ОКЕИ;
	
	Если ПараметрыОтчета.Свойство("КНД", КНД) Тогда
		Если КНД = "0710099"
		 ИЛИ КНД = "0710098"
		 ИЛИ КНД = "0710097"
		 ИЛИ КНД = "0710096"
		 ИЛИ КНД = "0710095"
		 ИЛИ КНД = "0710094" Тогда // только для бухотчетности
			ИменаВычитаемыхПоказателей = Неопределено;
			Если ТипЗнч(ЗначениеПоказателя) <> Тип("Число") Тогда
				Возврат ЗначениеПоказателя;
			КонецЕсли;
			Если ПараметрыОтчета.Свойство("ИменаВычитаемыхПоказателей", ИменаВычитаемыхПоказателей) Тогда
				КодПоказателяДляПоиска = КодПоказателя;
				ПозицияРазделителя = СтрНайти(КодПоказателя, "_", НаправлениеПоиска.СКонца);
				Если ПозицияРазделителя > 0 Тогда
					КодПоказателяДляПоиска = Лев(КодПоказателя, ПозицияРазделителя - 1);
				КонецЕсли;
				Если ТипЗнч(ИменаВычитаемыхПоказателей) = Тип("Массив") Тогда
					Если ИменаВычитаемыхПоказателей.Количество() > 0
					   И ТипЗнч(ИменаВычитаемыхПоказателей[0]) = Тип("Структура") Тогда
						Для Каждого ВычитаемыйПоказатель Из ИменаВычитаемыхПоказателей Цикл
							Если ВычитаемыйПоказатель.ИмяПоказателя = КодПоказателяДляПоиска Тогда
								ЗначениеПоказателя = -ЗначениеПоказателя;
								Прервать;
							КонецЕсли;
						КонецЦикла;
					ИначеЕсли ИменаВычитаемыхПоказателей.Найти(КодПоказателяДляПоиска) <> Неопределено Тогда
						ЗначениеПоказателя = -ЗначениеПоказателя;
					КонецЕсли;
				ИначеЕсли ТипЗнч(ИменаВычитаемыхПоказателей) = Тип("Структура") Тогда
					Если ИменаВычитаемыхПоказателей.Свойство(КодПоказателяДляПоиска) Тогда
						ЗначениеПоказателя = -ЗначениеПоказателя;
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			Если ПараметрыОтчета.Свойство("ОКЕИ", ОКЕИ) Тогда
				Если      ОКЕИ = "383" Тогда // в единицах
					Возврат ЗначениеПоказателя;
				ИначеЕсли ОКЕИ = "384" Тогда // в тысячах
					Возврат ЗначениеПоказателя * 1000;
				ИначеЕсли ОКЕИ = "385" Тогда // в миллионах
					Возврат ЗначениеПоказателя * 1000000;
				Иначе // в тысячах - по умолчанию
					Возврат ЗначениеПоказателя * 1000;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ЗначениеПоказателя;
	
КонецФункции

Функция ВключитьЗаполненныеСтраницыВДеревеНастройкиСтраниц(ДанныеОтчета)
	
	ДеревоИзменено = Ложь;
	
	Если ТипЗнч(ДанныеОтчета.ДеревоНастройкиСтраниц) = Тип("ДеревоЗначений") Тогда
		СписокЗаполненныхРазделов = ДанныеОтчета.СписокЗаполненныхРазделов;
		Для Каждого ОписаниеСтраницыРаздела Из ДанныеОтчета.ДеревоНастройкиСтраниц.Строки Цикл
			Если СписокЗаполненныхРазделов.НайтиПоЗначению(ОписаниеСтраницыРаздела.ИмяСтраницы) <> Неопределено
				И НЕ ЗначениеЗаполнено(ОписаниеСтраницыРаздела.ПоказатьСтраницу) Тогда
				ОписаниеСтраницыРаздела.ПоказатьСтраницу = 1;
				ДеревоИзменено = Истина;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат ДеревоИзменено;
	
КонецФункции

Функция СодержимоеОбластейПравилЗагрузки(Знач ПравилаЗагрузки, НастройкиЗагрузки)
	
	ОбластиПравилЗагрузки = Новый Соответствие;
	
	Если ТипЗнч(ПравилаЗагрузки) = Тип("ТекстовыйДокумент") И ТипЗнч(НастройкиЗагрузки) = Тип("Структура") Тогда
		
		ИмяФайлаНастроек = Неопределено;
		Если НастройкиЗагрузки.Свойство("ИмяФайлаНастроек", ИмяФайлаНастроек) И ЗначениеЗаполнено(ИмяФайлаНастроек) Тогда
			Если Пользователи.ЭтоПолноправныйПользователь(, Ложь, Ложь) = Истина Тогда
				ПравилаЗагрузкиИзФайла = Новый ТекстовыйДокумент;
				Попытка
					ПравилаЗагрузкиИзФайла.Прочитать(ИмяФайлаНастроек);
					ПравилаЗагрузки = ПравилаЗагрузкиИзФайла;
					ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'Используются обработчики из файла настроек загрузки ""%1"".'"), ИмяФайлаНастроек));
				Исключение
					ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'Не найден файл настроек загрузки ""%1"": %2.'"), ИмяФайлаНастроек,
						РегламентированнаяОтчетностьКлиентСервер.СформироватьТекстСообщения(ИнформацияОбОшибке().Описание)));
					ПравилаЗагрузкиИзФайла = Неопределено;
				КонецПопытки;
			КонецЕсли;
		КонецЕсли;
		
		ОписанияОбластейОбработчиков = Неопределено;
		Если НЕ НастройкиЗагрузки.Свойство("ОбластиОбработчиков", ОписанияОбластейОбработчиков)
			ИЛИ ТипЗнч(ОписанияОбластейОбработчиков) <> Тип("Структура") Тогда
			Возврат ОбластиПравилЗагрузки;
		КонецЕсли;
		
		КоличествоСтрокПравилЗагрузки = ПравилаЗагрузки.КоличествоСтрок();
		Для НомСтрокиПравилЗагрузки = 1 По КоличествоСтрокПравилЗагрузки Цикл
			СтрокаПравилЗагрузки = ПравилаЗагрузки.ПолучитьСтроку(НомСтрокиПравилЗагрузки);
			НомПозицииНачалаОбласти = СтрНайти(СтрокаПравилЗагрузки, "#Область");
			Если НомПозицииНачалаОбласти > 0 Тогда
				ИмяОбласти = СокрЛП(Сред(СтрокаПравилЗагрузки, НомПозицииНачалаОбласти + 9));
				
				ИмяОбработчика = "";
				Для Каждого ОписаниеОбластиОбработчика Из ОписанияОбластейОбработчиков Цикл
					Если ОписаниеОбластиОбработчика.Значение = ИмяОбласти Тогда
						ИмяОбработчика = ОписаниеОбластиОбработчика.Ключ;
						Прервать;
					КонецЕсли;
				КонецЦикла;
				
				Если НЕ ПустаяСтрока(ИмяОбработчика) И НЕ ПустаяСтрока(ИмяОбласти) Тогда
					ОбластьОбработчика = ПравилаЗагрузки.ПолучитьОбласть(ИмяОбласти);
					
					ОбластьОбработчика.УдалитьСтроку(1);
					КоличествоСтрокОбласти = ОбластьОбработчика.КоличествоСтрок();
					ОбластьОбработчика.УдалитьСтроку(КоличествоСтрокОбласти);
					
					ОбластиПравилЗагрузки.Вставить(ИмяОбработчика, ОбластьОбработчика.ПолучитьТекст());
					
					НомСтрокиПравилЗагрузки = НомСтрокиПравилЗагрузки + КоличествоСтрокОбласти;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат ОбластиПравилЗагрузки;
	
КонецФункции

Функция ТекстОбработчикаПоИмени(ТекстыПравилЗагрузки, ИмяОбработчика)
	
	ПустойОбработчик = ";";
	
	Если ТипЗнч(ТекстыПравилЗагрузки) = Тип("Соответствие") Тогда
		
		ТекстОбработчика = ТекстыПравилЗагрузки.Получить(ИмяОбработчика);
		
		Если ЗначениеЗаполнено(ТекстОбработчика) Тогда
			Возврат ТекстОбработчика;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ПустойОбработчик;
	
КонецФункции

#КонецОбласти

#Область ПомещениеДанныхИзМестХраненияВТабличныйДокумент

// Процедура заполняет в табличном документе многострочную часть из дерева многоуровневого раздела.
// Используется для загрузки реестров НДС (приложения).
//
// Параметры:
//  ТабличныйДокумент - ТабличныйДокумент - Шаблон табличного документа соответствующий разделу отчета.
//  СтруктураМногострочныхЧастей - Структура - Структура многострочных частей инициализированная в форме отчета.
//  Ветвь - ДеревоЗначений, СтрокаДереваЗначений - Обрабатываемая ветвь многоуровневого раздела.
//  Координаты - Строка - Суффикс имени заполняемой области табличного документа.
//
Процедура ВывестиМногострочныеДанныеВТабличныйДокумент(ТабличныйДокумент, СтруктураМногострочныхЧастей, Ветвь, Координаты = "") Экспорт
	
	Для каждого ЭлемСтруктуры Из Ветвь.ДанныеМногострочныхЧастей Цикл
		
		ДеревоМнЧ = ЭлемСтруктуры.Значение;
		
		Для Индекс = 0 По ДеревоМнЧ.Строки.Количество() - 1 Цикл
			
			// Добавление необходимого количества дополнительных строк.
			Если Индекс > 0 Тогда
				СтрИнд = "_" + Формат(Индекс, "ЧГ=");
				ИмяОбластиПреемника = "ДобавлениеСтроки" + ЭлемСтруктуры.Ключ + Координаты + СтрИнд;
				ВставитьДопСтроку(ТабличныйДокумент, СтруктураМногострочныхЧастей, ЭлемСтруктуры.Ключ, ИмяОбластиПреемника);
			КонецЕсли;
			
			// Обработка гиперссылок удаления строки, если эта строка единственная.
			Если ДеревоМнЧ.Строки.Количество() = 1 Тогда
				ИмяИскомойОбласти = "УдалитьСтроку" + ЭлемСтруктуры.Ключ + Координаты + "_1";
				ОбластьЗнач = ТабличныйДокумент.Области.Найти(ИмяИскомойОбласти);
				Если ОбластьЗнач <> Неопределено Тогда
					ОбластьЗнач.Гиперссылка = Ложь;
					ОбластьЗнач.Текст = "";
				КонецЕсли;
			КонецЕсли;
			
			// Вывод многострочных данных.
			Данные = ДеревоМнЧ.Строки[Индекс].Данные;
			СтрИнд = "_" + Формат(Индекс + 1, "ЧГ=");
			Для Каждого ЭлСтруктуры Из Данные Цикл
				ИмяИскомойОбласти = ЭлСтруктуры.Ключ + Координаты + СтрИнд;
				ОбластьЗнач = ТабличныйДокумент.Области.Найти(ИмяИскомойОбласти);
				Если ОбластьЗнач <> Неопределено Тогда
					ОбластьЗнач.Значение = ЭлСтруктуры.Значение;
				КонецЕсли;
			КонецЦикла;
			
			// Добавление необходимого количества подчиненных дополнительных строк.
			ПодчВетвь = ДеревоМнЧ.Строки[Индекс];
			ПодчКоординаты = Координаты + СтрИнд;
			
			ВывестиМногострочныеДанныеВТабличныйДокумент(ТабличныйДокумент, СтруктураМногострочныхЧастей, ПодчВетвь, ПодчКоординаты);
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ВставитьДопСтроку(ТабличныйДокумент, СтруктураМногострочныхЧастей, Знач ИмяГруппы, Знач ИмяОбластиПреемника, ЭтоАвтоВставкаПодчиненнойМнЧ = Ложь)
	
	НачИндекс = "_1";
	
	Если СтрНайти(ИмяОбластиПреемника, "ДобавлениеСтроки" + ИмяГруппы) > 0 Тогда
		
		ИскомаяОбласть = ТабличныйДокумент.Области.Найти("МногострочнаяЧасть" + ИмяГруппы);
		
		ВремТаблДок = ТабличныйДокумент.ПолучитьОбласть(ИскомаяОбласть.Имя);
		ВставляемаяОбласть = ВремТаблДок.Область(ИскомаяОбласть.Имя);
		ВставляемаяОбласть.Имя = "";
		
		НовКоординаты = СтрокаСКоординатамиПоказателя(ИмяОбластиПреемника);
		
		КолУровнейПодчиненности = СтрЧислоВхождений(НовКоординаты, "_");
		НачКоординаты = "";
		Для НомУр = 1 По КолУровнейПодчиненности Цикл
			НачКоординаты = НачКоординаты + НачИндекс;
		КонецЦикла;
		
		МассивСтрок = СтрРазделить(ИмяОбластиПреемника, "_");
		ПреИндекс_Число = ЧислоИзСтроки(МассивСтрок[МассивСтрок.ВГраница()]);
		НовИндекс_Число = ?(ЭтоАвтоВставкаПодчиненнойМнЧ, 1, ПреИндекс_Число + 1);
		ПреИндекс = "_" + Формат(ПреИндекс_Число, "ЧГ=");
		НовИндекс = "_" + Формат(НовИндекс_Число, "ЧГ=");
		
		НачПостфикс = ИмяГруппы + НачКоординаты + НачИндекс;
		ПреПостфикс = ИмяГруппы + НовКоординаты + ПреИндекс;
		НовПостфикс = ИмяГруппы + НовКоординаты + НовИндекс;
		
		МассивИменГраф = СтруктураМногострочныхЧастей[ИмяГруппы]["ИменаГраф"];
		
		Для каждого ИмяГрафы Из МассивИменГраф Цикл
			
			НачИмяОбл = ИмяГрафы + НачКоординаты + НачИндекс;
			НовИмяОбл = ИмяГрафы + НовКоординаты + НовИндекс;
			
			ОбластьЯчейки = ВремТаблДок.Области[НачИмяОбл];
			ОбластьЯчейки.Имя = НовИмяОбл;
			
			Если ОбластьЯчейки.СодержитЗначение = Истина Тогда
				ОбластьЯчейки.Очистить();
			КонецЕсли;
			
		КонецЦикла;
		
		Обл = ВремТаблДок.Области.Найти("УдалитьСтроку" + НачПостфикс);
		Если Обл <> Неопределено Тогда
			Обл.Имя = "УдалитьСтроку" + НовПостфикс;
		КонецЕсли;
		
		Если ЭтоАвтоВставкаПодчиненнойМнЧ Тогда
			Обл = ВремТаблДок.Области.Найти("УдалитьСтроку" + НовПостфикс);
			Если Обл <> Неопределено Тогда
				Обл.Гиперссылка = Ложь;
				Обл.Текст = "";
			КонецЕсли;
		Иначе
			Обл = ВремТаблДок.Области.Найти("УдалитьСтроку" + НовПостфикс);
			Если Обл <> Неопределено Тогда
				Обл.Гиперссылка = Истина;
				Обл.Текст = "х";
				Если НовИндекс_Число = 2 Тогда
					Если Обл <> Неопределено Тогда
						Обл = ТабличныйДокумент.Области.Найти("УдалитьСтроку" + ПреПостфикс);
						Обл.Гиперссылка = Истина;
						Обл.Текст = "х";
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		Обл = ТабличныйДокумент.Области.Найти("ДобавитьСтроку" + ПреПостфикс);
		Если Обл <> Неопределено Тогда
			Обл.Имя = "ДобавитьСтроку" + НовПостфикс;
		КонецЕсли;
		Обл = ТабличныйДокумент.Области.Найти("ДобавитьСтрокуЗначок" + ПреПостфикс);
		Если Обл <> Неопределено Тогда
			Обл.Имя = "ДобавитьСтрокуЗначок" + НовПостфикс;
		КонецЕсли;
		
		ОблПреемник = ТабличныйДокумент.Области.Найти(ИмяОбластиПреемника);
		ОблПреемник.Имя = "ДобавлениеСтроки" + НовПостфикс;
		
		// Изменения в оформлении ячеек: установка значения "НетЛинии"/"Сплошная" для
		// свойства "ГраницаСнизу" (в случае задания номеров специальных колонок).
		НомераСпецКолонок = Неопределено;
		СтруктураМногострочныхЧастей[ИмяГруппы].Свойство("КолонкиСИзмНижнГраницей", НомераСпецКолонок);
		
		Если НомераСпецКолонок <> Неопределено Тогда
			Для каждого НомКолонки Из НомераСпецКолонок Цикл
				// Удаление линии в определенных колонках последней (до добавления) строки.
				Если НЕ ЭтоАвтоВставкаПодчиненнойМнЧ Тогда
					Обл = ТабличныйДокумент.Область(
						ОблПреемник.Верх - 1, НомКолонки, ОблПреемник.Верх - 1, НомКолонки);
					Если Обл <> Неопределено Тогда
						Обл.ГраницаСнизу = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.НетЛинии);
					КонецЕсли;
				КонецЕсли;
				// Установка линии в определенных колонках добавляемой строки.
				Обл = ВремТаблДок.Область(
					ВставляемаяОбласть.Низ, НомКолонки, ВставляемаяОбласть.Низ, НомКолонки);
				Если Обл <> Неопределено Тогда
					Обл.ГраницаСнизу = Новый Линия(ТипЛинииЯчейкиТабличногоДокумента.Сплошная);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		ОблПреемник_ = ТабличныйДокумент.Область(
			ОблПреемник.Верх, , ОблПреемник.Верх + ИскомаяОбласть.Низ - ИскомаяОбласть.Верх, );
		ТабличныйДокумент.ВставитьОбласть(
			ВставляемаяОбласть, ОблПреемник_, ТипСмещенияТабличногоДокумента.ПоВертикали);
		
		Если НЕ ЭтоАвтоВставкаПодчиненнойМнЧ Тогда
			// Установка текущей области после добавления строки.
			НовИмяТекОбл = МассивИменГраф[0] + НовКоординаты + НовИндекс;
			НовТекОбл = ТабличныйДокумент.Области[НовИмяТекОбл];
			ТабличныйДокумент.ТекущаяОбласть = НовТекОбл;
		КонецЕсли;
		
	КонецЕсли;
	
	ИменаПодчиненныхГрупп = СтруктураМногострочныхЧастей[ИмяГруппы]["ИменаПодчиненныхГрупп"];
	
	Для каждого ИмяПодчГруппы Из ИменаПодчиненныхГрупп Цикл
		НовКоординатыДляПодчОбласти = НовКоординаты + НовИндекс;
		
		КолУровнейПодчиненности = СтрЧислоВхождений(НовКоординатыДляПодчОбласти, "_");
		НачКоординатыДляПодчОбласти = "";
		Для НомУр = 1 По КолУровнейПодчиненности Цикл
			НачКоординатыДляПодчОбласти = НачКоординатыДляПодчОбласти + НачИндекс;
		КонецЦикла;
		
		НачИндВставляемойОбласти = НачИндекс;
		
		ИскомаяОбласть = ТабличныйДокумент.Области.Найти(
			"ДобавлениеСтроки" + ИмяПодчГруппы + НачКоординатыДляПодчОбласти + НачИндВставляемойОбласти);
		
		Если ИскомаяОбласть = Неопределено Тогда
			НачИндВставляемойОбласти = 1;
			Пока ТабличныйДокумент.Области.Найти("ДобавлениеСтроки" + ИмяПодчГруппы
				+ НачКоординатыДляПодчОбласти + "_" + Формат(НачИндВставляемойОбласти, "ЧГ=")) = Неопределено Цикл
				НачИндВставляемойОбласти = НачИндВставляемойОбласти + 1;
			КонецЦикла;
			НачИндВставляемойОбласти = "_" + Формат(НачИндВставляемойОбласти, "ЧГ=");
			ИскомаяОбласть = ТабличныйДокумент.Области.Найти(
				"ДобавлениеСтроки" + ИмяПодчГруппы + НачКоординатыДляПодчОбласти + НачИндВставляемойОбласти);
		КонецЕсли;
		
		ВремТабличныйДокумент = ТабличныйДокумент.ПолучитьОбласть(ИскомаяОбласть.Имя);
		ВставляемаяОбласть = ВремТабличныйДокумент.Область(ИскомаяОбласть.Имя);
		Для каждого ОбластьЯчейки Из ВремТабличныйДокумент.Области Цикл
			ОбластьЯчейки.Имя = СтрЗаменить(ОбластьЯчейки.Имя,
				ИмяПодчГруппы + НачКоординатыДляПодчОбласти + НачИндВставляемойОбласти,
				ИмяПодчГруппы + НовКоординатыДляПодчОбласти + НачИндекс);
		КонецЦикла;
		ИмяОбластиПреемникаДляПодчОбласти = СтрЗаменить(ИмяОбластиПреемника, ПреПостфикс, НовПостфикс);
		ОбластьПреемник = ТабличныйДокумент.Области.Найти(ИмяОбластиПреемникаДляПодчОбласти);
		
		ТабличныйДокумент.ВставитьОбласть(ВставляемаяОбласть, ОбластьПреемник, ТипСмещенияТабличногоДокумента.ПоВертикали);
		
		ИмяОбластиПреемникаДляПодчОбласти = "ДобавлениеСтроки" + ИмяПодчГруппы + НовКоординатыДляПодчОбласти + НачИндекс;
		
		ВставитьДопСтроку(ТабличныйДокумент, СтруктураМногострочныхЧастей, ИмяПодчГруппы, ИмяОбластиПреемникаДляПодчОбласти, Истина);
	КонецЦикла;
	
КонецПроцедуры

Функция СтрокаСКоординатамиПоказателя(Знач Координаты)
	
	СтрокаСКоординатами = "";
	
	Если ТипЗнч(Координаты) = Тип("Массив") Тогда
		Для каждого КоординатаЧисло Из Координаты Цикл
			Если ТипЗнч(КоординатаЧисло) <> Тип("Число") Тогда
				Возврат Неопределено;
			КонецЕсли;
			СтрокаСКоординатами = СтрокаСКоординатами + "_" + Формат(КоординатаЧисло, "ЧГ=");
		КонецЦикла;
	ИначеЕсли ТипЗнч(Координаты) = Тип("Строка") Тогда
		МассивСтрок = СтрРазделить(Координаты, "_");
		КолСтрок = МассивСтрок.Количество();
		Если КолСтрок = 0 Тогда
			Возврат Неопределено;
		КонецЕсли;
		МассивСтрок.Удалить(КолСтрок - 1);
		МассивСтрок.Удалить(0);
		Для каждого КоординатаСтрока Из МассивСтрок Цикл
			Если СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(КоординатаСтрока) Тогда
				СтрокаСКоординатами = СтрокаСКоординатами + "_" + Формат(КоординатаСтрока, "ЧГ=");
			Иначе
				Возврат Неопределено;
			КонецЕсли;
		КонецЦикла;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат СтрокаСКоординатами;
	
КонецФункции

#КонецОбласти

// Читает текст из текстового файла или файла XML с возможностью автоматического определения кодировки.
//
// Параметры:
//  ИмяФайла                    - Строка - Имя файла на диске или адрес во временном хранилище.
//  ЗаданнаяКодировкаТекста     - Строка или КодировкаТекста - Указанная явно кодировка текста.
//  АвтоопределениеКодировкиXML - Булево - Если "Истина", то кодировка файла XML определяется автоматически.
//
Функция ПрочитатьТекстИзФайла(ИмяФайла, ЗаданнаяКодировкаТекста = Неопределено, АвтоопределениеКодировкиXML = Ложь, КоличествоСимволов = 0) Экспорт
	
	ЭтоВременныйФайл = Ложь;
	
	Если ЭтоАдресВременногоХранилища(ИмяФайла) Тогда
		ИмяФайлаНаДиске = ПолучитьИмяВременногоФайла();
		ПолучитьИзВременногоХранилища(ИмяФайла).Записать(ИмяФайлаНаДиске);
		ЭтоВременныйФайл = Истина;
	Иначе
		ИмяФайлаНаДиске = ИмяФайла;
	КонецЕсли;
	
	НоваяКодировка = ИсправленнаяКодировкаЧтенияТекстаНаСервере(ИмяФайлаНаДиске, ЗаданнаяКодировкаТекста);
	ОбъектЧтение = Новый ЧтениеТекста(ИмяФайлаНаДиске, НоваяКодировка);
	Если КоличествоСимволов > 0 Тогда
		ТекстИзФайла = ОбъектЧтение.Прочитать(?(АвтоопределениеКодировкиXML, Макс(КоличествоСимволов, 1000), КоличествоСимволов));
	Иначе
		ТекстИзФайла = ОбъектЧтение.Прочитать();
	КонецЕсли;
	
	ОбъектЧтение.Закрыть();
	
	Если ЭтоВременныйФайл Тогда
		УдалитьФайлы(ИмяФайлаНаДиске);
	КонецЕсли;
	
	Если АвтоопределениеКодировкиXML И ЗначениеЗаполнено(ТекстИзФайла) Тогда
		ПерваяСтрокаФайла = ВРЕГ(Лев(СтрПолучитьСтроку(ТекстИзФайла, 1), 100));
		Если СтрНайти(ПерваяСтрокаФайла, ВРЕГ("encoding=""UTF-8""")) <> 0 Тогда
			ТекстИзФайла = ПрочитатьТекстИзФайла(ИмяФайла, КодировкаТекста.UTF8, , КоличествоСимволов);
		ИначеЕсли СтрНайти(ПерваяСтрокаФайла, ВРЕГ("encoding=""UTF-16""")) <> 0 Тогда
			ТекстИзФайла = ПрочитатьТекстИзФайла(ИмяФайла, КодировкаТекста.UTF16, , КоличествоСимволов);
		ИначеЕсли СтрНайти(ПерваяСтрокаФайла, ВРЕГ("<?xml version=""1.0""?>")) <> 0 Тогда // кодировка не указана
			КонтрольнаяСтрока = ПерваяСтрокаФайла;
			Если СтрЧислоСтрок(ТекстИзФайла) > 1 Тогда
				КонтрольнаяСтрока = ВРЕГ(Лев(СтрПолучитьСтроку(ТекстИзФайла, 2), 100));   // вторая строка файла
			КонецЕсли;
			Если СтрНайти(КонтрольнаяСтрока, ВРЕГ("msg=""")) <> 0 И СтрНайти(КонтрольнаяСтрока, "О") = 0 Тогда // не нашли "О" (кириллица)
				ТекстИзФайла = ПрочитатьТекстИзФайла(ИмяФайла, КодировкаТекста.UTF8, , КоличествоСимволов);
			КонецЕсли;
		ИначеЕсли СтрНайти(ПерваяСтрокаФайла, ВРЕГ("<protocol")) <> 0 Тогда
			ТекстИзФайла = ПрочитатьТекстИзФайла(ИмяФайла, КодировкаТекста.UTF8, , КоличествоСимволов);
		КонецЕсли;
	КонецЕсли;
	
	Если АвтоопределениеКодировкиXML И КоличествоСимволов > 0 Тогда
		Возврат Лев(ТекстИзФайла, КоличествоСимволов);
	КонецЕсли;
	
	Возврат ТекстИзФайла;
	
КонецФункции

Функция ИсправленнаяКодировкаЧтенияТекстаНаСервере(ИмяФайла, Знач Кодировка = Неопределено)
	
	Если ЗначениеЗаполнено(Кодировка) Тогда
		
		НоваяКодировка = Кодировка;
		
	Иначе
	
		Если КодировкаНаСервереОпределяетсяВерно() Тогда
			НоваяКодировка = Неопределено;
		Иначе
			Если ФайлИмеетBOM(ИмяФайла) Тогда
				НоваяКодировка = Неопределено;
			Иначе
				НоваяКодировка = "windows-1251";
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат НоваяКодировка; 
	
КонецФункции

Функция КодировкаНаСервереОпределяетсяВерно()
	
	ИсходнаяСтрока = "АБВГДЕЖЗИКЛМНОПРСТУФХЦЧШЭЮЯабвгдежзиклмнопрстуфхцчшэюя";
	ИмяФайла       = ПолучитьИмяВременногоФайла();
	
	// Записываем текст с кодировкой.
	ЗаписьКонтрольногоФайла = Новый ЗаписьТекста(ИмяФайла, "windows-1251");
	ЗаписьКонтрольногоФайла.Записать(ИсходнаяСтрока);
	ЗаписьКонтрольногоФайла.Закрыть();
	
	// Читаем текст без кодировки.
	ЧтениеФайлаБезКодировки = Новый ЧтениеТекста(ИмяФайла);
	ПрочтеннаяСтрокаБезКодировки = ЧтениеФайлаБезКодировки.Прочитать();
	ЧтениеФайлаБезКодировки.Закрыть();
	
	УдалитьФайлы(ИмяФайла);
	
	Возврат ИсходнаяСтрока = ПрочтеннаяСтрокаБезКодировки;
	
КонецФункции

Функция ФайлИмеетBOM(ИмяФайла)
	
	ПредставлениеКодировкиUTF8  = ПредставлениеКодировкиФайла(ИмяФайла, 3);
	ПредставлениеКодировкиUTF16 = ПредставлениеКодировкиФайла(ИмяФайла, 2);
	ПредставлениеКодировкиUTF32 = ПредставлениеКодировкиФайла(ИмяФайла, 4);
	ПредставлениеКодировкиUTF7  = ПредставлениеКодировкиФайла(ИмяФайла, 16);
	
	Возврат ПредставлениеКодировкиUTF8  = "239187191"
		ИЛИ ПредставлениеКодировкиUTF16 = "254255"
		ИЛИ ПредставлениеКодировкиUTF16 = "255254"
		ИЛИ ПредставлениеКодировкиUTF32 = "00254255"
		ИЛИ ПредставлениеКодировкиUTF32 = "25525400"
		ИЛИ ПредставлениеКодировкиUTF7  = "434711856434711857434711843434711847";
	
КонецФункции

Функция ПредставлениеКодировкиФайла(ИмяФайла, КоличествоБайт)
	
	ПредставлениеКодировки = "";
	
	ТекстовыйПоток = Новый ЧтениеТекста;
	ТекстовыйПоток.Открыть(ИмяФайла, "ISO-8859-1");
	
	Для Инд = 1 По КоличествоБайт Цикл
		
		ТекущийСимвол = ТекстовыйПоток.Прочитать(1);
		Если ТекущийСимвол = Неопределено Тогда
			ТекстовыйПоток.Закрыть();
			Возврат ПредставлениеКодировки;
		КонецЕсли;
		ТекущийБайт = КодСимвола(ТекущийСимвол); // Значение байта 0-255
		
		ПредставлениеКодировки = ПредставлениеКодировки + Строка(ТекущийБайт);
		
	КонецЦикла;
	
	ТекстовыйПоток.Закрыть();
	
	Возврат ПредставлениеКодировки;
	
КонецФункции

Функция СвойстваФайлаЗагрузки(ФайлЗагрузки, МаксКоличествоПрочитанныхСвойств, ЭтоXML = Истина, ЗаменятьДефисы = Ложь, ЭтоСтрока = Ложь) Экспорт
	
	СвойстваЗагрузки = Новый Соответствие;
	
	Если ЭтоXML Тогда
		
		ОбъектЧтениеXML = Новый ЧтениеXML;
		КоличествоПрочитанныхАтрибутов = 0;
		Попытка
			Если ЭтоСтрока Тогда
				ОбъектЧтениеXML.УстановитьСтроку(ФайлЗагрузки);
			Иначе
				ОбъектЧтениеXML.ОткрытьФайл(ФайлЗагрузки);
			КонецЕсли;
			ОбъектЧтениеXML.ИгнорироватьПробелы = Ложь;
			Пока ОбъектЧтениеXML.Прочитать() Цикл
				Если ОбъектЧтениеXML.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
					Пока ОбъектЧтениеXML.ПрочитатьАтрибут() Цикл
						КоличествоПрочитанныхАтрибутов = КоличествоПрочитанныхАтрибутов + 1;
						Если ЗаменятьДефисы Тогда
							ИмяОбъекта = СтрЗаменить(ОбъектЧтениеXML.Имя, "-", "_");
						Иначе
							ИмяОбъекта = ОбъектЧтениеXML.Имя;
						КонецЕсли;
						Если СвойстваЗагрузки[ИмяОбъекта] = Неопределено Тогда
							СвойстваЗагрузки.Вставить(ИмяОбъекта, ОбъектЧтениеXML.Значение);
						КонецЕсли;
						Если КоличествоПрочитанныхАтрибутов >= МаксКоличествоПрочитанныхСвойств Тогда
							ОбъектЧтениеXML.Закрыть();
							Возврат СвойстваЗагрузки;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
			ОбъектЧтениеXML.Закрыть();
		Исключение
			ОбъектЧтениеXML.Закрыть();
		КонецПопытки;
		
	Иначе
		
		КоличествоПрочитанныхЗначений = 0;
		Если ЭтоСтрока Тогда
			ЧислоСтрок = СтрЧислоСтрок(ФайлЗагрузки);
			Для НомСтроки = 1 По ЧислоСтрок Цикл
				ТекСтр = СокрЛП(СтрПолучитьСтроку(ФайлЗагрузки, НомСтроки));
				ВхождениеДвоеточия = СтрНайти(ТекСтр, ":");
				ИмяПоказателя = СокрЛП(Лев(ТекСтр, ВхождениеДвоеточия - 1));
				ЗначениеПоказателя = СокрЛП(Сред(ТекСтр, ВхождениеДвоеточия + 1));
				Если ВхождениеДвоеточия <> 0 Тогда
					КоличествоПрочитанныхЗначений = КоличествоПрочитанныхЗначений + 1;
					Если СвойстваЗагрузки[ИмяПоказателя] = Неопределено Тогда
						СвойстваЗагрузки.Вставить(ИмяПоказателя, ЗначениеПоказателя);
					КонецЕсли;
					Если КоличествоПрочитанныхЗначений >= МаксКоличествоПрочитанныхСвойств Тогда
						Возврат СвойстваЗагрузки;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		Иначе
			Текст = Новый ЧтениеТекста;
			Текст.Открыть(ФайлЗагрузки, "cp866");
			ТекСтр = Текст.ПрочитатьСтроку();
			Пока ТекСтр <> Неопределено Цикл
				ТекСтр = СокрЛП(ТекСтр);
				ВхождениеДвоеточия = СтрНайти(ТекСтр, ":");
				ИмяПоказателя = СокрЛП(Лев(ТекСтр, ВхождениеДвоеточия - 1));
				ЗначениеПоказателя = СокрЛП(Сред(ТекСтр, ВхождениеДвоеточия + 1));
				Если ВхождениеДвоеточия <> 0 Тогда
					КоличествоПрочитанныхЗначений = КоличествоПрочитанныхЗначений + 1;
					Если СвойстваЗагрузки[ИмяПоказателя] = Неопределено Тогда
						СвойстваЗагрузки.Вставить(ИмяПоказателя, ЗначениеПоказателя);
					КонецЕсли;
					Если КоличествоПрочитанныхЗначений >= МаксКоличествоПрочитанныхСвойств Тогда
						Текст.Закрыть();
						Возврат СвойстваЗагрузки;
					КонецЕсли;
				КонецЕсли;
				ТекСтр = Текст.ПрочитатьСтроку();
			КонецЦикла;
			Текст.Закрыть();
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СвойстваЗагрузки;
	
КонецФункции

Функция XDTOОбъектИзФайлаИлиСтроки(СтрокаИлиИмяФайлаXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	
	Если Лев(СтрокаИлиИмяФайлаXML, 1) = "<" Тогда
		ЧтениеXML.УстановитьСтроку(СтрокаИлиИмяФайлаXML);
	Иначе
		ЧтениеXML.ОткрытьФайл(СтрокаИлиИмяФайлаXML);
	КонецЕсли;
	
	ЧтениеXML.ПерейтиКСодержимому();
	
	Объект = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);
	
	ЧтениеXML.Закрыть();
	
	Возврат Объект;
	
КонецФункции

// Функция возвращает массив узлов дерева значений, удовлетворяющий выражению XPath.
//
// Реализованы выражения:
//  <имя_узла>   - выбирает все узлы с именем "имя_узла";
//  "/"          - выбирает от корневого узла;
//  "//"         - выбирает узлы в документе от текущего узла,
//                 который соответствует выбору, независимо от того, где они находятся;
//  "."          - выбирает текущий узел;
//  ".."         - выбирает родителя текущего узла;
//  "@"          - выбирает атрибуты;
//  "*"          - соответствует любому узлу;
//  "@*"         - соответствует узлу-атрибуту;
//  [<предикат>] - выбор узлов с указанными значениями, например "title[@lang='en']", "book[1]", "book[last()]".
//
Функция УзлыПоXPath(УзелДерева, ВыражениеXPath) Экспорт
	
	Узел = УзелДерева;
	
	Разделитель = "/";
	
	ТипДеревоЗначений = Тип("ДеревоЗначений");
	
	Результат     = Новый Массив;
	ПромРезультат = Новый Массив;
	
	СтрокаВыражения = СокрЛП(ВыражениеXPath);
	ШагиВыражения = СтрРазделить(СтрокаВыражения, Разделитель, Истина);
	
	СтрокаВсеШаги = "";
	Для Каждого ТекущийШаг Из ШагиВыражения Цикл
		СтрокаВсеШаги = СтрокаВсеШаги + ТекущийШаг;
	КонецЦикла;
	Если ПустаяСтрока(СтрокаВсеШаги) Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если ПустаяСтрока(ШагиВыражения[0]) Тогда
		Если НЕ ПустаяСтрока(ШагиВыражения[1]) // это не двойной разделитель
			И ТипЗнч(УзелДерева) <> ТипДеревоЗначений Тогда 
			Узел = УзелДерева.Владелец(); // путь начинается от корневого узла
		КонецЕсли;
		ШагиВыражения.Удалить(0); // удаляем первое значение, если оно пустое
	КонецЕсли;
	
	ПромРезультат.Добавить(Узел);
	
	ВключатьПодчиненные = Ложь;
	РодительскийУзел    = Ложь;
	ВыбиратьАтрибуты    = Ложь;
	ВыбиратьЛюбойТип    = Ложь;
	
	Для Инд = 0 По ШагиВыражения.ВГраница() Цикл
		
		ШагВыражения = СокрЛП(ШагиВыражения[Инд]);
		
		Если ПустаяСтрока(ШагВыражения) Тогда
			ВключатьПодчиненные = Истина;
			Продолжить;
		ИначеЕсли СтрНачинаетсяС(ШагВыражения, "@") Тогда
			ВыбиратьАтрибуты = Истина;
			ШагВыражения = Сред(ШагВыражения, 2);
		ИначеЕсли ШагВыражения = "node()" Тогда
			ВыбиратьЛюбойТип = Истина;
		ИначеЕсли ШагВыражения = ".." Тогда
			РодительскийУзел = Истина;
		ИначеЕсли ШагВыражения = "." Тогда
			Результат.Очистить();
			Для Каждого ТекущийУзел Из ПромРезультат Цикл
				Результат.Добавить(ТекущийУзел);
			КонецЦикла;
			Продолжить;
		КонецЕсли;
		
		Предикат = ПредикатЕслиНайден(ШагВыражения);
		
		Результат.Очистить();
		Для Каждого УзелРезультата Из ПромРезультат Цикл
			Если РодительскийУзел Тогда
				НайденныеУзлы = Новый Массив;
				Если ТипЗнч(УзелРезультата) <> ТипДеревоЗначений Тогда
					РодительУзлаРезультата = УзелРезультата.Родитель;
					Если РодительУзлаРезультата = Неопределено Тогда
						РодительУзлаРезультата = УзелДерева.Владелец();
					КонецЕсли;
				Иначе
					РодительУзлаРезультата = УзелРезультата;
				КонецЕсли;
				НайденныеУзлы.Добавить(РодительУзлаРезультата);
			ИначеЕсли ВыбиратьЛюбойТип ИЛИ СтрНачинаетсяС(ШагВыражения, "*") Тогда
				ДобавитьКолонкуВДеревоЕслиНеНайдена(Узел, "_Отбор");
				НайденныеУзлы = УзелРезультата.Строки.НайтиСтроки(Новый Структура("_Отбор", Ложь), ВключатьПодчиненные);
			Иначе
				НайденныеУзлы = УзелРезультата.Строки.НайтиСтроки(Новый Структура("Код", ШагВыражения), ВключатьПодчиненные);
			КонецЕсли;
			
			МаксИндекс = НайденныеУзлы.Количество();
			Для Индекс = 1 По МаксИндекс Цикл
				ТекущийУзел = НайденныеУзлы[Индекс - 1];
				
				Если НЕ ВыбиратьЛюбойТип И ТипЗнч(ТекущийУзел) <> ТипДеревоЗначений Тогда
					Если ТекущийУзел.Тип = "А" ИЛИ ТекущийУзел.Тип = "A" Тогда
						Если НЕ ВыбиратьАтрибуты Тогда
							Продолжить;
						КонецЕсли;
					ИначеЕсли ВыбиратьАтрибуты Тогда
						Продолжить;
					КонецЕсли;
				КонецЕсли;
				
				Если НЕ УзелУдовлетворяетВыражениюПредиката(ТекущийУзел, МаксИндекс, Индекс, Предикат) Тогда
					Продолжить;
				КонецЕсли;
				
				НайденныйЭлемент = Результат.Найти(ТекущийУзел);
				Если НайденныйЭлемент <> Неопределено Тогда
					Результат.Удалить(НайденныйЭлемент);
				КонецЕсли;
				Результат.Добавить(ТекущийУзел);
			КонецЦикла;
		КонецЦикла;
		
		ПромРезультат.Очистить();
		Для Каждого ТекущийУзел Из Результат Цикл
			ПромРезультат.Добавить(ТекущийУзел);
		КонецЦикла;
		
		ВключатьПодчиненные = Ложь;
		РодительскийУзел    = Ложь;
		ВыбиратьАтрибуты    = Ложь;
		ВыбиратьЛюбойТип    = Ложь;
	КонецЦикла;
	
	Возврат Результат;

КонецФункции

Функция ПредикатЕслиНайден(ШагВыраженияXPath)
	
	Предикат = "";
	
	ПозицияОткр = СтрНайти(ШагВыраженияXPath, "[");
	Если ПозицияОткр > 0 Тогда
		ПозицияЗакр = СтрНайти(ШагВыраженияXPath, "]", , ПозицияОткр + 1);
		Если ПозицияЗакр > 0 Тогда
			Предикат = СокрЛП(Сред(ШагВыраженияXPath, ПозицияОткр + 1, ПозицияЗакр - ПозицияОткр - 1));
			ШагВыраженияXPath = Лев(ШагВыраженияXPath, ПозицияОткр - 1);
		Иначе
			Возврат "";
		КонецЕсли;
	КонецЕсли;
	
	Возврат Предикат;
	
КонецФункции

Функция УзелУдовлетворяетВыражениюПредиката(Узел, МаксИндекс, Индекс, Знач Предикат)
	
	Если НЕ ПустаяСтрока(Предикат) Тогда
		
		Если СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(Предикат) Тогда
			Возврат (Индекс = Число(" " + Предикат));
		КонецЕсли;
		
		Предикат = СтрЗаменить(Предикат, "!=", "<>");
		Предикат = СтрЗаменить(Предикат, "div", "/");
		Предикат = СтрЗаменить(Предикат, "mod", "%");
		Предикат = СтрЗаменить(Предикат, "'",  """");
		
		Атрибуты = Неопределено;
		Элементы = Неопределено;
		Если СтрНайти(Предикат, "()") > 0 Тогда
			Предикат = СтрЗаменить(Предикат, "last()", "МаксИндекс");
			Предикат = СтрЗаменить(Предикат, "position()", "Индекс");
		ИначеЕсли СтрНачинаетсяС(Предикат, "@") Тогда
			Предикат = Сред(Предикат, 2);
			ВсеЭлементыИАтрибутыУзла(Узел, Атрибуты);
		ИначеЕсли СтрНайти("0123456789", Лев(Предикат, 1)) = 0 Тогда
			Элементы = ВсеЭлементыИАтрибутыУзла(Узел);
		КонецЕсли;
		
		// Все функции Вычислить() вызываются в безопасном режиме.
		УстановитьБезопасныйРежим(Истина);
		Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
			МодульРаботаВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль("РаботаВМоделиСервиса");
			МассивРазделителей = МодульРаботаВМоделиСервиса.РазделителиКонфигурации();
		Иначе
			МассивРазделителей = Новый Массив;
		КонецЕсли;
		Для Каждого ИмяРазделителя Из МассивРазделителей Цикл
			УстановитьБезопасныйРежимРазделенияДанных(ИмяРазделителя, Истина);
		КонецЦикла;
		
		Попытка
			
			Если ТипЗнч(Атрибуты) = Тип("Соответствие") Тогда
				Если Предикат = "*" Тогда
					Возврат Истина;
				КонецЕсли;
				
				Для Каждого Атрибут Из Атрибуты Цикл
					Если СтрНайти(Предикат, Атрибут.Ключ) > 0 Тогда
						УзелАтрибут = Атрибут.Значение;
						Если НЕ ПустаяСтрока(УзелАтрибут.ЗначениеПоУмолчанию) Тогда
							ЗначениеАтрибута = Строка(УзелАтрибут.ЗначениеПоУмолчанию);
						Иначе
							ЗначениеАтрибута = Строка(УзелАтрибут.Значение);
						КонецЕсли;
						Результат = Вычислить(СтрЗаменить(Предикат, Атрибут.Ключ, """" + ЗначениеАтрибута + """")); // безопасный режим установлен ранее
						Если ТипЗнч(Результат) = Тип("Булево") Тогда
							Если Результат Тогда
								Возврат Истина;
							КонецЕсли;
						Иначе
							Если Результат = ЗначениеАтрибута Тогда
								Возврат Истина;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
				
				Возврат Ложь;
			КонецЕсли;
			
			Если ТипЗнч(Элементы) = Тип("ТаблицаЗначений") Тогда
				Если Предикат = "*" Тогда
					Возврат Истина;
				КонецЕсли;
				
				Для Каждого Элемент Из Элементы Цикл
					Если СтрНайти(Предикат, Элемент.Код) > 0 Тогда
						УзелЭлемент = Элемент.СтрокаДерева;
						Если НЕ ПустаяСтрока(УзелЭлемент.ЗначениеПоУмолчанию) Тогда
							ЗначениеЭлемента = ЧислоИзСтроки(УзелЭлемент.ЗначениеПоУмолчанию);
						Иначе
							ЗначениеЭлемента = ЧислоИзСтроки(УзелЭлемент.Значение);
						КонецЕсли;
						Результат = Вычислить(СтрЗаменить(Предикат, Элемент.Код, Формат(ЗначениеЭлемента, "ЧН=; ЧГ="))); // безопасный режим установлен ранее
						Если ТипЗнч(Результат) = Тип("Булево") Тогда
							Если Результат Тогда
								Возврат Истина;
							КонецЕсли;
						Иначе
							Если Результат = ЗначениеЭлемента Тогда
								Возврат Истина;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				КонецЦикла;
				
				Возврат Ложь;
			КонецЕсли;
			
			Результат = Вычислить(Предикат); // безопасный режим установлен ранее
			Если ТипЗнч(Результат) = Тип("Булево") Тогда
				Возврат Результат;
			Иначе
				Возврат Результат = Индекс;
			КонецЕсли;
			
		Исключение
			
			ОписаниеОшибки = ИнформацияОбОшибке().Описание;
			ОбщегоНазначения.СообщитьПользователю(
				СтрШаблон(НСтр("ru = 'Не удалось вычислить выражение XPath для дерева загрузки! %1'"), ОписаниеОшибки));
			ЗаписьЖурналаРегистрации(НСтр("ru = 'Загрузка данных регламентированного отчета'"),
				УровеньЖурналаРегистрации.Ошибка,,, ОписаниеОшибки);
				
			Возврат Ложь;
			
		КонецПопытки;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

Процедура ДобавитьКолонкуВДеревоЕслиНеНайдена(УзелДерева, ИмяКолонки, ОписаниеТиповКолонки = Неопределено)
	
	Перем Дерево;
	
	Если ТипЗнч(УзелДерева) = Тип("ДеревоЗначений") Тогда
		Дерево = УзелДерева;
	Иначе
		Дерево = УзелДерева.Владелец();
	КонецЕсли;
	
	Если Дерево.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
		Дерево.Колонки.Добавить(ИмяКолонки, ?(ОписаниеТиповКолонки = Неопределено, Новый ОписаниеТипов("Булево"), ОписаниеТиповКолонки));
	КонецЕсли;
	
КонецПроцедуры

// Выполняет произвольный алгоритм на встроенном языке 1С:Предприятия, предварительно устанавливая
//  безопасный режим выполнения кода и безопасный режим разделения данных для всех разделителей,
//  присутствующих в составе конфигурации. В результате при выполнении алгоритма:
//   - игнорируются попытки установки привилегированного режима,
//   - запрещаются все внешние (по отношению к платформе 1С:Предприятие) действия (COM,
//     загрузка внешних компонент, запуск внешних приложений и команд операционной системы,
//     доступ к файловой системе и Интернет-ресурсам),
//   - запрещается отключение использования разделителей сеанса,
//   - запрещается изменение значений разделителей сеанса (если разделение данным разделителем не
//     является условно выключенным),
//   - запрещается изменение объектов, которые управляют состоянием условного разделения.
//
// Параметры:
//  Алгоритм  - Строка       - содержащая произвольный алгоритм на встроенном языке 1С:Предприятия.
//  П         - Произвольный - в качестве значения данного параметра может быть передано значение,
//    которое требуется для выполнения алгоритма (при этом в тексте алгоритма обращение к данному
//    значению должно осуществляться как к имени переменной "П").
//
Процедура ВыполнитьАлгоритмВБезопасномРежиме(Знач Алгоритм, Знач П = Неопределено)
	
	УстановитьБезопасныйРежим(Истина);
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РаботаВМоделиСервиса") Тогда
		МодульРаботаВМоделиСервиса = ОбщегоНазначения.ОбщийМодуль("РаботаВМоделиСервиса");
		МассивРазделителей = МодульРаботаВМоделиСервиса.РазделителиКонфигурации();
	Иначе
		МассивРазделителей = Новый Массив;
	КонецЕсли;
	
	Для Каждого ИмяРазделителя Из МассивРазделителей Цикл
		
		УстановитьБезопасныйРежимРазделенияДанных(ИмяРазделителя, Истина);
		
	КонецЦикла;
	
	Выполнить Алгоритм;
	
КонецПроцедуры

// Записывает произвольные данные в текстовый файл формата XML или JSON.
//
// Параметры:
//  Данные    - Произвольный - структурированные данные любого типа;
//  ИмяФайла  - Строка       - содержит полный путь к создаваемому файлу;
//  ТипФайла  - Строка       - если содержит строку "xml", то будет произведена запись в формате XML,
//                             если содержит любое другое значение - в JSON.
//
Процедура ЗаписатьДанныеВXMLилиJSON(Данные, ИмяФайла, ТипФайла = "xml") Экспорт
	
	Если ВРег(ТипФайла) = "XML" Тогда
		
		ЗаписьXML = Новый ЗаписьXML;
		ЗаписьXML.ОткрытьФайл(ИмяФайла, "windows-1251");
		ЗаписьXML.ЗаписатьОбъявлениеXML();
		
		СериализаторXDTO.ЗаписатьXML(ЗаписьXML, Данные);
		
		ЗаписьXML.Закрыть();
		
	Иначе
		
		ПараметрыЗаписи = Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Авто, " ");
		
		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.ОткрытьФайл(ИмяФайла, "windows-1251", Истина, ПараметрыЗаписи);
		
		СериализаторXDTO.ЗаписатьJSON(ЗаписьJSON, Данные);
		
		ЗаписьJSON.Закрыть();
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти
