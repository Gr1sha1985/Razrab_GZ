#Область Описание
// Счета учета заполняются (перед отображением пользователю, при интерактивном редактировании 
// или перед записью), проверяются и отображаются (скрываются) на форме по единым правилам.
//
// Эти правила размещены в менеджерах документов.
// Модули документов не должны содержать прикладного кода (кроме кода правил), 
// который заполняет, проверяет или управляет отображением счетов.
// Для этого следует использовать процедуры программного интерфейса этого модуля.
//
// Для описания правил также используются методы этого модуля, размещенные в области Правила.
// Подробно структура правил описана в функции НовыйПравилаЗаполнения().
//
// Правила включают следующие артефакты:
// - Реквизиты документа и его табличных частей
// - Роли
// - Условия
// - Данные заполнения
//
// Правила могут быть иерархическими, подчиненными.
//
// Кроме того:
// - для заполнения счетов и проверки Условий используются разнообразные _Настройки_
// - некоторые роли схожи между собой, имеют одинаковый _МетодЗаполнения_
//
// Все эти артефакты описаны в коде этого модуля в области "ПрикладныеАлгоритмы".
// Их описание состоит в общем случае из двух частей:
// - декларативной (область "Объявления")
// - алгоритмов (остальные области внутри "ПрикладныеАлгоритмы")
//
// Таким образом, для расширения возможностей по заполнению счетов следует
// - объявить эти возможности (новые роли, условия и т.п.) в декларативной части
// - (если потребуется) в отдельных функциях описать алгоритмы.
// Для образца можно использовать примеры существующих возможностей.
//
// Далее об этих артефактах подробнее.
//
// РОЛИ
//
// Правилами может быть предусмотрено, что реквизит документа играет одну или несколько ролей 
// в контексте отражения документа в учете - скажем, может быть счетом запасов или выручки.
//
// Роль определяет то, как будет заполнен счет: по каким данным, настройкам,
// какое будет значение по умолчанию, какие требования к счету предъявляются.
// 
// Список доступных ролей можно узнать из функций 
// - МетодЗаполнения() 
// - тех, что вызываются из нее
// - ЗаполнитьРеквизит()
//
// Некоторые роли имеют смысл только при определенных значениях глобальных функциональных опций.
// Подробнее см. ФункцияВключена()
//
// НАСТРОЙКИ
// 
// Для того, чтобы получать данные о счетах оптимально, разделено
// - получение настроек 
// - собственно вычисление счета.
//
// Настройки могут определяться сразу для многих строк и использоваться разными правилами.
//
// Список используемых настроек содержится в НастройкиДляВыполненияПравила() и НастройкиДляПроверкиУсловия()
// Конкретные алгоритмы, которые получают настройки, вызываются из ДанныеНастройки().
//
// МЕТОДЫ ЗАПОЛНЕНИЯ
//
// Детальный алгоритм - как из настроек и данных заполнения вычисляется счет,
// какие значения используются по умолчанию - можно узнать, заглянув в ЗаполнитьРеквизит()
// и вызываемые из него методы.
//
// УСЛОВИЯ
//
// В разных обстоятельствах конкретный реквизит документа может иметь смысл или не иметь,
// может играть ту или иную роль.
// Это определяется Условиями. Они также указываются в правилах.
//
// Условия могут разрешать или запрещать применение конкретного правила.
// Например, если выполняется правило "ПлательщикНалогаНаПрибыль", то реквизит,
// предназначенный для особенностей учета расходов может требоваться ("разрешено") заполнить.
//
// Некоторые из условий типа "Разрешено" учитываются только при проверке заполнения, но не при заполнении.
// То есть, реквизит будет заполнен вне зависимости от выполнения условия, но если окажется не заполнен,
// то ничего страшного.
// Такие условия называются "Условие проверки заполнения".
//
// Для оптимальной проверки условий логика их проверки разделена на несколько уровней - 
// сначала проверяются те, что можно проверить просто, затем (если еще нужно) - которые сложнее.
//
// Поэтому список условий "размазан" по нескольким функциям, начинающимся с ПроверитьУсловие..., 
// и содержащим алгоритмы проверки.
//
// ИСХОДНЫЕ ДАННЫЕ
//
// Методы заполнения, вычисления настроек и проверки условий оперируют данными документа.
// 
// Те данные, которые будут использоваться для определения счета, также прописываются в правилах.
// Это могут быть 
// - данные шапки, общие для всего документа
// - значения реквизитов табличной части (влияют только на одну строку)
// - иные данные, вычисляемые для документа (скажем, итог по колонке документа).
//
// Данные могут использоваться как для непосредственного вычисления значений для заполнения,
// так и для предварительного определения конкретных Настроек и проверки Условий.
//
// Какие конкретно данные могут использоваться непосредственно для заполнения - см. ИсточникиДанныхПравила().
// Какие для вычисления настроек - в ИсточникиДанныхНастройки()
// Какие для проверки условий - в ИсточникиДанныхДляПроверкиУсловия() 
//
// ПРОВЕРКА КОРРЕКТНОСТИ
//
// Специально описывать проверку заполнения не требуется: 
// все реквизиты, которые исходя из правил должны быть заполнены, должны быть заполнены.
//
// Но иногда требуется особая, дополнительная проверка корректности (а не только полноты) 
// введенных значений.
//
// Такие проверки следует описать в ТребуетПроверкиКорректности() и ОшибкаЗаполнения()
// 
// 
#КонецОбласти

#Область ПрограммныйИнтерфейс

#Область Правила

// Конструктор правил заполнения счетов учета
//
// Параметры:
//  ДляПодготовкиМетаданных	 - Булево - Истина, если следует игнорировать настройки конкретной информационной базы.
//              Такая возможность нужна для целей разработки: подготовки генерируемого кода, составления полного описания и т.п.
// Возвращаемое значение:
//  Структура - пустая коллекция правил
Функция НовыйПравилаЗаполнения(ДляПодготовкиМетаданных = Ложь) Экспорт
	
	// Правила структура содежащая правила заполнения настроек и правила их получения
	Правила = Новый Структура;
	
	// В режиме ДляПодготовкиМетаданных игнорируются сведения информационной базы - значения функциональных опций
	Если ДляПодготовкиМетаданных Тогда
		Правила.Вставить("ДляПодготовкиМетаданных");
	КонецЕсли;
	
	// Служит для упрощения кода, который описывает правила заполнения конкретного документа.
	Правила.Вставить("ТекущаяСтрока",             Неопределено); // Неопределено или ссылка на строку из ПравилаЗаполнения
	Правила.Вставить("ТекущийВладелец",           Неопределено); // Неопределено или ссылка на строку из ПравилаЗаполнения
	
	// Ключ     - имя источника данных
	// Значение - Строка - имя реквизита, из которого выбирать данные.
	Правила.Вставить("РеквизитыДокумента",            Новый Структура);
	// Ключ     - имя источника данных
	// Значение - Массив - имена реквизитов, из которых выбирать промежуточные данные.
	// Промежуточные данные используются для вычисления дополнительных данных.
	// Дополнительные данные рассчитываются логикой документа в ДополнитьДанныеЗаполненияСчетовУчета().
	Правила.Вставить("ДополнительныеДанныеДокумента", Новый Структура); 
	
	// Правила заполнения - таблица содержащая описание описание того какие реквизиты нужно заполнять и как их нужно заполнять
	Правила.Вставить("ПравилаЗаполнения",         Новый ТаблицаЗначений);
	
	ТипИмени = ОбщегоНазначения.ОписаниеТипаСтрока(255);
	
	// Табличная часть - Строка с именем табличной части которой принадлежит заполняемый реквизит
	// Для шапки записывается пустая строка.
	Правила.ПравилаЗаполнения.Колонки.Добавить("ТабличнаяЧасть",            ТипИмени);
	
	// Имя реквизита, который нужно заполнить
	Правила.ПравилаЗаполнения.Колонки.Добавить("Реквизит",                  ТипИмени); 
	
	Правила.ПравилаЗаполнения.Колонки.Добавить("ПолноеИмяРеквизита",        Новый ОписаниеТипов("Строка")); //<ТабличнаяЧасть>.<Реквизит>
	
	// Роль описывает назначение реквизита; в частности по Роли будет определено, как именно следует заполнять реквизит
	Правила.ПравилаЗаполнения.Колонки.Добавить("Роль",                      ТипИмени); 
	
	// Правило следует выполнять при некоторых условиях.
	// В полях УсловияРазрешено и УсловияЗапрещено - перечни имен условий. 
	// Если все УсловияРазрешено выполняются, то правило будет выполнено.
	// Если хотя бы одно УсловияЗапрещено выполняется, то правило не будет выполнено.
	// Имена условий определены в ПроверитьУсловие*()
	Правила.ПравилаЗаполнения.Колонки.Добавить("УсловияРазрешено",          Новый ОписаниеТипов("Массив"));
	Правила.ПравилаЗаполнения.Колонки.Добавить("УсловияЗапрещено",          Новый ОписаниеТипов("Массив"));
	// УсловияПроверкиЗаполнения дополняют УсловияРазрешено в ходе проверки заполнения. 
	// Если хотя бы одно из условий проверки заполнения не выполняется, то проверка также не выполняется.
	Правила.ПравилаЗаполнения.Колонки.Добавить("УсловияПроверкиЗаполнения", Новый ОписаниеТипов("Массив"));
	
	// Колонка ИсточникиДанных хранит источники данных для заполнения.
	// В общем случае источниками данных могут быть
	// 1. реквизиты самого заполняемого объекта (например, строки табличной части)
	// 2. значения, переданные в процедуру заполнения в качестве параметра ДанныеЗаполнения
	//
	// Первые перечислены в свойстве РеквизитыОбъекта структуры ИсточникиДанных.
	// Ключ - роль источника данных, предусмотренная в ИсточникиДанныхНастройки(), значение - имя реквизита.
	// Вторые - в свойстве ДанныеЗаполнения. 
	// Ключ - так же роль источника данных, значение - имя свойства (ключ) из ДанныеЗаполнения.
	//
	// Таким образом, структура ИсточникиДанных всегда содержит два ключа - РеквизитыОбъекта и ДанныеЗаполнения.
	//
	// В ИсточникиДанных следует описать только нетривиальные источники:
	// 1. в РеквизитыОбъекта - случаи, когда источник данных - реквизит объекта 
	// 2. в ДанныеЗаполнения - случаи, когда для разных реквизитов с одной ролью 
	//    используются разные элементы из ДанныеЗаполнения.
	//    Например,
	//    - для СчетОтправителя - СкладОтправитель
	//    - для СчетПолучателя - СкладПолучатель.
	// Описывать для каждого правила, что из ДанныеЗаполнения в качестве Организации используется элемент "Организация" 
	// - избыточно.
	// Потому что, в отличие от заполняемого объекта, в ДанныеЗаполнения свойства имеют те имена,
	// которые предусмотрены в ИсточникиДанныхНастройки().
	//
	Правила.ПравилаЗаполнения.Колонки.Добавить("ИсточникиДанных",           Новый ОписаниеТипов("Структура"));
	
	// Используем индексы, а не ссылки на строки, для того, чтобы полагаться на автоматическое освобождение памяти по счетчику ссылок
	Правила.ПравилаЗаполнения.Колонки.Добавить("Владелец",                  Новый ОписаниеТипов("Число"));
	Правила.ПравилаЗаполнения.Колонки.Добавить("ЕстьПодчиненныеПравила",    Новый ОписаниеТипов("Булево"));
	
	Правила.ПравилаЗаполнения.Индексы.Добавить("Владелец");
	
	// Кеш общих значений используется при исполнении правил (в служебной части модуля).
	// В кеш могут быть помещены значения
	// - обращение к которым может требоваться при исполнении многих правил
	// - изменение которых маловероятно в течение времени жизни коллекции.
	// Для обращения к кешу следует использовать ОбщееЗначение()
	// Перечень общих значений см. в ОбщееЗначение()
	Правила.Вставить("КешОбщихЗначений", НовыйКешОбщихЗначений());
	
	Возврат Правила;
	
КонецФункции

// Позволяет описать правила заполнения.
// Добавляет правило заполнения в коллекцию правил.
// Следует вызывать из модулей менеджеров документов.
//
// Параметры:
//  Правила				 - см. НовыйПравилаЗаполнения()
//  ТабличнаяЧасть		 - Строка - Имя табличной части или пустая строка, если правило описывает реквизит шапки документа
//  Реквизит			 - Строка - Имя реквизита (без имени табличной части)
//  Роль				 - Строка - Роль реквизита в правиле. Подробнее см. область Описание
//  ЗаполнитьПоУмолчанию - Булево - заполнять свойства правила значениями по умолчанию. См. ДобавитьВПравилоПоУмолчанию
Процедура ДобавитьПравилоЗаполнения(Правила, ТабличнаяЧасть, Реквизит, Роль, ЗаполнитьПоУмолчанию = Истина) Экспорт
	
	Правила.ТекущийВладелец = Неопределено;
	
	Если Не Правила.Свойство("ДляПодготовкиМетаданных")
		И Не ФункцияВключена(Роль) Тогда
		Правила.ТекущаяСтрока = Неопределено;
		Возврат;
	КонецЕсли;
	
	Правило = Правила.ПравилаЗаполнения.Добавить();
	
	Правило.ТабличнаяЧасть     = ТабличнаяЧасть;
	Правило.Реквизит           = Реквизит;
	Правило.ПолноеИмяРеквизита = ОбщегоНазначенияБПКлиентСервер.ПолноеИмяРеквизита(Реквизит, ТабличнаяЧасть);
	Правило.Роль               = Роль;
	Правило.Владелец           = -1;
	
	Правило.ИсточникиДанных.Вставить("РеквизитыОбъекта", Новый Структура);
	Правило.ИсточникиДанных.Вставить("ДанныеЗаполнения", Новый Структура);
	
	Правила.ТекущаяСтрока = Правило;
	
	Если ЗаполнитьПоУмолчанию Тогда
		ДобавитьВПравилоПоУмолчанию(Правила, Роль);
	КонецЕсли;
	
КонецПроцедуры

// Позволяет описать правила заполнения.
// Добавляет подчиненное правило заполнения в коллекцию правил.
// Правило добавляется в подчинение предыдущему правилу, добавленному с помощью ДобавитьПравилоЗаполнения().
// Правило относится к реквизиту той же табличной части, что и родитель.
// Следует вызывать из модулей менеджеров документов.
//
// Параметры:
//  Правила				 - см. НовыйПравилаЗаполнения()
//  Реквизит			 - Строка - Имя реквизита (без имени табличной части). 
//  Роль				 - Строка - Роль реквизита в правиле. Подробнее см. область Описание
//  ЗаполнитьПоУмолчанию - Булево - заполнять свойства правила значениями по умолчанию. См. ДобавитьВПравилоПоУмолчанию
Процедура ДобавитьПодчиненноеПравилоЗаполнения(Правила, Реквизит, Роль, ЗаполнитьПоУмолчанию = Истина) Экспорт
	
	// Обычно в правилах не более двух уровней подчиненности, причем у одного владельца - несколько подчиненных.
	// Чтобы упростить описание правил, несколько вызовов ДобавитьПодчиненноеПравилоЗаполнения() подряд 
	// добавят несколько правил, подчиненных одному владельцу.
	// Чтобы прервать эту цепь подчинения, следует вызвать ДобавитьПравилоЗаполнения().
	// Если потребуется добавить еще один уровень подчиненности, то это следует сделать явно:
	// ДобавитьУровеньПодчиненности()
	//
	// Поэтому при вызове ДобавитьПодчиненноеПравилоЗаполнения()
	// - если ТекущийВладелец был заполнен, то ТекущийВладелец не изменится. 
	// - если был не заполнен (и заполнена текущая строка) - то ТекущийВладелец станет равным ТекущаяСтрока до изменения.
	
	Владелец = Правила.ТекущийВладелец;
	
	Если Владелец = Неопределено Тогда
		Владелец = Правила.ТекущаяСтрока;
	КонецЕсли;
	
	Если Владелец = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ТабличнаяЧасть = Владелец.ТабличнаяЧасть;
	ДобавитьПравилоЗаполнения(Правила, ТабличнаяЧасть, Реквизит, Роль, ЗаполнитьПоУмолчанию);
	
	Правила.ТекущийВладелец = Владелец;// После вызова ДобавитьПравилоЗаполнения, который очищает ТекущийВладелец
	
	// Подчиненное правило может оказаться отключенным функциональной опцией
	Если Правила.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	ПодчиненноеПравило = Правила.ТекущаяСтрока;
	
	// Унаследуем от родителя данные об источниках данных
	ПодчиненноеПравило.ИсточникиДанных = ОбщегоНазначенияКлиентСервер.СкопироватьРекурсивно(Владелец.ИсточникиДанных);
	
	// Свяжем правила друг с другом
	ПодчиненноеПравило.Владелец = Правила.ПравилаЗаполнения.Индекс(Владелец);
	Владелец.ЕстьПодчиненныеПравила = Истина;
	
КонецПроцедуры

// Позволяет описать правила заполнения.
// Позволяет добавить третий (четвертый и т.д.) уровень подчиненности.
// Следует использовать, когда нужно добавить правила, подчиненные к тем, что описаны с помощью ДобавитьПодчиненноеПравилоЗаполнения()
// После вызова этой процедуры все последующие вызовы ДобавитьПодчиненноеПравилоЗаполнения() будут добавлять правила,
// подчиненные тому, что описано с помощью вызова ДобавитьПодчиненноеПравилоЗаполнения(), 
// предшествовавшего вызову ДобавитьУровеньПодчиненности().
// Следует вызывать из модулей менеджеров документов.
//
// Параметры:
//  Правила	- см. НовыйПравилаЗаполнения()
Процедура ДобавитьУровеньПодчиненности(Правила) Экспорт
	
	Правила.ТекущийВладелец = Правила.ТекущаяСтрока;
	
КонецПроцедуры

// Позволяет описать правила заполнения.
// Позволяет описывать очень сложные, разветвленные правила для комплексных документов.
// Выполняет действие, обратное по отношению к ДобавитьУровеньПодчиненности()
// Следует вызывать из модулей менеджеров документов.
//
// Параметры:
//  Правила	- см. НовыйПравилаЗаполнения()
Процедура ВернутьсяНаПредыдущийУровеньПодчиненности(Правила) Экспорт
	
	Правила.ТекущийВладелец = ВладелецПравила(Правила.ТекущийВладелец);
	
КонецПроцедуры

// Позволяет детализировать правило заполнения счетов учета.
// Применяется к правилу, добавленному при предыдущем вызове ДобавитьПравилоЗаполнения()
// или ДобавитьПодчиненноеПравилоЗаполнения().
// Указывает на реквизит документа или его табличной части, данные которого следует использовать
// для выполнения правила.
// Такой источник данных следует описать
// - во всех случаях, когда используются данные строки табличной части
// - в случаях, когда невозможно использовать ДобавитьВПравилоОписаниеРеквизитаДокумента()
// Следует вызывать из модулей менеджеров документов.
//
// Параметры:
//  Правила	             - см. НовыйПравилаЗаполнения()
//  ИмяИсточника		 - Строка - Имя источника, как задано в модуле СчетаУчетаВДокументах
//  ИмяРеквизитаОбъекта	 - Строка - Имя реквизита объекта или табличной части (без имени табличной части)
Процедура ДобавитьВПравилоИсточникДанныхРеквизитОбъекта(Правила, ИмяИсточника, ИмяРеквизитаОбъекта) Экспорт
	
	Если Правила.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Правила.ТекущаяСтрока.ИсточникиДанных.РеквизитыОбъекта.Вставить(ИмяИсточника, ИмяРеквизитаОбъекта);
	
КонецПроцедуры

// Позволяет детализировать правило заполнения счетов учета.
// Применяется к правилу, добавленному при предыдущем вызове ДобавитьПравилоЗаполнения()
// или ДобавитьПодчиненноеПравилоЗаполнения().
// Указывает на источник данных, которые используются для выполнения правила, 
// объявленный с помощью ДобавитьВПравилоОписаниеРеквизитаДокумента().
// Такой источник данных следует описать, когда для разных правил 
// одноименные данные следует получать из разных реквизитов документа.
// Следует вызывать из модулей менеджеров документов.
//
// Параметры:
//  Правила	             - см. НовыйПравилаЗаполнения()
//  ИмяИсточника		 - Строка - Имя источника, как задано в модуле СчетаУчетаВДокументах
//  ИмяРеквизитаОбъекта	 - Строка - Имя данных, как задано в ДобавитьПодчиненноеПравилоЗаполнения()
Процедура ДобавитьВПравилоИсточникДанныхЗаполнения(Правила, ИмяИсточника, ИмяДанныхЗаполнения) Экспорт
	
	Если Правила.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Правила.ТекущаяСтрока.ИсточникиДанных.ДанныеЗаполнения.Вставить(ИмяИсточника, ИмяДанныхЗаполнения);
	
КонецПроцедуры

// Позволяет детализировать правило заполнения счетов учета.
// Применяется к правилу, добавленному при предыдущем вызове ДобавитьПравилоЗаполнения()
// или ДобавитьПодчиненноеПравилоЗаполнения().
// Ограничивает применение правила условием. 
// Правило будет применяться, когда выполняются все условия, заданные для правила
// с помощью ДобавитьВПравилоУсловиеРазрешено().
// Следует вызывать из модулей менеджеров документов.
//
// Параметры:
//  Правила	    - см. НовыйПравилаЗаполнения()
//  Условие		- Строка - Имя условия, как задано в модуле СчетаУчетаВДокументах
Процедура ДобавитьВПравилоУсловиеРазрешено(Правила, Условие) Экспорт
	
	Если Правила.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Правила.ТекущаяСтрока.УсловияРазрешено.Добавить(Условие);
	
КонецПроцедуры

// Позволяет детализировать правило заполнения счетов учета.
// Применяется к правилу, добавленному при предыдущем вызове ДобавитьПравилоЗаполнения()
// или ДобавитьПодчиненноеПравилоЗаполнения().
// Ограничивает применение правила условием. 
// Правило будет применяться, когда не выполняется ни одно из условий, заданных для правила
// с помощью ДобавитьВПравилоУсловиеЗапрещено()
// Следует вызывать из модулей менеджеров документов.
//
// Параметры:
//  Правила	    - см. НовыйПравилаЗаполнения()
//  Условие		- Строка - Имя условия, как задано в модуле СчетаУчетаВДокументах
Процедура ДобавитьВПравилоУсловиеЗапрещено(Правила, Условие) Экспорт
	
	Если Правила.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Правила.ТекущаяСтрока.УсловияЗапрещено.Добавить(Условие);
	
КонецПроцедуры

// Позволяет детализировать правило заполнения счетов учета.
// Применяется к правилу, добавленному при предыдущем вызове ДобавитьПравилоЗаполнения()
// или ДобавитьПодчиненноеПравилоЗаполнения().
// Ограничивает проверку заполнения документа условием.
// Проверка будет выполняться при проведении документа пользователем,
// который управляет счетами учета, когда выполняются все условия, заданные для правила
// с помощью ДобавитьВПравилоУсловиеПроверкиЗаполнения().
// На заполнение документа эта часть правила не влияет.
// Следует вызывать из модулей менеджеров документов.
//
// Параметры:
//  Правила	    - см. НовыйПравилаЗаполнения()
//  Условие		- Строка - Имя условия, как задано в модуле СчетаУчетаВДокументах
Процедура ДобавитьВПравилоУсловиеПроверкиЗаполнения(Правила, Условие) Экспорт
	
	Если Правила.ТекущаяСтрока = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Правила.ТекущаяСтрока.УсловияПроверкиЗаполнения.Добавить(Условие);
	
КонецПроцедуры

// Описывает контекст документа - реквизиты его шапки, которые используются для заполнения
// счетов в соответствии с одним или несколькими правилами.
// Следует вызывать из модулей менеджеров документов.
//
// Параметры:
//  Правила	           - см. НовыйПравилаЗаполнения()
//  ИмяИсточникаДанных - Строка - Имя источника данных, как задано в модуле СчетаУчетаВДокументах
//  ИмяРеквизита	   - Строка - Имя реквизита документа. Можно опустить, если совпадает с именем источника данных
Процедура ДобавитьВПравилоОписаниеРеквизитаДокумента(Правила, ИмяИсточникаДанных, ИмяРеквизита = "") Экспорт
	
	Если ПустаяСтрока(ИмяРеквизита) Тогда
		ИмяРеквизита = ИмяИсточникаДанных;
	КонецЕсли;
	
	Правила.РеквизитыДокумента.Вставить(ИмяИсточникаДанных, ИмяРеквизита);
	
КонецПроцедуры

// Описывает контекст документа - реквизиты его шапки, которые используются для заполнения
// счетов в соответствии с одним или несколькими правилами.
// Служит для описания данных, которые вычисляются из реквизитов шапки в контексте документа.
// Часто такие данные имеют тип Булево и служат для проверки условий.
// Если в документе для создания правил вызвана ДобавитьВПравилоОписаниеДополнительныхДанных(),
// то в модуле менеджера документа должна быть размещена процедура ДополнитьДанныеЗаполненияСчетовУчета().
// Эта процедура определяет значение дополнительных данных по значениям реквизитов.
// Следует вызывать из модулей менеджеров документов.
//
// Параметры:
//  Правила	           - см. НовыйПравилаЗаполнения()
//  ИмяИсточникаДанных - Строка - Имя источника данных, как задано в модуле СчетаУчетаВДокументах, или имя условия
//  ИменаРеквизитов	   - Строка - Имена реквизитов документа, значения которых позволяют определить значение данных.
Процедура ДобавитьВПравилоОписаниеДополнительныхДанных(Правила, ИмяИсточникаДанных, Знач ИменаРеквизитов) Экспорт
	
	ИменаРеквизитов = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаРеквизитов, , Истина, Истина);
	Правила.ДополнительныеДанныеДокумента.Вставить(ИмяИсточникаДанных, ИменаРеквизитов);
	
КонецПроцедуры

#КонецОбласти

#Область ЗаполнениеВФорме

// Заполняет счета во всем документе.
// Предназначена для контекстных вызовов из формы документа при изменении реквизитов, от которых зависят счета учета.
//
// Параметры:
//  ПараметрыЗаполнения	 - см. СчетаУчетаВДокументахКлиентСервер.НовыйПараметрыЗаполнения()
//                         Содержит, в том числе, данные формы, отображающие ДокументОбъект и перечень счетов, которые требуется заполнить.
// Возвращаемое значение:
// Структура - измененные реквизиты шапки документа
Функция ЗаполнитьОбъектПриИзменении(ПараметрыЗаполнения) Экспорт
	
	// Объект - ДокументОбъект или соответствующие данные формы
	// МенеджерОбъекта предоставляет правила заполнения и дополняет данные заполнения
	
	Если Не ПараметрыЗаполнения.Заполнять Тогда
		Возврат ИзмененныеЗначения();
	КонецЕсли;
	
	МенеджерОбъекта = Документы[ПараметрыЗаполнения.ИмяДокумента];
	
	ЗначенияДоИзменения = ЗначенияДоИзменения(ПараметрыЗаполнения.КЗаполнению, ПараметрыЗаполнения.ДанныеФормы.Объект, "");
	
	// Определим, какие правила нужно выполнять
	Отбор = Новый Структура;
	Отбор.Вставить("РеквизитыПолноеИмя", ПараметрыЗаполнения.КЗаполнению);
	
	// В простых формах документов могут быть доступны не все табличные части и реквизиты
	Отбор.Вставить("ДанныеФормы", ПараметрыЗаполнения.ДанныеФормы.Объект);
	
	// Заполним
	Правила = ПравилаЗаполнения(МенеджерОбъекта);
	ДанныеЗаполнения = ДанныеЗаполненияИзДокумента(МенеджерОбъекта, ПараметрыЗаполнения.ДанныеФормы.Объект, Правила);
	ЗаполнитьВсеКоллекции(ПараметрыЗаполнения.ДанныеФормы.Объект, Правила, ДанныеЗаполнения, Отбор);
	
	// Получим значения измененных реквизитов
	Возврат ИзмененныеЗначения(ЗначенияДоИзменения, ПараметрыЗаполнения.ДанныеФормы.Объект);
	
КонецФункции

// Определяет значения счетов в строке табличной части или шапке документа.
// Предназначена для неконтекстных вызовов в форме документа при изменении реквизитов, от которых зависят счета учета.
// Вызывать следует только тогда, когда известно, что заполнять - нужно.
//
// Параметры:
//  МенеджерДокумента			 - ДокументМенеджер - менеджер заполняемого документа. Должен соответствовать требованиям, описанным в ЗаполнениеВнеФормы
//  КЗаполнению					 - Соответствие - Содержит полные имена реквизитов, которые нужно заполнить
//  Контекст					 - Структура - содержит данные шапки заполняемого документа, необходимые для заполнения
//  ИмяТабличнойЧасти			 - Строка - имя заполняемой табличной части
//  ДанныеСтроки				 - Структура - содержит данные заполняемой строки табличной части, необходимые для заполнения
//  ВозвращатьТолькоИзмененные	 - Булево - позволяет 
// 		- при неконтекстных вызовах сократить данные, передаваемые с сервера
// 		- при контекстных - сократить время выполнения за счет отказа от вычисления измененных значений
// Возвращаемое значение:
//  Структура - измененные реквизиты; Ключ - имя реквизита (для табличных частей не включает имя табличной части!)
Функция ЗаполнитьРеквизитыПриИзменении(МенеджерДокумента, КЗаполнению, Контекст, ИмяТабличнойЧасти = "", ДанныеСтроки = Неопределено, ВозвращатьТолькоИзмененные = Истина) Экспорт
	
	// Определим, какие правила нужно выполнять
	Отбор = Новый Структура;
	Отбор.Вставить("РеквизитыПолноеИмя", КЗаполнению);
	Отбор.Вставить("ТабличнаяЧасть",     ИмяТабличнойЧасти);
	
	Если ДанныеСтроки = Неопределено Тогда
		ЭлементКоллекции = Контекст;
	Иначе
		ЭлементКоллекции = ДанныеСтроки;
	КонецЕсли;
	
	ЗначенияДоИзменения = ЗначенияДоИзменения(КЗаполнению, ЭлементКоллекции, ИмяТабличнойЧасти);
	
	// Заполним
	Коллекция = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ЭлементКоллекции);
	
	Правила = ПравилаЗаполнения(МенеджерДокумента);
	ДанныеЗаполнения = ДанныеЗаполненияИзДокумента(МенеджерДокумента, Контекст, Правила);
	ЗаполнитьКоллекцию(Коллекция, Правила, ДанныеЗаполнения, Отбор);
	
	// Получим значения измененных реквизитов
	Если ВозвращатьТолькоИзмененные Тогда
		Возврат ИзмененныеЗначения(ЗначенияДоИзменения, ЭлементКоллекции);
	Иначе
		ЗаполнитьЗначенияСвойств(ЗначенияДоИзменения, ЭлементКоллекции); // Теперь в ЗначенияДоИзменения - новые значения
		Возврат ЗначенияДоИзменения;
	КонецЕсли;
	
КонецФункции

// Заполняет все счета в строке документа.
// Предназначена для контекстных вызовов из формы документа при подборе и других массовых добавлениях строк.
//
// Параметры:
//  Строки				 - Массив, ТабличнаяЧасть - коллекция заполняемых строк
//  ИмяТабличнойЧасти    - Строка - Имя табличной части
//  Контекст			 - Структура - содержит данные шапки заполняемого документа, необходимые для заполнения
//  МенеджерОбъекта		 - ДокументМенеджер - менеджер заполняемого документа. Должен соответствовать требованиям, описанным в ЗаполнениеВнеФормы
//  ВключаяЗаполненные	 - Булево - следует ли обновлять (приводить в соответствие другим данным) значения уже заполненных реквизитов
Процедура ЗаполнитьСтроки(Строки, ИмяТабличнойЧасти, Контекст, МенеджерОбъекта, ВключаяЗаполненные = Ложь) Экспорт
	
	Если Не СчетаУчетаВДокументахВызовСервераПовтИсп.ПользовательУправляетСчетамиУчета() Тогда
		Возврат;
	КонецЕсли;
	
	Правила          = ПравилаЗаполнения(МенеджерОбъекта);
 	ДанныеЗаполнения = ДанныеЗаполненияИзДокумента(МенеджерОбъекта, Контекст, Правила);
	
	Отбор = Новый Структура;
	Отбор.Вставить("ТабличнаяЧасть",         ИмяТабличнойЧасти);
	Если Не ВключаяЗаполненные Тогда
		// Эта процедура вызывается из обработчиков, которые добавляют строки.
		// В них некоторые счета могут быть заполнены из документа-основания.
		// Поэтому по умолчанию обрабатываем только незаполненные реквизиты.
		Отбор.Вставить("НеЗаполненныеРеквизиты", Истина); 
	КонецЕсли;
	
	ЗаполнитьКоллекцию(Строки, Правила, ДанныеЗаполнения, Отбор);
	
КонецПроцедуры

#КонецОбласти

#Область ЗаполнениеВнеФормы

// В процедуры и функции этой области передается ДокументОбъект.
// Этот документ должен соответствовать требованиям:
// в его модуле менеджера объекта должны быть методы
// - УстановитьПравилаЗаполненияСчетовУчета()
// - ДополнитьДанныеЗаполненияСчетовУчета() 
//   (если предусмотрено правилами)

// Заполняет счета учета в документе, если исходя из настроек пользователя они не заполняются в форме документа.
// Следует вызывать из обработчика ПередЗаписью документа.
//
// Параметры:
//  Объект		 - ДокументОбъект - см. заголовок области
//  РежимЗаписи	 - РежимЗаписиДокумента; не заполняет счета при пометке на удаление
Процедура ЗаполнитьПередЗаписью(Объект, РежимЗаписи) Экспорт
	
	Если РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения Тогда
		Возврат;
	КонецЕсли;
	
	Если Не ЗаполнятьПередЗаписью(Объект.ДополнительныеСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	Отбор = Новый Структура;
	Отбор.Вставить("НеЗаполненныеРеквизиты", Истина);
	
	Заполнить(Объект, Отбор);
	
КонецПроцедуры

// Заполняет счета учета в документе, если исходя из настроек пользователя они заполняются в форме документа.
// Следует вызывать после интерактивных действий, которые приводят к перезаполнению всех данных документа,
// таких как ввод на основании.
//
// Параметры:
//  Объект - ДокументОбъект - см. заголовок области
Процедура ЗаполнитьПередОтображениемПользователю(Объект) Экспорт
	
	Если ЗаполнятьПередЗаписью(Объект.ДополнительныеСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	Отбор = Новый Структура;
	Отбор.Вставить("НеЗаполненныеРеквизиты", Истина);
	
	Заполнить(Объект, Отбор);
	
КонецПроцедуры

// Заполняет счета учета в документе.
// Условия заполнения можно определить гибко с помощью параметра Отбор.
//
// Параметры:
//  Объект	 - ДокументОбъект - см. заголовок области
//  Отбор	 - Структура - см. ПравилоСоответствуетОтбору()	
Процедура Заполнить(Объект, Отбор) Экспорт
	
	МенеджерОбъекта   = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Объект.Ссылка);
	Правила           = ПравилаЗаполнения(МенеджерОбъекта);
	ДанныеЗаполнения  = ДанныеЗаполненияИзДокумента(МенеджерОбъекта, Объект, Правила);
	
	УстановитьПривилегированныйРежим(Истина);
	
	ЗаполнитьВсеКоллекции(Объект, Правила, ДанныеЗаполнения, Отбор);
	
КонецПроцедуры

// Проверяет полноту и корректность заполнения счетов учета в документе.
//
// Параметры:
//  Объект				 - ДокументОбъект 
//  Отказ				 - Булево - Возвращаемый параметр, устанавливается в Истина, если выявлены ошибки
//  ПроверяемыеРеквизиты - Массив - Имена реквизитов, подлежащих проверке
//  РеквизитыЗаСсылками	 - Соответствие	- Ключ - Имя реквизита; Значение - имя поля на форме
//                         Описывает реквизиты, которые выводятся на форме, сгруппированными в одно поле
//                         (скрыты за ним).Как правило, такие "группировочные", "комплексные" поля представляют из себя ссылки.
//	Сообщения			 - Возвращаемый параметр, таблица сформированных сообщений проверки, 
//							см. ПроверкаЗаполненияДокументов.НовыйРезультатПроверки()
//	ВыводитьСообщения	 - Булево - Если Истина, то сформированные сообщения будут выведены пользователю.
//
// Возвращаемое значение:
//  Булево - Будут ли счета заполнены перед записью. 
//           Если будут (возвращено Истина), то после выполнения этой функции можно не выполнять проверки, 
//           результат которых может оказаться непонятным пользователю.
Функция ПроверитьЗаполнение(Объект, Отказ, ПроверяемыеРеквизиты, РеквизитыЗаСсылками = Неопределено, Сообщения = Неопределено, ВыводитьСообщения = Истина) Экспорт
	
	Если РеквизитыЗаСсылками = Неопределено Тогда
		РеквизитыЗаСсылками = Новый Соответствие;
	КонецЕсли;
		
	ЗаполнитьСчетаУчетаПередЗаписью = ЗаполнятьПередЗаписью(Объект.ДополнительныеСвойства);
	
	МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Объект.Ссылка);
	Правила         = ПравилаЗаполнения(МенеджерОбъекта);
	
	ПланыВыполнения = Неопределено;
	Если Не ЗаполнитьСчетаУчетаПередЗаписью Тогда
		ДанныеЗаполнения = ДанныеЗаполненияИзДокумента(МенеджерОбъекта, Объект, Правила);
		ПланыВыполнения  = ПланыВыполненияПравил(Правила, ДанныеЗаполнения, "ПроверкаЗаполнения", Объект);
	КонецЕсли;
	
	Реквизиты = Новый Соответствие; // Ключ - полное имя реквизита; значение - Булево: Истина - требуется проверка, Ложь - не требуется
	
	Если ТипЗнч(Сообщения) <> Тип("ТаблицаЗначений") Тогда
		Сообщения = ПроверкаЗаполненияДокументов.НовыйРезультатПроверки();
	КонецЕсли;
	
	Для Каждого Правило Из Правила.ПравилаЗаполнения Цикл
		
		Если ЗаполнитьСчетаУчетаПередЗаписью Тогда
			Реквизиты.Вставить(Правило.ПолноеИмяРеквизита, Ложь);
			Продолжить;
		КонецЕсли;
		
		Если Реквизиты[Правило.ПолноеИмяРеквизита] = Истина Тогда
			// У одного реквизита может быть несколько ролей
			Продолжить;
		КонецЕсли;
		
		Если ПроверяемыеРеквизиты.Найти(Правило.ПолноеИмяРеквизита) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		// Убедимся, что реквизит имеет смысл в данном контексте
		
		ИндексПравила  = Правила.ПравилаЗаполнения.Индекс(Правило);
		ПланВыполнения = ПланыВыполнения.Найти(ИндексПравила, "ИндексПравила");
		
		Если Не ПланВыполнения.СоответствуетКонтексту Или Не ПланВыполнения.СоответствуетОтбору Тогда
			Реквизиты.Вставить(Правило.ПолноеИмяРеквизита, Ложь);
			Продолжить;
		КонецЕсли;
		
		ТребуетПроверкиКорректности = ТребуетПроверкиКорректности(Правило, Правила.КешОбщихЗначений);
		
		Если Не ТребуетПроверкиКорректности
			И ПланВыполнения.ЭлементыНеСоответствуютКонтексту.Количество() = 0 Тогда
			// Подойдет стандартная проверка
			Реквизиты.Вставить(Правило.ПолноеИмяРеквизита, Истина);
			Продолжить;
		КонецЕсли;
				
		// Некоторые элементы проверять не надо.
		// Поэтому проверку следует выполнить для каждой строки отдельно,
		// а стандартную обработку - переопределить.
		
		Реквизиты.Вставить(Правило.ПолноеИмяРеквизита, Ложь);
		
		ПараметрыПроверкиЗначения = НовыйПараметрыЗаполненияРеквизита();
		// Модифицируемые и возвращаемые параметры не используются при проверке
		ПараметрыПроверкиЗначения.Правило           = Правило;
		ПараметрыПроверкиЗначения.ПланВыполнения    = ПланВыполнения;
		ПараметрыПроверкиЗначения.КешОбщихЗначений  = Правила.КешОбщихЗначений;
		// Параметры "Элемент" и "НастройкиЭлемента" определяются ниже - по-разному для коллекций разных типов
		
		Если ПустаяСтрока(Правило.ТабличнаяЧасть) Тогда
			
			ПараметрыПроверкиЗначения.Элемент           = Объект;
			ПараметрыПроверкиЗначения.НастройкиЭлемента = Новый Соответствие;
			
			ДополнитьНастройкиЭлемента(
				ПараметрыПроверкиЗначения.НастройкиЭлемента,
				0,
				ПланВыполнения.Настройки);
				
			ПроверитьЗначение(
				Объект[Правило.ПолноеИмяРеквизита],
				ПараметрыПроверкиЗначения,
				Сообщения,
				ТребуетПроверкиКорректности);
			
		Иначе
			
			Коллекция = Объект[Правило.ТабличнаяЧасть];
			
			Для ИндексЭлемента = 0 По Коллекция.Количество() - 1 Цикл
				
				Если Не ВыполнятьПравилоДляЭлементаКоллекции(ПланВыполнения, ИндексЭлемента) Тогда
					// Для этого элемента не надо проверять
					Продолжить;
				КонецЕсли;
				
				Элемент = Коллекция[ИндексЭлемента];
				
				ПараметрыПроверкиЗначения.Элемент           = Элемент;
				ПараметрыПроверкиЗначения.НастройкиЭлемента = Новый Соответствие;
				
				ДополнитьНастройкиЭлемента(
					ПараметрыПроверкиЗначения.НастройкиЭлемента,
					ИндексЭлемента,
					ПланВыполнения.Настройки);
				
				ПроверитьЗначение(
					Элемент[Правило.Реквизит],
					ПараметрыПроверкиЗначения,
					Сообщения,
					ТребуетПроверкиКорректности,
					Элемент.НомерСтроки);
					
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Если Сообщения.Количество() > 0 И ВыводитьСообщения Тогда
		ПроверкаЗаполненияДокументов.СообщитьРезультатПроверки(Сообщения, Отказ, Объект.Метаданные(), РеквизитыЗаСсылками);
	КонецЕсли;
	
	НеТребуютПроверки = Новый Массив;
	
	// Удалим проверенные и не требующие проверки реквизиты из ПроверяемыеРеквизиты
	Для Каждого ОписаниеРеквизита Из Реквизиты Цикл
		Если ОписаниеРеквизита.Значение <> Истина Тогда
			НеТребуютПроверки.Добавить(ОписаниеРеквизита.Ключ);
		КонецЕсли;
	КонецЦикла;
	
	ОбщегоНазначения.УдалитьНепроверяемыеРеквизитыИзМассива(ПроверяемыеРеквизиты, НеТребуютПроверки);
	
	Возврат ЗаполнитьСчетаУчетаПередЗаписью;// Для того, чтобы в модуле документа можно было отказаться от дополнительных проверок тех реквизитов, которые для пользователя могут оказаться непонятным
	
КонецФункции

#КонецОбласти

#Область НастройкаФормы

// Проверяет право пользователя на просмотр счетов учета.
// Если есть права на просмотр, то пользователь может включить или отключить отображение счетов.
// Если нет прав на просмотр, то такой возможности у него нет.
//
// Возвращаемое значение:
//  Булево - Истина, если есть право просмотра счетов.
//
Функция ПравоПросмотраСчетовУчета() Экспорт
	
	Возврат ПравоДоступа("Просмотр", Метаданные.ПланыСчетов.Хозрасчетный);
	
КонецФункции

// Устанавливает свойство Видимость у элементов формы документа, связанных со счетами учета.
// Предназначена для вызова из обработчика ПриСозданииНаСервере формы
//
// Параметры:
//  Элементы		 - ВсеЭлементыФормы - управляемые элементы
//  ЭлементыСчетов	 - Массив - Массив имен элементов формы, связанных со счетами
Процедура УстановитьВидимостьСчетовУчета(Элементы, ЭлементыСчетов) Экспорт
	
	ПользовательУправляетСчетамиУчета = СчетаУчетаВДокументахВызовСервераПовтИсп.ПользовательУправляетСчетамиУчета();
	
	Для Каждого ЭлементСчет Из ЭлементыСчетов Цикл
		Если Элементы.Найти(ЭлементСчет) <> Неопределено Тогда
			Элементы[ЭлементСчет].Видимость = ПользовательУправляетСчетамиУчета;
		КонецЕсли;
	КонецЦикла;
		
КонецПроцедуры

// Возвращает признак отображения колонки Субконто, если хоть в одной строке таблицы,
// есть субконто отличное от Номенклатурных групп
//
// Параметры:
//  Таблица			 - Табличная часть формы - Таблица, для которой устанавливается признак отображения колонки субконто.
// Возвращаемое значение:
//  Булево - 
Функция ОтобразитьСубконтоСчетаДоходов(Таблица) Экспорт
	
	ОтобразитьСубконтоСчетаДоходов = Ложь;
	Для Каждого СтрокаТаблицы Из Таблица Цикл
		// Если есть хоть одно субконто не Номенклатурные группы, то отображаем колонку Субконто
		Если ТипЗнч(СтрокаТаблицы.Субконто) <> Тип("СправочникСсылка.НоменклатурныеГруппы") Тогда
			ОтобразитьСубконтоСчетаДоходов = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Возврат ОтобразитьСубконтоСчетаДоходов;
	
КонецФункции

#КонецОбласти

#Область ПодготовкаМетаданных

// Представляет в реляционной форме связи между реквизитами,
// которые описаны в модуле менеджера документа в виде правил заполнения счетов учета.
//
// Параметры:
//  МенеджерОбъекта - ДокументМенеджер - должен соответствовать требованиям, описанным в заголовке области ЗаполнениеВнеФормы
// Возвращаемое значение:
//  ТаблицаЗначений - 
Функция СвязиРеквизитов(МенеджерОбъекта) Экспорт
	
	// Связи могут быть двух типов:
	// 1. между связанными правилами, например счетом выручки и субконто
	// 2. между счетом другим источником данных для его заполнения, например - счетом запасов и номенклатурой
	// Связь направлена от реквизита, который влияет на заполнение другого реквизита.
	// Т.е. в примерах выше счет выручки -> субконто и номенклатура -> счет запасов.
	
	ТипИмени = ОбщегоНазначения.ОписаниеТипаСтрока(255);
	
	Связи = Новый ТаблицаЗначений;
	Связи.Колонки.Добавить("Тип",                         ОбщегоНазначения.ОписаниеТипаСтрока(18)); // "ИсточникДанных" или "ПодчиненноеПравило"
	Связи.Колонки.Добавить("ТабличнаяЧастьИсточникСвязи", ТипИмени);
	Связи.Колонки.Добавить("ТабличнаяЧастьПриемникСвязи", ТипИмени);
	Связи.Колонки.Добавить("РеквизитИсточникСвязи",       ТипИмени);
	Связи.Колонки.Добавить("РеквизитПриемникСвязи",       ТипИмени); 
	
	МетаданныеДокумента = МенеджерОбъекта.ПустаяСсылка().Метаданные();
	
	Правила = ПравилаЗаполнения(МенеджерОбъекта, Истина);
	Для Каждого Правило Из Правила.ПравилаЗаполнения Цикл
		
		Владельцы = Новый Массив;
		Владелец = ВладелецПравила(Правило);
		Пока Владелец <> Неопределено Цикл
			Владельцы.Добавить(Владелец);
			Владелец = ВладелецПравила(Владелец);
		КонецЦикла;
		
		// Запишем связи между реквизитами исходя из связей между правилами
		КоличествоВладельцев = Владельцы.Количество();
		Для НомерСКонца = 1 По КоличествоВладельцев Цикл
			
			Индекс = КоличествоВладельцев - НомерСКонца;
			Владелец = Владельцы[Индекс];
			
			Связь = Связи.Добавить();
			Связь.Тип = "ПодчиненноеПравило";
			Связь.ТабличнаяЧастьИсточникСвязи = Владелец.ТабличнаяЧасть;
			Связь.РеквизитИсточникСвязи       = Владелец.Реквизит;
			Связь.ТабличнаяЧастьПриемникСвязи = Правило.ТабличнаяЧасть;
			Связь.РеквизитПриемникСвязи       = Правило.Реквизит;
			
		КонецЦикла;
		
		// Запишем связи между счетами и не-счетами
		ПравилоИВладельцы = ОбщегоНазначенияКлиентСервер.СкопироватьМассив(Владельцы);
		ПравилоИВладельцы.Добавить(Правило);
		
		ИсточникиДанных = ПотребныеИсточникиДанныхДокумента(ПравилоИВладельцы);
		
		Для Каждого ИсточникДанных Из ИсточникиДанных Цикл
			
			ИмяИсточникаДанных = ИсточникДанных.Ключ;
			
			// Источник может быть связанным с одним или несколькими реквизитами. 
			// Этот реквизит может быть как в шапке так и в табличной части,
			// иметь такое же имя, как источник или другое и т.п.
			
			// Определим имя реквизита
			Если Правило.ИсточникиДанных.РеквизитыОбъекта.Свойство(ИмяИсточникаДанных) Тогда
				
				// Это реквизит той коллекции, что задана в правиле
				
				ИмяРеквизита = Правило.ИсточникиДанных.РеквизитыОбъекта[ИмяИсточникаДанных];
				
				// Убедимся, что такой реквизит есть
				// Если реквизита нет, то получим исключение.
				Если ПустаяСтрока(Правило.ТабличнаяЧасть) Тогда
					МетаданныеРеквизита = МетаданныеДокумента.Реквизиты[ИмяРеквизита];
				Иначе
					МетаданныеРеквизита = МетаданныеДокумента.ТабличныеЧасти[Правило.ТабличнаяЧасть].Реквизиты[ИмяРеквизита];
				КонецЕсли;
				
				// Добавим описание связи
				Связь = Связи.Добавить();
				Связь.Тип = "ИсточникДанных";
				Связь.ТабличнаяЧастьИсточникСвязи = Правило.ТабличнаяЧасть;
				Связь.РеквизитИсточникСвязи       = ИмяРеквизита;
				Связь.ТабличнаяЧастьПриемникСвязи = Правило.ТабличнаяЧасть;
				Связь.РеквизитПриемникСвязи       = Правило.Реквизит;
				
			Иначе 
				
				// Это реквизит шапки
				
				Если Правило.ИсточникиДанных.ДанныеЗаполнения.Свойство(ИмяИсточникаДанных) Тогда
					ИмяДанныхЗаполнения = Правило.ИсточникиДанных.ДанныеЗаполнения[ИмяИсточникаДанных];
				Иначе
					ИмяДанныхЗаполнения = ИмяИсточникаДанных;
				КонецЕсли;
				
				Если Не Правила.РеквизитыДокумента.Свойство(ИмяДанныхЗаполнения) 
					И Не Правила.ДополнительныеДанныеДокумента.Свойство(ИмяДанныхЗаполнения) Тогда
					// Это может быть ошибкой в правиле. 
					// Но может и не быть - например, если источник данных одноименный с условием, но само условие определяется по другим данным
					Продолжить;
				КонецЕсли;
				
				ИменаРеквизитов = Новый Массив;
				Если Правила.РеквизитыДокумента.Свойство(ИмяДанныхЗаполнения) Тогда
					ИменаРеквизитов.Добавить(Правила.РеквизитыДокумента[ИмяДанныхЗаполнения]);
				КонецЕсли;
				// Источник данных может определяться значениями нескольких реквизитов
				Если Правила.ДополнительныеДанныеДокумента.Свойство(ИмяДанныхЗаполнения) Тогда
					Для Каждого ИмяРеквизита Из Правила.ДополнительныеДанныеДокумента[ИмяДанныхЗаполнения] Цикл
						ИменаРеквизитов.Добавить(ИмяРеквизита);
					КонецЦикла;
				КонецЕсли;
				
				Для Каждого ИмяРеквизита Из ИменаРеквизитов Цикл
					
					Если ИмяРеквизита <> "Дата" Тогда
						// Убедимся, что такой реквизит есть.
						// Если реквизита нет, то получим исключение.
						МетаданныеРеквизита = МетаданныеДокумента.Реквизиты[ИмяРеквизита];
					КонецЕсли;
					
					// Добавим описание связи
					Связь = Связи.Добавить();
					Связь.Тип = "ИсточникДанных";
					Связь.ТабличнаяЧастьИсточникСвязи = "";
					Связь.РеквизитИсточникСвязи       = ИмяРеквизита;
					Связь.ТабличнаяЧастьПриемникСвязи = Правило.ТабличнаяЧасть;
					Связь.РеквизитПриемникСвязи       = Правило.Реквизит;
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	// Так как одни и те же реквизиты используются для разных ролей,
	// то составление связей по правилам может привести к повторяющимя строкам в таблице связей.
	// Уберем повторяющиеся строки
	
	Отбор = Новый Структура;
	Для Каждого Колонка Из Связи.Колонки Цикл
		Отбор.Вставить(Колонка.Имя);
	КонецЦикла;
	
	// Просто свернуть недостаточно, так как важно сохранить порядок следования правил.
	
	КоличествоСтрок = Связи.Количество();
	Для НомерСКонца = 1 По КоличествоСтрок Цикл
		
		Индекс = КоличествоСтрок - НомерСКонца;
		Строка = Связи[Индекс];
		
		ЗаполнитьЗначенияСвойств(Отбор, Строка);
		
		Одинаковые = Связи.НайтиСтроки(Отбор);
		Если Одинаковые.Количество() > 1 Тогда
			Связи.Удалить(Строка);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Связи;
	
КонецФункции

// Формирует код функции, которая обеспечивает первый этап заполнения счетов учета при интерактивных действиях 
// в форме документа - измененеии реквизитов, от которых зависят счета.
// Эта функция
// - определяет список реквизитов-счетов, зависящих от значения измененных реквизитов
// - для режима, когда счета заполняются в форме, при вызова с клиента - готовит коллекции значений для безконтекстной передачи на сервер
// - для режима, когда счета не заполняются в форме, очищает зависимые счета, чтобы их значения были вычислены перед записью
//
// Параметры:
//  МенеджерОбъекта	 - ДокументМенеджер	 - должен соответствовать требованиям, описанным в заголовке области ЗаполнениеВнеФормы
// Возвращаемое значение:
//  Строка - код функции на встроенном языке 1С:Предприятие
Функция КодФункцииНачатьЗаполнениеСчетовУчета(МенеджерОбъекта) Экспорт
	
	Связи = СвязиРеквизитов(МенеджерОбъекта);
	
	Причины = Новый ТаблицаЗначений;
	Причины.Колонки.Добавить("ТабличнаяЧасть");
	Причины.Колонки.Добавить("Реквизит");
	Причины.Колонки.Добавить("ПолноеИмя");
	
	Для Каждого Связь Из Связи Цикл
		
		ПолноеИмя = ОбщегоНазначенияБПКлиентСервер.ПолноеИмяРеквизита(Связь.РеквизитИсточникСвязи, Связь.ТабличнаяЧастьИсточникСвязи);
		
		Отбор = Новый Структура("ПолноеИмя", ПолноеИмя);
		
		Если Причины.НайтиСтроки(Отбор).Количество() > 0 Тогда
			Продолжить;
		КонецЕсли;
		
		НоваяСтрока = Причины.Добавить();
		НоваяСтрока.ТабличнаяЧасть = Связь.ТабличнаяЧастьИсточникСвязи;
		НоваяСтрока.Реквизит       = Связь.РеквизитИсточникСвязи;
		НоваяСтрока.ПолноеИмя      = ПолноеИмя;
		
	КонецЦикла;
	
	Текст = Новый ТекстовыйДокумент;
	Текст.ДобавитьСтроку(
	"&НаКлиентеНаСервереБезКонтекста
	|Функция НачатьЗаполнениеСчетовУчета(ПричиныИзменения, Объект = Неопределено, СтрокаСписка = Неопределено, КонтейнерОбъект = Неопределено, КонтейнерСтрокаСписка = Неопределено)
	|
	|	// Код этой функции сформирован автоматически с помощью СчетаУчетаВДокументах.КодФункцииНачатьЗаполнениеСчетовУчета()
	|
	|	ПараметрыЗаполнения = СчетаУчетаВДокументахКлиентСервер.НовыйПараметрыЗаполнения(
	|		""" + МенеджерОбъекта.ПустаяСсылка().Метаданные().Имя + """,
	|		ПричиныИзменения,
	|		Объект,
	|		СтрокаСписка,
	|		КонтейнерОбъект,
	|		КонтейнерСтрокаСписка);
    |");
	
	// 1. Заполняемые реквизиты
	Текст.ДобавитьСтроку("	// 1. Заполняемые реквизиты");
	
	Для Каждого Причина Из Причины Цикл
		
		Текст.ДобавитьСтроку("	// " + Причина.ПолноеИмя);
		
		Текст.ДобавитьСтроку("	Если ПараметрыЗаполнения.ПричиныИзменения.Найти("""+Причина.ПолноеИмя+""") <> Неопределено Тогда");
		
		Обработанные = Новый Соответствие;
		
		Для Каждого ЗависимыйСчет Из Связи Цикл
			
			Если ЗависимыйСчет.ТабличнаяЧастьИсточникСвязи <> Причина.ТабличнаяЧасть
				Или ЗависимыйСчет.РеквизитИсточникСвязи <> Причина.Реквизит Тогда
				Продолжить;
			КонецЕсли;
			
			// Реквизит, который зависит от этой причины
			ПолноеИмяЗависимого = ОбщегоНазначенияБПКлиентСервер.ПолноеИмяРеквизита(
				ЗависимыйСчет.РеквизитПриемникСвязи,
				ЗависимыйСчет.ТабличнаяЧастьПриемникСвязи);
				
			Если Обработанные[ПолноеИмяЗависимого] <> Неопределено Тогда
				// Связи могут отличаться типом
				Продолжить;
			КонецЕсли;
				
			Обработанные.Вставить(ПолноеИмяЗависимого, Истина);
			
			Текст.ДобавитьСтроку("		СчетаУчетаВДокументахКлиентСервер.НачатьЗаполнениеРеквизита(ПараметрыЗаполнения, """+ПолноеИмяЗависимого+""");");
				
		КонецЦикла;
		
		Текст.ДобавитьСтроку("	КонецЕсли;");
		Текст.ДобавитьСтроку("");
		
	КонецЦикла;
	
	// Данные для заполнения
	Текст.ДобавитьСтроку("	// 2. (если требуется) Передадим на сервер данные, необходимые для заполнения");
	Текст.ДобавитьСтроку("	Если ПараметрыЗаполнения.Свойство(""Контейнер"") Тогда");
	
	Для Каждого Причина Из Причины Цикл
		
		Текст.ДобавитьСтроку("		// " + Причина.ПолноеИмя);
		
		Текст.ДобавитьСтроку("		Если ПараметрыЗаполнения.ПричиныИзменения.Найти("""+Причина.ПолноеИмя+""") <> Неопределено Тогда");
		
		ИсточникиДанных = Новый Соответствие;
		
		// Причина будет первой
		ДобавитьСтрокуДополнитьДанныеЗаполнения(
			Текст,
			Причина.Реквизит,
			Причина.ТабличнаяЧасть);
		ИсточникиДанных.Вставить(Причина.ПолноеИмя, Причина.ПолноеИмя);
		
		Для Каждого ЗависимыйСчет Из Связи Цикл
			
			Если ЗависимыйСчет.ТабличнаяЧастьИсточникСвязи <> Причина.ТабличнаяЧасть
				Или ЗависимыйСчет.РеквизитИсточникСвязи <> Причина.Реквизит Тогда
				Продолжить;
			КонецЕсли;
			
			// Сам заполняемый реквизит
			ПолноеИмяЗаполняемого = ОбщегоНазначенияБПКлиентСервер.ПолноеИмяРеквизита(
				ЗависимыйСчет.РеквизитПриемникСвязи,
				ЗависимыйСчет.ТабличнаяЧастьПриемникСвязи);
			
			Если ИсточникиДанных[ПолноеИмяЗаполняемого] = Неопределено Тогда
				ИсточникиДанных.Вставить(ПолноеИмяЗаполняемого, ПолноеИмяЗаполняемого);
				ДобавитьСтрокуДополнитьДанныеЗаполнения(
					Текст,
					ЗависимыйСчет.РеквизитПриемникСвязи,
					ЗависимыйСчет.ТабличнаяЧастьПриемникСвязи);
			КонецЕсли;
				
			Для Каждого ИсточникДанных Из Связи Цикл
				
				Если ИсточникДанных.ТабличнаяЧастьПриемникСвязи <> ЗависимыйСчет.ТабличнаяЧастьПриемникСвязи
					Или ИсточникДанных.РеквизитПриемникСвязи <> ЗависимыйСчет.РеквизитПриемникСвязи Тогда
					Продолжить;
				КонецЕсли;
				
				ПолноеИмяИсточникаДанных = ОбщегоНазначенияБПКлиентСервер.ПолноеИмяРеквизита(
					ИсточникДанных.РеквизитИсточникСвязи,
					ИсточникДанных.ТабличнаяЧастьИсточникСвязи);
				
				Если ИсточникиДанных[ПолноеИмяИсточникаДанных] <> Неопределено Тогда
					// Уже описали
					Продолжить;
				КонецЕсли;
				
				ИсточникиДанных.Вставить(ПолноеИмяИсточникаДанных, ПолноеИмяИсточникаДанных);
				
				ДобавитьСтрокуДополнитьДанныеЗаполнения(
					Текст,
					ИсточникДанных.РеквизитИсточникСвязи,
					ИсточникДанных.ТабличнаяЧастьИсточникСвязи);
				
			КонецЦикла;
			
		КонецЦикла;
		
		Текст.ДобавитьСтроку("		КонецЕсли;");
		Текст.ДобавитьСтроку("");
		
	КонецЦикла;
	
	Текст.ДобавитьСтроку(
	"	КонецЕсли; // Нужно передавать на сервер данные заполнения
	|	
	|	Возврат ПараметрыЗаполнения;
	|
	|КонецФункции");
	
	Возврат Текст.ПолучитьТекст();
	
КонецФункции

Процедура ДобавитьСтрокуДополнитьДанныеЗаполнения(Текст, Реквизит, ТабличнаяЧасть)
	
	Если ПустаяСтрока(ТабличнаяЧасть) Тогда
		ИмяЭлементаДанных = "Объект";
	Иначе
		ИмяЭлементаДанных = "Строка";
	КонецЕсли;
	
	Текст.ДобавитьСтроку("			СчетаУчетаВДокументахКлиентСервер.ДополнитьДанныеЗаполнения(ПараметрыЗаполнения, """+ИмяЭлементаДанных+""", """+Реквизит+""");");
	
КонецПроцедуры

// Формирует перечень реквизитов, заполнение которых описано в правилах заполнения.
//
// Параметры:
//  МенеджерОбъекта	 - ДокументМенеджер	 - должен соответствовать требованиям, описанным в заголовке области ЗаполнениеВнеФормы
// Возвращаемое значение:
//  Массив - полные имена реквизитов (включая имя табличной части)
Функция РеквизитыДокумента(ИмяДокумента) Экспорт
	
	Реквизиты = Новый Массив;
	
	Правила = ПравилаЗаполнения(Документы[ИмяДокумента], Истина);
	Для Каждого Правило Из Правила.ПравилаЗаполнения Цикл
		Если Реквизиты.Найти(Правило.ПолноеИмяРеквизита) = Неопределено Тогда
			Реквизиты.Добавить(Правило.ПолноеИмяРеквизита);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Реквизиты;
	
КонецФункции

#КонецОбласти

#Область УстаревшиеПроцедурыИФункции

// Устарела: Следует использовать ЗаполнитьПередЗаписью(), 
// ЗаполнитьПередОтображениемПользователю(), Заполнить(), 
// ЗаполнитьОбъектПриИзменении(), ЗаполнитьРеквизитыПриИзменении(),
// либо перед записью документа устанавливать дополнительное свойство 
// ЗаполнитьСчетаУчетаПередЗаписью
//
// Предназначена для вызова из устаревшего интерфейса документов - процедур 
// ЗаполнитьСчетаУчетаРасчетов(), ЗаполнитьСчетаСписанияНДСЗначениямиПоУмолчанию() 
//
// Параметры:
//  Объект			 - ДокументОбъект - должен соответствовать требования, описанным в области ЗаполнениеВнеФормы()
//  ИменаРеквизитов	 - Соответствие	- Ключ - полное имя реквизита; Значение - любое, кроме Неопределено
Процедура ЗаполнитьРеквизиты(Объект, ИменаРеквизитов) Экспорт
	
	Отбор = Новый Структура;
	Отбор.Вставить("РеквизитыПолноеИмя", ИменаРеквизитов);
	
	Заполнить(Объект, Отбор);
	
КонецПроцедуры

// Устарела: Следует использовать ЗаполнитьПередЗаписью(), 
// ЗаполнитьПередОтображениемПользователю(), Заполнить(), 
// ЗаполнитьОбъектПриИзменении(), ЗаполнитьСтроки(),
// либо перед записью документа устанавливать дополнительное свойство 
// ЗаполнитьСчетаУчетаПередЗаписью
//
// Предназначена для вызова из устаревшего интерфейса документов - процедуры 
// ЗаполнитьСчетаУчетаВТабличнойЧасти() 
//
// Параметры:
//  МенеджерОбъекта		 - Менеджер документа. Должен соответствовать требованиям, описанным в области ЗаполнениеВнеФормы()
//  Объект				 - ДокументОбъект или соответствующие данные формы
//  ИмяТабличнойЧасти	 - Строка
Процедура ЗаполнитьСчетаУчетаВТабличнойЧасти(Объект, ИмяТабличнойЧасти) Экспорт
	
	МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Объект.Ссылка);
	
	ЗаполнитьСтроки(Объект[ИмяТабличнойЧасти], ИмяТабличнойЧасти, Объект, МенеджерОбъекта, Истина);
	
КонецПроцедуры

// Устарела: Следует использовать ЗаполнитьПередЗаписью(), 
// ЗаполнитьПередОтображениемПользователю(), Заполнить(), 
// ЗаполнитьОбъектПриИзменении(), ЗаполнитьСтроки(),
// либо перед записью документа устанавливать дополнительное свойство 
// ЗаполнитьСчетаУчетаПередЗаписью
//
// Предназначена для вызова из устаревшего интерфейса документов - процедуры 
// ЗаполнитьСчетаУчетаВСтрокеТабличнойЧасти() 
//
// Параметры:
//  МенеджерОбъекта		 - Менеджер документа. Должен соответствовать требованиям, описанным в области ЗаполнениеВнеФормы()
//  Объект				 - ДокументОбъект или соответствующие данные формы
//  СтрокаТабличнойЧасти - ДокументОбъект.СтрокаТабличнойЧасти
//  ИмяТабличнойЧасти	 - Строка
Процедура ЗаполнитьСчетаУчетаВСтрокеТабличнойЧасти(Объект, СтрокаТабличнойЧасти, ИмяТабличнойЧасти) Экспорт
	
	МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Объект.Ссылка);
	
	ЗаполнитьСтроки(ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(СтрокаТабличнойЧасти), ИмяТабличнойЧасти, Объект, МенеджерОбъекта, Истина);
	
КонецПроцедуры

// Устарела: Следует использовать ЗаполнитьПередЗаписью(), 
// ЗаполнитьПередОтображениемПользователю(), Заполнить(), 
// ЗаполнитьОбъектПриИзменении(), ЗаполнитьРеквизитыПриИзменении(),
// либо перед записью документа устанавливать дополнительное свойство 
// ЗаполнитьСчетаУчетаПередЗаписью
//
// Предназначена для вызова из устаревшего интерфейса документов - процедур 
// ЗаполнитьСчетаУчетаРасчетов(), ЗаполнитьСчетаСписанияНДСЗначениямиПоУмолчанию() 
//
// Параметры:
//  Объект			 - ДокументОбъект - должен соответствовать требованиям, описанным в области ЗаполнениеВнеФормы()
Процедура ЗаполнитьСчетаУчетаРасчетов(Объект) Экспорт
	
	ИменаРеквизитов = Новый Соответствие;
	ИменаРеквизитов.Вставить("СчетУчетаРасчетовСКонтрагентом", Истина);
	ИменаРеквизитов.Вставить("СчетУчетаРасчетовПоАвансам",     Истина);
	ИменаРеквизитов.Вставить("СчетУчетаРасчетовПоТаре",        Истина);
	
	ЗаполнитьРеквизиты(Объект, ИменаРеквизитов);
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область ПрикладныеАлгоритмы

#Область Объявления

// В этом подразделе объявляются роли, настройки, условия, источники данных, которые можно использовать в правилах.
// Конкретные алгоритмы - заполнения, проверки условий и т.п. - могут размещаться в этом разделе, если они лаконичные.
// Громоздкие алгоритмы следует размещать в других подразделов области ПрикладныеАлгоритмы

Процедура ДобавитьВПравилоПоУмолчанию(Правила, Роль)
	
	Если Роль = "ПредъявленныйНДС_Запасы"
		Или Роль = "ПредъявленныйНДС_Расходы"
		Или Роль = "ПредъявленныйНДС_ОсновныеСредства"
		Или Роль = "ПредъявленныйНДС_ОбъектыСтроительства"
		Или Роль = "ПредъявленныйНДС_НематериальныеАктивы" Тогда
		
		ДобавитьВПравилоУсловиеПроверкиЗаполнения(Правила, "ЗаполненаСуммаНДС");
		ДобавитьВПравилоУсловиеПроверкиЗаполнения(Правила, "ПредъявленныйНДСУчитываетсяНаОтдельномСчете");
		
	КонецЕсли;

	Если Роль = "АвансыПокупателя" Или Роль = "АвансыПоставщику" Тогда
		СчетаУчетаВДокументах.ДобавитьВПравилоУсловиеРазрешено(Правила, "ЗачитыватьАвансы");
	КонецЕсли;
	
	Если Роль = "СпособУчетаНДСПредъявленного" Тогда
		
		ДобавитьВПравилоУсловиеПроверкиЗаполнения(Правила, "ЗаполненаСуммаНДС");
		ДобавитьВПравилоУсловиеПроверкиЗаполнения(Правила, "РаздельныйУчетНДСНаСчете19");
		
	КонецЕсли;
	
	Если Роль = "СпособУчетаНДСИспользованного" Тогда
		
		ДобавитьВПравилоУсловиеПроверкиЗаполнения(Правила, "РаздельныйУчетНДСНаСчете19");
		
	КонецЕсли;
	
	Если Роль = "СпособУчетаНДСпоОСиНМА" Тогда
		
		ДобавитьВПравилоУсловиеПроверкиЗаполнения(Правила, "ЗаполненаСуммаНДС");
		ДобавитьВПравилоУсловиеПроверкиЗаполнения(Правила, "РаздельныйУчетНДСНаСчете19");
		
	КонецЕсли;
	
	Если Роль = "ВыручкаНДС" Тогда
		
		ДобавитьВПравилоУсловиеПроверкиЗаполнения(Правила, "ЗаполненаСуммаНДС");
		
	КонецЕсли;
	
	Если Роль = "ЗатратыНДС" Тогда
		ДобавитьВПравилоУсловиеРазрешено(Правила, "РаздельныйУчетНДСДо2014Года");
	КонецЕсли;
	
	Если Роль = "ВозвратнаяТараПолученная" Или Роль = "ВозвратнаяТараПереданная" Тогда
		
		// Предполагается, что в документе есть табличная часть с именем "ВозвратнаяТара"
		ДобавитьВПравилоУсловиеПроверкиЗаполнения(Правила, "СписокЗаполнен");
		ДобавитьВПравилоИсточникДанныхЗаполнения(Правила, "Список", "ВозвратнаяТара");
		ДобавитьВПравилоОписаниеРеквизитаДокумента(Правила, "ВозвратнаяТара");
		
	КонецЕсли;
	
КонецПроцедуры

Функция ФункцияВключена(Роль)
	
	Если Роль = "ВозвратнаяТараПереданная" Или Роль = "ВозвратнаяТараПолученная" Или Роль = "ВозвратнаяТараНаСкладе" Тогда
		Возврат ПолучитьФункциональнуюОпцию("ИспользоватьВозвратнуюТару");
	КонецЕсли;
	
	Если Роль = "ТоварыПриобретенныеДляКомитента" 
		Или Роль = "РасчетыСКомитентомЗаПриобретенныеДляНегоТоварыУслуги" Тогда
		Возврат ПолучитьФункциональнуюОпцию("ОсуществляетсяЗакупкаТоваровУслугДляКомитентов");
	КонецЕсли;
	
	Если Роль = "ТоварыПринятыеНаКомиссию" Тогда
		Возврат ПолучитьФункциональнуюОпцию("ОсуществляетсяРеализацияТоваровУслугКомитентов");
	КонецЕсли;
	
	Если Роль = "ЗапасыОтгруженные" Тогда
		Возврат ПолучитьФункциональнуюОпцию("ВедетсяОтгрузкаБезПереходаПраваСобственности")
			Или ПолучитьФункциональнуюОпцию("ОсуществляетсяРеализацияТоваровУслугЧерезКомиссионеров");
	КонецЕсли;
	
	Если Роль = "ПодразделениеЗатрат" Тогда
		Возврат ПолучитьФункциональнуюОпцию("ВестиУчетЗатратПоПодразделениям");
	КонецЕсли;
	
	Если Роль = "ОбособленноеПодразделение" Тогда
		Возврат БухгалтерскийУчетПереопределяемый.ВестиУчетПоПодразделениям();
	КонецЕсли;
	
	Если ЭтоСубконтоРегистрацияВНалоговомОргане(Роль) Тогда
		Возврат БухгалтерскийУчетПереопределяемый.ВестиУчетПоПодразделениям();
	КонецЕсли;
	
	Если Роль = "ПредъявленныйНДС_ОсновныеСредства" 
		Или Роль = "ПредъявленныйНДС_ОбъектыСтроительства"
		Или Роль = "ВидДеятельностиРеализацияОсновныхСредств"
		Или Роль = "ОборудованиеНаСкладе"
		Или Роль = "ОбъектыСтроительства" Тогда
		Возврат ПолучитьФункциональнуюОпцию("ВедетсяУчетОсновныхСредств");
	КонецЕсли;
	
	Если Роль = "ПредъявленныйНДС_НематериальныеАктивы" Или Роль = "НематериальныеАктивы" Тогда
		Возврат ПолучитьФункциональнуюОпцию("ВедетсяУчетНМА");
	КонецЕсли;
	
	Если Роль = "МатериалыПринятыеВПереработку" 
		Или Роль = "МатериалыПринятыеВПереработкуВПроизводстве" Тогда
		Возврат ПолучитьФункциональнуюОпцию("ВедетсяПроизводственнаяДеятельность");
	КонецЕсли;
	
	Если Роль = "ЗапасыВЦенахПродажи" Тогда
		Возврат ПолучитьФункциональнуюОпцию("ВедетсяРозничнаяТорговля");
	КонецЕсли;
	
	Если Роль = "ПодразделениеБанковскогоСчета" Тогда
		Возврат ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоБанковскихСчетовОрганизации")
			И БухгалтерскийУчетПереопределяемый.ВестиУчетПоПодразделениям();
	КонецЕсли;
	
	Если ЭтоСубконтоСтатьяДвиженияДенежныхСредств(Роль) Тогда
		Возврат ПолучитьФункциональнуюОпцию("ИспользоватьСтатьиДвиженияДенежныхСредств");
	КонецЕсли;
	
	Возврат Истина; // Основная функциональность
	
КонецФункции


Функция МетодЗаполнения(Правило)
	
	Роль = Правило.Роль;
	
	Если Роль = "ЗапасыЗатраты" Тогда
		Возврат "ЗапасыЗатраты";
	ИначеЕсли РесурсНастройкиЗапасы(Роль) <> Неопределено Тогда
		Возврат "Запасы";
	ИначеЕсли Роль = "РасходыНаМалоценку" Тогда
		Возврат "РасходыНаМалоценку";
	ИначеЕсли РесурсНастройкиРасчеты(Роль) <> Неопределено Тогда
		Возврат "Расчеты";
	ИначеЕсли Роль = "АрендныеОбязательства" Или Роль = "ЛизинговыеПлатежи" Тогда
		Возврат "РасчетыПоЛизингу";
	ИначеЕсли Роль = "РасчетыПоФакторингу" Тогда
		Возврат "РасчетыПоФакторингу";
	ИначеЕсли РесурсНастройкиВыручка(Роль) <> Неопределено Тогда
		Возврат "Выручка";
	ИначеЕсли Роль = "ПредъявленныйНДС_Запасы" 
		Или Роль   = "ПредъявленныйНДС_Расходы" 
		Или Роль   = "ПредъявленныйНДС_ОсновныеСредства"
		Или Роль   = "ПредъявленныйНДС_ОбъектыСтроительства"
		Или Роль   = "ПредъявленныйНДС_НематериальныеАктивы" Тогда
		Возврат "ПредъявленныйНДС";
	ИначеЕсли Роль = "Затраты"
		Или Роль = "РасходыНаПродажу"
		Или Роль = "ИспользованиеМатериалов"
		Или Роль = "ПрочиеРасходы"
		Или Роль = "ЗатратыНаПроизводство"
		Или Роль = "РасходыУслугиБанка"
		Или Роль = "РасходыУслугиФакторинга"
		Или Роль = "ЗатратыНДС" Тогда
		Возврат "Затраты";
	ИначеЕсли Роль = "СубконтоЗатрат1" Или Роль = "СубконтоЗатрат2" Или Роль = "СубконтоЗатрат3" Тогда
		Возврат "СубконтоЗатрат";
	ИначеЕсли Роль = "ВидДеятельностиРеализацияОсновныхСредств" Тогда
		Возврат "ВидДеятельности";
	ИначеЕсли Роль = "НаличныеДеньги"
		Или Роль = "БезналичныеДеньги"
		Или Роль = "Инкассация"
		Или Роль = "ПереводыВПути"
		Или Роль = "Подотчет" Тогда
		Возврат "Деньги";
	ИначеЕсли Роль = "ПолученныеКредиты" Или Роль = "ПолученныеЗаймы" Тогда
		Возврат "ПолученныеКредитыЗаймы";
	ИначеЕсли ЭтоСубконтоСтатьяДвиженияДенежныхСредств(Роль) Тогда
		Возврат "СубконтоСтатьяДвиженияДенежныхСредств";
	ИначеЕсли Роль = "ПодразделениеЗатрат" 
		Или Роль = "ОбособленноеПодразделение" 
		Или Роль = "ПодразделениеБанковскогоСчета" Тогда
		Возврат "Подразделение";
	ИначеЕсли Роль = "СубконтоНалогов1" Или Роль = "СубконтоНалогов2" Или Роль = "СубконтоНалогов3" Тогда
		Возврат "СубконтоНалогов";
	ИначеЕсли ЭтоСубконтоРегистрацияВНалоговомОргане(Роль) Тогда
		Возврат "СубконтоРегистрацияВНалоговомОргане";
	Иначе
		Возврат Роль;
	КонецЕсли;
	
КонецФункции

Функция ИсточникиДанныхПравила(Правило)
	
	// Исключая данные, которые нужны настройкам
	
	ИсточникиДанных = Новый Массив;
	
	МетодЗаполнения = МетодЗаполнения(Правило);
	
	Если МетодЗаполнения = "Запасы"
	 Или МетодЗаполнения = "Затраты"
	 Или МетодЗаполнения = "КомандировочныеРасходы"
	 Или МетодЗаполнения = "СубконтоЗатрат"
	 Или МетодЗаполнения = "ЗапасыЗатраты"
	 Или МетодЗаполнения = "СодержаниеСлужебногоТранспорта" Тогда
		ИсточникиДанных.Добавить("Основание");
	КонецЕсли;
	
	Если МетодЗаполнения = "Подразделение" Тогда
		ИсточникиДанных.Добавить("Организация");
		Если Правило.Роль = "ПодразделениеБанковскогоСчета" Тогда
			ИсточникиДанных.Добавить("БанковскийСчет");
		Иначе
			ИсточникиДанных.Добавить("Подразделение");
		КонецЕсли;
	КонецЕсли;
	
	Если МетодЗаполнения = "СпособУчетаНДСПредъявленного" Тогда
		ИсточникиДанных.Добавить("ПредъявленСчетФактура");
	КонецЕсли;
	
	Если МетодЗаполнения = "Деньги" Тогда
		ИсточникиДанных.Добавить("ВалютаДокумента");
		ИсточникиДанных.Добавить("Основание");
		ИсточникиДанных.Добавить("ПриобретениеИностраннойВалюты");
		ИсточникиДанных.Добавить("БанковскийСчет");
	КонецЕсли;
	
	Если МетодЗаполнения = "ПриобретениеИностраннойВалюты" Тогда
		ИсточникиДанных.Добавить("ОтражатьРазницуВКурсеВСоставеОперационныхРасходов");
	КонецЕсли;
	
	Если МетодЗаполнения = "ПолученныеКредитыЗаймы" Тогда
		ИсточникиДанных.Добавить("ВалютаДокумента");
		ИсточникиДанных.Добавить("ВидПлатежаПоКредитамЗаймам");
	КонецЕсли;
	
	Если МетодЗаполнения = "СубконтоСтатьяДвиженияДенежныхСредств" Тогда
		ИсточникиДанных.Добавить("СтатьяДвиженияДенежныхСредств");
	КонецЕсли;
	
	Если МетодЗаполнения = "Налоги" Тогда
		ИсточникиДанных.Добавить("Налог");
	КонецЕсли;
	
	Если МетодЗаполнения = "СубконтоНалогов" Тогда
		ИсточникиДанных.Добавить("Налог");
		ИсточникиДанных.Добавить("ВидНалоговогоОбязательства");
	КонецЕсли;
	
	Если МетодЗаполнения = "СубконтоРегистрацияВНалоговомОргане" Тогда
		ИсточникиДанных.Добавить("Контрагент");
	КонецЕсли;
	
	Если МетодЗаполнения = "ОсновныеСредства" 
	 Или МетодЗаполнения = "ОсновныеСредстваАмортизация" Тогда
		ИсточникиДанных.Добавить("ОбъектыПредназначеныДляСдачиВАренду");
	КонецЕсли;
	
	Возврат ИсточникиДанных;
	
КонецФункции

Функция НастройкиДляЗаполнения(Правило)
	
	Настройки = Новый Массив;
	
	МетодЗаполнения = МетодЗаполнения(Правило);
	
	Если МетодЗаполнения = "Запасы" Тогда
		
		Настройки.Добавить("СчетаУчетаНоменклатуры");
		
	ИначеЕсли МетодЗаполнения = "ПредъявленныйНДС" Тогда
		
		ДобавитьНастройкуПоИсточникуДанных(Настройки, Правило);
		Если АналитикаЗатратОпределяетсяНоменклатуройУслуг(СвойствоВладельцаПравила(Правило, "Роль")) Тогда
			Настройки.Добавить("ЭтоУслуга");
		КонецЕсли;
		
	ИначеЕсли МетодЗаполнения = "СпособУчетаНДСПредъявленного" Тогда
		
		ДобавитьНастройкуПоИсточникуДанных(Настройки, Правило);
		
		// Фиктивная настройка - нужна только для настройки связей реквизитов в документе
		Настройки.Добавить("ВходящийДокумент");
		
	ИначеЕсли МетодЗаполнения = "СпособУчетаНДСИспользованного" Тогда
		
		Настройки.Добавить("СпособУчетаНДСИспользованного");
		
	ИначеЕсли МетодЗаполнения = "Затраты" Или МетодЗаполнения = "ЗапасыЗатраты" Тогда
		
		Если АналитикаЗатратОпределяетсяНоменклатуройУслуг(Правило.Роль) Тогда
			Настройки.Добавить("СчетаУчетаНоменклатуры");
			Настройки.Добавить("ЭтоУслуга");
		КонецЕсли;
		Настройки.Добавить("ОсновнойСчетЗатрат");
		
	ИначеЕсли МетодЗаполнения = "РасходыНаМалоценку" Тогда
		
		Настройки.Добавить("СчетаУчетаНоменклатуры");
		Настройки.Добавить("ПрименяетсяМалоценка");
		Настройки.Добавить("ОсновнойСчетЗатрат");
	
	ИначеЕсли МетодЗаполнения = "КомандировочныеРасходы" Тогда	
		
		Настройки.Добавить("ОсновнойСчетЗатрат");
		
		// Фиктивная настройка - нужна только для настройки связей реквизитов в документе
		Настройки.Добавить("ВходящийДокумент");
		
	ИначеЕсли МетодЗаполнения = "СодержаниеСлужебногоТранспорта" Тогда	
		
		Настройки.Добавить("ОсновнойСчетЗатрат");
		
	ИначеЕсли МетодЗаполнения = "СубконтоЗатрат" 
		Или МетодЗаполнения = "СтатьяЗатрат" Тогда
		
		РольВладельца = СвойствоВладельцаПравила(Правило, "Роль");
		Если АналитикаЗатратОпределяетсяНоменклатуройУслуг(РольВладельца) Тогда
			Настройки.Добавить("СчетаУчетаНоменклатуры");
			Настройки.Добавить("ЭтоУслуга");
		КонецЕсли;
		Если СтатьяЗатратОпределяетсяНоменклатуройЗапасов(РольВладельца) Тогда
			Настройки.Добавить("СтатьяЗатратНоменклатуры");
		КонецЕсли;
		Если РольВладельца = "ЗатратыНДС" Тогда
			Настройки.Добавить("СпециальныйРежимНалогообложения");
		КонецЕсли;
		
	ИначеЕсли МетодЗаполнения = "Выручка" Тогда
		
		Настройки.Добавить("СчетаУчетаНоменклатуры");
		Настройки.Добавить("СпециальныйРежимНалогообложения");
		
	ИначеЕсли МетодЗаполнения = "ВидДеятельности" Тогда
		
		Настройки.Добавить("ВидДеятельностиНоменклатуры");
		
	ИначеЕсли МетодЗаполнения = "Расчеты" Тогда
		
		Настройки.Добавить("СчетаРасчетов");
		Настройки.Добавить("УсловияРасчетов");
		Настройки.Добавить("ВидДоговора");
		
	ИначеЕсли МетодЗаполнения = "РасчетыПоЛизингу" Тогда
		
		Настройки.Добавить("УсловияРасчетов");
		
	ИначеЕсли МетодЗаполнения = "РасчетыПоФакторингу" Тогда
		
		Настройки.Добавить("УсловияРасчетов");
		
	ИначеЕсли МетодЗаполнения = "ОбъектыСтроительства" Тогда
		
		Настройки.Добавить("СчетаУчетаОбъектовСтроительства");
		
	ИначеЕсли МетодЗаполнения = "СубконтоНалогов" Тогда
		
		Настройки.Добавить("УровеньБюджета");
		
	ИначеЕсли МетодЗаполнения = "СубконтоРегистрацияВНалоговомОргане" Тогда
		
		Настройки.Добавить("РегистрацияВНалоговомОргане");
		
	ИначеЕсли МетодЗаполнения = "ПолученныеКредитыЗаймы" Тогда
		
		Настройки.Добавить("ДолгосрочныйДоговор");
		
	ИначеЕсли МетодЗаполнения = "СпособОтраженияРасходовПоАмортизации" Тогда
		
		Настройки.Добавить("СпособОтраженияРасходовПоАмортизации");
		
	КонецЕсли;
	
	Возврат Настройки;
	
КонецФункции
		
Функция НастройкиДляПроверкиЗаполнения(Правило)
	
	Настройки = Новый Массив;
	
	МетодЗаполнения = МетодЗаполнения(Правило);
	
	Если МетодЗаполнения = "Расчеты"
		Или МетодЗаполнения = "РасчетыПоЛизингу"
		Или МетодЗаполнения = "РасчетыПоФакторингу" Тогда
		
		Настройки.Добавить("УсловияРасчетов");
		
	КонецЕсли;
	
	Возврат Настройки;
	
КонецФункции
		
Функция ИсточникиДанныхНастройки(ИмяНастройки)
	
	ИсточникиДанных = Новый Структура; // Хранит только ключи - имена источников данных. Структура используется для оптимизации поиска.
	Если ИмяНастройки = "СчетаУчетаНоменклатуры" Тогда
		ИсточникиДанных.Вставить("Номенклатура");
		ИсточникиДанных.Вставить("Организация");
		ИсточникиДанных.Вставить("Склад");
		ИсточникиДанных.Вставить("ДокументОснование");
		ИсточникиДанных.Вставить("Дата");
	ИначеЕсли ИмяНастройки = "СпособУчетаНДСИспользованного" Тогда
		ИсточникиДанных.Вставить("НоменклатурнаяГруппа");
		ИсточникиДанных.Вставить("НоменклатурнаяГруппаСубконто1");
		ИсточникиДанных.Вставить("НоменклатурнаяГруппаСубконто2");
		ИсточникиДанных.Вставить("НоменклатурнаяГруппаСубконто3");
	ИначеЕсли ИмяНастройки = "ВидДоговора" Тогда
		ИсточникиДанных.Вставить("ВидДоговора");
		ИсточникиДанных.Вставить("ДоговорКонтрагента");
	ИначеЕсли ИмяНастройки = "УсловияРасчетов" Тогда
		ИсточникиДанных.Вставить("ДоговорКонтрагента");
	ИначеЕсли ИмяНастройки = "НалоговыйАгентПоНДС" Тогда
		ИсточникиДанных.Вставить("ДоговорКонтрагента");
	ИначеЕсли ИмяНастройки = "ДолгосрочныйДоговор" Тогда
		ИсточникиДанных.Вставить("ДоговорКонтрагента");
	ИначеЕсли ИмяНастройки = "ВидДеятельностиНоменклатуры" Тогда
		ИсточникиДанных.Вставить("Номенклатура");
	ИначеЕсли ИмяНастройки = "СтатьяЗатратНоменклатуры" Тогда
		ИсточникиДанных.Вставить("Номенклатура");
	ИначеЕсли ИмяНастройки = "ЭтоУслуга" Тогда
		ИсточникиДанных.Вставить("Номенклатура");
	ИначеЕсли ИмяНастройки = "СчетаРасчетов" Тогда
		ИсточникиДанных.Вставить("Организация");
		ИсточникиДанных.Вставить("Контрагент");
		ИсточникиДанных.Вставить("ДоговорКонтрагента");
	ИначеЕсли ИмяНастройки = "СчетаУчетаОбъектовСтроительства" Тогда
		ИсточникиДанных.Вставить("ОбъектСтроительства");
		ИсточникиДанных.Вставить("Организация");
	ИначеЕсли ИмяНастройки = "ТипСклада" Тогда
		ИсточникиДанных.Вставить("Склад");
		ИсточникиДанных.Вставить("ДокументОснование");
	ИначеЕсли ИмяНастройки = "СпециальныйРежимНалогообложения" Тогда
		ИсточникиДанных.Вставить("Организация");
		ИсточникиДанных.Вставить("Дата");
		ИсточникиДанных.Вставить("Склад");
		ИсточникиДанных.Вставить("ДокументОснование");
		ИсточникиДанных.Вставить("Номенклатура");
		ИсточникиДанных.Вставить("ДеятельностьНаПатенте");
	ИначеЕсли ИмяНастройки = "ЧужиеЗапасы" Тогда
		ИсточникиДанных.Вставить("СчетЗапасов");
	ИначеЕсли ИмяНастройки = "УровеньБюджета" Тогда
		ИсточникиДанных.Вставить("Налог");
	ИначеЕсли ИмяНастройки = "РегистрацияВНалоговомОргане" Тогда
		ИсточникиДанных.Вставить("Организация");
		ИсточникиДанных.Вставить("Контрагент");
		ИсточникиДанных.Вставить("КПППлательщика");
	ИначеЕсли ИмяНастройки = "СпособОтраженияРасходовПоАмортизации" Тогда
		ИсточникиДанных.Вставить("Организация");
		ИсточникиДанных.Вставить("Дата");
		ИсточникиДанных.Вставить("МестонахождениеОС");
	ИначеЕсли ИмяНастройки = "ВходящийДокумент" Тогда
		ИсточникиДанных.Вставить("ВходящийДокумент");
	ИначеЕсли ЭтоНастройкаУчетнойПолитики(ИмяНастройки) Тогда
		ИсточникиДанных.Вставить("Организация");
		ИсточникиДанных.Вставить("Дата");
	КонецЕсли;
	
	Возврат ИсточникиДанных;
	
КонецФункции


Функция ПроверитьУсловиеПоФункциональнымОпциям(Условие) // очередность, сложность - 0
	
	Если Условие = "СобственныеЗапасы" Тогда
		Если Не ПолучитьФункциональнуюОпцию("ОсуществляетсяЗакупкаТоваровУслугДляКомитентов")
			И Не ПолучитьФункциональнуюОпцию("ОсуществляетсяРеализацияТоваровУслугКомитентов")
			И Не ПолучитьФункциональнуюОпцию("ВедетсяПроизводственнаяДеятельность") Тогда // переработка
			Возврат Истина;
		Иначе
			Возврат Неопределено; // проверим еще
		КонецЕсли;
	ИначеЕсли Условие = "ЗачитыватьАвансы" Или Условие = "ПогашатьЗадолженность" Тогда
		Если Не ПолучитьФункциональнуюОпцию("УправлениеЗачетомАвансовПогашениемЗадолженности") Тогда
			Возврат Истина;
		Иначе
			Возврат Неопределено; // Проверим еще
		КонецЕсли;
	КонецЕсли;
	
	// Остальные функциональные опции проверяются однотипно:
	// если опция отключена, то условие заведомо не выполняется,
	// если включено, то еще непонятно, выполняется или нет.
	ИмяФункциональнойОпции = "";
	
	Если Условие = "ПриобретениеТоваровДляКомитента" Тогда
		ИмяФункциональнойОпции = "ОсуществляетсяЗакупкаТоваровУслугДляКомитентов";
	ИначеЕсли Условие = "ПродажаТоваровКомитента" Тогда
		ИмяФункциональнойОпции = "ОсуществляетсяРеализацияТоваровУслугКомитентов";
	ИначеЕсли Условие = "ОперацииСКомиссионером" Тогда
		ИмяФункциональнойОпции = "ОсуществляетсяРеализацияТоваровУслугЧерезКомиссионеров";
	ИначеЕсли Условие = "ТоварыВЦенахПродажи" 
		ИЛИ Условие = "ТоварыВЦенахПродажиНТТ" 
		ИЛИ Условие = "ТоварыВЦенахПродажиАТТ" Тогда
		ИмяФункциональнойОпции = "ВедетсяРозничнаяТорговля";
	ИначеЕсли Условие = "Номенклатура_ОбъектСтроительства" Тогда
		ИмяФункциональнойОпции = "ВедетсяУчетОсновныхСредств";
	ИначеЕсли Условие = "Номенклатура_НематериальныйАктив" Тогда
		ИмяФункциональнойОпции = "ВедетсяУчетНМА";
	ИначеЕсли Условие = "УслугиЛизинга" Тогда
		ИмяФункциональнойОпции = "ВедетсяУчетОсновныхСредств";
	ИначеЕсли Условие = "УслугиФакторинга" Тогда
		ИмяФункциональнойОпции = "ИспользоватьФакторинг";
	КонецЕсли;
	
	Если Не ПустаяСтрока(ИмяФункциональнойОпции) Тогда
		Если Не ПолучитьФункциональнуюОпцию(ИмяФункциональнойОпции) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

Функция ПроверитьУсловиеПоДаннымЗаполнения(ИмяУсловия, ДанныеЗаполнения) // очередность, сложность - 1
	
	// Возвращаемое значение имеет составной тип: Булево, Неопределено.
	// Неопределено возвращается, когда проверка условия на этом уровне не предусмотрена.
	// Если возвращено Неопределено то программа попытается проверить это условие по настройкам или данным коллекции.
	
	// ДанныеЗаполнения должны содержать все потребные ключи - см. ИсточникиДанныхДляПроверкиУсловия()
	
	Результат = ДанныеЗаполнения[ИмяУсловия]; // Результат мог быть передан в данных заполнения
	
	Если ТипЗнч(Результат) = Тип("Булево") Тогда
		Возврат Результат;
	КонецЕсли;
	
	// Результат проверки придется рассчитать (вычислить).
	
	Если ИмяУсловия = "ЗачитыватьАвансы" Тогда
		
		Возврат ДанныеЗаполнения.СпособЗачетаАвансов <> Перечисления.СпособыЗачетаАвансов.НеЗачитывать;
		
	ИначеЕсли ИмяУсловия = "СписокЗаполнен" Тогда
		
		Если ДанныеЗаполнения.Список = Неопределено Тогда
			Возврат Истина;
		Иначе
			Возврат ДанныеЗаполнения.Список.Количество() > 0;
		КонецЕсли;
		
	ИначеЕсли ИмяУсловия = "ПредъявленныйНДСУчитываетсяНаОтдельномСчете" Тогда
		
		Если ДанныеЗаполнения.НДСВключенВСтоимость = Истина Тогда
			// Даже включенный в стоимость НДС может учитываться на отдельном счете.
			// Для проверки этих исключений нужны настройки и данные строк.
			// Поэтому эти исключения проверяем в ПроверитьУсловиеПоНастройкам() и ПроверитьУсловиеПоКоллекции()
			Возврат Неопределено;
		Иначе
			Возврат Истина;
		КонецЕсли;
		
	ИначеЕсли ИмяУсловия = "ИспользоватьПереводыВПути" Тогда
		
		Возврат УчетнаяПолитика.ИспользоватьПереводыВПутиПриПеремещенияДенежныхСредств(ДанныеЗаполнения.Организация, ДанныеЗаполнения.Дата);
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

Функция ПроверитьУсловиеПоНастройкам(ИмяУсловия, ПланВыполнения, НастройкиЭлемента) // очередность, сложность - 2
	
	// Возвращаемое значение имеет составной тип: Булево, Неопределено.
	// Неопределено возвращается, когда проверка условия не предусмотрена.
	
	// Сверху процедуры нужно обеспечить, чтобы НастройкиЭлемента содержало все настройки, потребные для проверки условия.
	// См. НастройкиДляПроверкиУсловия()
	
	Если ИмяУсловия = "ПродажаТоваровКомитента" Тогда
		
		ВидДоговора = ДанныеНастройкиЭлементаКоллекции("ВидДоговора", ПланВыполнения, НастройкиЭлемента);
		Возврат ВидДоговора = Перечисления.ВидыДоговоровКонтрагентов.СКомитентом;
		
	ИначеЕсли ИмяУсловия = "ОперацииСКомиссионером" Тогда
		
		ВидДоговора = ДанныеНастройкиЭлементаКоллекции("ВидДоговора", ПланВыполнения, НастройкиЭлемента);
		Возврат ВидДоговора = Перечисления.ВидыДоговоровКонтрагентов.СКомиссионером 
			ИЛИ ВидДоговора = Перечисления.ВидыДоговоровКонтрагентов.СТранспортнойКомпанией;
		
	ИначеЕсли ИмяУсловия = "ДоговорСПокупателем" Тогда
		
		ВидДоговора = ДанныеНастройкиЭлементаКоллекции("ВидДоговора", ПланВыполнения, НастройкиЭлемента);
		Возврат ВидДоговора = Перечисления.ВидыДоговоровКонтрагентов.СПокупателем;
		
	ИначеЕсли ИмяУсловия = "ДоговорСПоставщиком" Тогда
		
		ВидДоговора = ДанныеНастройкиЭлементаКоллекции("ВидДоговора", ПланВыполнения, НастройкиЭлемента);
		Возврат ВидДоговора = Перечисления.ВидыДоговоровКонтрагентов.СПоставщиком;
		
	ИначеЕсли ИмяУсловия = "Услуги" Тогда 
		
		Возврат  ДанныеНастройкиЭлементаКоллекции("ЭтоУслуга", ПланВыполнения, НастройкиЭлемента);
		
	ИначеЕсли ИмяУсловия = "ТоварыВЦенахПродажи" Тогда
		
		ТипСклада = ДанныеНастройкиЭлементаКоллекции("ТипСклада", ПланВыполнения, НастройкиЭлемента);
		
		Если Не Справочники.Склады.ЭтоСкладРозничнойТорговли(ТипСклада) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		СпособОценкиТоваровВРознице = ДанныеНастройкиЭлементаКоллекции("СпособОценкиТоваровВРознице", ПланВыполнения, НастройкиЭлемента);
		
		Возврат СпособОценкиТоваровВРознице = Перечисления.СпособыОценкиТоваровВРознице.ПоПродажнойСтоимости;
		
	ИначеЕсли ИмяУсловия = "ТоварыВЦенахПродажиНТТ" Тогда
		
		ТипСклада = ДанныеНастройкиЭлементаКоллекции("ТипСклада", ПланВыполнения, НастройкиЭлемента);
		
		Если Не Справочники.Склады.ЭтоСкладРозничнойТорговли(ТипСклада) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		СпособОценкиТоваровВРознице = ДанныеНастройкиЭлементаКоллекции("СпособОценкиТоваровВРознице", ПланВыполнения, НастройкиЭлемента);
		
		Возврат СпособОценкиТоваровВРознице = Перечисления.СпособыОценкиТоваровВРознице.ПоПродажнойСтоимости 
			И ТипСклада = Перечисления.ТипыСкладов.НеавтоматизированнаяТорговаяТочка;
			
	ИначеЕсли ИмяУсловия = "ТоварыВЦенахПродажиАТТ" Тогда
		
		ТипСклада = ДанныеНастройкиЭлементаКоллекции("ТипСклада", ПланВыполнения, НастройкиЭлемента);
		
		Если Не Справочники.Склады.ЭтоСкладРозничнойТорговли(ТипСклада) Тогда
			Возврат Ложь;
		КонецЕсли;
		
		СпособОценкиТоваровВРознице = ДанныеНастройкиЭлементаКоллекции("СпособОценкиТоваровВРознице", ПланВыполнения, НастройкиЭлемента);
		
		Возврат СпособОценкиТоваровВРознице = Перечисления.СпособыОценкиТоваровВРознице.ПоПродажнойСтоимости 
			И ТипСклада = Перечисления.ТипыСкладов.РозничныйМагазин;
		
	ИначеЕсли ИмяУсловия = "ПредъявленныйНДСУчитываетсяНаОтдельномСчете" Тогда
		
		// Как правило, НДС учитывается на отдельном счете.
		// Исключение - это когда НДС включен в стоимость.
		// Выше - в ПроверитьУсловиеПоДаннымЗаполнения() - уже проверили, что имеем дело с исключением.
		//
		// Но даже в этих случаях НДС может учитываться на счете 19 в трех случаях:
		// 1. если на счете 19 ведется раздельный учет НДС
		// 2. если плательщик НДС отражает сумму НДС без счета-фактуры
		// 3. если организация - налоговый агент по НДС
		
		Если ДанныеНастройкиЭлементаКоллекции("РаздельныйУчетНДСНаСчете19", ПланВыполнения, НастройкиЭлемента) = Истина Тогда
			Возврат Истина;
		ИначеЕсли ДанныеНастройкиЭлементаКоллекции("НалоговыйАгентПоНДС", ПланВыполнения, НастройкиЭлемента) = Истина Тогда
			Возврат Истина;
		ИначеЕсли ДанныеНастройкиЭлементаКоллекции("ПлательщикНДС", ПланВыполнения, НастройкиЭлемента) = Истина Тогда
			Возврат Ложь;
		Иначе
			// Наличие счета-фактуры проверим в ПроверитьУсловиеПоКоллекции()
			Возврат Неопределено;
		КонецЕсли;
		
	ИначеЕсли ИмяУсловия = "СобственныеЗапасы" Тогда
		
		Возврат ДанныеНастройкиЭлементаКоллекции("ЧужиеЗапасы", ПланВыполнения, НастройкиЭлемента) = Ложь;
		
	ИначеЕсли ЭтоНастройкаУчетнойПолитики(ИмяУсловия) Тогда
		
		Возврат ДанныеНастройкиЭлементаКоллекции(ИмяУсловия, ПланВыполнения, НастройкиЭлемента) <> Ложь;
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

Функция ПроверитьУсловиеПоКоллекции(ИмяУсловия, Коллекция, ОписаниеРеквизитовКоллекции) // очередность, сложность - 3
	
	// Возвращаемое значение имеет составной тип: Булево, Массив, Неопределено.
	// - Неопределено возвращается, когда проверка условия не предусмотрена.
	// - Булево - результат проверки, если он одинаковый для всех строк коллекции.
	// - Массив содержит результаты проверки (Булево) для каждой строки коллекции.
	//   Связь коллекции и массива результатов - по индексу.
	
	// Не следует вызывать для пустых коллекций.
	
	Если ИмяУсловия = "ПриобретениеТоваровДляКомитента" Тогда
		
		Результат = ЗаполненРеквизитКоллекции(Коллекция, ОписаниеРеквизитовКоллекции, "Комитент");
		Если Результат = Неопределено Тогда
			Результат = Ложь;
		КонецЕсли;
		
	ИначеЕсли ИмяУсловия = "РасчетыПоПеням" Тогда
		
		Результат = Новый Массив;
		Для Каждого ЭлементКоллекции Из Коллекция Цикл
			Сделка = ЗначениеРеквизитаЭлементаКоллекции(ЭлементКоллекции, ОписаниеРеквизитовКоллекции, "Сделка");
			Результат.Добавить(ТипЗнч(Сделка) = Тип("ДокументСсылка.НачислениеПеней"));
		КонецЦикла;
		
	ИначеЕсли ИмяУсловия = "ЗаполненаСуммаНДС" Тогда
		
		Результат = ЗаполненРеквизитКоллекции(Коллекция, ОписаниеРеквизитовКоллекции, "СуммаНДС");
		
	ИначеЕсли ИмяУсловия = "ПредъявленныйНДСУчитываетсяНаОтдельномСчете" Тогда
		
		// Уже знаем, что организация - плательщик НДС и пользователь хочет включить НДС в стоимость.
		// Но сделать он это может только при наличии счета-фактуры.
		// Если счета-фактуры нет, то НДС будет отнесен в особом порядке на расходы, не принимаемые в целях налогообложения.
		// Это делается транзитом через счет 19. 
		// Поэтому предъявленный НДС требуется временно учесть на отдельном счете.
		
		Результат = Новый Массив;
		Для Каждого ЭлементКоллекции Из Коллекция Цикл
			ПредъявленСчетФактура = ЗначениеРеквизитаЭлементаКоллекции(ЭлементКоллекции, ОписаниеРеквизитовКоллекции, "ПредъявленСчетФактура");
			Результат.Добавить(ПредъявленСчетФактура = Ложь);
		КонецЦикла;
	
	ИначеЕсли ИмяУсловия = "Номенклатура_НематериальныйАктив" Тогда
		
		Результат = ПроверитьТипРеквизитаКоллекции(Коллекция, "Номенклатура", Тип("СправочникСсылка.НематериальныеАктивы"), ОписаниеРеквизитовКоллекции);
		
	ИначеЕсли ИмяУсловия = "Номенклатура_ОбъектСтроительства" Тогда
		
		Результат = ПроверитьТипРеквизитаКоллекции(Коллекция, "Номенклатура", Тип("СправочникСсылка.ОбъектыСтроительства"), ОписаниеРеквизитовКоллекции);
		
	ИначеЕсли ИмяУсловия = "ПогашатьЗадолженность" Тогда
		
		Результат = Новый Массив;
		Для Каждого ЭлементКоллекции Из Коллекция Цикл
			СпособПогашенияЗадолженности = ЗначениеРеквизитаЭлементаКоллекции(ЭлементКоллекции, ОписаниеРеквизитовКоллекции, "СпособПогашенияЗадолженности");
			Результат.Добавить(СпособПогашенияЗадолженности <> Перечисления.СпособыПогашенияЗадолженности.НеПогашать);
		КонецЦикла;
		
	ИначеЕсли ИмяУсловия = "ЗаполненБанковскийСчет" Тогда
		
		Результат = ЗаполненРеквизитКоллекции(Коллекция, ОписаниеРеквизитовКоллекции, "БанковскийСчет");
		
	ИначеЕсли ИмяУсловия = "ЗаполненаСумма" Тогда
		
		Результат = ЗаполненРеквизитКоллекции(Коллекция, ОписаниеРеквизитовКоллекции, "Сумма");
		
		
	ИначеЕсли ИмяУсловия = "ВидОбязательства_Кредит" Тогда
		
		Результат = Новый Массив;
		Для Каждого ЭлементКоллекции Из Коллекция Цикл
			ВидОбязательства = ЗначениеРеквизитаЭлементаКоллекции(ЭлементКоллекции, ОписаниеРеквизитовКоллекции, "ВидОбязательства");
			Результат.Добавить(ВидОбязательства = "Кредит");
		КонецЦикла;
		
		
	ИначеЕсли ИмяУсловия = "ВидОбязательства_Займ" Тогда
		
		Результат = Новый Массив;
		Для Каждого ЭлементКоллекции Из Коллекция Цикл
			ВидОбязательства = ЗначениеРеквизитаЭлементаКоллекции(ЭлементКоллекции, ОписаниеРеквизитовКоллекции, "ВидОбязательства");
			Результат.Добавить(ВидОбязательства = "Займ");
		КонецЦикла;
		
		
	ИначеЕсли ИмяУсловия = "ЕстьВДокументеПоступления" Тогда
		
		Результат = Новый Массив;
		Для Каждого ЭлементКоллекции Из Коллекция Цикл
			ЕстьВДокументеПоступления = ЗначениеРеквизитаЭлементаКоллекции(ЭлементКоллекции, ОписаниеРеквизитовКоллекции, "ЕстьВДокументеПоступления");
			Результат.Добавить(ЕстьВДокументеПоступления);
		КонецЦикла;
		
	Иначе
		
		Результат = Неопределено;
		
	КонецЕсли;
	
	Если ТипЗнч(Результат) = Тип("Массив") Тогда
		УникальныеРезультаты = Новый Массив;
		ОбщегоНазначенияКлиентСервер.ДополнитьМассив(УникальныеРезультаты, Результат, Истина);
		Если УникальныеРезультаты.Количество() = 1 Тогда
			Возврат УникальныеРезультаты[0];
		Иначе
			Возврат Результат;
		КонецЕсли;
	Иначе
		Возврат Результат;
	КонецЕсли;
	
КонецФункции


Функция НастройкиДляПроверкиУсловия(ИмяУсловия)
	
	Настройки = Новый Массив;
	
	Если ИмяУсловия = "ПродажаТоваровКомитента" 
		Или ИмяУсловия = "ОперацииСКомиссионером" 
		Или ИмяУсловия = "ДоговорСПокупателем" 
		Или ИмяУсловия = "ДоговорСПоставщиком" Тогда
		
		Настройки.Добавить("ВидДоговора");
		
	ИначеЕсли ИмяУсловия = "Услуги" Тогда 
		
		Настройки.Добавить("ЭтоУслуга");
		
	ИначеЕсли ИмяУсловия = "ТоварыВЦенахПродажи"
		ИЛИ ИмяУсловия = "ТоварыВЦенахПродажиНТТ"
		ИЛИ ИмяУсловия = "ТоварыВЦенахПродажиАТТ" Тогда
		
		Настройки.Добавить("ТипСклада");
		Настройки.Добавить("СпособОценкиТоваровВРознице");
		
	ИначеЕсли ИмяУсловия = "ПредъявленныйНДСУчитываетсяНаОтдельномСчете" Тогда
		
		Настройки.Добавить("РаздельныйУчетНДСНаСчете19");
		Настройки.Добавить("ПлательщикНДС");
		Настройки.Добавить("НалоговыйАгентПоНДС");
		
	ИначеЕсли ИмяУсловия = "СобственныеЗапасы" Тогда 
		// Это условие можно использовать только для проверки заполнения, так как оно опирается на значение другого заполняемого счета
		Настройки.Добавить("ЧужиеЗапасы");
		
	ИначеЕсли ЭтоНастройкаУчетнойПолитики(ИмяУсловия) Тогда
		
		Настройки.Добавить(ИмяУсловия);
		
	КонецЕсли;
	
	Возврат Настройки;
	
КонецФункции

Функция ИсточникиДанныхДляПроверкиУсловия(ИмяУсловия)
	
	ИсточникиДанных = Новый Структура; // Хранит только ключи - имена источников данных. Структура используется для оптимизации поиска.
	Если ИмяУсловия = "ЗачитыватьАвансы" Тогда
		ИсточникиДанных.Вставить("СпособЗачетаАвансов");
	ИначеЕсли ИмяУсловия = "ПогашатьЗадолженность" Тогда
		ИсточникиДанных.Вставить("СпособПогашенияЗадолженности");
	ИначеЕсли ИмяУсловия = "ПредъявленныйНДСУчитываетсяНаОтдельномСчете" Тогда
		ИсточникиДанных.Вставить("НДСВключенВСтоимость");
	ИначеЕсли ИмяУсловия = "СписокЗаполнен" Тогда
		ИсточникиДанных.Вставить("Список");
	ИначеЕсли ИмяУсловия = "ПриобретениеТоваровДляКомитента" Тогда
		ИсточникиДанных.Вставить("Комитент");
	ИначеЕсли ИмяУсловия = "ИспользоватьПереводыВПути" Тогда
		ИсточникиДанных.Вставить("Организация");
		ИсточникиДанных.Вставить("Дата");
	КонецЕсли;
	
	Возврат ИсточникиДанных;
	
КонецФункции


Функция ДанныеНастройки(ИмяНастройки, ПредметыНастройки)
	
	// Это функция-маршрутизатор.
	// Громоздкий прикладной код следует выносить в отдельные функции
	
	Если ИмяНастройки = "СчетаУчетаНоменклатуры" Тогда
		
		Возврат ДанныеНастройкиСчетаУчетаНоменклатуры(ПредметыНастройки);
		
	ИначеЕсли ИмяНастройки = "СпособУчетаНДСИспользованного" Тогда
		
		Возврат ДанныеНастройкиСпособУчетаНДСИспользованного(ПредметыНастройки);
		
	ИначеЕсли ИмяНастройки = "СчетаРасчетов" Тогда
		
		Возврат ДанныеНастройкиСчетаРасчетов(ПредметыНастройки);
		
	ИначеЕсли ИмяНастройки = "ВидДеятельностиНоменклатуры" Тогда
		
		Возврат ЗначенияРеквизитаПредметовНастройки(ПредметыНастройки, "Номенклатура", "НоменклатурнаяГруппа", Тип("СправочникСсылка.Номенклатура"));
		
	ИначеЕсли ИмяНастройки = "ЭтоУслуга" Тогда
		
		Возврат ЗначенияРеквизитаПредметовНастройки(ПредметыНастройки, "Номенклатура", "Услуга", Тип("СправочникСсылка.Номенклатура"));
		
	ИначеЕсли ИмяНастройки = "СтатьяЗатратНоменклатуры" Тогда
		
		Возврат ЗначенияРеквизитаПредметовНастройки(ПредметыНастройки, "Номенклатура", "СтатьяЗатрат", Тип("СправочникСсылка.Номенклатура"));
		
	ИначеЕсли ИмяНастройки = "ВидДоговора" Тогда
		
		Возврат ДанныеНастройкиВидДоговора(ПредметыНастройки);
		
	ИначеЕсли ИмяНастройки = "ДолгосрочныйДоговор" Тогда
		
		Возврат ДанныеНастройкиДолгосрочныйДоговор(ПредметыНастройки);
		
	ИначеЕсли ИмяНастройки = "НалоговыйАгентПоНДС" Тогда
		
		Возврат ЗначенияРеквизитаПредметовНастройки(ПредметыНастройки, "ДоговорКонтрагента", "УчетАгентскогоНДС", Тип("СправочникСсылка.ДоговорыКонтрагентов"));
		
	ИначеЕсли ИмяНастройки = "УсловияРасчетов" Тогда
		
		Возврат ДанныеНастройкиУсловияРасчетов(ПредметыНастройки);
		
	ИначеЕсли ИмяНастройки = "СчетаУчетаОбъектовСтроительства" Тогда
		
		Возврат ДанныеНастройкиСчетаУчетаОбъектовСтроительства(ПредметыНастройки);
		
	ИначеЕсли ИмяНастройки = "ТипСклада" Тогда
		
		Если ОпределятьСкладПоДокументуОснованию(ПредметыНастройки[0].Склад, ПредметыНастройки[0].ДокументОснование) Тогда
			Возврат ЗначенияРеквизитаПредметовНастройки(ПредметыНастройки, "ДокументОснование", "Склад.ТипСклада", ТипЗнч(ПредметыНастройки[0].ДокументОснование));
		Иначе
			Возврат ЗначенияРеквизитаПредметовНастройки(ПредметыНастройки, "Склад",             "ТипСклада",       Тип("СправочникСсылка.Склады"));
		КонецЕсли;
		
	ИначеЕсли ИмяНастройки = "СпециальныйРежимНалогообложения" Тогда
		
		Возврат ДанныеНастройкиСпециальныйРежимНалогообложения(ПредметыНастройки);
		
	ИначеЕсли ИмяНастройки = "ЧужиеЗапасы" Тогда
		
		Возврат ЗначенияРеквизитаПредметовНастройки(ПредметыНастройки, "СчетЗапасов", "Забалансовый", Тип("ПланСчетовСсылка.Хозрасчетный"));
		
	ИначеЕсли ИмяНастройки = "УровеньБюджета" Тогда
		
		Возврат ДанныеНастройкиУровеньБюджета(ПредметыНастройки);
		
	ИначеЕсли ИмяНастройки = "СпособОтраженияРасходовПоАмортизации" Тогда
		
		Возврат ДанныеНастройкиСпособОтраженияРасходовПоАмортизации(ПредметыНастройки);
		
	ИначеЕсли ИмяНастройки = "РегистрацияВНалоговомОргане" Тогда
		
		Возврат ДанныеНастройкиРегистрацияВНалоговомОргане(ПредметыНастройки);
		
	ИначеЕсли ЭтоНастройкаУчетнойПолитики(ИмяНастройки) Тогда
		
		Возврат ДанныеНастройкиУчетнойПолитики(ИмяНастройки, ПредметыНастройки);
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

// Параметры - см. НовыйПараметрыЗаполненияРеквизита()
Процедура ЗаполнитьРеквизит(Параметры)
	
	// Это функция-маршрутизатор.
	// Громоздкий прикладной код следует выносить в отдельные процедуры
	
	МетодЗаполнения = МетодЗаполнения(Параметры.Правило);
	
	Если МетодЗаполнения = "Запасы" Тогда
		
		ЗаполнитьЗапасы(Параметры);
		
	ИначеЕсли МетодЗаполнения = "ПредъявленныйНДС" Тогда
		
		ЗаполнитьПредъявленныйНДС(Параметры);
		
	ИначеЕсли МетодЗаполнения = "СпособУчетаНДСПредъявленного" Тогда
		
		ЗаполнитьСпособУчетаНДСПредъявленного(Параметры);
		
	ИначеЕсли МетодЗаполнения = "СпособУчетаНДСИспользованного" Тогда
		
		Параметры.ЗначениеПоУмолчанию = Перечисления.СпособыУчетаНДС.ПринимаетсяКВычету;
		Параметры.Значение            = ДанныеНастройкиЭлементаКоллекции("СпособУчетаНДСИспользованного", Параметры);
		
	ИначеЕсли МетодЗаполнения = "СпособУчетаНДСпоОСиНМА" Тогда
		
		Параметры.Значение = Перечисления.СпособыУчетаНДС.Распределяется;
		
	ИначеЕсли МетодЗаполнения = "Затраты" 
		Или МетодЗаполнения = "КомандировочныеРасходы"
		Или МетодЗаполнения = "СодержаниеСлужебногоТранспорта" Тогда
		
		ЗаполнитьЗатраты(Параметры);
		
	ИначеЕсли МетодЗаполнения = "РасходыНаМалоценку" Тогда
		
		ЗаполнитьРасходыНаМалоценку(Параметры);
		
	ИначеЕсли МетодЗаполнения = "ЗапасыЗатраты" Тогда
		
		ЗаполнитьЗапасыЗатраты(Параметры);
		
	ИначеЕсли МетодЗаполнения = "СубконтоЗатрат" Тогда
		
		ЗаполнитьСубконтоЗатрат(Параметры);
		
	ИначеЕсли МетодЗаполнения = "СтатьяЗатрат" Тогда
		
		ЗаполнитьЗначениеСубконтоСтатьяЗатрат(Параметры);
		
	ИначеЕсли МетодЗаполнения = "НоменклатурнаяГруппа" Тогда
		
		ЗаполнитьЗначениеСубконтоНоменклатурнаяГруппа(Параметры);
		
	ИначеЕсли МетодЗаполнения = "Подразделение" Тогда
		
		ЗаполнитьПодразделение(Параметры);
		
	ИначеЕсли МетодЗаполнения = "Выручка" Тогда

		ЗаполнитьВыручка(Параметры);
		
	ИначеЕсли МетодЗаполнения = "ВидДеятельности" Тогда

		ЗаполнитьВидДеятельности(Параметры);
		
	ИначеЕсли МетодЗаполнения = "Расчеты" Тогда

		ЗаполнитьРасчеты(Параметры);
		
	ИначеЕсли МетодЗаполнения = "РасчетыПоЛизингу" Тогда

		ЗаполнитьРасчетыПоЛизингу(Параметры);
		
	ИначеЕсли МетодЗаполнения = "РасчетыПоФакторингу" Тогда

		ЗаполнитьРасчетыПоФакторингу(Параметры);

	ИначеЕсли МетодЗаполнения = "ОбъектыСтроительства" Тогда

		ЗаполнитьПоОбъектамСтроительства(Параметры);
		
	ИначеЕсли МетодЗаполнения = "Деньги" Тогда
		
		ЗаполнитьДеньги(Параметры);
		
	ИначеЕсли МетодЗаполнения = "ПриобретениеИностраннойВалюты" Тогда
		
		Если Параметры.ПланВыполнения.ДанныеЗаполнения.ОтражатьРазницуВКурсеВСоставеОперационныхРасходов = Ложь Тогда
			Параметры.Значение = ПланыСчетов.Хозрасчетный.ПрочиеРасчетыСРазнымиДебиторамиИКредиторами;
		Иначе
			Параметры.Значение = ПланыСчетов.Хозрасчетный.ПриобретениеИностраннойВалюты;
		КонецЕсли;
		
	ИначеЕсли МетодЗаполнения = "ПредоставленныеЗаймы" Тогда
		
		Параметры.Значение = ПланыСчетов.Хозрасчетный.ПредоставленныеЗаймы;
		
	ИначеЕсли МетодЗаполнения = "ПолученныеКредитыЗаймы" Тогда
		
		ЗаполнитьПолученныеКредитыЗаймы(Параметры);
		
	ИначеЕсли МетодЗаполнения = "РеализацияИностраннойВалюты" Тогда
		
		Параметры.Значение = ПланыСчетов.Хозрасчетный.РеализацияИностраннойВалюты;
		
	ИначеЕсли МетодЗаполнения = "ПродажиПоПлатежнымКартам" Тогда
		
		Параметры.Значение = ПланыСчетов.Хозрасчетный.ПродажиПоПлатежнымКартам;
		
	ИначеЕсли МетодЗаполнения = "СубконтоСтатьяДвиженияДенежныхСредств" Тогда
		
		ЗаполнитьСубконтоСтатьяДвиженияДенежныхСредств(Параметры);
		
	ИначеЕсли МетодЗаполнения = "Налоги" Тогда
		
		ЗаполнитьНалоги(Параметры);
		
	ИначеЕсли МетодЗаполнения = "СубконтоНалогов" Тогда
		
		ЗаполнитьСубконтоНалогов(Параметры);
		
	ИначеЕсли МетодЗаполнения = "СубконтоРегистрацияВНалоговомОргане" Тогда
		
		ЗаполнитьСубконтоРегистрацияВНалоговомОргане(Параметры);
		
	ИначеЕсли МетодЗаполнения = "ОсновныеСредства" Тогда
		
		Если Параметры.ПланВыполнения.ДанныеЗаполнения.ОбъектыПредназначеныДляСдачиВАренду = Ложь Тогда
			Параметры.Значение = ПланыСчетов.Хозрасчетный.ОСвОрганизации;
		Иначе
			Параметры.Значение = ПланыСчетов.Хозрасчетный.МЦвОрганизации;
		КонецЕсли;
		
	ИначеЕсли МетодЗаполнения = "ОсновныеСредстваАмортизация" Тогда
		
		Если Параметры.ПланВыполнения.ДанныеЗаполнения.ОбъектыПредназначеныДляСдачиВАренду = Ложь Тогда
			Параметры.Значение = ПланыСчетов.Хозрасчетный.АмортизацияОС_01;
		Иначе
			Параметры.Значение = ПланыСчетов.Хозрасчетный.АмортизацияОС_03;
		КонецЕсли;
		
	ИначеЕсли МетодЗаполнения = "СпособОтраженияРасходовПоАмортизации" Тогда
		
		ЗаполнитьСпособОтраженияРасходовПоАмортизации(Параметры);
		
	Иначе
		
		Параметры.ЗначениеПоУмолчанию = ПланыСчетов.Хозрасчетный.ОсновнойСчет(Параметры.Правило.Роль);
		
		Если Не ЗаполнитьПоОснованию(Параметры) Тогда
			Параметры.Значение = Параметры.ЗначениеПоУмолчанию;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Функция ТребуетПроверкиКорректности(Правило, КешОбщихЗначений = Неопределено)
	
	Если ТребованиеБалансовостиСчетаЗапасов(Правило.Роль) <> Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПроверятьСоответствиеВидовДеятельности(Правило) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПроверятьСоответствиеСчетаВалютеДоговора(Правило, КешОбщихЗначений) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПроверятьСпособУчетаНДС(Правило) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если ПроверятьСпособУчетаНДС(Правило) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Функция ОшибкаЗаполнения(ПараметрыПроверкиЗаполнения)
	
	Значение = ПараметрыПроверкиЗаполнения.Элемент[ПараметрыПроверкиЗаполнения.Правило.Реквизит];
	
	Если Не ЗначениеЗаполнено(Значение) Тогда
		Возврат "";
	КонецЕсли;
	
	ТребованиеБалансовостиСчета = ТребованиеБалансовостиСчетаЗапасов(ПараметрыПроверкиЗаполнения.Правило.Роль);
	Если ТребованиеБалансовостиСчета <> Неопределено Тогда
		Если ТребованиеБалансовостиСчета И Значение.Забалансовый Тогда
			Возврат НСтр("ru = 'Следует указать балансовый счет.'");
		ИначеЕсли Не ТребованиеБалансовостиСчета И Не Значение.Забалансовый Тогда
			Возврат НСтр("ru = 'Следует указать забалансовый счет.'");
		КонецЕсли;
	КонецЕсли;
	
	Ошибка = ОшибкаЗаполненияВыручки(ПараметрыПроверкиЗаполнения);
	Если Не ПустаяСтрока(Ошибка) Тогда
		Возврат Ошибка;
	КонецЕсли;
	
	Ошибка = ОшибкаСоответствияСчетаВалютеДоговора(ПараметрыПроверкиЗаполнения);
	Если Не ПустаяСтрока(Ошибка) Тогда
		Возврат Ошибка;
	КонецЕсли;
	
	Ошибка = ОшибкаЗаполненияСпособУчетаНДС(ПараметрыПроверкиЗаполнения);
	Если Не ПустаяСтрока(Ошибка) Тогда
		Возврат Ошибка;
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

#КонецОбласти

#Область СчетаУчетаНоменклатуры

Функция ДанныеНастройкиСчетаУчетаНоменклатуры(ПредметыНастройки)
	
	Результат = НовыйДанныеНастройки(ПредметыНастройки);
	
	// Счета можно оптимально получать для списка номенклатуры
	КлючевоеПоле     = "Номенклатура";
	ТипКлючевогоПоля = Тип("СправочникСсылка.Номенклатура");
	Кластеры         = РазбитьНаКластеры(ПредметыНастройки, Новый Структура(КлючевоеПоле));
	
	Пока ВыбратьСледующийКластер(Кластеры) Цикл
		
		КлючКластера   = Кластеры.КлючКластера;
		ДанныеКластера = Кластеры.ДанныеКластера;
		
		Если Не ПроверитьСтандартныеТипы(КлючКластера, "Дата, Организация") Тогда
			Продолжить;
		КонецЕсли;
		
		// Склад может быть определен по документу основанию
		Если ОпределятьСкладПоДокументуОснованию(КлючКластера.Склад,  КлючКластера.ДокументОснование) Тогда
			Склад = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(КлючКластера.ДокументОснование, "Склад");
		Иначе
			Склад = КлючКластера.Склад;
		КонецЕсли;
		
		Номенклатура = ВыгрузитьЗначения(ДанныеКластера, КлючевоеПоле, ТипКлючевогоПоля);
			
		НастройкиПоКлючу = БухгалтерскийУчетПереопределяемый.ПолучитьСчетаУчетаСпискаНоменклатуры(
			КлючКластера.Организация,
			Номенклатура,
			Склад,
			КлючКластера.Дата,
			Неопределено); // Отключаем режим совместимости
			
		ДополнитьМассивНастроекЭлементамиСоответствияПоПростомуКлючу(
			Результат,
			НастройкиПоКлючу,
			КлючевоеПоле,
			ПредметыНастройки,
			ДанныеКластера);
			
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ОпределятьСкладПоДокументуОснованию(Склад, ДокументОснование)
	
	Возврат Склад = Неопределено
		И ДокументОснование <> Неопределено
		И Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(ДокументОснование))
		И ДокументОснование.Метаданные().Реквизиты.Найти("Склад") <> Неопределено;
		
КонецФункции


Функция НастройкиПоИсточникуДанных()
	
	НастройкиПоИсточникуДанных = Новый Массив;
	НастройкиПоИсточникуДанных.Добавить("СчетаУчетаНоменклатуры"); // По умолчанию. Она будет использоваться, если имя источника не задано явно в ИсточникиДанных.РеквизитыОбъекта
	НастройкиПоИсточникуДанных.Добавить("СчетаУчетаОбъектовСтроительства");
	
	Возврат НастройкиПоИсточникуДанных;
	
КонецФункции

Функция НастройкаПоИсточникуДанных(Параметры)
	
	НастройкиПоИсточникуДанных = НастройкиПоИсточникуДанных();
	Для Каждого ИмяНастройки Из НастройкиПоИсточникуДанных Цикл
	
		Если КоллекцияСодержитРеквизитыДляНастройки(ИмяНастройки, Параметры.Правило.ИсточникиДанных.РеквизитыОбъекта) Тогда
			Возврат ДанныеНастройкиЭлементаКоллекции(ИмяНастройки, Параметры);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ДанныеНастройкиЭлементаКоллекции(НастройкиПоИсточникуДанных[0], Параметры);
	
КонецФункции

Процедура ДобавитьНастройкуПоИсточникуДанных(Настройки, Правило)
	
	НастройкиПоИсточникуДанных = НастройкиПоИсточникуДанных();
	
	Для Каждого ИмяНастройки Из НастройкиПоИсточникуДанных Цикл
		
		Если КоллекцияСодержитРеквизитыДляНастройки(ИмяНастройки, Правило.ИсточникиДанных.РеквизитыОбъекта) Тогда
			Настройки.Добавить(ИмяНастройки);
			Возврат;
		КонецЕсли;
		
	КонецЦикла;
	
	Настройки.Добавить(НастройкиПоИсточникуДанных[0]);
	
КонецПроцедуры

Функция ПроверитьТипРеквизитаКоллекции(Коллекция, ИмяРеквизита, Тип, ОписаниеРеквизитовКоллекции)

	Результат = Новый Массив;
	Для Каждого ЭлементКоллекции Из Коллекция Цикл
		Значение = ЗначениеРеквизитаЭлементаКоллекции(ЭлементКоллекции, ОписаниеРеквизитовКоллекции, ИмяРеквизита);
		Результат.Добавить(ТипЗнч(Значение) = Тип);
	КонецЦикла;
	
	Возврат Результат;
		
КонецФункции

#КонецОбласти

#Область Запасы
	
Функция РесурсНастройкиЗапасы(Роль)
		
	Если Роль      = "Запасы"
		Или Роль   = "ЗапасыКромеЗабалансовых"
		Или Роль   = "ЗапасыКромеПринятыхНаКомиссиюИлиВПереработку" // Все, кроме принятых на комиссию или в переработку. Наличие такой роли обусловлено тем, что алгоритмы проведения не могут использовать отдельные забалансовые счета
		Или Роль   = "ОборудованиеНаСкладе"
		Или Роль   = "ТоварыПринятыеНаКомиссию"
		Или Роль   = "ТоварыПриобретенныеДляКомитента" 
		Или Роль   = "ЗапасыВЦенахПродажи"
		Или Роль   = "ВозвратнаяТараНаСкладе"
		Или Роль   = "ЗапасыЗатраты" Тогда
		
		Возврат "СчетУчета";
		
	ИначеЕсли Роль = "ЗапасыОтгруженные" Тогда
		
		Возврат "СчетПередачи";
		
	ИначеЕсли Роль = "МатериалыПринятыеВПереработку" Тогда
		
		Возврат "СчетУчетаДавСырья";
		
	ИначеЕсли Роль = "МатериалыПринятыеВПереработкуВПроизводстве" Тогда
		
		Возврат "СчетПередачиЗаб";
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

Процедура ЗаполнитьЗапасы(Параметры)
	
	Роль = Параметры.Правило.Роль;
	
	Параметры.ЗначениеПоУмолчанию = ПланыСчетов.Хозрасчетный.ОсновнойСчет("Запасы");
	
	Если ЗаполнитьПоОснованию(Параметры) Тогда
		Возврат;
	КонецЕсли;
	
	Параметры.Значение = СчетЗапасовИзНастройки(Параметры.Элемент, Роль, Параметры.ПланВыполнения, Параметры.НастройкиЭлемента);
	
	СчетВладелец = СчетВладелец(Параметры.ВходящееСообщение);
	
	Если ЗначениеЗаполнено(Параметры.Значение) Тогда
		Если Роль = "ЗапасыОтгруженные" Тогда
			// Настройка для этой роли может хранить не только счет отгруженных запасов,
			// но и счет учета отдельных категорий материалов.
			// Если настройка хранит заведомо неподходящий счет, то попробуем определить более подходящий.
			Если ЗначениеЗаполнено(СчетВладелец) И СчетВладелец.Забалансовый Тогда
				Если Не Параметры.Значение.Забалансовый Тогда
					Параметры.Значение = Неопределено;
				КонецЕсли;
			ИначеЕсли БухгалтерскийУчетПовтИсп.СчетВИерархии(Параметры.Значение, ПланыСчетов.Хозрасчетный.МатериалыПереданныеВПереработку)
				Или БухгалтерскийУчетПовтИсп.СчетВИерархии(Параметры.Значение, ПланыСчетов.Хозрасчетный.СпецоснасткаИСпецодеждаВЭксплуатации) Тогда
				Параметры.Значение = Неопределено;
			КонецЕсли;
		ИначеЕсли Роль = "ЗапасыКромеПринятыхНаКомиссиюИлиВПереработку" 
			И СчетЗапрещенРольюЗапасыКромеПринятыхНаКомиссиюИлиВПереработку(Параметры.Значение) Тогда
			Параметры.Значение = Неопределено;
		КонецЕсли;
	КонецЕсли;	
	
	Если Не ЗначениеЗаполнено(Параметры.Значение) Тогда
		
		// Найдем подходящее предопределенное значение
		Если Роль = "ЗапасыОтгруженные" Тогда
			Если ЗначениеЗаполнено(СчетВладелец) Тогда
				СчетЗапасов = СчетВладелец;
			Иначе
				СчетЗапасов = СчетЗапасовИзНастройки(Параметры.Элемент, "Запасы", Параметры.ПланВыполнения, Параметры.НастройкиЭлемента);
			КонецЕсли;
			Параметры.Значение = ПланыСчетов.Хозрасчетный.СчетОтгруженныхЗапасов(СчетЗапасов);
		ИначеЕсли Роль = "ЗапасыКромеЗабалансовых" Или Роль = "ЗапасыКромеПринятыхНаКомиссиюИлиВПереработку" Тогда
			Параметры.Значение = Параметры.ЗначениеПоУмолчанию;
		Иначе
			Параметры.Значение = ПланыСчетов.Хозрасчетный.ОсновнойСчет(Роль);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Функция ТребованиеБалансовостиСчетаЗапасов(Роль)
	
	Если Роль = "ЗапасыКромеЗабалансовых"
		Или Роль = "ВозвратнаяТараНаСкладе"
		Или Роль = "ОборудованиеНаСкладе" Тогда
		
		Возврат Истина; // Только балансовые
		
	ИначеЕсли Роль = "ТоварыПринятыеНаКомиссию"
		Или Роль = "МатериалыПринятыеВПереработку"
		Или Роль = "МатериалыПринятыеВПереработкуВПроизводстве"
		Или Роль = "ТоварыПриобретенныеДляКомитента" Тогда
		
		Возврат Ложь; // Только забалансовые
		
	КонецЕсли;
	
	Возврат Неопределено; // Любой подходит
	
КонецФункции

Функция СчетЗапрещенРольюЗапасыКромеПринятыхНаКомиссиюИлиВПереработку(Счет)
	
	Возврат БухгалтерскийУчетПовтИсп.СчетВИерархии(Счет, ПланыСчетов.Хозрасчетный.МатериалыПринятыеВПереработку_)
		Или БухгалтерскийУчетПовтИсп.СчетВИерархии(Счет, ПланыСчетов.Хозрасчетный.ТоварыПринятыеНаКомиссию);
		
КонецФункции

Функция СчетЗапасовИзНастройки(Объект, Роль, ВыполнениеПравила, НастройкиЭлемента)
	
	Настройка = ДанныеНастройкиЭлементаКоллекции("СчетаУчетаНоменклатуры", ВыполнениеПравила, НастройкиЭлемента);
		
	Если Настройка = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	// Определим имя ресурса настройки, по версии ПолучитьСчетаУчетаСпискаНоменклатуры()
	ИмяРесурсаНастройки = РесурсНастройкиЗапасы(Роль);

	// Для некоторых ролей следует проверить балансовость счета.
	Если Роль = "ЗапасыВЦенахПродажи" Тогда
		// Для этой роли есть особенность. Она допускает указание как балансового, так и забалансового счета.
		// Однако, в качестве балансового может быть выбран только один счет - по умолчанию.
		// Поэтому из настройки мы можем выбрать счет только тогда, когда он забалансовый.
		// То есть, в отличие от правил из ТребованиеБалансовостиСчетаЗапасов(), в отношении роли "ЗапасыВЦенахПродажи"
		// распространяется только на выбор из настройки.
		ТребованиеБалансовостиСчета = Ложь;
	Иначе
		ТребованиеБалансовостиСчета = ТребованиеБалансовостиСчетаЗапасов(Роль);
	КонецЕсли;

	Счет = Настройка[ИмяРесурсаНастройки];
	Если ТребованиеБалансовостиСчета = Неопределено Тогда
		// Проверять не требуется
		СчетПодходит = Истина;
	Иначе
		Если ИмяРесурсаНастройки = "СчетУчета" Тогда
			Забалансовый = Настройка.СчетУчетаЯвляетсяЗабалансовым;
		Иначе
			СвойстваСчета = БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
			Забалансовый = СвойстваСчета.Забалансовый;
		КонецЕсли;
		
		Балансовый = Не Забалансовый;
		
		СчетПодходит = (ТребованиеБалансовостиСчета = Балансовый);
		
	КонецЕсли;

	Если Не СчетПодходит Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Счет;
		
КонецФункции

Функция ДанныеНастройкиУчетнойПолитики(ИмяНастройки, ПредметыНастройки)
	
	Результат = НовыйДанныеНастройки(ПредметыНастройки);
	Для Каждого ПредметНастройки Из ПредметыНастройки Цикл
		
		Если Не ПроверитьСтандартныеТипы(ПредметНастройки, "Дата, Организация") Тогда
			Продолжить;
		КонецЕсли;
		
		// См. ЭтоНастройкаУчетнойПолитики()
		Если ИмяНастройки = "СпособОценкиТоваровВРознице" Тогда
			ЗначениеНастройки = УчетнаяПолитика.СпособОценкиТоваровВРознице(ПредметНастройки.Организация, ПредметНастройки.Дата);
		ИначеЕсли ИмяНастройки = "ПлательщикНалогаНаПрибыль" Тогда
			ЗначениеНастройки = УчетнаяПолитика.ПлательщикНалогаНаПрибыль(ПредметНастройки.Организация, ПредметНастройки.Дата);
		ИначеЕсли ИмяНастройки = "ПлательщикНДС" Тогда
			ЗначениеНастройки = УчетнаяПолитика.ПлательщикНДС(ПредметНастройки.Организация, ПредметНастройки.Дата);
		ИначеЕсли ИмяНастройки = "РаздельныйУчетНДСНаСчете19" Тогда
			ЗначениеНастройки = УчетнаяПолитика.РаздельныйУчетНДСНаСчете19(ПредметНастройки.Организация, ПредметНастройки.Дата);
		ИначеЕсли ИмяНастройки = "РаздельныйУчетНДСДо2014Года" Тогда
			ЗначениеНастройки = УчетнаяПолитика.РаздельныйУчетНДСДо2014Года(ПредметНастройки.Организация, ПредметНастройки.Дата);
		ИначеЕсли ИмяНастройки = "ОсновнойСчетЗатрат" Тогда
			ЗначениеНастройки = УчетнаяПолитика.ОсновнойСчетУчетаЗатрат(ПредметНастройки.Организация, ПредметНастройки.Дата);
		ИначеЕсли ИмяНастройки = "ПрименяетсяМалоценка" Тогда
			ЗначениеНастройки = УчетнаяПолитика.ПрименяетсяФСБУ5_2019(ПредметНастройки.Дата);
		ИначеЕсли ИмяНастройки = "ТребуетсяСчетРасходовПоОказаниюУслуг" Тогда
			ЗначениеНастройки = РегистрыНакопления.РеализацияУслуг.ТребуетсяСчетРасходовПоОказаниюУслуг(ПредметНастройки.Дата, ПредметНастройки.Организация);
		КонецЕсли;
		
		Индекс = ПредметыНастройки.Индекс(ПредметНастройки);
		Результат[Индекс] = ЗначениеНастройки;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ЭтоНастройкаУчетнойПолитики(ИмяНастройки)
	
	// Должны быть определены в ДанныеНастройкиУчетнойПолитики()
	
	Возврат ИмяНастройки = "СпособОценкиТоваровВРознице"
		Или ИмяНастройки = "ПлательщикНалогаНаПрибыль"
		Или ИмяНастройки = "ПлательщикНДС"
		Или ИмяНастройки = "РаздельныйУчетНДСНаСчете19"
		Или ИмяНастройки = "РаздельныйУчетНДСДо2014Года"
		Или ИмяНастройки = "ОсновнойСчетЗатрат"
		Или ИмяНастройки = "ПрименяетсяМалоценка"
		Или ИмяНастройки = "ТребуетсяСчетРасходовПоОказаниюУслуг";
		
КонецФункции

#КонецОбласти

#Область НДС

Процедура ЗаполнитьПредъявленныйНДС(Параметры)
	
	Параметры.ЗначениеПоУмолчанию = ПланыСчетов.Хозрасчетный.ОсновнойСчет(Параметры.Правило.Роль);
	
	Если Не АналитикаЗатратОпределяетсяНоменклатуройУслуг(СвойствоВладельцаПравила(Параметры.Правило, "Роль"))
		Или ДанныеНастройкиЭлементаКоллекции("ЭтоУслуга", Параметры) = Истина Тогда
		
		// Настройку для номенклатуры можно использовать 
		// - для услуг    - всегда
		// - для не-услуг - только в тех случаях, когда речь не идет о затратах
		//   (NB: в этом отличие от определения определения счета - для не-услуг счет затрат не определяется по настройке).
		// Таким образом, в тех случаях, когда счет затрат НЕ выбираем из настройки, то и счет НДС НЕ выбираем из настройки.
		// См. также ЗаполнитьЗатраты()
	
		Настройка = НастройкаПоИсточникуДанных(Параметры);
		
		Если Настройка <> Неопределено Тогда
			Параметры.Значение = Настройка.СчетУчетаНДС;
		КонецЕсли;
			
	КонецЕсли;
		
	Если ЗначениеЗаполнено(Параметры.Значение) Тогда
		Возврат;
	КонецЕсли;
	
	// Счет НДС может зависеть от других зависимых реквизитов - субконто, см. ЗаполнитьСубконтоЗатрат() и ЗаполнитьЗатраты()
	СчетЗатрат = СчетВладелец(Параметры.ВходящееСообщение);
	Если ЗначениеЗаполнено(СчетЗатрат) Тогда
		
		Если Не Параметры.ВходящееСообщение.Свойство("ЗначенияСубконто") Тогда
			ВидЦенности = УчетНДС.ОпределитьВидЦенности(СчетЗатрат);
		Иначе
			ВидЦенности = УчетНДС.ОпределитьВидЦенности(
				СчетЗатрат,
				Параметры.ВходящееСообщение.ЗначенияСубконто[0],
				Параметры.ВходящееСообщение.ЗначенияСубконто[1],
				Параметры.ВходящееСообщение.ЗначенияСубконто[2]);
		КонецЕсли;
	
		Если ЗначениеЗаполнено(ВидЦенности) Тогда
			Параметры.Значение = УчетНДС.СчетПредъявленногоНалогаПоВидуЦенности(ВидЦенности);
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьСпособУчетаНДСПредъявленного(Параметры)
	
	// ПредъявленСчетФактура используется, когда сразу в момент оформления операции мы можем решить,
	// что счет-фактура отсутствует.
	// В таком случае мы можем сразу списать НДС при отсутствии счета-фактуры.
	// Если в момент оформления операции счета-фактуры нет, но могут "дослать" или "донести", то такой источник данных использовать не следует.
	// Потому что в таком случае механизмы НДС не поддерживают списание НДС сразу - это делается отдельным документом.
	ПредъявленСчетФактура = ЗначениеРеквизитаЭлементаКоллекции(
		Параметры.Элемент,
		Параметры.Правило.ИсточникиДанных.РеквизитыОбъекта,
		"ПредъявленСчетФактура");
		
	Если ПредъявленСчетФактура = Неопределено Тогда
		ПредъявленСчетФактура = Параметры.ПланВыполнения.ДанныеЗаполнения.ПредъявленСчетФактура;
	КонецЕсли;
	
	Если ПредъявленСчетФактура = Ложь Тогда
		Параметры.Значение = Перечисления.СпособыУчетаНДС.Списывается;
		Возврат;
	КонецЕсли;
	
	Параметры.ЗначениеПоУмолчанию = Перечисления.СпособыУчетаНДС.ПринимаетсяКВычету;
	
	Настройка = НастройкаПоИсточникуДанных(Параметры);
	
	Если Настройка <> Неопределено Тогда
		Если Настройка.СпособУчетаНДС <> Перечисления.СпособыУчетаНДС.Списывается Тогда
			// "Списывается" допускается только тогда, когда СФ не предъявлен.
			Параметры.Значение = Настройка.СпособУчетаНДС;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция ДанныеНастройкиСпособУчетаНДСИспользованного(ПредметыНастройки)
	
	НоменклатурныеГруппы = Новый Массив(ПредметыНастройки.Количество());
	
	Для Индекс = 0 По НоменклатурныеГруппы.ВГраница() Цикл
		
		ПредметНастройки = ПредметыНастройки[Индекс];
		
		НоменклатурнаяГруппа = Справочники.НоменклатурныеГруппы.ПустаяСсылка();
		Для Каждого Колонка Из ПредметыНастройки.Колонки Цикл
			Если ТипЗнч(ПредметНастройки[Колонка.Имя]) = Тип("СправочникСсылка.НоменклатурныеГруппы") Тогда
				НоменклатурнаяГруппа = ПредметНастройки[Колонка.Имя];
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		НоменклатурныеГруппы[Индекс] = НоменклатурнаяГруппа;
		
	КонецЦикла;
	
	Результат = НовыйДанныеНастройки(ПредметыНастройки);
	
	СпособыУчетаНДС = ОбщегоНазначения.ЗначениеРеквизитаОбъектов(НоменклатурныеГруппы, "СпособУчетаНДС");
	Для Индекс = 0 По НоменклатурныеГруппы.ВГраница() Цикл
		НоменклатурнаяГруппа = НоменклатурныеГруппы[Индекс];
		СпособУчетаНДС = СпособыУчетаНДС[НоменклатурнаяГруппа];
		Результат[Индекс] = СпособУчетаНДС;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ПроверятьСпособУчетаНДС(Правило)
	
	Возврат Правило.Роль = "СпособУчетаНДСПредъявленного";
	
КонецФункции

Функция ОшибкаЗаполненияСпособУчетаНДС(Параметры)
	
	Если Не ПроверятьСпособУчетаНДС(Параметры.Правило) Тогда
		Возврат "";
	КонецЕсли;
	
	ПредъявленСчетФактура = ЗначениеРеквизитаЭлементаКоллекции(
		Параметры.Элемент,
		Параметры.Правило.ИсточникиДанных.РеквизитыОбъекта,
		"ПредъявленСчетФактура");
		
	Если ПредъявленСчетФактура = Неопределено Тогда
		ПредъявленСчетФактура = Параметры.ПланВыполнения.ДанныеЗаполнения.ПредъявленСчетФактура;
	КонецЕсли;
	
	Если ПредъявленСчетФактура <> Ложь Тогда
		Возврат "";
	КонецЕсли;
	
	Значение = Параметры.Элемент[Параметры.Правило.Реквизит];
	Если ЗначениеЗаполнено(Значение) И Значение <> Перечисления.СпособыУчетаНДС.Списывается Тогда 
		// См. комментарий в ЗаполнитьСпособУчетаНДСПредъявленного()
		Возврат НСтр("ru = 'При отсутствии счета-фактуры НДС должен быть списан'");
		
	КонецЕсли;
	
КонецФункции

#КонецОбласти
	
#Область Затраты
	
Функция АналитикаЗатратОпределяетсяНоменклатуройУслуг(Роль)
	Возврат (Роль = "Затраты" Или Роль = "РасходыНаПродажу" Или Роль = "ЗапасыЗатраты");
КонецФункции

Процедура ЗаполнитьЗатраты(Параметры)
	
	Параметры.ЗначениеПоУмолчанию = ПланыСчетов.Хозрасчетный.ОсновнойСчет("Затраты");
	
	Если ЗаполнитьПоОснованию(Параметры) Тогда
		Возврат;
	КонецЕсли;
	
	СчетЗатратОпределенНоменклатуройУслуг = Ложь;
	
	Если АналитикаЗатратОпределяетсяНоменклатуройУслуг(Параметры.Правило.Роль) Тогда
		
		// Счета (и аналитика затрат) может определяться настройками счетов для номенклатуры.
		// Но в зависимости от того, товар или услуга, эта настройка имеет разный смысл.
		// Счет _затрат_ в настройке указывается только для услуг.
		// Поэтому когда нужна аналитика _затрат_, а номенклатура - не услуга,
		// то использовать настройку для номенклатуры нельзя.
		// См. также ЗаполнитьПредъявленныйНДС()
			
		Если ДанныеНастройкиЭлементаКоллекции("ЭтоУслуга", Параметры) = Истина Тогда
			Настройка = ДанныеНастройкиЭлементаКоллекции("СчетаУчетаНоменклатуры", Параметры);
			Если Настройка <> Неопределено Тогда
				Параметры.Значение = Настройка.СчетУчета;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Параметры.Значение) Тогда
		СчетЗатратОпределенНоменклатуройУслуг = Истина;
	ИначеЕсли Параметры.Правило.Роль = "РасходыНаПродажу" Тогда
		Параметры.Значение = ПланыСчетов.Хозрасчетный.ОсновнойСчет("РасходыНаПродажу");
	ИначеЕсли Параметры.Правило.Роль = "РасходыУслугиБанка" Тогда
		Параметры.Значение = ПланыСчетов.Хозрасчетный.ОсновнойСчет("ПрочиеРасходы");
	ИначеЕсли Параметры.Правило.Роль = "РасходыУслугиФакторинга" Тогда
		Параметры.Значение = ПланыСчетов.Хозрасчетный.ОсновнойСчет("ПрочиеРасходы");
	ИначеЕсли Параметры.Правило.Роль = "ПрочиеРасходы" Тогда
		Параметры.Значение = ПланыСчетов.Хозрасчетный.ОсновнойСчет("ПрочиеРасходы");
	ИначеЕсли Параметры.Правило.Роль = "ЗатратыНаПроизводство" Тогда
		Параметры.Значение = ПланыСчетов.Хозрасчетный.ОсновнойСчет("ЗатратыНаПроизводство");
	Иначе
		// Основной счет учета, заданный в настройках, это совершенно негибкая настройка.
		// Она не учитывает разнообразия фактов хозяйственной жизни.
		// Поэтому к этой настройке прибегаем только для заполнения по-умолчанию - то есть,
		// когда счет в документе не заполнен.
		// Если счет затрат в документе заполнен, то он не меняется и эта настройка не используется.
		ЗначениеНастройки = ДанныеНастройкиЭлементаКоллекции("ОсновнойСчетЗатрат", Параметры);
		Если ЗначениеЗаполнено(ЗначениеНастройки) Тогда
			Параметры.ЗначениеПоУмолчанию = ЗначениеНастройки;
		КонецЕсли;
	КонецЕсли;
		
	Параметры.ИсходящееСообщение.Вставить("СчетЗатратОпределенНоменклатуройУслуг",  СчетЗатратОпределенНоменклатуройУслуг);
	
КонецПроцедуры

Процедура ЗаполнитьРасходыНаМалоценку(Параметры)
	
	Если ЗаполнитьПоОснованию(Параметры) Тогда
		Возврат;
	КонецЕсли;
	
	СчетЗапасов = СчетЗапасовИзНастройки(Параметры.Элемент, "Запасы", Параметры.ПланВыполнения, Параметры.НастройкиЭлемента);
	
	Если ДанныеНастройкиЭлементаКоллекции("ПрименяетсяМалоценка", Параметры) = Истина
		И СчетЗапасов = ПланыСчетов.Хозрасчетный.ПриобретениеМалоценногоОборудованияИЗапасов Тогда
		
		ЗначениеНастройки = ДанныеНастройкиЭлементаКоллекции("ОсновнойСчетЗатрат", Параметры);
		Если ЗначениеЗаполнено(ЗначениеНастройки) Тогда
			Параметры.ЗначениеПоУмолчанию = ЗначениеНастройки;
		КонецЕсли;
	Иначе
		Параметры.Значение = ПланыСчетов.Хозрасчетный.ПустаяСсылка();
		Параметры.ЗначениеПоУмолчанию = ПланыСчетов.Хозрасчетный.ПустаяСсылка();
		Параметры.Очистить = Истина;
	КонецЕсли;
		
	Параметры.ИсходящееСообщение.Вставить("СчетЗатратОпределенНоменклатуройУслуг",  Ложь);
	
КонецПроцедуры

Функция СтатьяЗатратОпределяетсяНоменклатуройЗапасов(Роль)
	Возврат (Роль = "ИспользованиеМатериалов" Или Роль = "РасходыНаМалоценку");
КонецФункции

Процедура ЗаполнитьСубконтоЗатрат(Параметры)
	
	КоличествоСубконто = 3;
	
	// Определим НомерСубконто
	Для НомерСубконто = 1 По КоличествоСубконто + 1 Цикл
		Если Параметры.Правило.Роль = "СубконтоЗатрат" + НомерСубконто Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если НомерСубконто > КоличествоСубконто Тогда
		Возврат;
	КонецЕсли;
	
	Если Не Параметры.ВходящееСообщение.Свойство("ЗначенияСубконто") Тогда
		Параметры.ВходящееСообщение.Вставить("ЗначенияСубконто", Новый Массив(КоличествоСубконто));
	КонецЕсли;
	
	// Убедимся, что можем пытаться заполнять
	СвойстваСчета = СвойстваСчетаОтВладельца(Параметры.ВходящееСообщение);
	
	Если СвойстваСчета = Неопределено Или НомерСубконто > СвойстваСчета.КоличествоСубконто Тогда
		Параметры.Очистить = Истина;
		Возврат;
	КонецЕсли;
		
	ВидСубконто = СвойстваСчета["ВидСубконто" + НомерСубконто];
	ТипЗначения = СвойстваСчета["ВидСубконто" + НомерСубконто + "ТипЗначения"];
	
	// Значение из основания
	Если ЗаполнитьПоОснованию(Параметры) Тогда
		Если Параметры.Значение = ТипЗначения.ПривестиЗначение(Параметры.Значение) Тогда
			Возврат;
		Иначе
			Параметры.Значение = Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	// Значение из контекста
	Если Параметры.ВходящееСообщение.Свойство("СчетЗатратОпределенНоменклатуройУслуг") 
		И Параметры.ВходящееСообщение.СчетЗатратОпределенНоменклатуройУслуг Тогда
		
		Настройка  = ДанныеНастройкиЭлементаКоллекции("СчетаУчетаНоменклатуры", Параметры);
		Если Настройка <> Неопределено Тогда
			Параметры.Значение = ТипЗначения.ПривестиЗначение(Настройка["Субконто" + НомерСубконто]);
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Параметры.Значение) Тогда
		Если ВидСубконто = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.СтатьиЗатрат Тогда
			ЗаполнитьЗначениеСубконтоСтатьяЗатрат(Параметры);
		ИначеЕсли ВидСубконто = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.НоменклатурныеГруппы Тогда
			ЗаполнитьЗначениеСубконтоНоменклатурнаяГруппа(Параметры);
		Иначе
			// Проверим, подойдет ли текущее значение
			ТекущееЗначение = Параметры.Элемент[Параметры.Правило.Реквизит];
			Параметры.Значение = ТипЗначения.ПривестиЗначение(ТекущееЗначение);
		КонецЕсли;
	КонецЕсли;
	
	// Значение по умолчанию
	Если Не ЗначениеЗаполнено(Параметры.Значение) Тогда
		Если ВидСубконто = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.ПрочиеДоходыИРасходы Тогда
			Если СвойствоВладельцаПравила(Параметры.Правило, "Роль") = "РасходыУслугиБанка" Тогда
				Параметры.ЗначениеПоУмолчанию = ОбщегоНазначенияКлиентСервер.ПредопределенныйЭлемент("Справочник.ПрочиеДоходыИРасходы.РасходыНаУслугиБанков");
			ИначеЕсли СвойствоВладельцаПравила(Параметры.Правило, "Роль") = "РасходыУслугиФакторинга" Тогда
				Параметры.ЗначениеПоУмолчанию = ОбщегоНазначенияКлиентСервер.ПредопределенныйЭлемент("Справочник.ПрочиеДоходыИРасходы.РасходыНаУслугиФакторинговыхКомпаний");
			ИначеЕсли СвойствоВладельцаПравила(Параметры.Правило, "Роль") = "ПрочиеРасходы" Тогда
				Параметры.ЗначениеПоУмолчанию = ОбщегоНазначенияКлиентСервер.ПредопределенныйЭлемент("Справочник.ПрочиеДоходыИРасходы.ПрочиеВнереализационныеДоходыРасходы");
			Иначе
				Параметры.ЗначениеПоУмолчанию = Справочники.ПрочиеДоходыИРасходы.ОсновнаяСтатьяПрочихРасходов();
			КонецЕсли;
		Иначе
			Параметры.ЗначениеПоУмолчанию = ТипЗначения.ПривестиЗначение(Неопределено);
		КонецЕсли;
		Параметры.Значение = Параметры.ЗначениеПоУмолчанию;
		Параметры.Очистить = Истина;
	КонецЕсли;
	
	// Передадим результат "соседям"
	Параметры.ВходящееСообщение.ЗначенияСубконто[НомерСубконто - 1] = Параметры.Значение;
	
КонецПроцедуры

Процедура ЗаполнитьЗначениеСубконтоСтатьяЗатрат(Параметры)
	
	Параметры.ЗначениеПоУмолчанию = Справочники.СтатьиЗатрат.ПустаяСсылка();
	
	РольВладельца = СвойствоВладельцаПравила(Параметры.Правило, "Роль");
	
	Если СтатьяЗатратОпределяетсяНоменклатуройЗапасов(РольВладельца) Тогда
		
		Параметры.Значение = ДанныеНастройкиЭлементаКоллекции("СтатьяЗатратНоменклатуры", Параметры);
		
	ИначеЕсли РольВладельца = "ЗатратыНДС" Тогда
		
		Если ДанныеНастройкиЭлементаКоллекции("СпециальныйРежимНалогообложения", Параметры) = Истина Тогда
			Параметры.Значение = Справочники.СтатьиЗатрат.СтатьяЗатратПоНазначению("СписаниеНДСНаРасходыЕНВД");
		Иначе
			Параметры.Значение = Справочники.СтатьиЗатрат.СтатьяЗатратПоНазначению("СписаниеНДСНаРасходы");
		КонецЕсли;
				
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Параметры.Значение) Тогда
		Возврат;
	КонецЕсли;
	
	// Проверим, подойдет ли текущее значение
	ТекущееЗначение = Параметры.Элемент[Параметры.Правило.Реквизит];
	Если ЗначениеЗаполнено(ТекущееЗначение) И ТипЗнч(ТекущееЗначение) = Тип("СправочникСсылка.СтатьиЗатрат") Тогда
		Параметры.Значение = ТекущееЗначение;
	ИначеЕсли РольВладельца = "РасходыНаМалоценку" Тогда
		Параметры.Значение = Справочники.СтатьиЗатрат.СтатьяЗатратПоНазначению("ПриобретениеМалоценногоОборудованияИЗапасов");
	ИначеЕсли РольВладельца = "ИспользованиеМатериалов" Тогда
		Параметры.Значение = Справочники.СтатьиЗатрат.СтатьяЗатратПоНазначению("СписаниеМатериалов");
	ИначеЕсли РольВладельца = "КомандировочныеРасходы" Тогда
		Параметры.Значение = УчетКомандировок.СтатьяЗатратКомандировочныеРасходы();
	ИначеЕсли РольВладельца = "СодержаниеСлужебногоТранспорта" Тогда
		Параметры.Значение = Справочники.СтатьиЗатрат.СтатьяЗатратПоНазначению("СлужебныйАвтотранспорт");
	Иначе
		Параметры.Значение = Справочники.СтатьиЗатрат.ОсновнаяСтатьяЗатрат();
	КонецЕсли;
			
КонецПроцедуры

Процедура ЗаполнитьПодразделение(Параметры)
	
	СвойстваСчета = СвойстваСчетаОтВладельца(Параметры.ВходящееСообщение);
	
	Если СвойстваСчета = Неопределено Или Не СвойстваСчета.УчетПоПодразделениям Тогда
		Параметры.ЗначениеПоУмолчанию = Справочники.ПодразделенияОрганизаций.ПустаяСсылка();
		Параметры.Очистить = Истина;
		Возврат;
	КонецЕсли;
	
	Параметры.ЗначениеПоУмолчанию = ОбщегоНазначенияБПВызовСервераПовтИсп.ПодразделениеПоУмолчанию(Параметры.ПланВыполнения.ДанныеЗаполнения.Организация);
	
	Если Параметры.Правило.Роль = "ПодразделениеБанковскогоСчета" Тогда
		
		БанковскийСчет = ЗначениеРеквизитаЭлементаКоллекции(
			Параметры.Элемент, 
			Параметры.Правило.ИсточникиДанных.РеквизитыОбъекта,
			"БанковскийСчет");
			
		Если ЗначениеЗаполнено(БанковскийСчет) Тогда
				
			Параметры.Значение = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(БанковскийСчет, "ПодразделениеОрганизации");
			
			Если Не ЗначениеЗаполнено(Параметры.Значение) Тогда
				// Надо принудительно очистить подразделение
				Параметры.ЗначениеПоУмолчанию = Справочники.ПодразделенияОрганизаций.ПустаяСсылка();
				Параметры.Очистить = Истина;
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе
		
		Если Параметры.Правило.Роль <> "ОбособленноеПодразделение" Тогда
			// Значение в проводке может отличаться от подразделения-основания для заполнения,
			// поэтому по возможности его следует сохранить
			ТекущееЗначение = Параметры.Элемент[Параметры.Правило.Реквизит];
			Если ЗначениеЗаполнено(ТекущееЗначение) И ТекущееЗначение.Владелец = Параметры.ПланВыполнения.ДанныеЗаполнения.Организация Тогда
				Параметры.Значение = ТекущееЗначение;
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Параметры.Значение) Тогда
				Возврат;
			КонецЕсли;
		
		КонецЕсли;
		
		Параметры.Значение = Параметры.ПланВыполнения.ДанныеЗаполнения.Подразделение;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область Выручка
	
Функция РесурсНастройкиВыручка(Роль)
		
	Если Роль = "Выручка" Или Роль = "ПрочиеДоходы" Тогда
		
		Возврат "СчетДоходов";
		
	ИначеЕсли Роль = "ВыручкаНДС" Тогда
		
		Возврат "СчетУчетаНДСПродажи";
		
	ИначеЕсли Роль = "Расходы" Тогда
		
		Возврат "СчетРасходов";
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции

Процедура ЗаполнитьВыручка(Параметры)
	
	Роль = Параметры.Правило.Роль;
	
	// Если запасы нам не принадлежат, то и счета выручки не должны заполняться
	Если Параметры.ВходящееСообщение.Свойство("ОчиститьСчетаВыручки") Тогда
		ОчиститьСчетаВыручки = Истина;
	ИначеЕсли Роль = "Выручка" Тогда
		СчетВладелец = СчетВладелец(Параметры.ВходящееСообщение); // Ожидается, что это будет счет запасов
		ОчиститьСчетаВыручки = ЗначениеЗаполнено(СчетВладелец) И СчетВладелец.Забалансовый;
	Иначе
		ОчиститьСчетаВыручки = Ложь;
	КонецЕсли;
	
	Если ОчиститьСчетаВыручки Тогда
		Параметры.Очистить = Истина;
		// Счета выручки могут быть иерархическими, например, счет расходов подчинен счету доходов.
		// Для счета расходов проверить балансовость счета запасов не удастся, поэтому передадим сообщение подчиненным счетам.
		Параметры.ИсходящееСообщение.Вставить("ОчиститьСчетаВыручки", Истина);
		Возврат;
	КонецЕсли;
	
	НастройкаСчетов = ДанныеНастройкиЭлементаКоллекции("СчетаУчетаНоменклатуры", Параметры);
	
	Если НастройкаСчетов <> Неопределено Тогда
		// Проверим корректность настройки
		НастройкаКорректна = СчетРасходовСоответствуетСчетуВыручки(
			НастройкаСчетов[РесурсНастройкиВыручка("Выручка")],
			НастройкаСчетов[РесурсНастройкиВыручка("Расходы")]);
		Если НастройкаКорректна Тогда
			ИмяРесурса = РесурсНастройкиВыручка(Роль);
			Параметры.Значение = НастройкаСчетов[ИмяРесурса];
			Если ЗначениеЗаполнено(Параметры.Значение) Тогда
				Возврат;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если Роль = "Выручка" Тогда
		
		// Проверим на ПрочиеДоходы
		Если ЗначениеЗаполнено(СчетВладелец) Тогда
			Для Каждого СчетЗапасов Из УчетДоходовРасходов.ЗапасыПродажаКоторыхПрочиеДоходы() Цикл
				Если БухгалтерскийУчетПовтИсп.СчетВИерархии(СчетВладелец, СчетЗапасов) Тогда
					Параметры.Значение = ПланыСчетов.Хозрасчетный.ОсновнойСчет("ПрочиеДоходы");
					Возврат;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		// Заполним "обычным" значением счета выручки - 90.01.1 или 90.01.2
		СпециальныйРежимНалогообложения = (ДанныеНастройкиЭлементаКоллекции("СпециальныйРежимНалогообложения", Параметры) = Истина);
		Параметры.Значение = УчетДоходовРасходов.ОсновнойСчетВыручки(СпециальныйРежимНалогообложения);
		
	ИначеЕсли Роль = "Расходы" Тогда
		
		СпециальныйРежимНалогообложения = (ДанныеНастройкиЭлементаКоллекции("СпециальныйРежимНалогообложения", Параметры) = Истина);
		Параметры.Значение = УчетДоходовРасходов.СчетСебестоимостьПродаж(СчетВладелец(Параметры.ВходящееСообщение), СпециальныйРежимНалогообложения); // Подчиненные правила получат счет выручки
		
	ИначеЕсли Роль = "ВыручкаНДС" Тогда
		
		Параметры.Значение = УчетДоходовРасходов.СчетВыручкаНДС(СчетВладелец(Параметры.ВходящееСообщение)); // Подчиненные правила получат счет выручки
		
	Иначе // Можно явно указать ПрочиеДоходы
		
		Параметры.Значение = ПланыСчетов.Хозрасчетный.ОсновнойСчет(Роль); 
		
	КонецЕсли;
		
КонецПроцедуры

Процедура ЗаполнитьВидДеятельности(Параметры)
	
	СвойстваСчета = СвойстваСчетаОтВладельца(Параметры.ВходящееСообщение);
	Если СвойстваСчета = Неопределено Или СвойстваСчета.КоличествоСубконто = 0 Тогда
		Параметры.Очистить = Истина;
		Возврат;
	КонецЕсли;
	
	Если СвойстваСчета.ВидСубконто1 = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.НоменклатурныеГруппы Тогда
		
		// Попробуем заполнить единственной номенклатурной группой
		Параметры.Значение = БухгалтерскийУчетВызовСервераПовтИсп.ОсновнаяНоменклатурнаяГруппа();
		Если Не ЗначениеЗаполнено(Параметры.Значение) Тогда
			Параметры.Значение = ДанныеНастройкиЭлементаКоллекции("ВидДеятельностиНоменклатуры", Параметры);
		КонецЕсли;
		
	ИначеЕсли СвойстваСчета.ВидСубконто1 = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.ПрочиеДоходыИРасходы Тогда
		
		Если Параметры.Правило.Роль = "ВидДеятельностиРеализацияОсновныхСредств" Тогда
			Параметры.Значение = ОбщегоНазначенияКлиентСервер.ПредопределенныйЭлемент("Справочник.ПрочиеДоходыИРасходы.РеализацияОсновныхСредств");
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(Параметры.Значение) Тогда
			Параметры.Значение = ОбщегоНазначенияКлиентСервер.ПредопределенныйЭлемент("Справочник.ПрочиеДоходыИРасходы.РеализацияПрочегоИмущества");
		КонецЕсли;
		
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Параметры.Значение) Тогда
		Возврат;
	КонецЕсли;
	
	// Проверим, подойдет ли текущее значение
	ТекущееЗначение = Параметры.Элемент[Параметры.Правило.Реквизит];
	Параметры.Значение = СвойстваСчета.ВидСубконто1ТипЗначения.ПривестиЗначение(ТекущееЗначение);
	
	Если Не ЗначениеЗаполнено(Параметры.Значение) Тогда
		Параметры.ЗначениеПоУмолчанию = Параметры.Значение;
		Параметры.Очистить = Истина;
	КонецЕсли;
	
КонецПроцедуры

Функция ДанныеНастройкиВидДоговора(ПредметыНастройки)
	
	Результат = ПредметыНастройки.ВыгрузитьКолонку("ВидДоговора");
	Если Результат.Количество() = 0 Или ЗначениеЗаполнено(Результат[0]) Тогда
		// Получена ранее
		Возврат Результат;
	КонецЕсли;
	
	Возврат ЗначенияРеквизитаПредметовНастройки(ПредметыНастройки, "ДоговорКонтрагента", "ВидДоговора", Тип("СправочникСсылка.ДоговорыКонтрагентов"))
	
КонецФункции

Функция ДанныеНастройкиСпециальныйРежимНалогообложения(ПредметыНастройки)
	
	Результат = НовыйДанныеНастройки(ПредметыНастройки);
	
	Номенклатура = ВыгрузитьЗначения(ПредметыНастройки, "Номенклатура", Тип("СправочникСсылка.Номенклатура"));
	Услуги       = ОбщегоНазначения.ЗначениеРеквизитаОбъектов(Номенклатура, "Услуга");
	
	Склады      = ВыгрузитьЗначения(ПредметыНастройки, "Склад", Тип("СправочникСсылка.Склады"));
	ТипыСкладов = ОбщегоНазначения.ЗначениеРеквизитаОбъектов(Склады, "ТипСклада");
	
	Для Каждого ПредметНастройки Из ПредметыНастройки Цикл
		
		ПараметрыОсобыйПорядокНалогообложения = Новый Структура; // Описана в РеализацияОсобыйПорядокНалогообложения
		
		ЭтоУслуга = Услуги[ПредметНастройки.Номенклатура];
		Если ЗначениеЗаполнено(ЭтоУслуга) Тогда
			ПараметрыОсобыйПорядокНалогообложения.Вставить("ЭтоУслуга", ЭтоУслуга);
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ПредметНастройки.ДокументОснование) Тогда
			ПараметрыОсобыйПорядокНалогообложения.Вставить("ДокументОснование",     ПредметНастройки.ДокументОснование);
		ИначеЕсли ЗначениеЗаполнено(ПредметНастройки.Склад) Тогда
			ТипСклада = ТипыСкладов[ПредметНастройки.Склад];
			Если ЗначениеЗаполнено(ТипСклада) Тогда
				ПараметрыОсобыйПорядокНалогообложения.Вставить("ТипСклада", ТипСклада);
			КонецЕсли;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ПредметНастройки.ДеятельностьНаПатенте) Тогда
			ПараметрыОсобыйПорядокНалогообложения.Вставить("ДеятельностьНаПатенте", ПредметНастройки.ДеятельностьНаПатенте);
		КонецЕсли;
		
		ОсобыйПорядок = УчетДоходовРасходов.РеализацияОсобыйПорядокНалогообложения(
			ПредметНастройки.Организация,
			ПредметНастройки.Дата,
			ПараметрыОсобыйПорядокНалогообложения);
			
		Индекс = ПредметыНастройки.Индекс(ПредметНастройки);
		Результат[Индекс] = (ОсобыйПорядок.Результат = Истина); // Если есть сомнения - считаем, что общий порядок
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ПроверятьСоответствиеВидовДеятельности(Правило)
	Возврат Правило.Роль = "Расходы" И СвойствоВладельцаПравила(Правило, "Роль") = "Выручка";
КонецФункции

Функция СчетРасходовСоответствуетСчетуВыручки(СчетВыручки, СчетРасходов)
	
	Если Не ЗначениеЗаполнено(СчетВыручки) Или Не ЗначениеЗаполнено(СчетРасходов) Тогда
		Возврат Истина;
	КонецЕсли;
	
	СчетаСпециальныеРежимы = БухгалтерскийУчетПовтИсп.СчетаУчетаЕНВД();
	СпециальныйРежимВыручка = (СчетаСпециальныеРежимы.Найти(СчетВыручки)  <> Неопределено);
	СпециальныйРежимРасходы = (СчетаСпециальныеРежимы.Найти(СчетРасходов) <> Неопределено);
	
	Возврат СпециальныйРежимВыручка = СпециальныйРежимРасходы;
	
КонецФункции

Функция ОшибкаЗаполненияВыручки(Параметры)
	
	Если Не ПроверятьСоответствиеВидовДеятельности(Параметры.Правило) Тогда
		Возврат "";
	КонецЕсли;
	
	Выручка = Параметры.Элемент[Параметры.Правило.Реквизит];
	Расходы = Параметры.Элемент[СвойствоВладельцаПравила(Параметры.Правило, "Реквизит")];
	
	Если СчетРасходовСоответствуетСчетуВыручки(Выручка, Расходы) Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат НСтр("ru = 'Счета доходов и расходов относятся к разным видам деятельности.'");
	
КонецФункции

#КонецОбласти
	
#Область Расчеты
	
Функция РесурсНастройкиРасчеты(Роль)
		
	Если Роль = "РасчетыСПоставщиком" 
		Или Роль = "РасчетыДругие" Тогда
		
		Возврат "СчетРасчетов";
		
	ИначеЕсли Роль = "РасчетыСПокупателем" Тогда
		
		Возврат "СчетРасчетовПокупателя";
		
	ИначеЕсли Роль = "РасчетыСКомитентом" Тогда
		
		Возврат "СчетРасчетовСКомитентом";
		
	ИначеЕсли Роль = "АвансыПокупателя" Тогда
			
		Возврат "СчетАвансовПокупателя";
			
	ИначеЕсли Роль = "АвансыПоставщику" Тогда
		
		Возврат "СчетАвансов";
			
	ИначеЕсли Роль = "РасчетыПоПретензиям" Тогда
			
		Возврат "СчетРасчетовПоПретензиям";
			
	ИначеЕсли Роль = "ВозвратнаяТараПереданная" Тогда
		
		Возврат "СчетУчетаТарыПокупателя";
		
	ИначеЕсли Роль = "ВозвратнаяТараПолученная" Тогда
		
		Возврат "СчетУчетаТары";
		
	ИначеЕсли Роль = "РасчетыСКомитентомЗаПриобретенныеДляНегоТоварыУслуги" Тогда
		
		Возврат "СчетРасчетовСКомитентом";
		
	КонецЕсли;
	
	Возврат Неопределено;
	
КонецФункции
	
Процедура ЗаполнитьРасчеты(Параметры)
	
	ВидРасчетов     = Неопределено;
	Параметры.ВходящееСообщение.Свойство("ВидРасчетов", ВидРасчетов);
	
	Если Не ЗначениеЗаполнено(ВидРасчетов) Тогда
		// Определим вид расчетов по условиям расчетов
		УсловияРасчетов = ДанныеНастройкиЭлементаКоллекции("УсловияРасчетов", Параметры);
		Если УсловияРасчетов <> Неопределено Тогда
			ВидРасчетов = УчетВзаиморасчетов.ВидРасчетовПоУсловиямРасчетов(УсловияРасчетов.ВалютаВзаиморасчетов, УсловияРасчетов.РасчетыВУсловныхЕдиницах);
		КонецЕсли;
		// Обработаем ситуацию, когда по условиям расчетов определить вид расчетов не удалось
		Если Не ЗначениеЗаполнено(ВидРасчетов) Тогда
			ВидРасчетов = УчетВзаиморасчетов.ВидРасчетовПоУсловиямРасчетов();
		КонецЕсли;
		Параметры.ВходящееСообщение.Вставить("ВидРасчетов", ВидРасчетов);
	КонецЕсли;
	
	
	Роль = Параметры.Правило.Роль;
	Если ПолучитьФункциональнуюОпцию("ОсуществляетсяРеализацияТоваровУслугКомитентов") Тогда
		Если Роль = "РасчетыСПоставщиком" Или Роль = "АвансыПоставщику" Тогда
			// Проверим вид договора
			ВидДоговора = ДанныеНастройкиЭлементаКоллекции("ВидДоговора", Параметры);
			Если ВидДоговора = Перечисления.ВидыДоговоровКонтрагентов.СКомитентом Тогда
				Роль = "РасчетыСКомитентом";
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	НастройкаСчетов = ДанныеНастройкиЭлементаКоллекции("СчетаРасчетов", Параметры);
	ИмяРесурса      = РесурсНастройкиРасчеты(Роль);
	
	Если НастройкаСчетов <> Неопределено И ЗначениеЗаполнено(ИмяРесурса) Тогда
		Параметры.Значение = НастройкаСчетов[ИмяРесурса];
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Параметры.Значение) Тогда
		Параметры.Значение = УчетВзаиморасчетов.ОсновнойСчетРасчетов(ВидРасчетов, Роль);
	КонецЕсли;
		
КонецПроцедуры

Функция ДанныеНастройкиСчетаРасчетов(ПредметыНастройки)
	
	Настройки = Новый Массив;
	
	Для Каждого ПредметНастройки Из ПредметыНастройки Цикл
		
		Если ТипЗнч(ПредметНастройки.Организация) <> Тип("СправочникСсылка.Организации")
			Или ТипЗнч(ПредметНастройки.Контрагент) <> Тип("СправочникСсылка.Контрагенты")
			Или ТипЗнч(ПредметНастройки.ДоговорКонтрагента) <> Тип("СправочникСсылка.ДоговорыКонтрагентов") Тогда
			Настройка = Неопределено;
		Иначе
			Настройка = БухгалтерскийУчетПереопределяемый.ПолучитьСчетаРасчетовСКонтрагентом(
				ПредметНастройки.Организация,
				ПредметНастройки.Контрагент,
				ПредметНастройки.ДоговорКонтрагента)
		КонецЕсли;
		
		Настройки.Добавить(Настройка);
		
	КонецЦикла;
	
	Возврат Настройки;
	
КонецФункции

Функция ДанныеНастройкиУсловияРасчетов(ПредметыНастройки)
	
	Результат = НовыйДанныеНастройки(ПредметыНастройки);
	
	УсловияРасчетовПоУмолчанию = Новый Структура;
	УсловияРасчетовПоУмолчанию.Вставить("ВалютаВзаиморасчетов",     Справочники.Валюты.ПустаяСсылка());
	УсловияРасчетовПоУмолчанию.Вставить("РасчетыВУсловныхЕдиницах", Ложь);
	
	Для Индекс = 0 По Результат.ВГраница() Цикл
		Результат[Индекс] = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(УсловияРасчетовПоУмолчанию);
	КонецЦикла;
	
	// По реквизитам договора определим условия расчетов.
	// См. также ОпределениеВидаРасчетовПоПараметрамДоговора()
	Если Не БухгалтерскийУчетПереопределяемый.ИспользоватьВалютныйУчет() Тогда
		
		// Разных условий быть не может, от реквизитов договоров условия не зависят
		Возврат Результат;
		
	КонецЕсли;
		
	Договоры = ПредметыНастройки.ВыгрузитьКолонку("ДоговорКонтрагента");
	
	Если Договоры.Количество() = 0 
		Или ТипЗнч(Договоры[0]) <> Тип("СправочникСсылка.ДоговорыКонтрагентов") Тогда
	
		// Реквизиты получить не можем
	
		Возврат Результат;
	
	КонецЕсли;
	
	ИменаПолей = "ВалютаВзаиморасчетов, РасчетыВУсловныхЕдиницах"; // Совпадают с элементами Условия
	ЗначенияРеквизитов = ОбщегоНазначения.ЗначенияРеквизитовОбъектов(Договоры, ИменаПолей);
	
	ДополнитьМассивНастроекЭлементамиСоответствияПоПростомуКлючу(Результат, ЗначенияРеквизитов, "ДоговорКонтрагента", ПредметыНастройки);
	
	Возврат Результат;
	
КонецФункции

Функция ПроверятьСоответствиеСчетаВалютеДоговора(Правило, КешОбщихЗначений = Неопределено)
	
	Если Не ОбщееЗначение(КешОбщихЗначений, "ИспользоватьВалютныйУчет") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	МетодЗаполнения = МетодЗаполнения(Правило);
	Возврат (МетодЗаполнения = "Расчеты" Или МетодЗаполнения = "РасчетыПоЛизингу");
	
КонецФункции

Функция ОшибкаСоответствияСчетаВалютеДоговора(Параметры)
	
	Если Не ПроверятьСоответствиеСчетаВалютеДоговора(Параметры.Правило, Параметры.КешОбщихЗначений) Тогда
		Возврат "";
	КонецЕсли;
	
	УсловияРасчетов = ДанныеНастройкиЭлементаКоллекции(
		"УсловияРасчетов",
		Параметры.ПланВыполнения,
		Параметры.НастройкиЭлемента);
	Если УсловияРасчетов = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(УсловияРасчетов.ВалютаВзаиморасчетов) Тогда
		Возврат "";
	КонецЕсли;
	
	ВалютаРегламентированногоУчета = ОбщееЗначение(Параметры.КешОбщихЗначений, "ВалютаРегламентированногоУчета");
	ВалютныйДоговор = (УсловияРасчетов.ВалютаВзаиморасчетов <> ВалютаРегламентированногоУчета);
	ВалютныйСчет    = Параметры.Элемент[Параметры.Правило.Реквизит].Валютный;
	
	Если Не ВалютныйДоговор Тогда
		// Вести расчеты в рублях на счетах, предназначенных для учета расчетов в валюте, не запрещено.
		Возврат "";
	КонецЕсли;
	
	Если ВалютныйСчет Тогда
		// Счет и договор соответствуют друг другу - оба валютные
		Возврат "";
	КонецЕсли;
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = 'Для договора с расчетами в %1 указан счет, не предназначенный для учета расчетов в валюте.'"),
		УсловияРасчетов.ВалютаВзаиморасчетов);
	
КонецФункции

#КонецОбласти

#Область ОбъектыСтроительства
	
Процедура ЗаполнитьПоОбъектамСтроительства(Параметры)
	
	Параметры.ЗначениеПоУмолчанию = ПланыСчетов.Хозрасчетный.ОсновнойСчет(Параметры.Правило.Роль);
	
	Настройка = ДанныеНастройкиЭлементаКоллекции("СчетаУчетаОбъектовСтроительства", Параметры);
	
	Если Настройка <> Неопределено Тогда
		Параметры.Значение = Настройка.СчетУчета;
	КонецЕсли;
		
КонецПроцедуры
	
Функция ДанныеНастройкиСчетаУчетаОбъектовСтроительства(ПредметыНастройки)
		
	Результат = НовыйДанныеНастройки(ПредметыНастройки);
		
	// Получаем настройки для каждой строки отдельно
	// Можно оптимизировать и получать настройки скопом для всех строк.
	// Но так как таких строк мало, то большого выигрыша от этой оптимизации не ожидаем.
	
	Для Каждого ПредметНастройки Из ПредметыНастройки Цикл
		
		СчетаУчетаОбъектаСтроительства = БухгалтерскийУчетПереопределяемый.СчетаУчетаОбъектовСтроительства(
			ПредметНастройки.Организация,
			ПредметНастройки.ОбъектСтроительства);
			
		ИндексПредметаНастройки = ПредметыНастройки.Индекс(ПредметНастройки);
		Результат[ИндексПредметаНастройки] = СчетаУчетаОбъектаСтроительства;
	
	КонецЦикла;
		
	Возврат Результат;
		
КонецФункции

#КонецОбласти

#Область Деньги
Процедура ЗаполнитьДеньги(Параметры)
	
	Роль = Параметры.Правило.Роль;
	
	Параметры.ЗначениеПоУмолчанию = ПланыСчетов.Хозрасчетный.ОсновнойСчет(Роль);
	
	ПереводНаДругойСчет = Неопределено;
	Если Параметры.ПланВыполнения.ДанныеЗаполнения.Свойство("ПереводНаДругойСчет", ПереводНаДругойСчет)
		И ПереводНаДругойСчет Тогда
		СчетКонтрагента = ЗначениеРеквизитаЭлементаКоллекции(
			Параметры.Элемент,
			Параметры.Правило.ИсточникиДанных.РеквизитыОбъекта,
			"БанковскийСчет");
		Если ЗначениеЗаполнено(СчетКонтрагента) Тогда
			СвойстваБанковскогоСчета = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(СчетКонтрагента,
				"СчетКорпоративныхРасчетов, СчетБанк");
			Если СвойстваБанковскогоСчета.СчетКорпоративныхРасчетов И ЗначениеЗаполнено(СвойстваБанковскогоСчета.СчетБанк) Тогда
				Параметры.Значение = СвойстваБанковскогоСчета.СчетБанк;
				Возврат;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗаполнитьПоОснованию(Параметры) Тогда
		Возврат;
	КонецЕсли;
	
	ОплатаВВалюте = Ложь;
	Если ОбщееЗначение(Параметры.КешОбщихЗначений, "ИспользоватьВалютныйУчет") Тогда
		
		ВалютаДокумента = Неопределено;
		Параметры.ПланВыполнения.ДанныеЗаполнения.Свойство("ВалютаДокумента", ВалютаДокумента);
		
		Если ВалютаДокумента = Неопределено Тогда
			ВалютаДокумента = ЗначениеРеквизитаЭлементаКоллекции(Параметры.Элемент, Параметры.Правило.ИсточникиДанных.РеквизитыОбъекта, "Валюта");
		КонецЕсли;
		
		ВалютаРегламентированногоУчета = ОбщееЗначение(Параметры.КешОбщихЗначений, "ВалютаРегламентированногоУчета");
		ОплатаВВалюте = ЗначениеЗаполнено(ВалютаДокумента) И ВалютаДокумента <> ВалютаРегламентированногоУчета;
		
		ПриобретениеИностраннойВалюты = Ложь;
		Если Параметры.ПланВыполнения.ДанныеЗаполнения.Свойство("ПриобретениеИностраннойВалюты", ПриобретениеИностраннойВалюты)
			И ЗначениеЗаполнено(ПриобретениеИностраннойВалюты) Тогда
			ОплатаВВалюте = ОплатаВВалюте ИЛИ ПриобретениеИностраннойВалюты;
		КонецЕсли;
		
		Если ОплатаВВалюте Тогда
			Параметры.Значение = ПланыСчетов.Хозрасчетный.ОсновнойСчет(Роль + "ВВалюте");
		Иначе
			Параметры.Значение = Параметры.ЗначениеПоУмолчанию;
		КонецЕсли;
		
	КонецЕсли;
	
	СчетОрганизации = ЗначениеРеквизитаЭлементаКоллекции(
		Параметры.Элемент,
		Параметры.Правило.ИсточникиДанных.РеквизитыОбъекта,
		"СчетОрганизации");
	
	Если ЗначениеЗаполнено(СчетОрганизации) Тогда
		СвойстваБанковскогоСчета = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(СчетОрганизации,
			"СчетКорпоративныхРасчетов, СчетБанк");
		Если СвойстваБанковскогоСчета.СчетКорпоративныхРасчетов И ЗначениеЗаполнено(СвойстваБанковскогоСчета.СчетБанк) Тогда
			Параметры.Значение = СвойстваБанковскогоСчета.СчетБанк;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция ЭтоСубконтоСтатьяДвиженияДенежныхСредств(Роль)
	
	Возврат Роль = "СубконтоСтатьяДвиженияДенежныхСредств1" 
		Или Роль = "СубконтоСтатьяДвиженияДенежныхСредств2" 
		Или Роль = "СубконтоСтатьяДвиженияДенежныхСредств3";
	
КонецФункции

Процедура ЗаполнитьСубконтоСтатьяДвиженияДенежныхСредств(Параметры)
	
	КоличествоСубконто = 3;
	
	// Определим НомерСубконто
	Для НомерСубконто = 1 По КоличествоСубконто + 1 Цикл
		Если Параметры.Правило.Роль = "СубконтоСтатьяДвиженияДенежныхСредств" + НомерСубконто Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если НомерСубконто > КоличествоСубконто Тогда
		Возврат;
	КонецЕсли;
	
	// Убедимся, что можем пытаться заполнять
	СвойстваСчета = СвойстваСчетаОтВладельца(Параметры.ВходящееСообщение);
	
	Если СвойстваСчета = Неопределено Или НомерСубконто > СвойстваСчета.КоличествоСубконто Тогда
		Параметры.Очистить = Истина;
		Возврат;
	КонецЕсли;
		
	ВидСубконто = СвойстваСчета["ВидСубконто" + НомерСубконто];
	ТипЗначения = СвойстваСчета["ВидСубконто" + НомерСубконто + "ТипЗначения"];
	
	// Значение из основания
	Если ВидСубконто <> ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.СтатьиДвиженияДенежныхСредств Тогда
		Возврат;
	КонецЕсли;
	
	Параметры.ЗначениеПоУмолчанию = ТипЗначения.ПривестиЗначение(Неопределено);
	
	// Проверим, подойдет ли переданное значение. Оно может содержаться как в "общих" данных заполнения, так и в реквизитах элемента коллекции
	ПереданноеЗначение = ЗначениеРеквизитаЭлементаКоллекции(Параметры.Элемент, Параметры.Правило.ИсточникиДанных.РеквизитыОбъекта, "СтатьяДвиженияДенежныхСредств");
	Если ПереданноеЗначение = Неопределено Тогда
		ПереданноеЗначение = Параметры.ПланВыполнения.ДанныеЗаполнения.СтатьяДвиженияДенежныхСредств;
	КонецЕсли;
	СтатьяДвиженияДенежныхСредств = ТипЗначения.ПривестиЗначение(ПереданноеЗначение);
	Если СтатьяДвиженияДенежныхСредств = ПереданноеЗначение Тогда
		// Подходит
		Параметры.Значение = СтатьяДвиженияДенежныхСредств;
		Возврат;
	КонецЕсли;
	
	// Попробуем сохранить текущее значение
	ТекущееЗначение = Параметры.Элемент[Параметры.Правило.Реквизит];
	Параметры.Значение = ТипЗначения.ПривестиЗначение(ТекущееЗначение);
	
КонецПроцедуры

Процедура ЗаполнитьЗначениеСубконтоНоменклатурнаяГруппа(Параметры)

	Параметры.ЗначениеПоУмолчанию = Справочники.НоменклатурныеГруппы.ПустаяСсылка();
	
	Параметры.Значение = БухгалтерскийУчетВызовСервераПовтИсп.ОсновнаяНоменклатурнаяГруппа();
	
	Если ЗначениеЗаполнено(Параметры.Значение) Тогда
		Возврат;
	КонецЕсли;
	
	// Проверим, подойдет ли текущее значение
	ТекущееЗначение = Параметры.Элемент[Параметры.Правило.Реквизит];
	Если ЗначениеЗаполнено(ТекущееЗначение) И ТипЗнч(ТекущееЗначение) = Тип("СправочникСсылка.НоменклатурныеГруппы") Тогда
		Параметры.Значение = ТекущееЗначение;
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область Налоги

Процедура ЗаполнитьНалоги(Параметры)
	
	Роль = Параметры.Правило.Роль;
	
	Параметры.ЗначениеПоУмолчанию = ПланыСчетов.Хозрасчетный.ОсновнойСчет(Роль);
	
	Если ЗаполнитьПоОснованию(Параметры) Тогда
		Возврат;
	КонецЕсли;
	
	Налог = ЗначениеРеквизитаЭлементаКоллекции(Параметры.Элемент, Параметры.Правило.ИсточникиДанных.РеквизитыОбъекта, "Налог");
	Если ЗначениеЗаполнено(Налог) Тогда
		Параметры.Значение = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Налог, "СчетУчета");
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьСубконтоНалогов(Параметры)
	
	КоличествоСубконто = 3;
	
	// Определим НомерСубконто
	Для НомерСубконто = 1 По КоличествоСубконто + 1 Цикл
		Если Параметры.Правило.Роль = "СубконтоНалогов" + НомерСубконто Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если НомерСубконто > КоличествоСубконто Тогда
		Возврат;
	КонецЕсли;
	
	// Убедимся, что можем пытаться заполнять
	СвойстваСчета = СвойстваСчетаОтВладельца(Параметры.ВходящееСообщение);
	
	Если СвойстваСчета = Неопределено Или НомерСубконто > СвойстваСчета.КоличествоСубконто Тогда
		Параметры.Очистить = Истина;
		Возврат;
	КонецЕсли;
	
	ВидСубконто = СвойстваСчета["ВидСубконто" + НомерСубконто];
	ТипЗначения = СвойстваСчета["ВидСубконто" + НомерСубконто + "ТипЗначения"];
	
	Если ВидСубконто = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.ВидыПлатежейВГосБюджет Тогда
		
		Параметры.ЗначениеПоУмолчанию = Перечисления.ВидыПлатежейВГосБюджет.Налог;
		Параметры.Очистить = Истина;
		
		ВидНалоговогоОбязательства = ЗначениеРеквизитаЭлементаКоллекции(Параметры.Элемент, Параметры.Правило.ИсточникиДанных.РеквизитыОбъекта, "ВидНалоговогоОбязательства");
		
		ТекущееЗначение = Перечисления.ВидыПлатежейВГосБюджет.ВидПлатежа(ВидНалоговогоОбязательства);
		
	ИначеЕсли ВидСубконто = ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные.УровниБюджетов Тогда
		
		Параметры.ЗначениеПоУмолчанию = ТипЗначения.ПривестиЗначение(Неопределено);
		
		ТекущееЗначение = ДанныеНастройкиЭлементаКоллекции("УровеньБюджета", Параметры);
		
	Иначе
		
		Возврат;
		
	КонецЕсли;
	
	Параметры.Значение = ТипЗначения.ПривестиЗначение(ТекущееЗначение);
	
КонецПроцедуры

Функция ДанныеНастройкиУровеньБюджета(ПредметыНастройки)
	
	Результат = НовыйДанныеНастройки(ПредметыНастройки);
	Для Каждого ПредметНастройки Из ПредметыНастройки Цикл
		
		ЗначениеНастройки = Справочники.ВидыНалоговИПлатежейВБюджет.УровеньБюджета(ПредметНастройки.Налог);
		
		Индекс = ПредметыНастройки.Индекс(ПредметНастройки);
		Результат[Индекс] = ЗначениеНастройки;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура ЗаполнитьСубконтоРегистрацияВНалоговомОргане(Параметры)
	
	Если Не НалоговыйУчет.УчетВРазрезеНалоговыхОрганов() Тогда
		Возврат;
	КонецЕсли;
	
	КоличествоСубконто = 3;
	
	// Определим НомерСубконто
	Для НомерСубконто = 1 По КоличествоСубконто + 1 Цикл
		Если Параметры.Правило.Роль = "СубконтоРегистрацияВНалоговомОргане" + НомерСубконто Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если НомерСубконто > КоличествоСубконто Тогда
		Возврат;
	КонецЕсли;
	
	// Убедимся, что можем пытаться заполнять
	СвойстваСчета = СвойстваСчетаОтВладельца(Параметры.ВходящееСообщение);
	
	Если СвойстваСчета = Неопределено Или НомерСубконто > СвойстваСчета.КоличествоСубконто Тогда
		Параметры.Очистить = Истина;
		Возврат;
	КонецЕсли;
	
	ВидСубконто = СвойстваСчета["ВидСубконто" + НомерСубконто];
	ТипЗначения = СвойстваСчета["ВидСубконто" + НомерСубконто + "ТипЗначения"];
	
	// Значение из основания
	Если ВидСубконто <> ПланыВидовХарактеристик.ВидыСубконтоХозрасчетные["РегистрацияВНалоговомОргане"] Тогда
		Возврат;
	КонецЕсли;
	
	Параметры.ЗначениеПоУмолчанию = ТипЗначения.ПривестиЗначение(Неопределено);
	
	ТекущееЗначение = ДанныеНастройкиЭлементаКоллекции("РегистрацияВНалоговомОргане", Параметры);
	
	Параметры.Значение = ТипЗначения.ПривестиЗначение(ТекущееЗначение);
	
КонецПроцедуры

Функция ДанныеНастройкиРегистрацияВНалоговомОргане(ПредметыНастройки)
	
	Результат = НовыйДанныеНастройки(ПредметыНастройки);
	Для Каждого ПредметНастройки Из ПредметыНастройки Цикл
		
		Если Не ПроверитьСтандартныеТипы(ПредметНастройки, "Организация, Контрагент") Тогда
			Продолжить;
		КонецЕсли;
		
		ЗначениеНастройки = Справочники.РегистрацииВНалоговомОргане.НайтиРегистрациюВНалоговомОргане(ПредметНастройки.Организация, ПредметНастройки.Контрагент);
		
		// В одном налоговом органе организация может стоять на учете дважды, по двум основаниям.
		// По контрагенту будет найдена "основная" регистрация, чтобы найти другое основание, выполним поиск по КПП.
		Если ЗначениеЗаполнено(ЗначениеНастройки)
			И НЕ ПустаяСтрока(ПредметНастройки.КПППлательщика) И ПредметНастройки.КПППлательщика <> ЗначениеНастройки.КПП Тогда
			РегистрацияПоКПП = Справочники.РегистрацииВНалоговомОргане.НайтиПоКПП(ПредметНастройки.Организация, ПредметНастройки.КПППлательщика);
			Если ЗначениеЗаполнено(РегистрацияПоКПП) Тогда
				ЗначениеНастройки = РегистрацияПоКПП;
			КонецЕсли;
		КонецЕсли;
		
		Индекс = ПредметыНастройки.Индекс(ПредметНастройки);
		Результат[Индекс] = ЗначениеНастройки;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ЭтоСубконтоРегистрацияВНалоговомОргане(Роль)
	
	Возврат Роль = "СубконтоРегистрацияВНалоговомОргане1" 
		Или Роль = "СубконтоРегистрацияВНалоговомОргане2" 
		Или Роль = "СубконтоРегистрацияВНалоговомОргане3";
	
КонецФункции

#КонецОбласти

#Область КредитыИЗаймы

Процедура ЗаполнитьПолученныеКредитыЗаймы(Параметры)
	
	Роль = Параметры.Правило.Роль;
	
	// Счет зависит от трех параметров:
	
	// 1. ДолгосрочныйДоговор
	ДолгосрочныйДоговор = ДанныеНастройкиЭлементаКоллекции("ДолгосрочныйДоговор", Параметры.ПланВыполнения, Параметры.НастройкиЭлемента);
	
	// 2. ПлатежВВалюте
	ВалютаДокумента = Параметры.ПланВыполнения.ДанныеЗаполнения.ВалютаДокумента;
	Если ВалютаДокумента = Неопределено Тогда
		ВалютаДокумента = ЗначениеРеквизитаЭлементаКоллекции(Параметры.Элемент, Параметры.Правило.ИсточникиДанных.РеквизитыОбъекта, "Валюта")
	КонецЕсли;
	ВалютаРегламентированногоУчета = ОбщееЗначение(Параметры.КешОбщихЗначений, "ВалютаРегламентированногоУчета");
	ПлатежВВалюте = ЗначениеЗаполнено(ВалютаДокумента) И ВалютаДокумента <> ВалютаРегламентированногоУчета;
		
	// 3. ЭтоТелоКредитаЗайма
	ВидПлатежаПоКредитамЗаймам = ЗначениеРеквизитаЭлементаКоллекции(
		Параметры.Элемент,
		Параметры.Правило.ИсточникиДанных.РеквизитыОбъекта,
		"ВидПлатежаПоКредитамЗаймам");
		
	Если Не ЗначениеЗаполнено(ВидПлатежаПоКредитамЗаймам) Тогда
		ЭтоТелоКредитаЗайма = Истина;
	Иначе
		ЭтоТелоКредитаЗайма = (ВидПлатежаПоКредитамЗаймам <> Перечисления.ВидыПлатежейПоКредитамЗаймам.УплатаПроцентов);
	КонецЕсли;
	
	// Выбор счета
	Если Роль = "ПолученныеКредиты" Тогда
		
		Если ЭтоТелоКредитаЗайма Тогда
			Если ПлатежВВалюте Тогда
				Если ДолгосрочныйДоговор Тогда
					Параметры.Значение = ПланыСчетов.Хозрасчетный.ДолгосрочныеКредитыВал;
				Иначе
					Параметры.Значение = ПланыСчетов.Хозрасчетный.КраткосрочныеКредитыВал;
				КонецЕсли;
			Иначе
				Если ДолгосрочныйДоговор Тогда
					Параметры.Значение = ПланыСчетов.Хозрасчетный.ДолгосрочныеКредиты;
				Иначе
					Параметры.Значение = ПланыСчетов.Хозрасчетный.КраткосрочныеКредиты;
				КонецЕсли;
			КонецЕсли;
		Иначе // Проценты
			Если ПлатежВВалюте Тогда
				Если ДолгосрочныйДоговор Тогда
					Параметры.Значение = ПланыСчетов.Хозрасчетный.ПроцентыПоДолгосрочнымКредитамВал;
				Иначе
					Параметры.Значение = ПланыСчетов.Хозрасчетный.ПроцентыПоКраткосрочнымКредитамВал;
				КонецЕсли;
			Иначе
				Если ДолгосрочныйДоговор Тогда
					Параметры.Значение = ПланыСчетов.Хозрасчетный.ПроцентыПоДолгосрочнымКредитам;
				Иначе
					Параметры.Значение = ПланыСчетов.Хозрасчетный.ПроцентыПоКраткосрочнымКредитам;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
				
	Иначе // Займы
		
		Если ЭтоТелоКредитаЗайма Тогда
			Если ПлатежВВалюте Тогда
				Если ДолгосрочныйДоговор Тогда
					Параметры.Значение = ПланыСчетов.Хозрасчетный.ДолгосрочныеЗаймыВал;
				Иначе
					Параметры.Значение = ПланыСчетов.Хозрасчетный.КраткосрочныеЗаймыВал;
				КонецЕсли;
			Иначе
				Если ДолгосрочныйДоговор Тогда
					Параметры.Значение = ПланыСчетов.Хозрасчетный.ДолгосрочныеЗаймы;
				Иначе
					Параметры.Значение = ПланыСчетов.Хозрасчетный.КраткосрочныеЗаймы;
				КонецЕсли;
			КонецЕсли;
		Иначе // Проценты
			Если ПлатежВВалюте Тогда
				Если ДолгосрочныйДоговор Тогда
					Параметры.Значение = ПланыСчетов.Хозрасчетный.ПроцентыПоДолгосрочнымЗаймамВал;
				Иначе
					Параметры.Значение = ПланыСчетов.Хозрасчетный.ПроцентыПоКраткосрочнымЗаймамВал;
				КонецЕсли;
			Иначе
				Если ДолгосрочныйДоговор Тогда
					Параметры.Значение = ПланыСчетов.Хозрасчетный.ПроцентыПоДолгосрочнымЗаймам;
				Иначе
					Параметры.Значение = ПланыСчетов.Хозрасчетный.ПроцентыПоКраткосрочнымЗаймам;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли; // Роль
	
КонецПроцедуры

Функция ДанныеНастройкиДолгосрочныйДоговор(ПредметыНастройки)
	
	// Долгосрочными считаем договоры, заключенные на срок более 12 месяцев
	
	Результат = НовыйДанныеНастройки(ПредметыНастройки);
	
	ЗначенияПоля = ВыгрузитьЗначения(ПредметыНастройки, "ДоговорКонтрагента", Тип("СправочникСсылка.ДоговорыКонтрагентов"));
	
	ЗначенияРеквизитовВсехДоговоров = ОбщегоНазначения.ЗначенияРеквизитовОбъектов(ЗначенияПоля, "Дата, СрокДействия");
	
	Для Каждого ПредметНастройки Из ПредметыНастройки Цикл
		
		СвойстваДоговора = ЗначенияРеквизитовВсехДоговоров[ПредметНастройки.ДоговорКонтрагента];
		Если СвойстваДоговора = Неопределено
			Или Не ЗначениеЗаполнено(СвойстваДоговора.Дата)
			Или Не ЗначениеЗаполнено(СвойстваДоговора.СрокДействия) Тогда
			ДолгосрочныйДоговор = Истина;
		Иначе
			МаксимальныйСрокКраткосрочногоДоговора = НачалоДня(ДобавитьМесяц(СвойстваДоговора.Дата, 12) - 1);
			ДолгосрочныйДоговор = (МаксимальныйСрокКраткосрочногоДоговора < СвойстваДоговора.СрокДействия);
		КонецЕсли;
		
		Индекс = ПредметыНастройки.Индекс(ПредметНастройки);
		Результат[Индекс] = ДолгосрочныйДоговор;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область СпособОтраженияРасходовПоАмортизации

Процедура ЗаполнитьСпособОтраженияРасходовПоАмортизации(Параметры);
	
	Параметры.Значение = ДанныеНастройкиЭлементаКоллекции("СпособОтраженияРасходовПоАмортизации", Параметры);
	
КонецПроцедуры

Функция ДанныеНастройкиСпособОтраженияРасходовПоАмортизации(ПредметыНастройки)
	
	Результат = НовыйДанныеНастройки(ПредметыНастройки);
		
	// Получаем настройки для каждой строки отдельно
	// Можно оптимизировать и получать настройки скопом для всех строк.
	// Но так как таких строк мало, то большого выигрыша от этой оптимизации не ожидаем.
	
	Для Каждого ПредметНастройки Из ПредметыНастройки Цикл
		
		СпособОтраженияРасходовПоАмортизации = УчетОС.СпособОтраженияРасходовПоАмортизации(
			ПредметНастройки.МестонахождениеОС,
			ПредметНастройки.Организация,
			ПредметНастройки.Дата
			);
			
		ИндексПредметаНастройки = ПредметыНастройки.Индекс(ПредметНастройки);
		Результат[ИндексПредметаНастройки] = СпособОтраженияРасходовПоАмортизации;
	
	КонецЦикла;
		
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область Служебные

#Область ДляИспользованияВПрикладныхАлгоритмах

Функция ДанныеНастройкиЭлементаКоллекции(ИмяНастройки, ВыполнениеПравилаИлиВсеПараметры, ПараметрНастройкиЭлемента = Неопределено)
	
	Если ТипЗнч(ВыполнениеПравилаИлиВсеПараметры) = Тип("Структура") Тогда
		ПланВыполнения    = ВыполнениеПравилаИлиВсеПараметры.ПланВыполнения;
		НастройкиЭлемента = ВыполнениеПравилаИлиВсеПараметры.НастройкиЭлемента;
	Иначе
		ПланВыполнения    = ВыполнениеПравилаИлиВсеПараметры;
		НастройкиЭлемента = ПараметрНастройкиЭлемента;
	КонецЕсли;
	
	ИдентификаторНастройки = ПланВыполнения.Настройки[ИмяНастройки].Идентификатор;
	
	Возврат НастройкиЭлемента[ИдентификаторНастройки];
	
КонецФункции

Функция ЗаполнитьПоОснованию(Параметры)
	
	Основание = ЗначениеРеквизитаЭлементаКоллекции(Параметры.Элемент, Параметры.Правило.ИсточникиДанных.РеквизитыОбъекта, "Основание");
	
	Если Не ЗначениеЗаполнено(Основание) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Параметры.Значение = Основание;
	Возврат Истина;
	
КонецФункции

Функция ЗаполненРеквизитКоллекции(Коллекция, ОписаниеРеквизитовКоллекции, РольРеквизита)
	
	// Возвращаемое значение описано в ПроверитьУсловиеПоКоллекции()
	
	ИмяРеквизита = ИмяРеквизитаКоллекции(ОписаниеРеквизитовКоллекции, РольРеквизита);
	Если Не ЗначениеЗаполнено(ИмяРеквизита) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Массив;
	Для Каждого ЭлементКоллекции Из Коллекция Цикл
		
		Если Не ЕстьСвойствоСтруктуры(ЭлементКоллекции, ИмяРеквизита) Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Значение = ЗначениеЗаполнено(ЭлементКоллекции[ИмяРеквизита]);
		Результат.Добавить(Значение);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ЗначениеРеквизитаЭлементаКоллекции(ЭлементКоллекции, ОписаниеРеквизитовКоллекции, ИмяДанных)
	
	ИмяРеквизита = ИмяРеквизитаКоллекции(ОписаниеРеквизитовКоллекции, ИмяДанных);
	
	Если ИмяРеквизита = Неопределено Тогда
		Возврат Неопределено;
	ИначеЕсли Не ЕстьСвойствоСтруктуры(ЭлементКоллекции, ИмяРеквизита) Тогда
		Возврат Неопределено;
	Иначе
		Возврат ЭлементКоллекции[ИмяРеквизита];
	КонецЕсли;
	
КонецФункции

Функция ВыгрузитьЗначения(КоллекцияСтрок, ИмяКолонки, ТипЗначений = Неопределено)
	
	// В отличие от ОбщегоНазначения.ВыгрузитьКолонку фильтруем значения по типу
	
	МассивЗначений = Новый Массив;
	
	Для Каждого СтрокаКоллекции Из КоллекцияСтрок Цикл
		Значение = СтрокаКоллекции[ИмяКолонки];
		Если ТипЗначений <> Неопределено И ТипЗнч(Значение) <> ТипЗначений Тогда
			Продолжить;
		КонецЕсли;
		МассивЗначений.Добавить(Значение);
	КонецЦикла; 
	
	Возврат МассивЗначений;
	
КонецФункции

Функция ПроверитьСтандартныеТипы(КоллекцияСвойств, ИменаСвойствСтрокой)
	
	ИменаСвойств = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаСвойствСтрокой,,Истина,Истина);
	Для Каждого ИмяСвойства Из ИменаСвойств Цикл
		
		Если ИмяСвойства = "Организация" Тогда
			ДопустимыйТип = Новый ОписаниеТипов("СправочникСсылка.Организации");
		ИначеЕсли ИмяСвойства = "Контрагент" Тогда
			ДопустимыйТип = Новый ОписаниеТипов("СправочникСсылка.Контрагенты");
		ИначеЕсли ИмяСвойства = "Дата" Тогда
			ДопустимыйТип = Новый ОписаниеТипов("Дата");
		Иначе
			Возврат Ложь;
		КонецЕсли;
		
		Значение = КоллекцияСвойств[ИмяСвойства];
		Если Не ДопустимыйТип.СодержитТип(ТипЗнч(Значение)) Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

#Область ИерархияПравил

Функция ВладелецПравила(Правило)
	
	Если Правило.Владелец = -1 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Правило.Владелец()[Правило.Владелец];
	
КонецФункции

Функция ИндексВладельцаПравила(Правило)
	
	Если Правило.Владелец = -1 Тогда 
		Возврат Неопределено;
	КонецЕсли;
	Возврат Правило.Владелец;
	
КонецФункции

Функция СвойствоВладельцаПравила(Правило, ИмяСвойства)
	
	Владелец = ВладелецПравила(Правило);
	
	Если Владелец = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Владелец[ИмяСвойства];
	
КонецФункции

Функция ПодчиненныеПравила(Правило)
	
	ВсеПравила = Правило.Владелец();
	
	Отбор = Новый Структура;
	Отбор.Вставить("Владелец", ВсеПравила.Индекс(Правило));
	
	Возврат ВсеПравила.НайтиСтроки(Отбор);
	
КонецФункции

Функция СчетВладелец(ВходящееСообщение)
	
	Если ВходящееСообщение.Свойство("Владелец") Тогда
		Счет = ВходящееСообщение.Владелец;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Если ТипЗнч(Счет) <> Тип("ПланСчетовСсылка.Хозрасчетный") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат Счет;
	
КонецФункции

Функция СвойстваСчетаОтВладельца(ВходящееСообщение)
	
	Счет = СчетВладелец(ВходящееСообщение);
	Если Не ЗначениеЗаполнено(Счет) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИмяСвойств = "СвойстваСчетаВладельца";
	Если Не ВходящееСообщение.Свойство(ИмяСвойств) Тогда
		СвойстваСчета = БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(Счет);
		ВходящееСообщение.Вставить(ИмяСвойств, СвойстваСчета);
	КонецЕсли;
	
	Возврат ВходящееСообщение[ИмяСвойств];
	
КонецФункции

#КонецОбласти

#Область ПланыВыполненияПравил

Функция ПланыВыполненияПравил(Правила, ДанныеЗаполнения, Режим, ЗаполняемыйОбъект = Неопределено, Отбор = Неопределено)
	
	// Для заполнения используем 
	// - исходные (внешние) данные "как есть"
	// - настройки, полученные с учетом исходных данных.
	// (внешние данные хранятся в ДанныеЗаполнения)
	//
	// Данные заполнения для каждого правила могут отличаться: для разных правил могут использоваться 
	// - разные источники данных для заполнения
	// - разные настройки 
	// - разные источники данных для настроек
	//
	// Также может оказаться, что отдельные правила выполнять не нужно вообще.
	//
	// Поэтому готовим коллекцию ПланыВыполненияПравил, в которой для каждого правила будут лежать данные, нужные для его выполнения.
	// План выполнения, в частности, включает
	// - настройки
	// - исходные данные
	// - признак, что правило нужно пропустить
	
	ПланыВыполнения = Новый ТаблицаЗначений;
	ПланыВыполнения.Колонки.Добавить("ИндексПравила",                    Новый ОписаниеТипов("Число"));
	ПланыВыполнения.Колонки.Добавить("СоответствуетКонтексту",           Новый ОписаниеТипов("Булево")); // Если хотя бы один элемент соответствует, то и правило в целом соответствует.
	ПланыВыполнения.Колонки.Добавить("ЭлементыНеСоответствуютКонтексту", Новый ОписаниеТипов("Массив")); // Хранит индексы элементов коллекции.
	ПланыВыполнения.Колонки.Добавить("СоответствуетОтбору",              Новый ОписаниеТипов("Булево"));
	ПланыВыполнения.Колонки.Добавить("Настройки",                        Новый ОписаниеТипов("Структура"));
	ПланыВыполнения.Колонки.Добавить("ДанныеЗаполнения",                 Новый ОписаниеТипов("Структура"));
	ПланыВыполнения.Индексы.Добавить("ИндексПравила");
	
	ОднаКоллекция         = (Режим = "ЗаполнениеКоллекции") Или (ЗаполняемыйОбъект = Неопределено);
	ДляЗаполнения         = (Режим = "Заполнение" Или Режим = "ЗаполнениеКоллекции");
	ДляПроверкиЗаполнения = (Режим = "ПроверкаЗаполнения");
	
	// Сначала проверим соответствие отбору.
	
	// Для этого понадобятся сведения о заполняемой коллекции.
	// Они понадобятся и далее.
	// Поэтому закешируем их.
	КоллекцииПравил = Новый Массив(Правила.ПравилаЗаполнения.Количество());
	
	Для Каждого Правило Из Правила.ПравилаЗаполнения Цикл
		
		ПланВыполнения = ПланыВыполнения.Добавить();
		ПланВыполнения.ИндексПравила = Правила.ПравилаЗаполнения.Индекс(Правило);
		
		// Разные правила могут работать с разными коллекциями
		Если ОднаКоллекция Тогда
			Коллекция = ЗаполняемыйОбъект;
		Иначе
			Если ПустаяСтрока(Правило.ТабличнаяЧасть) Тогда
				Коллекция = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ЗаполняемыйОбъект);
			Иначе
				Коллекция = ЗаполняемыйОбъект[Правило.ТабличнаяЧасть];
				Если Коллекция.Количество() = 0 Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
		КоллекцииПравил[ПланВыполнения.ИндексПравила] = Коллекция;
		
		// Проверим соответствие отбору
		ПланВыполнения.СоответствуетОтбору = ПравилоСоответствуетОтбору(Правило, Отбор, Коллекция, Правила.КешОбщихЗначений);
		Если Не ПланВыполнения.СоответствуетОтбору Тогда
			Продолжить;
		КонецЕсли;
		
		// Пока соответствие контексту еще не проверили. Но устанавливаем флаг, как сигнал, что следует проверить.
		ПланВыполнения.СоответствуетКонтексту = Истина;
		// Также следует проверить соответствие контекста и у владельца (и у всех его владельцев).
		// Соответствующие владельцу (владельцам) планы выполнения уже были добавлены.
		ИндексВладельцаПравила = ИндексВладельцаПравила(Правило);
		Пока ИндексВладельцаПравила <> Неопределено И ПланВыполнения.ИндексПравила <> ИндексВладельцаПравила Цикл // Неравенство индексов проверяем, чтобы исключить зацикливание
			ПланВыполненияВладельца = ПланыВыполнения.Найти(ИндексВладельцаПравила, "ИндексПравила");
			ПланВыполненияВладельца.СоответствуетКонтексту = Истина;
			ИндексВладельцаПравила = ИндексВладельцаПравила(Правила.ПравилаЗаполнения[ПланВыполненияВладельца.ИндексПравила]);
		КонецЦикла;
		
	КонецЦикла;
	
	// Затем выполним остальные действия для составления плана выполнения
	ДанныеНастроек  = Новый Соответствие; // Ключ - идентификатор настройки. Отдельная коллекция нужна, так как у разных правил могут быть одинаковые настройки.
	Для Каждого ПланВыполнения Из ПланыВыполнения Цикл
		
		Правило = Правила.ПравилаЗаполнения[ПланВыполнения.ИндексПравила];
		
		ПроверенныеУсловия = Новый Структура;
		
		Если Не ПланВыполнения.СоответствуетКонтексту Тогда
			Продолжить;
		КонецЕсли;
		
		Коллекция = КоллекцииПравил[ПланВыполнения.ИндексПравила];
		Если Коллекция = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		// Проверим соответствие контекста по владельцу
		ПланВыполненияВладельца = Неопределено;
		ИндексВладельцаПравила = ИндексВладельцаПравила(Правило);
		Если ИндексВладельцаПравила <> Неопределено Тогда
			ПланВыполненияВладельца = ПланыВыполнения.Найти(ИндексВладельцаПравила, "ИндексПравила");
			ПланВыполнения.СоответствуетКонтексту = ПланВыполненияВладельца.СоответствуетКонтексту;
			Если Не ПланВыполнения.СоответствуетКонтексту Тогда
				Продолжить;
			КонецЕсли;
			// Ниже по владельцу можем проверить и для элементов коллекции
		КонецЕсли;
		
		// Проверим условия, которые можно проверить на данном этапе
		ПланВыполнения.СоответствуетКонтексту = ПроверитьУсловия(
			ПроверенныеУсловия,
			Правило,
			ПланВыполнения,
			"ФункциональныеОпции",
			Неопределено,
			ДляПроверкиЗаполнения);
			
		Если Не ПланВыполнения.СоответствуетКонтексту Тогда
			Продолжить;
		КонецЕсли;

		// Заполним исходные данные правила ("ДанныеЗаполнения")
		НеобходимыеДанныеЗаполнения = Новый Структура;
		Если ДляЗаполнения Или ТребуетПроверкиКорректности(Правило, Правила.КешОбщихЗначений) Тогда
			Для Каждого ИмяДанных Из ИсточникиДанныхПравила(Правило) Цикл
				НеобходимыеДанныеЗаполнения.Вставить(ИмяДанных);
			КонецЦикла;
		КонецЕсли;
	
		Для Каждого ТипУсловия Из ТипыУсловий(ДляПроверкиЗаполнения) Цикл
			Для Каждого ИмяУсловия Из Правило[ТипУсловия.Ключ] Цикл
				НеобходимыеДанныеЗаполнения.Вставить(ИмяУсловия);
				Для Каждого ИмяДанных Из ИсточникиДанныхДляПроверкиУсловия(ИмяУсловия) Цикл
					НеобходимыеДанныеЗаполнения.Вставить(ИмяДанных.Ключ);
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;
		
		ПланВыполнения.ДанныеЗаполнения = ПодготовитьДанныеЗаполнения(НеобходимыеДанныеЗаполнения, ДанныеЗаполнения, Правило.ИсточникиДанных);
		
		// Проверим условия, которые можно проверить на данном этапе
		ПланВыполнения.СоответствуетКонтексту = ПроверитьУсловия(
			ПроверенныеУсловия,
			Правило,
			ПланВыполнения,
			"ДанныеЗаполнения",
			ПланВыполнения.ДанныеЗаполнения,
			ДляПроверкиЗаполнения);
		
		Если Не ПланВыполнения.СоответствуетКонтексту Тогда
			Продолжить;
		КонецЕсли;
	
		// Получим настройки
		ПотребныеНастройки = ПотребныеНастройки(Правило, ДляЗаполнения, ДляПроверкиЗаполнения);
		
		Для Каждого ИмяНастройки Из ПотребныеНастройки Цикл
			
			// У каждого сочетания правила и настройки свой набор источников данных:
			// - у каждого правила могут быть свои источники
			// - для настройки нужны не все данные, для которых в правиле определены источники
			
			ИсточникиДанных = Новый Структура;
			
			// Возьмем из правила информацию об источниках данных.
			// При этом ограничим переданные для правила заполнения источники данных только теми, 
			// которые нужны для данной настройки
			Эталон = ИсточникиДанныхНастройки(ИмяНастройки);
			Для Каждого Правило_ИсточникиДанныхОпределенногоВида Из Правило.ИсточникиДанных Цикл
				// Источники данных могут быть разных видов: ДанныеЗаполнения и РеквизитыОбъекта
				
				Настройка_ИсточникиДанныхОпределенногоВида = Новый Структура;
				
				Для Каждого Правило_ОписаниеИсточникаДанных Из Правило_ИсточникиДанныхОпределенногоВида.Значение Цикл
					Если Эталон.Свойство(Правило_ОписаниеИсточникаДанных.Ключ) Тогда
						Настройка_ИсточникиДанныхОпределенногоВида.Вставить(
							Правило_ОписаниеИсточникаДанных.Ключ, 
							Правило_ОписаниеИсточникаДанных.Значение);
					КонецЕсли;
				КонецЦикла;
				
				ИсточникиДанных.Вставить(Правило_ИсточникиДанныхОпределенногоВида.Ключ, Настройка_ИсточникиДанныхОпределенногоВида);
				
			КонецЦикла;
			
			НастройкаОдинаковаяДляВсехЭлементовКоллекции = 
				(Коллекция = Неопределено 
				Или Коллекция.Количество() < 2  // Если в коллекции более одного элемента, то она должна иметь индекс 
				Или ИсточникиДанных.РеквизитыОбъекта.Количество() = 0);
			
			ИдентификаторНастройки = ИдентификаторНастройки(ИмяНастройки, ИсточникиДанных, Правило.ТабличнаяЧасть);
				
			ДанныеНастройки = ДанныеНастроек[ИдентификаторНастройки];
			Если ДанныеНастройки = Неопределено Тогда
				
				ДанныеНастройки = ДанныеНастройкиВЕдиномФормате(
					ИмяНастройки,
					ИсточникиДанных,
					ДанныеЗаполнения,
					НастройкаОдинаковаяДляВсехЭлементовКоллекции,
					Коллекция);
					
				ДанныеНастроек.Вставить(ИдентификаторНастройки, ДанныеНастройки);
					
			КонецЕсли;
			
			Настройка = Новый Структура;
			Настройка.Вставить("Идентификатор",                         ИдентификаторНастройки);
			Настройка.Вставить("ОдинаковаяДляВсехЭлементовКоллекции",   НастройкаОдинаковаяДляВсехЭлементовКоллекции);
			Настройка.Вставить("Данные",                                ДанныеНастройки);
			
			ПланВыполнения.Настройки.Вставить(ИмяНастройки, Настройка);
			
		КонецЦикла; // По ПотребныеНастройки
	
		// Проверим выполнение оставшихся условий для правила в целом
		ПланВыполнения.СоответствуетКонтексту = ПроверитьУсловия(
			ПроверенныеУсловия,
			Правило,
			ПланВыполнения,
			"ОбщиеНастройки",
			ПланВыполнения.Настройки,
			ДляПроверкиЗаполнения);
			
		Если Не ПланВыполнения.СоответствуетКонтексту Тогда
			Продолжить;
		КонецЕсли;
	
		// Проверим выполнение условий для элементов коллекции
		Если Коллекция <> Неопределено Тогда
		
			РезультатыПроверкиУсловийПоКоллекции = Новый Структура;
			Для Каждого ТипУсловия Из ТипыУсловий(ДляПроверкиЗаполнения) Цикл
				Для Каждого Условие Из Правило[ТипУсловия.Ключ] Цикл
					Если Коллекция.Количество() = 0 Тогда
						РезультатПроверки = Ложь;
					Иначе
						РезультатПроверки = ПроверитьУсловиеПоКоллекции(Условие, Коллекция, Правило.ИсточникиДанных.РеквизитыОбъекта);
					КонецЕсли;
					РезультатыПроверкиУсловийПоКоллекции.Вставить(Условие, РезультатПроверки);
				КонецЦикла;
			КонецЦикла;
	
			ЕстьЭлементыСоответствующиеКонтексту = Ложь;
			Для ИндексЭлемента = 0 По Коллекция.Количество() - 1 Цикл
				
				ЭлементКоллекции = Коллекция[ИндексЭлемента];
				
				ЭлементСоответствуетКонтексту = Истина;
				
				Если ПланВыполненияВладельца <> Неопределено Тогда
					Если ПланВыполненияВладельца.ЭлементыНеСоответствуютКонтексту.Найти(ИндексЭлемента) <> Неопределено Тогда
						ЭлементСоответствуетКонтексту = Ложь;
					КонецЕсли;
				КонецЕсли;
				
				Если ЭлементСоответствуетКонтексту Тогда
				
					ПроверенныеУсловияЭлемента = ОбщегоНазначенияКлиентСервер.СкопироватьСтруктуру(ПроверенныеУсловия);
				
					НастройкиЭлемента = Новый Соответствие;
					ДополнитьНастройкиЭлемента(НастройкиЭлемента, ИндексЭлемента, ПланВыполнения.Настройки);
					ЭлементСоответствуетКонтексту = ПроверитьУсловия(
						ПроверенныеУсловияЭлемента,
						Правило,
						ПланВыполнения,
						"НастройкиЭлементаКоллекции",
						НастройкиЭлемента,
						ДляПроверкиЗаполнения);
						
					Если ЭлементСоответствуетКонтексту Тогда
						
						// Проверим способом "ЭлементКоллекции"
						
						РезультатПроверкиУсловийПоЭлементуКоллекции = Новый Структура;
						
						Для Каждого Условие Из РезультатыПроверкиУсловийПоКоллекции Цикл
							
							Если ТипЗнч(Условие.Значение) = Тип("Массив") Тогда
								Значение = Условие.Значение[ИндексЭлемента];
							Иначе
								Значение = Условие.Значение;
							КонецЕсли;
							
							РезультатПроверкиУсловийПоЭлементуКоллекции.Вставить(Условие.Ключ, Значение);
							
						КонецЦикла;
						
						ЭлементСоответствуетКонтексту = ПроверитьУсловия(
							ПроверенныеУсловияЭлемента,
							Правило,
							ПланВыполнения,
							"ЭлементКоллекции",
							РезультатПроверкиУсловийПоЭлементуКоллекции,
							ДляПроверкиЗаполнения);
						
					КонецЕсли;
				КонецЕсли;
				
				Если ЭлементСоответствуетКонтексту Тогда
					ЕстьЭлементыСоответствующиеКонтексту = Истина;
				Иначе
					ПланВыполнения.ЭлементыНеСоответствуютКонтексту.Добавить(ИндексЭлемента);
				КонецЕсли;
			
			КонецЦикла;
			
			ПланВыполнения.СоответствуетКонтексту = ЕстьЭлементыСоответствующиеКонтексту;
			
		КонецЕсли; // Коллекция <> Неопределено
		
	КонецЦикла; // По Правила.ПравилаЗаполнения
	
	Возврат ПланыВыполнения;
	
КонецФункции

Функция ПравилоСоответствуетОтбору(Правило, Отбор, Коллекция = Неопределено, КешОбщихЗначений = Неопределено)
	
	Если Отбор = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
		
	Если Отбор.Свойство("ТабличнаяЧасть") Тогда
		Если Правило.ТабличнаяЧасть <> Отбор.ТабличнаяЧасть Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
		
	Если Отбор.Свойство("РеквизитыПолноеИмя") Тогда
		Если Отбор.РеквизитыПолноеИмя[Правило.ПолноеИмяРеквизита] = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Если Отбор.Свойство("Реквизиты") Тогда
		Если Не Отбор.Реквизиты.Свойство(Правило.Реквизит) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
		
	Если Отбор.Свойство("ИсточникиДанных") Тогда
		Возврат ИсточникиДанныхВлияютНаПравило(Правило, Отбор.ИсточникиДанных);
	КонецЕсли;
	
	Если Отбор.Свойство("ДанныеФормы") Тогда
		
		Если ПустаяСтрока(Правило.ТабличнаяЧасть) Тогда
			
			Возврат Отбор.ДанныеФормы.Свойство(Правило.Реквизит);
			
		ИначеЕсли Не Отбор.ДанныеФормы.Свойство(Правило.ТабличнаяЧасть) 
			Или ТипЗнч(Отбор.ДанныеФормы[Правило.ТабличнаяЧасть]) <> Тип("ДанныеФормыКоллекция") 
			Или Отбор.ДанныеФормы[Правило.ТабличнаяЧасть].Количество() = 0 Тогда
			
			Возврат Ложь;
			
		Иначе
			
			ПервыйЭлемент = Отбор.ДанныеФормы[Правило.ТабличнаяЧасть][0]; // Проверить свойство можно только у элемента коллекции, но не самой коллекции
			Возврат ПервыйЭлемент.Свойство(Правило.Реквизит);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если Отбор.Свойство("НеЗаполненныеРеквизиты") И Отбор.НеЗаполненныеРеквизиты 
		И Коллекция <> Неопределено 
		И Не ТребуетПроверкиКорректности(Правило, КешОбщихЗначений) Тогда
		
		СоответствуетОтбору = Ложь;
		Для Каждого ЭлементКоллекции Из Коллекция Цикл
			Если Не ЗначениеЗаполнено(ЭлементКоллекции[Правило.Реквизит]) Тогда
				СоответствуетОтбору = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если Не СоответствуетОтбору Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЕсли;
		
	Возврат Истина;
	
КонецФункции

Функция ДанныеЗаполненияИзДокумента(МенеджерОбъекта, Документ, Правила)
	
	ДанныеЗаполнения  = Новый Структура;
	
	Для Каждого КлючИЗначение Из Правила.РеквизитыДокумента Цикл
		
		Значение = ЗначениеСвойстваСтруктуры(Документ, КлючИЗначение.Значение);
		ДанныеЗаполнения.Вставить(КлючИЗначение.Ключ, Значение);
		
	КонецЦикла;
	
	ЕстьДополнительныеДанные = Ложь;
	Для Каждого КлючИЗначение Из Правила.ДополнительныеДанныеДокумента Цикл
			
		ДанныеЗаполнения.Вставить(КлючИЗначение.Ключ, Неопределено);
		ЕстьДополнительныеДанные = Истина;
		
		// Промежуточные данные
		Для Каждого ИмяРеквизита Из КлючИЗначение.Значение Цикл
			Значение = ЗначениеСвойстваСтруктуры(Документ, ИмяРеквизита);
			ДанныеЗаполнения.Вставить(ИмяРеквизита, Значение);
		КонецЦикла;
			
	КонецЦикла;
	
	Если ЕстьДополнительныеДанные Тогда
		МенеджерОбъекта.ДополнитьДанныеЗаполненияСчетовУчета(ДанныеЗаполнения);
	КонецЕсли;
	
	Возврат ДанныеЗаполнения;
	
КонецФункции

Функция ПодготовитьДанныеЗаполнения(НеобходимыеДанныеЗаполнения, ДанныеЗаполнения, ОписаниеИсточниковДанных)
	
	Результат = Новый Структура;
	
	// Обработаем описание, переданное в ИсточникиДанных
	Для Каждого ОписаниеЭлементаДанныхЗаполнения Из ОписаниеИсточниковДанных.ДанныеЗаполнения Цикл
		
		Если Не НеобходимыеДанныеЗаполнения.Свойство(ОписаниеЭлементаДанныхЗаполнения.Ключ) Тогда
			// Такое не нужно
			Продолжить;
		КонецЕсли;
		
		ИмяРеквизита = ОписаниеЭлементаДанныхЗаполнения.Значение;
		Если ПустаяСтрока(ИмяРеквизита) Тогда
			ИмяРеквизита = ОписаниеЭлементаДанныхЗаполнения.Ключ;
		КонецЕсли;
		
		ЗначениеРеквизита = ЗначениеСвойстваСтруктуры(ДанныеЗаполнения, ИмяРеквизита);
		
		Результат.Вставить(ОписаниеЭлементаДанныхЗаполнения.Ключ, ЗначениеРеквизита);
		
	КонецЦикла;
	
	// Обеспечим в Результат набор ключей не менее необходимого.
	// Это позволит безопасно обращаться ко всем данным, требуемым алгоритмами получения настроек.
	
	Для Каждого ОписаниеЭлементаДанныхЗаполнения Из НеобходимыеДанныеЗаполнения Цикл
		
		ИмяДанных = ОписаниеЭлементаДанныхЗаполнения.Ключ;
		
		Если Результат.Свойство(ИмяДанных) Тогда
			// Уже заполнили, используя ОписаниеИсточниковДанных
			Продолжить;
		КонецЕсли;
		
		ЗначениеРеквизита = ЗначениеСвойстваСтруктуры(ДанныеЗаполнения, ИмяДанных);
		
		Результат.Вставить(ИмяДанных, ЗначениеРеквизита);
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Процедура ДополнитьНастройкиЭлемента(НастройкиЭлемента, ИндексЭлемента, ВыполнениеПравила_Настройки)
	
	Для Каждого Настройка Из ВыполнениеПравила_Настройки Цикл
		
		Если НастройкиЭлемента[Настройка.Значение.Идентификатор] = Неопределено Тогда
			
			Если Настройка.Значение.ОдинаковаяДляВсехЭлементовКоллекции Тогда
				ДанныеНастройкиЭлемента = Настройка.Значение.Данные;
			Иначе
				ДанныеНастройкиЭлемента = Настройка.Значение.Данные[ИндексЭлемента];
			КонецЕсли;
			
			НастройкиЭлемента.Вставить(Настройка.Значение.Идентификатор, ДанныеНастройкиЭлемента);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ВыполнятьПравилоДляЭлементаКоллекции(ПланВыполнения, ИндексЭлемента)
	
	Если Не ПланВыполнения.СоответствуетОтбору Или Не ПланВыполнения.СоответствуетКонтексту Тогда
		Возврат Ложь;
	КонецЕсли;
			
	Возврат (ПланВыполнения.ЭлементыНеСоответствуютКонтексту.Найти(ИндексЭлемента) = Неопределено);
	
КонецФункции

#КонецОбласти

#Область ВычислениеНастроек

Функция ДанныеНастройкиВЕдиномФормате(ИмяНастройки, ИсточникиДанных, ДанныеЗаполнения, ОдинаковаяДляВсехЭлементовКоллекции, Коллекция)
	
	// На выходе хотим получить
	// - или настройку, если она одинаковая для всех элементов коллекции
	// - или массив настроек - по числу строк. 
	//   Соответствие строкам - по идентификатору (индексу). Для разных строк может быть возвращена одна и та же настройка.
	
	Если ОдинаковаяДляВсехЭлементовКоллекции Тогда
		Результат = Неопределено;
	Иначе
		Результат = Новый Массив(Коллекция.Количество());
	КонецЕсли;
	
	ИсточникиДанныхНастройки = ИсточникиДанныхНастройки(ИмяНастройки);
			
	Если ИсточникиДанныхНастройки.Количество() = 0 Тогда
		
		// Такая настройка не имеет смысла
		Возврат Результат;
		
	КонецЕсли;
	
	// Предмет настройки - это то сочетание реквизитов, для которого выполнена настройка.
	// Предметов настройки
	// - либо столько, сколько строк в переданной коллекции (в том же порядке, что в переданной коллекции)
	// - либо один, если коллекция не передана
	ПредметыНастройки = Новый ТаблицаЗначений;
	
	ДанныеЗаполненияНастройки = ПодготовитьДанныеЗаполнения(ИсточникиДанныхНастройки, ДанныеЗаполнения, ИсточникиДанных);
	
	КолонкиСОдинаковымиЗначениями = Новый Структура; // Ключ - имя колонки; Значение - значение в колонке
	Для Каждого ОписаниеКолонки Из ИсточникиДанныхНастройки Цикл
		
		ИмяКолонки = ОписаниеКолонки.Ключ;
		
		Если Не ИсточникиДанных.РеквизитыОбъекта.Свойство(ИмяКолонки) Тогда
			// Значение колонки содержится в данных заполнения и одинаковое для всех предметов настройки
			// Такие колонки добавим позже
			КолонкиСОдинаковымиЗначениями.Вставить(ИмяКолонки, ДанныеЗаполненияНастройки[ИмяКолонки]);
			Продолжить;
		КонецЕсли;
			
		// Значение колонки содержится в коллекции.
		ПредметыНастройки.Колонки.Добавить(ИмяКолонки);
		
		// Колонка коллекции может иметь "неканоническое" имя.
		ИмяКолонкиВКоллекции = ИсточникиДанных.РеквизитыОбъекта[ИмяКолонки];
		ДанныеКолонки        = ОбщегоНазначения.ВыгрузитьКолонку(Коллекция, ИмяКолонкиВКоллекции, Ложь);
		
		Если ПредметыНастройки.Колонки.Количество() = 1 Тогда
			// Первая колонка определяет количество элементов
			ОбщегоНазначенияКлиентСервер.ДополнитьТаблицуИзМассива(ПредметыНастройки, ДанныеКолонки, ИмяКолонки);
		Иначе
			ПредметыНастройки.ЗагрузитьКолонку(ДанныеКолонки, ИмяКолонки);
		КонецЕсли;
		
	КонецЦикла;
	
	Если ПредметыНастройки.Количество() = 0 Тогда
		ПредметыНастройки.Добавить();
	КонецЕсли;
	
	Для Каждого ОписаниеКолонки Из КолонкиСОдинаковымиЗначениями Цикл
		ПредметыНастройки.Колонки.Добавить(ОписаниеКолонки.Ключ);
		ПредметыНастройки.ЗаполнитьЗначения(ОписаниеКолонки.Значение, ОписаниеКолонки.Ключ);
	КонецЦикла;
	
	Если ОдинаковаяДляВсехЭлементовКоллекции Тогда
		
		ДанныеНастройки = ДанныеНастройки(ИмяНастройки, ПредметыНастройки);
		Если ДанныеНастройки <> Неопределено Тогда
			Результат = ДанныеНастройки[0];
		Иначе
			Результат = Неопределено;
		КонецЕсли;
		
	Иначе
		
		// Настройки могут быть одинаковыми у некоторых (или всех) предметов.
		// Поэтому получим настройки только для отличающихся предметов.
		КолонкиПредметовНастройки = ОбщегоНазначенияКлиентСервер.КлючиСтруктурыВСтроку(ИсточникиДанныхНастройки);
		ДетализацияНастроек = ПредметыНастройки.Скопировать();
		ДетализацияНастроек.Свернуть(КолонкиПредметовНастройки);
	
		ДанныеНастройки = ДанныеНастройки(ИмяНастройки, ДетализацияНастроек);
		Если ДанныеНастройки <> Неопределено Тогда
		
			// ДанныеНастройки() должна уметь делить на кластеры по необходимости - это она знает, как оптимально получать настройки.
			// Можно использовать методы для деления на кластеры.
		
			// Сопоставим полученные данные строкам коллекции
			
			ПоляПоискаПредметовНастройки = ОбщегоНазначенияКлиентСервер.КлючиСтруктурыВСтроку(ИсточникиДанных.РеквизитыОбъекта);
			ДетализацияНастроек.Индексы.Добавить(ПоляПоискаПредметовНастройки);
			
 			Отбор = Новый Структура(ПоляПоискаПредметовНастройки);
			
			Для ИндексЭлемента = 0 По Коллекция.Количество() - 1 Цикл
				
				ЭлементКоллекции = Коллекция[ИндексЭлемента];
				
				Для Каждого ОписаниеРеквизита Из ИсточникиДанных.РеквизитыОбъекта Цикл
					// Колонка может иметь "неканоническое" имя
					Отбор[ОписаниеРеквизита.Ключ] = ЭлементКоллекции[ОписаниеРеквизита.Значение];
				КонецЦикла;
					
				ЭлементыКоллекцииДетализацияНастроек = ДетализацияНастроек.НайтиСтроки(Отбор);
				
				// Должен быть ровно один элемент, потому что все колонки, кроме ПоляПоискаПредметовНастройки заполняются одинаковыми значениями.
				ИндексНастройки = ДетализацияНастроек.Индекс(ЭлементыКоллекцииДетализацияНастроек[0]); 
				
				Результат[ИндексЭлемента] = ДанныеНастройки[ИндексНастройки];
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция РазбитьНаКластеры(ПредметыНастройки, ОптимальныйСоставКластера)
	
	// ОптимальныйСоставКластера - это набор полей (имен полей, разделенных запятыми), 
	// в разрезе которых настройка может быть получена эффективно
	// Например, счета номенклатуры могут быть эффективно получены для списка номенклатуры.
	// Тогда оптимальный состав - поле Номенклатура.
	
	Кластеры = Новый Структура;
	Кластеры.Вставить("ОдинКластер",          Истина);
	Кластеры.Вставить("АтрибутыКлюча",        Новый Массив);
	Кластеры.Вставить("АтрибутыКлючаСтрокой", "");
	Кластеры.Вставить("Ключи",                Новый ТаблицаЗначений);
	Кластеры.Вставить("КоличествоКлючей",     0);
	Кластеры.Вставить("ДанныеВсехКластеров",  ПредметыНастройки);
	Кластеры.Вставить("ПозицияВыборки",       -1);                // Изменяется при выборке
	Кластеры.Вставить("ОтборКлючей",          Новый Структура);   // Изменяется при выборке
	Кластеры.Вставить("КлючКластера",         Неопределено);      // Изменяется при выборке. Публичный - может быть прочитан снаружи.
	Кластеры.Вставить("ДанныеКластера",       Неопределено);      // Изменяется при выборке. Публичный - может быть прочитан снаружи.
	
	Кластеры.АтрибутыКлюча = Новый Массив;
	Для Каждого Колонка Из ПредметыНастройки.Колонки Цикл
		Если Не ОптимальныйСоставКластера.Свойство(Колонка.Имя) Тогда
			Кластеры.АтрибутыКлюча.Добавить(Колонка.Имя);
		КонецЕсли;
	КонецЦикла;
	
	Если Кластеры.АтрибутыКлюча.Количество() > 0 Тогда
		
		Кластеры.АтрибутыКлючаСтрокой = СтрСоединить(Кластеры.АтрибутыКлюча, ",");
		
		Кластеры.ОтборКлючей = Новый Структура(Кластеры.АтрибутыКлючаСтрокой);
		
		КоличествоСтрок = Кластеры.ДанныеВсехКластеров.Количество();
		Если КоличествоСтрок < 2 Тогда
			
			Кластеры.Ключи            = Кластеры.ДанныеВсехКластеров;
			Кластеры.КоличествоКлючей = КоличествоСтрок;
			
		Иначе
		
			Кластеры.Ключи = ПредметыНастройки.Скопировать(,Кластеры.АтрибутыКлючаСтрокой);
			Кластеры.Ключи.Свернуть(Кластеры.АтрибутыКлючаСтрокой);
			
			Кластеры.КоличествоКлючей = Кластеры.Ключи.Количество();
			
			Если Кластеры.КоличествоКлючей > 1 Тогда
		
				Кластеры.ОдинКластер = Ложь;
				Кластеры.ДанныеВсехКластеров.Индексы.Добавить(Кластеры.АтрибутыКлючаСтрокой);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Кластеры;
	
КонецФункции

Функция ВыбратьСледующийКластер(Кластеры)
	
	Кластеры.ПозицияВыборки = Кластеры.ПозицияВыборки + 1;
	Кластеры.КлючКластера   = Неопределено;
	Кластеры.ДанныеКластера = Неопределено;
	
	Если Кластеры.ОдинКластер Тогда
		Если Кластеры.КоличествоКлючей = 0 Тогда
			Получен = Ложь; // Ничего нельзя получить
		ИначеЕсли Кластеры.ПозицияВыборки <> 0 Тогда
			Получен = Ложь; // Можно было получить только один
		Иначе
			Кластеры.ДанныеКластера = Кластеры.ДанныеВсехКластеров;
			Кластеры.КлючКластера   = Кластеры.ДанныеВсехКластеров[0];
			Получен = Истина; // Единственный
		КонецЕсли;
	Иначе // Несколько кластеров
		Если Кластеры.ПозицияВыборки >= Кластеры.КоличествоКлючей Тогда
			Получен = Ложь; // Кончились
		Иначе
			Кластеры.КлючКластера = Кластеры.Ключи[Кластеры.ПозицияВыборки];
			ЗаполнитьЗначенияСвойств(Кластеры.ОтборКлючей, Кластеры.КлючКластера);
			Кластеры.ДанныеКластера = Кластеры.ДанныеВсехКластеров.НайтиСтроки(Кластеры.ОтборКлючей);
			Получен = Истина; // Следующий элемент получен
		КонецЕсли;
	КонецЕсли;
	
	Возврат Получен;
	
КонецФункции

Функция КоллекцияСодержитРеквизитыДляНастройки(ИмяНастройки, РеквизитыОбъекта)
	
	Для Каждого ИсточникДанныхНастройки Из ИсточникиДанныхНастройки(ИмяНастройки) Цикл
		Если РеквизитыОбъекта.Свойство(ИсточникДанныхНастройки.Ключ) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция НовыйДанныеНастройки(ПредметыНастройки)
	
	Возврат Новый Массив(ПредметыНастройки.Количество());
	
КонецФункции

Процедура ДополнитьМассивНастроекЭлементамиСоответствияПоПростомуКлючу(МассивНастроек, СоответствиеНастроек, КлючевоеПоле, ПредметыНастройки, ЧастьПредметовНастройки = Неопределено)
	
	// Коллекция ПредметыНастройки нужна для получения индекса.
	// Частью предметов настройки может быть массив строк.
	
	Если ЧастьПредметовНастройки = Неопределено Тогда
		ПредметыНастройкиДляОбработки = ПредметыНастройки;
	Иначе
		ПредметыНастройкиДляОбработки = ЧастьПредметовНастройки;
	КонецЕсли;
	
	Для Каждого ПредметНастройки Из ПредметыНастройкиДляОбработки Цикл
		
		ИдентификаторПредметаНастройки = ПредметыНастройки.Индекс(ПредметНастройки);
		ЗначениеКлюча                  = ПредметНастройки[КлючевоеПоле];
		
		МассивНастроек[ИдентификаторПредметаНастройки] = СоответствиеНастроек[ЗначениеКлюча];
		
	КонецЦикла;
	
КонецПроцедуры

Функция ЗначенияРеквизитаПредметовНастройки(ПредметыНастройки, ИмяПоля, ИмяРеквизита, ТипПоля)
	
	Результат = НовыйДанныеНастройки(ПредметыНастройки);
	
	ЗначенияПоля = ВыгрузитьЗначения(ПредметыНастройки, ИмяПоля, ТипПоля);
	
	ЗначенияРеквизита = ОбщегоНазначения.ЗначениеРеквизитаОбъектов(ЗначенияПоля, ИмяРеквизита);
	
	ДополнитьМассивНастроекЭлементамиСоответствияПоПростомуКлючу(Результат, ЗначенияРеквизита, ИмяПоля, ПредметыНастройки);
	
	Возврат Результат;
	
КонецФункции

Функция ИдентификаторНастройки(ИмяНастройки, ИсточникиДанных, ИмяТабличнойЧасти)
	
	Если ПустаяСтрока(ИмяТабличнойЧасти) Тогда
		Идентификатор = ИмяНастройки;
	Иначе
		Идентификатор = ИмяТабличнойЧасти + "." + ИмяНастройки;
	КонецЕсли;
	
	Если ИсточникиДанных.РеквизитыОбъекта.Количество() = 0 
		И ИсточникиДанных.ДанныеЗаполнения.Количество() = 0 Тогда
		Возврат Идентификатор;
	КонецЕсли;
	
	ТипИмени = ОбщегоНазначения.ОписаниеТипаСтрока(255);
	
	УпорядоченнаяКоллекция = Новый ТаблицаЗначений;
	УпорядоченнаяКоллекция.Колонки.Добавить("Реквизит", ТипИмени);
	УпорядоченнаяКоллекция.Колонки.Добавить("Ключ",     ТипИмени);
	УпорядоченнаяКоллекция.Колонки.Добавить("Значение", ТипИмени);
	
	Для Каждого ИсточникиДанныхОпределенногоВида Из ИсточникиДанных Цикл
		Для Каждого ОписаниеИсточникаДанных Из ИсточникиДанныхОпределенногоВида.Значение Цикл
			Элемент = УпорядоченнаяКоллекция.Добавить();
			Элемент.Реквизит = ИсточникиДанныхОпределенногоВида.Ключ;
			Элемент.Ключ     = ОписаниеИсточникаДанных.Ключ;
			Элемент.Значение = ОписаниеИсточникаДанных.Значение;
		КонецЦикла;
	КонецЦикла;
	
	УпорядоченнаяКоллекция.Сортировать("Реквизит,Ключ,Значение"); // Здесь Значение - это имя реквизита
	Идентификатор = Идентификатор + "+";
	Для Каждого Элемент Из УпорядоченнаяКоллекция Цикл
		Идентификатор = Идентификатор + Элемент.Реквизит + ":" + Элемент.Ключ + "=" + Элемент.Значение + ";";
	КонецЦикла;
	
	Возврат Идентификатор;
	
КонецФункции

#КонецОбласти

#Область ПроверкаУсловий

Функция ТипыУсловий(ВключатьУсловияПроверкиЗаполнения)
	
	ТипыУсловий = Новый Структура;
	
	ТипыУсловий.Вставить("УсловияРазрешено",          Истина);
	ТипыУсловий.Вставить("УсловияЗапрещено",          Ложь);
	
	Если ВключатьУсловияПроверкиЗаполнения Тогда
		ТипыУсловий.Вставить("УсловияПроверкиЗаполнения", Истина);
	КонецЕсли;
	
	Возврат ТипыУсловий;
	
КонецФункции

Функция ПроверитьУсловия(ПроверенныеУсловия, Правило, ПланВыполнения, СпособПроверки, ПредметПроверки, ДляПроверкиЗаполнения)
	
	// ПредметПроверки зависит от способа проверки.
	// "ФункциональныеОпции"        - не требуется (Неопределено)
	// "ДанныеЗаполнения"           - ПланВыполнения.ДанныеЗаполнения
	// "ОбщиеНастройки"             - ПланВыполнения.Настройки
	// "НастройкиЭлементаКоллекции" - НастройкиЭлементаКоллекции
	// "ЭлементКоллекции"           - результат проверки условия для элемента коллекции
	
	Для Каждого ТипУсловия Из ТипыУсловий(ДляПроверкиЗаполнения) Цикл
	
		Для Каждого Условие Из Правило[ТипУсловия.Ключ] Цикл
			
			// Определим результат проверки.
			// На каждом уровне результат определяется по-разному.
			
			Если ПроверенныеУсловия.Свойство(Условие) Тогда
				Продолжить;
			КонецЕсли;
			
			Если СпособПроверки = "ФункциональныеОпции" Тогда
				
				РезультатПроверки = ПроверитьУсловиеПоФункциональнымОпциям(Условие);
			
			ИначеЕсли СпособПроверки = "ДанныеЗаполнения" Тогда
				
				РезультатПроверки = ПроверитьУсловиеПоДаннымЗаполнения(Условие, ПредметПроверки);
				
			ИначеЕсли СпособПроверки = "ОбщиеНастройки" Тогда // для коллекции в целом
				
				// Проверим, можем ли проверить это условие этим способом
				ПотребныеНастройки = НастройкиДляПроверкиУсловия(Условие);
				
				МожноПроверитьНаЭтомУровне = Истина; // Можно, если у всех потребных настроек данные одинаковы для всех элементов коллекции
				НастройкиВсехЭлементов = Новый Соответствие; // Ключ - идентификатор настройки; Значение - данные настройки
				Для Каждого Настройка Из ПредметПроверки Цикл
					Если ПотребныеНастройки.Найти(Настройка.Ключ) = Неопределено Тогда
						Продолжить;
					КонецЕсли;
					Если Не Настройка.Значение.ОдинаковаяДляВсехЭлементовКоллекции Тогда
						МожноПроверитьНаЭтомУровне = Ложь;
						Прервать;
					КонецЕсли;
					НастройкиВсехЭлементов.Вставить(Настройка.Значение.Идентификатор, Настройка.Значение.Данные);
				КонецЦикла;
				
				Если МожноПроверитьНаЭтомУровне Тогда
					РезультатПроверки = ПроверитьУсловиеПоНастройкам(Условие, ПланВыполнения, НастройкиВсехЭлементов);
				Иначе
					РезультатПроверки = Неопределено; // Проверим его на следующем уровне
				КонецЕсли;
				
			ИначеЕсли СпособПроверки = "НастройкиЭлементаКоллекции" Тогда
				
				РезультатПроверки = ПроверитьУсловиеПоНастройкам(Условие, ПланВыполнения, ПредметПроверки);
				
			ИначеЕсли СпособПроверки = "ЭлементКоллекции" Тогда // ПоКоллекции 
				
				РезультатПроверки = ПредметПроверки[Условие];
				
			Иначе
				РезультатПроверки = Неопределено;
			КонецЕсли;
			
			Если РезультатПроверки = Неопределено Тогда
				// Проверяется на других уровнях проверки
				Продолжить;
			КонецЕсли;
			
			ПроверенныеУсловия.Вставить(Условие);
			
			Эталон = ТипУсловия.Значение;
			Если РезультатПроверки <> Эталон Тогда
				// Для условий типа "Разрешено": правило разрешено выполнять, только если есть уверенность, что условие выполняется.
				// То есть, Ложь означает, что проверка провалена; Истина - продолжить проверку других условий.
				// Для условия типа "Запрещено": правило запрещено выполнять, если есть уверенность, что условие выполняется.
				// То есть, Истина означает, что проверка провалена. Ложь и Неопределено - продолжить проверку других условий
				Возврат Ложь;
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Истина;

КонецФункции

#КонецОбласти

#Область ЗаполнениеДокументов

Процедура ЗаполнитьКоллекцию(Коллекция, Правила, ДанныеЗаполнения, Отбор = Неопределено)
	
	ТолькоНезаполненные = Отбор <> Неопределено И Отбор.Свойство("НеЗаполненныеРеквизиты") И Отбор.НеЗаполненныеРеквизиты;
	ПланыВыполнения     = ПланыВыполненияПравил(Правила, ДанныеЗаполнения, "ЗаполнениеКоллекции", Коллекция, Отбор);
	
	// Заполним элементы коллекции
	
	// Так как план выполнения правил содержит индексы элементов, а коллекцией может быть массив или табличная часть, 
	// то для обхода элементов не получится использовать Для Каждого
	Для ИндексЭлемента = 0 По Коллекция.Количество() - 1 Цикл
		
		Элемент = Коллекция[ИндексЭлемента];
		
		НастройкиЭлемента          = Новый Соответствие; // Состав настроек зависит от правила
		// Когда правило-владелец заполняется, то оно передает сообщения подчиненным правилам
		ВсеСообщения               = Новый Соответствие; // Ключ - индекс правила-владельца
		// Правило-владелец может не выполняться.
		// В этом случае оно не передаст сообщения подчиненным.
		// Поэтому подчиненным правилам передадим не сообщения, а значения счета.
		ВладельцыБезСообщений      = Новый Соответствие; // Ключ - индекс правила-владельца; значение - Истина
		
		Для Каждого ПланВыполнения Из ПланыВыполнения Цикл
			
			Правило = Правила.ПравилаЗаполнения[ПланВыполнения.ИндексПравила];
			
			Если Не ВыполнятьПравилоДляЭлементаКоллекции(ПланВыполнения, ИндексЭлемента) Тогда
				Если Правило.ЕстьПодчиненныеПравила Тогда
					ВладельцыБезСообщений.Вставить(ПланВыполнения.ИндексПравила, Истина);
				КонецЕсли;
				Продолжить;
			КонецЕсли;
			
			// Дополним настройки, чтобы там были те, на основании которых заполняется этот элемент по этому правилу
			ДополнитьНастройкиЭлемента(НастройкиЭлемента, ИндексЭлемента, ПланВыполнения.Настройки);
			
			// Обеспечим связи между разными правилами - подчиненные правила смогут получать данные от владельца и сиблингов
			ВходящееСообщение = Неопределено;
			
			ИндексВладельца = ИндексВладельцаПравила(Правило);
			Если ИндексВладельца <> Неопределено Тогда
				Если ВладельцыБезСообщений[ИндексВладельца] = Неопределено Тогда
					// Получаем сообщения от владельца
					ВходящееСообщение = ВсеСообщения[ИндексВладельца];
				Иначе
					// Эмулируем сообщение от владельца
					РеквизитВладелец = СвойствоВладельцаПравила(Правило, "Реквизит");
					Если ЕстьСвойствоСтруктуры(Элемент, РеквизитВладелец) Тогда
						ВходящееСообщение = Новый Структура;
						ВходящееСообщение.Вставить("Владелец", Элемент[РеквизитВладелец]);
						ВсеСообщения.Вставить(ИндексВладельца, ВходящееСообщение);
					КонецЕсли;
					ВладельцыБезСообщений.Удалить(ИндексВладельца);
				КонецЕсли;
			КонецЕсли;
			
			// Заполним
			ПараметрыЗаполненияРеквизита = НовыйПараметрыЗаполненияРеквизита();
			ПараметрыЗаполненияРеквизита.Элемент                    = Элемент;
			ПараметрыЗаполненияРеквизита.Правило                    = Правило;
			ПараметрыЗаполненияРеквизита.ПланВыполнения             = ПланВыполнения;
			ПараметрыЗаполненияРеквизита.НастройкиЭлемента          = НастройкиЭлемента;
			ПараметрыЗаполненияРеквизита.КешОбщихЗначений           = Правила.КешОбщихЗначений;
			
			ЗначениеРеквизита = Элемент[Правило.Реквизит];
			Если ТолькоНезаполненные И ЗначениеЗаполнено(ЗначениеРеквизита) Тогда
				Если Не ТребуетПроверкиКорректности(Правило, Правила.КешОбщихЗначений) Тогда
					Продолжить;
				КонецЕсли;
				Ошибка = ОшибкаЗаполнения(ПараметрыЗаполненияРеквизита);
				Если ПустаяСтрока(Ошибка) Тогда
					Продолжить;
				Иначе
					Элемент[Правило.Реквизит] = Неопределено;
				КонецЕсли;
			КонецЕсли;
			
			Если ВходящееСообщение = Неопределено Тогда
				ВходящееСообщение = Новый Структура;
			КонецЕсли;
			
			ПараметрыЗаполненияРеквизита.ВходящееСообщение = ВходящееСообщение;
			ЗаполнитьРеквизит(ПараметрыЗаполненияРеквизита);
			
			УстановитьЗначение(
				Элемент,
				Правило.Реквизит,
				ПараметрыЗаполненияРеквизита);
				
			Если Правило.ЕстьПодчиненныеПравила Тогда
				// Передадим сообщение подчиненным
				ПараметрыЗаполненияРеквизита.ИсходящееСообщение.Вставить("Владелец", Элемент[Правило.Реквизит]);
				ВсеСообщения.Вставить(ПланВыполнения.ИндексПравила, ПараметрыЗаполненияРеквизита.ИсходящееСообщение);
			КонецЕсли;
			
			Если ТолькоНезаполненные Тогда
				// После изменения владельца следует принудительно заполнить подчиненные.
				// Для этого их очистим.
				// Здесь необязательно обходить все уровни вложенности: на следующем уровне очистим послеследующий и т.д.
				Для Каждого ПодчиненноеПравило Из ПодчиненныеПравила(Правило) Цикл
					ИндексПодчиненногоПравила = Правила.ПравилаЗаполнения.Индекс(ПодчиненноеПравило);
					ПланВыполненияПодчиненногоПравила = ПланыВыполнения.Найти(ИндексПодчиненногоПравила, "ИндексПравила");
					Если ВыполнятьПравилоДляЭлементаКоллекции(ПланВыполненияПодчиненногоПравила, ИндексЭлемента) Тогда
						Элемент[ПодчиненноеПравило.Реквизит] = Неопределено;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
			
		КонецЦикла;
			
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьВсеКоллекции(Объект, Правила, ДанныеЗаполнения, Отбор)
	
	ИменаКоллекций = ОбщегоНазначенияКлиентСервер.СвернутьМассив(Правила.ПравилаЗаполнения.ВыгрузитьКолонку("ТабличнаяЧасть"));
	
	Для Каждого ИмяКоллекции Из ИменаКоллекций Цикл
		
		Если Не ПустаяСтрока(ИмяКоллекции) И Не ЕстьСвойствоСтруктуры(Объект, ИмяКоллекции) Тогда
			Продолжить;
		КонецЕсли;
		
		Отбор.Вставить("ТабличнаяЧасть", ИмяКоллекции);
		
		Если ПустаяСтрока(ИмяКоллекции) Тогда
			Коллекция = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Объект);
			ЗаполнитьКоллекцию(Коллекция, Правила, ДанныеЗаполнения, Отбор);
		Иначе
			ЗаполнитьКоллекцию(Объект[ИмяКоллекции], Правила, ДанныеЗаполнения, Отбор);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ПотребныеНастройки(Правило, ДляЗаполнения, ДляПроверкиЗаполнения)
	
	ПотребныеНастройки = Новый Массив;
	Если ДляЗаполнения Тогда
		ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ПотребныеНастройки, НастройкиДляЗаполнения(Правило), Истина);
	КонецЕсли;
	Если ДляПроверкиЗаполнения Тогда
		ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ПотребныеНастройки, НастройкиДляПроверкиЗаполнения(Правило), Истина);
	КонецЕсли;
	Для Каждого ТипУсловия Из ТипыУсловий(ДляПроверкиЗаполнения) Цикл
		Для Каждого Условие Из Правило[ТипУсловия.Ключ] Цикл
			ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ПотребныеНастройки, НастройкиДляПроверкиУсловия(Условие), Истина);
		КонецЦикла;
	КонецЦикла;
	
	Возврат ПотребныеНастройки;

КонецФункции

Функция ИсточникиДанныхВлияютНаПравило(Правило, ИсточникиДанных)
	
	// Источники данных заполнения могут быть переопределены в правиле
	Для Каждого Переопределение Из Правило.ИсточникиДанных.ДанныеЗаполнения Цикл
		Если ИсточникиДанных.Свойство(Переопределение.Значение) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	// Проверим участвует ли этот источник данных в правиле неявно
	ПравилоВОбертке = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Правило);
	ПотребныеИсточникиДанных = ПотребныеИсточникиДанныхДокумента(ПравилоВОбертке);
	
	Для Каждого ПотребныйИсточникДанных Из ПотребныеИсточникиДанных Цикл
		Если ИсточникиДанных.Свойство(ПотребныйИсточникДанных.Ключ) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
		
	Возврат Ложь;
		
КонецФункции

Функция ПотребныеИсточникиДанныхДокумента(Правила)
	
	ДляПроверкиЗаполнения = Ложь;
	
	ИсточникиДанных = Новый Структура;
	Настройки       = Новый Структура; // Источники для них найдем позже, так как у разных правил - одинаковые источники
	Для Каждого Правило Из Правила Цикл
		
		Для Каждого ИсточникДанных Из ИсточникиДанныхПравила(Правило) Цикл
			ИсточникиДанных.Вставить(ИсточникДанных);
		КонецЦикла;
		
		Для Каждого ТипУсловия Из ТипыУсловий(ДляПроверкиЗаполнения) Цикл
			Для Каждого Условие Из Правило[ТипУсловия.Ключ] Цикл
				ИсточникиДанных.Вставить(Условие);
				Для Каждого ИсточникДанных Из ИсточникиДанныхДляПроверкиУсловия(Условие) Цикл
					ИсточникиДанных.Вставить(ИсточникДанных.Ключ);
				КонецЦикла;
			КонецЦикла;
		КонецЦикла;
		
		Для Каждого Настройка Из ПотребныеНастройки(Правило, Истина, ДляПроверкиЗаполнения) Цикл
			Настройки.Вставить(Настройка);
		КонецЦикла;
		
	КонецЦикла;
	
	Для Каждого Настройка Из Настройки Цикл
		
		Для Каждого ИсточникДанных Из ИсточникиДанныхНастройки(Настройка.Ключ) Цикл
			ИсточникиДанных.Вставить(ИсточникДанных.Ключ);
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат ИсточникиДанных;
	
КонецФункции

Функция ЗаполнятьПередЗаписью(ДополнительныеСвойства)
	
	Если Не СчетаУчетаВДокументахВызовСервераПовтИсп.ПользовательУправляетСчетамиУчета() Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если Не ДополнительныеСвойства.Свойство("ЗаполнитьСчетаУчетаПередЗаписью") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ДополнительныеСвойства.ЗаполнитьСчетаУчетаПередЗаписью;
	
КонецФункции

Функция НовыйПараметрыЗаполненияРеквизита()
	
	// Параметры используются как для процедур заполнения реквизита,
	// так и для процедур проверки.
	// Модифицируемые и возвращаемые параметры используются только в процедурах заполнения.
	
	Параметры = Новый Структура;
	Параметры.Вставить("Элемент");
	Параметры.Вставить("Правило");
	Параметры.Вставить("ПланВыполнения");
	Параметры.Вставить("НастройкиЭлемента");
	Параметры.Вставить("КешОбщихЗначений");
	// Модифицируемые параметры
	Параметры.Вставить("ВходящееСообщение",  Новый Структура);
	Параметры.Вставить("ИсходящееСообщение", Новый Структура);
	// Возвращаемые параметры
	// Если указать Значение, то оно затрет то, что указано в документе. 
	Параметры.Вставить("Значение");
	// Если не указать Значение, то может быть использовано ЗначениеПоУмолчанию. В двух случаях: если в документе ничего не указано или если установлено Очистить
	Параметры.Вставить("ЗначениеПоУмолчанию", ПланыСчетов.Хозрасчетный.ПустаяСсылка()); 
	Параметры.Вставить("Очистить", Ложь);
	
	Возврат Параметры;
	
КонецФункции

Процедура УстановитьЗначение(Объект, ИмяРеквизита, Параметры)
	
	Если ЗначениеЗаполнено(Параметры.Значение) Тогда
		НовоеЗначение = Параметры.Значение;
	ИначеЕсли Не ЗначениеЗаполнено(Объект[ИмяРеквизита]) 
		Или Параметры.Очистить Тогда
		НовоеЗначение = Параметры.ЗначениеПоУмолчанию;
	Иначе
		Возврат;
	КонецЕсли;
		
	Если НовоеЗначение <> Объект[ИмяРеквизита] Тогда
		Объект[ИмяРеквизита] = НовоеЗначение;
	КонецЕсли;
	
КонецПроцедуры

Функция ЗначенияДоИзменения(КЗаполнению, ЭлементКоллекции, ИмяКоллекции)
	
	ЗначенияДоИзменения = Новый Структура;
	Для Каждого КлючИЗначение Из КЗаполнению Цикл
		ИмяРеквизитаДетально = ОбщегоНазначенияБПКлиентСервер.РазложитьПолноеИмяРеквизита(КлючИЗначение.Ключ);
		Если ИмяРеквизитаДетально.ТабличнаяЧасть = ИмяКоллекции Тогда
			ЗначенияДоИзменения.Вставить(ИмяРеквизитаДетально.Реквизит);
		КонецЕсли;
	КонецЦикла;
	ЗаполнитьЗначенияСвойств(ЗначенияДоИзменения, ЭлементКоллекции);
	
	Возврат ЗначенияДоИзменения;
	
КонецФункции

Функция ИзмененныеЗначения(ЗначенияДоИзменения = Неопределено, ЭлементКоллекции = Неопределено)
	
	ИзмененныеЗначения = Новый Структура;
	Если ЗначенияДоИзменения = Неопределено Тогда
		Возврат ИзмененныеЗначения;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из ЗначенияДоИзменения Цикл
		НовоеЗначение = ЭлементКоллекции[КлючИЗначение.Ключ];
		Если НовоеЗначение <> КлючИЗначение.Значение Тогда
			ИзмененныеЗначения.Вставить(КлючИЗначение.Ключ, НовоеЗначение);
		КонецЕсли;
	КонецЦикла;
	
	Возврат ИзмененныеЗначения;
	
КонецФункции

#КонецОбласти

#Область ПроверкаЗаполнения

// ПараметрыПроверкиЗаполнения - см. НовыйПараметрыЗаполненияРеквизита()
Процедура ПроверитьЗначение(Значение, ПараметрыПроверкиЗаполнения, Сообщения, ТребуетПроверкиКорректности, НомерСтроки = 0)
	
	Если Не ЗначениеЗаполнено(Значение) Тогда
		
		Сообщение = Сообщения.Добавить();
		Сообщение.ПолноеИмяРеквизита = ПараметрыПроверкиЗаполнения.Правило.ПолноеИмяРеквизита;
		Сообщение.НомерСтроки        = НомерСтроки;
		
	ИначеЕсли ТребуетПроверкиКорректности Тогда
		
		Ошибка = ОшибкаЗаполнения(ПараметрыПроверкиЗаполнения);
		
		Если Не ПустаяСтрока(Ошибка) Тогда
			Сообщение = Сообщения.Добавить();
			Сообщение.ПолноеИмяРеквизита = ПараметрыПроверкиЗаполнения.Правило.ПолноеИмяРеквизита;
			Сообщение.НомерСтроки        = НомерСтроки;
			Сообщение.Ошибка             = Ошибка;
		КонецЕсли;
		
	КонецЕсли;
				
КонецПроцедуры

#КонецОбласти

#Область СоставлениеПравил

Функция ПравилаЗаполнения(МенеджерОбъекта, ДляПодготовкиМетаданных = Ложь) Экспорт
	
	// В режиме ДляПодготовкиМетаданных игнорируются сведения информационной базы - значения функциональных опций
	
	Правила = НовыйПравилаЗаполнения(ДляПодготовкиМетаданных);
	
	МенеджерОбъекта.УстановитьПравилаЗаполненияСчетовУчета(Правила);
	
	// ТекущаяСтрока используется только на этапе установки правил
	Правила.ТекущаяСтрока   = Неопределено;
	Правила.ТекущийВладелец = Неопределено;
	
	Возврат Правила;
	
КонецФункции

#КонецОбласти

#Область ИнтерпретацияПравил

Функция ИмяРеквизитаКоллекции(ОписаниеРеквизитовКоллекции, ИмяДанных)
	
	Если Не ОписаниеРеквизитовКоллекции.Свойство(ИмяДанных) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ОписаниеРеквизитовКоллекции[ИмяДанных];
	
КонецФункции	

#КонецОбласти

#Область ДанныеФорм

// Работа со структурами и данными формы, состав которых может меняться: некоторые свойства могут отсутствовать

Функция ЕстьСвойствоСтруктуры(ЭлементКоллекции, ИмяРеквизита)
	
	Если ТипЗнч(ЭлементКоллекции) <> Тип("ДанныеФормыСтруктура") 
		И ТипЗнч(ЭлементКоллекции) <> Тип("Структура") Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат ЭлементКоллекции.Свойство(ИмяРеквизита);
	
КонецФункции

Функция ЗначениеСвойстваСтруктуры(ЭлементКоллекции, ИмяРеквизита)
	
	Если ЕстьСвойствоСтруктуры(ЭлементКоллекции, ИмяРеквизита) Тогда
		Возврат ЭлементКоллекции[ИмяРеквизита];
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

Процедура ЗаполнитьРасчетыПоФакторингу(Параметры)
	
	ВидРасчетов = УчетВзаиморасчетов.ВидРасчетовПоУсловиямРасчетов();
	Параметры.Значение = УчетВзаиморасчетов.ОсновнойСчетРасчетов(ВидРасчетов, Параметры.Правило.Роль);
	
КонецПроцедуры

Процедура ЗаполнитьРасчетыПоЛизингу(Параметры)
	
	// Определим вид расчетов по условиям расчетов
	УсловияРасчетов = ДанныеНастройкиЭлементаКоллекции("УсловияРасчетов", Параметры);
	Если УсловияРасчетов <> Неопределено Тогда
		ВидРасчетов = УчетВзаиморасчетов.ВидРасчетовПоУсловиямРасчетов(УсловияРасчетов.ВалютаВзаиморасчетов, УсловияРасчетов.РасчетыВУсловныхЕдиницах);
	КонецЕсли;
	// Обработаем ситуацию, когда по условиям расчетов определить вид расчетов не удалось
	Если Не ЗначениеЗаполнено(ВидРасчетов) Тогда
		ВидРасчетов = УчетВзаиморасчетов.ВидРасчетовПоУсловиямРасчетов();
	КонецЕсли;
	
	Параметры.Значение = УчетВзаиморасчетов.ОсновнойСчетРасчетов(ВидРасчетов, Параметры.Правило.Роль);
		
КонецПроцедуры

// Заполняет счета учета в таблице.
// Условия заполнения можно определить гибко с помощью параметра Отбор.
//
// Параметры:
//  МенеджерОбъекта - ДокументМенеджер, ОбработкаМенеджер - менеджер заполняемого объекта. Должен соответствовать требованиям, описанным в ЗаполнениеВнеФормы
//  РеквизитыШапки  - сруктура с обязательными реквизитами Организация и Дата
//  Таблица         - табличная часть объекта
//  Отбор	 - Структура - см. ПравилоСоответствуетОтбору()	
Процедура ЗаполнитьТаблицу(МенеджерОбъекта, РеквизитыШапки, Таблица, Отбор = Неопределено) Экспорт
	
	Правила           = ПравилаЗаполнения(МенеджерОбъекта);
	ДанныеЗаполнения  = ДанныеЗаполненияИзДокумента(МенеджерОбъекта, РеквизитыШапки, Правила);
	
	ЗаполнитьКоллекцию(Таблица, Правила, ДанныеЗаполнения, Отбор);
	
КонецПроцедуры

#КонецОбласти

#Область КешОбщихЗначений

Функция НовыйКешОбщихЗначений()
	
	Возврат Новый Структура;
	
КонецФункции

Функция ОбщееЗначение(КешОбщихЗначений, ИмяЗначения)
	
	Значение = Неопределено;
	Если КешОбщихЗначений <> Неопределено И КешОбщихЗначений.Свойство(ИмяЗначения, Значение) Тогда
		Возврат Значение;
	КонецЕсли;
	
	// Прикладная логика
	Если ИмяЗначения = "ИспользоватьВалютныйУчет" Тогда
		Значение = БухгалтерскийУчетПереопределяемый.ИспользоватьВалютныйУчет();
	ИначеЕсли ИмяЗначения = "ВалютаРегламентированногоУчета" Тогда
		Значение = ОбщегоНазначенияБПВызовСервераПовтИсп.ПолучитьВалютуРегламентированногоУчета();
	// Конец прикладной логики
	Иначе
		// При передаче неизвестного имени вызовем исключение, чтобы избежать трудно диагностируемых ошибок в именах общих значений
		ШаблонСообщения = НСтр("ru = 'Недопустимое имя значения ""%1"" в функции ОбщееЗначение() модуля СчетаУчетаВДокументах'");
		ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, ИмяЗначения);
	КонецЕсли;
	
	Если КешОбщихЗначений <> Неопределено Тогда
		КешОбщихЗначений.Вставить(ИмяЗначения, Значение);
	КонецЕсли;
	Возврат Значение;
	
КонецФункции

Процедура ЗаполнитьЗапасыЗатраты(Параметры)
	
	Если ДанныеНастройкиЭлементаКоллекции("ЭтоУслуга", Параметры) = Истина Тогда
		ЗаполнитьЗатраты(Параметры);
	Иначе
		ЗаполнитьЗапасы(Параметры);
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти
