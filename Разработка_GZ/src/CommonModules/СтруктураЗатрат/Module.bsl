// Модуль обеспечивает работу с данными о детальной структуре той или иной затраты в ходе расчета себестоимости,
// в частности
// - калькуляциями конкретных полуфабрикатов
// - структурой затрат выпущенной и реализуемой продукции в разрезе элементов.
//
// Одновременно в ходе расчета себестоимости может рассчитываться несколько вариантов структуры затрат,
// отличающихся детализацией и глубиной прослеживания затрат.

#Область Инициализация

// Создает коллекцию, содержащую данных о всех вариантах структуры, используемых в конкретном расчете.
//
Функция НовыйВариантыСтруктурыЗатрат() Экспорт
	
	Варианты = Новый ТаблицаЗначений;
	Варианты.Колонки.Добавить("Имя",              ОбщегоНазначения.ОписаниеТипаСтрока(50));
	Варианты.Колонки.Добавить("СоставКлюча",      Новый ОписаниеТипов("Структура"));// Ключ - имя элемента, Значение - тип элемента
	Варианты.Колонки.Добавить("ВнешниеИсточники", Новый ОписаниеТипов("Массив"));// Имена таблиц, хранящих данные о структуре затрат,
	                                                 // внешние по отношению к этой регламентной операции - результаты предыдущих регламентных операций
	Варианты.Колонки.Добавить("ОписаниеСумм");       // См. КоллекцииСумм.НовыйОписаниеКоллекцииСумм() - включает переменный набор
	Варианты.Колонки.Добавить("ОписаниеСводныхСумм");// См. КоллекцииСумм.НовыйОписаниеКоллекцииСумм() - исключая переменный набор
	
	// Производные
	Варианты.Колонки.Добавить("ИмяКолонкиОсновнойКлюч",           ОбщегоНазначения.ОписаниеТипаСтрока(100));
	Варианты.Колонки.Добавить("ИмяКолонкиУстановленОсновнойКлюч", ОбщегоНазначения.ОписаниеТипаСтрока(100));
	Варианты.Колонки.Добавить("ИмяТаблицыОсновныеКлючи",          ОбщегоНазначения.ОписаниеТипаСтрока(100));
	Варианты.Колонки.Добавить("СоставКлючаСтрокой",               Новый ОписаниеТипов("Строка"));
	
	Варианты.Индексы.Добавить("Имя");
	
	Возврат Варианты;
	
КонецФункции

// Добавляет описание одного варианта структуры затрат, используемой в конкретном расчете.
//
// Пример использования см. в ДобавитьСтандартныйВариантСтруктурыЗатрат()
//
// Параметры:
//  ВариантыСтруктурыЗатрат	 - см. НовыйВариантыСтруктурыЗатрат()
//  Имя						 - Строка - имя варианта; 
//                             При выборе имени следует иметь в виду, что в ходе расчета 
//                             в используемый менеджер временных таблиц будет добавлена таблица с таким именем,
//                             а в используемую коллекцию сумм - набор сумм.
//  СоставКлюча				 - Структура - Ключ - имя элемента ключа; Значение - тип элемента.
//                             Содержит набор полей, описывающих элемент структуры затрат.
//  ОписаниеСумм			 - КоллекцииСумм.НовыйОписаниеКоллекцииСумм	- описание сумм затрат, подлежащих детализации
//  ВнешниеИсточники		 - Массив - имена таблиц, хранящих данные о структуре затрат,
//                             внешние по отношению к этой регламентной операции - результаты предыдущих регламентных операций.
//                             Пример таких данных: начальное сальдо - рассчитано регламентной операцией за предыдущий месяц.
//  ОграничениеНаборовСумм	 - Структура - Ключи - имя набора сумм; Если параметр передан, структура затрат будет рассчитываться 
//                             не для всех сумм из ОписаниеСумм, а только для тех наборов, что входят в ограничение.
//  ДополнительныеЗначения	 - Структура - Ключ - имя значения; Значение - тип значения. 
//                             Дополнительные, кроме сумм, значения, характеризующие элемент структуры конкретной затраты.
//                             В оценке не участвуют. Пример: количество материала.
// 
Процедура ДобавитьВариантСтруктурыЗатрат(ВариантыСтруктурыЗатрат, Имя, СоставКлюча, ОписаниеСумм, ВнешниеИсточники, 
	ОграничениеНаборовСумм = Неопределено, ДополнительныеЗначения = Неопределено) Экспорт
	
	// Проверим выполнение ограничения наборов сумм
	Если Не ЗначениеЗаполнено(ОграничениеНаборовСумм) Тогда
		НаборыСумм = ОписаниеСумм.НаборыСумм;
	Иначе
		НаборыСумм = Новый Структура;
		Для Каждого ОписаниеНабораСумм Из ОписаниеСумм.НаборыСумм Цикл
			Если ОграничениеНаборовСумм.Свойство(ОписаниеНабораСумм.Ключ) Тогда
				НаборыСумм.Вставить(ОписаниеНабораСумм.Ключ, ОписаниеНабораСумм.Значение);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(НаборыСумм) Тогда
		// Вариант не имеет смысла
		Возврат;
	КонецЕсли;
	
	Вариант = ВариантыСтруктурыЗатрат.Добавить();
	
	Вариант.Имя                 = Имя;
	
	Вариант.СоставКлюча         = СоставКлюча;
	Вариант.ВнешниеИсточники    = ВнешниеИсточники;
	
	Вариант.ОписаниеСумм        = КоллекцииСумм.НовыйОписаниеКоллекцииСумм();
	Вариант.ОписаниеСводныхСумм = КоллекцииСумм.НовыйОписаниеКоллекцииСумм();
	
	Вариант.ИмяКолонкиОсновнойКлюч           = Имя + "ОсновнойКлюч";
	Вариант.ИмяКолонкиУстановленОсновнойКлюч = Имя + "УстановленОсновнойКлюч";
	Вариант.ИмяТаблицыОсновныеКлючи          = "Основные" + Имя;
	Вариант.СоставКлючаСтрокой               = ОбщегоНазначенияКлиентСервер.КлючиСтруктурыВСтроку(Вариант.СоставКлюча);
	
	
	// Заполним описания сумм
	ИменаСвойствВсехНаборовСводныхСумм = Новый Массив;
	
	// - наборы сводных сумм
	Для Каждого ОписаниеНабораСумм Из НаборыСумм Цикл
		
		Если ОписаниеНабораСумм.Значение.Переменный Тогда
			Продолжить;
		КонецЕсли;
		
		ИменаСвойствСтрокой = КоллекцииСумм.ИменаСвойствСтрокой(ОписаниеНабораСумм.Значение);
		
		КоллекцииСумм.ДобавитьНаборСумм(Вариант.ОписаниеСумм,        ОписаниеНабораСумм.Ключ, ИменаСвойствСтрокой);
		КоллекцииСумм.ДобавитьНаборСумм(Вариант.ОписаниеСводныхСумм, ОписаниеНабораСумм.Ключ, ИменаСвойствСтрокой);
		
		Для Каждого ИмяСвойства Из КоллекцииСумм.ИменаСвойств(ОписаниеНабораСумм.Значение) Цикл
			ИменаСвойствВсехНаборовСводныхСумм.Добавить(ИмяСвойства);
		КонецЦикла;
		
	КонецЦикла;
	
	// - набор детальных сумм
	КоллекцииСумм.ДобавитьПеременныйНаборСумм(
		Вариант.ОписаниеСумм,
		Вариант.Имя,
		СтрСоединить(ИменаСвойствВсехНаборовСводныхСумм, ","),
		ДополнительныеЗначения);
		
КонецПроцедуры

// Обеспечивает хранение информации о всех вариантах структуры затрат в коллекции сумм - 
// дополняет описание коллекции сумм соответствующими переменными наборами.
//
// Параметры:
//  ОписаниеСумм			 - КоллекцииСумм.НовыйОписаниеКоллекцииСумм - заполняемое описание
//  ВариантыСтруктурыЗатрат	 - НовыйВариантыСтруктурыЗатрат - источник данных для заполнения
//                             (допускается передавать массив элементов коллекции)
//
Процедура ДополнитьОписаниеКоллекцииСумм(ОписаниеСумм, ВариантыСтруктурыЗатрат) Экспорт
	
	Для Каждого Вариант Из ВариантыСтруктурыЗатрат Цикл
		
		ОписаниеНабораСумм = Вариант.ОписаниеСумм.НаборыСумм[Вариант.Имя];
		
		КоллекцииСумм.ДобавитьПеременныйНаборСумм(
			ОписаниеСумм,
			Вариант.Имя,
			СтрСоединить(КоллекцииСумм.ИменаСвойств(ОписаниеНабораСумм), ","),
			ОписаниеНабораСумм.ДополнительныеЗначения);
		
	КонецЦикла;
	
КонецПроцедуры

// Создает пустую коллекцию для хранения соответствия идентификатора элемента структуры затрат
// и набора его ключевых полей.
//
// Параметры:
//  Вариант	- элемент коллекции НовыйВариантыСтруктурыЗатрат
//
Функция НовыйОписаниеКлючей(Вариант) Экспорт
	
	ОписаниеКлючей = Новый ТаблицаЗначений;
	ОписаниеКлючей.Колонки.Добавить("Идентификатор",       УчетЗатрат.ТипИдентификатораВершины());
	ОписаниеКлючей.Колонки.Добавить("ИдентификаторГруппы", УчетЗатрат.ТипИдентификатораВершины()); // -1 для записей без группы
	Для Каждого ЭлементКлюча Из Вариант.СоставКлюча Цикл
		ОписаниеКлючей.Колонки.Добавить(ЭлементКлюча.Ключ, ЭлементКлюча.Значение);
	КонецЦикла;
	
	ОписаниеКлючей.Индексы.Добавить("Идентификатор");
	
	Возврат ОписаниеКлючей;
	
КонецФункции

// Дополняет граф затрат полями, хранящими исходные данные для составления структуры затрат.
// Поля следует заполнить отдельно.
// Также добавляются служебные поля.
//
// Параметры:
//  Затраты - РасчетСебестоимости.НовыйГрафЗатрат - заполняемый объект
//  ВариантыСтруктурыЗатрат	- НовыйВариантыСтруктурыЗатрат - сведения о вариантах структуры затрат, которые следует рассчитать
//
Процедура ИнициализироватьГрафЗатрат(Затраты, ВариантыСтруктурыЗатрат) Экспорт
	
	Затраты.Вставить("ВариантыСтруктурыЗатрат", ВариантыСтруктурыЗатрат);
	
	Для Каждого Вариант Из ВариантыСтруктурыЗатрат Цикл
		
		// Создадим колонки для хранения общих данных о структуре затраты
		Затраты.Вершины.Колонки.Добавить(Вариант.ИмяКолонкиУстановленОсновнойКлюч, Новый ОписаниеТипов("Булево"));
		Затраты.Вершины.Колонки.Добавить(Вариант.ИмяКолонкиОсновнойКлюч,           УчетЗатрат.ТипИдентификатораВершины());
		// Также коллекция дополняется колонкой с суммами. См. ДополнитьОписаниеКоллекцииСумм()
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область Соглашения

// Содержит перечень элементов наборов сумм, которые поддерживаются в текстах запросов этого модуля.
// Для расширения перечня следует модифицировать запросы.
Функция ДопустимыеСвойстваСумм()
	
	ИменаСвойств = Новый Структура;
	ИменаСвойств.Вставить("КоличествоМатериала");
	ИменаСвойств.Вставить("Сумма");
	ИменаСвойств.Вставить("СуммаНУ");
	ИменаСвойств.Вставить("СуммаПР");
	ИменаСвойств.Вставить("СуммаВР");
	
	Возврат ИменаСвойств;
	
КонецФункции

// Содержит перечень элементов ключей структуры затрат, которые поддерживаются в текстах запросов этого модуля.
// Для расширения перечня следует модифицировать запросы.
Функция ДопустимыеЭлементыКлюча()
	
	Возврат СоставКлючаКалькуляцииСебестоимости();
	
КонецФункции

#КонецОбласти

#Область КалькуляцияСебестоимости

// Этот вариант как правило используется в ходе расчета себестоимости.
// Поэтому тексты запросов подготовки данных обеспечивают именно этот вариант.
// Для других вариантов тексты, как правило, модифицируются с помощью СхемаЗапроса

// Добавляет описание варианта структуры затрат, используемого для составления справки-расчета "Калькуляция себестоимости".
//
// Параметры:
//  ВариантыСтруктурыЗатрат	 - см. НовыйВариантыСтруктурыЗатрат()
//  ОписаниеСумм			 - КоллекцииСумм.НовыйОписаниеКоллекцииСумм	- описание сумм затрат, подлежащих детализации
//
Процедура ДобавитьСтандартныйВариантСтруктурыЗатрат(ВариантыСтруктурыЗатрат, ОписаниеСумм) Экспорт
	
	ДополнительныеЗначения = Новый Структура;
	ДополнительныеЗначения.Вставить(
		"КоличествоМатериала",
		Метаданные.РегистрыСведений.РасчетКалькуляцииСебестоимости.Ресурсы.КоличествоМатериала.Тип);
	
	ДобавитьВариантСтруктурыЗатрат(
		ВариантыСтруктурыЗатрат,
		"СтатьиКалькуляции",
		СоставКлючаКалькуляцииСебестоимости(),
		ОписаниеСумм,
		ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве("СтатьиКалькуляцииНачальноеСальдо"),
		Неопределено,
		ДополнительныеЗначения);
	
КонецПроцедуры

// Имя варианта структуры затрат, используемого для составления справки-расчета "Калькуляция себестоимости".
// 
// Возвращаемое значение:
//  Строка - имя
//
Функция ИмяСтандартногоВарианта() Экспорт
	Возврат "СтатьиКалькуляции";
КонецФункции

Функция СоставКлючаКалькуляцииСебестоимости() Экспорт
	
	СоставКлюча = Новый Структура;
	СоставКлюча.Вставить("ПериодЗатрат",     ОбщегоНазначения.ОписаниеТипаДата(ЧастиДаты.Дата));
	СоставКлюча.Вставить("СчетРасходов",     Новый ОписаниеТипов("ПланСчетовСсылка.Хозрасчетный"));
	СоставКлюча.Вставить("ЭлементЗатрат",    Новый ОписаниеТипов("ПеречислениеСсылка.ЭлементыЗатрат"));
	СоставКлюча.Вставить("СтатьяЗатрат",     Новый ОписаниеТипов("СправочникСсылка.СтатьиЗатрат"));
	СоставКлюча.Вставить("Материал",         Новый ОписаниеТипов("СправочникСсылка.Номенклатура"));
	
	Возврат СоставКлюча;
	
КонецФункции

Функция ЭтоСтандартныйВариант(ВариантСтруктурыЗатрат)
	
	Возврат ВариантСтруктурыЗатрат.Имя = ИмяСтандартногоВарианта();
	
КонецФункции

#КонецОбласти

#Область ПодготовкаДанных

// Назначает идентификатор каждому сочетанию аналитики элементов структуры затрат (все вместе называем "Ключем").
// Это позволяет в дальнейших расчетах оперировать только идентификаторами.
// Для каждого варианта структуры затрат создается отдельная совокупность идентификаторов и соответствующих сочетаний аналитики.
//
// Связь идентификатора и значений аналитики сохраняется
// - в протокол
// - во временную таблицу, имя которой совпадает с именем варианта.
// 
// Дополнительно создается временная таблица, в которой некоторым вершинам графа затрат (соответствующим "первичным" затратам)
// сопоставлен идентификатор основного элемента структуры затрат.
//
// Такие основные элементы определяют дальнейшую структуру затрат: собственно "структура" - это комбинация таких основных элементов,
// получаемая в ходе группировки и распределения затрат.
//
// Параметры:
//  МенеджерВременныхТаблиц	 - МенеджерВременныхТаблиц - в менеджер будут помещены созданные таблицы;
//                             Менеджер должен содержать таблицы
//                             1. КлючиВершин - см. РасчетСебестоимости.СоздатьКлючиВершин
//                             2. описание счетов и аналитики счетов затрат - см. РасчетСебестоимости.СоздатьСчетаЗатрат
//                             3. все объявленные как ВнешниеИсточники в вариантах структуры затрат 
//  ВариантыСтруктурыЗатрат	 - НовыйВариантыСтруктурыЗатрат() - управляющая коллекция
//  Затраты	                 - РасчетСебестоимости.НовыйГрафЗатрат() - данные о суммах внешних поступлений
//  ЭлементыПротокола		 - Соответствие - будет дополнено данными о созданных ключах, если инициализирована для этого.
//                             Чтобы получить данные о ключах, коллекция должна содержать элементы,
//                             ключ которых - имя варианта, а значение - НовыйОписаниеКлючей()
//
Процедура СоздатьКлючи(МенеджерВременныхТаблиц, ВариантыСтруктурыЗатрат, Затраты, ЭлементыПротокола) Экспорт 
	
	ДопустимыеЭлементыКлюча = ДопустимыеЭлементыКлюча();
	
	// Таблица с данными о кор. счетах может использоваться для нескольких вариантов.
	// Создается один раз, как только понадобилась первому из них.
	СозданаКорСчетаЭлементовЗатрат = Ложь;
	
	Для Каждого Вариант Из ВариантыСтруктурыЗатрат Цикл
	
		// Текст запроса обеспечивает максимально возможный набор данных, которые могут быть получены из вершины:
		// - см. ДопустимыеЭлементыКлюча.
		// Затем он может быть сокращен: приведен в соответствие с СоставКлюча с помощью СхемаЗапроса.
		// Также с помощью СхемаЗапроса дополняется индексом, соответствующим СоставКлюча.
		// Создание ВТ_КорСчетаЭлементовЗатрат описано ниже.
		
		// ПериодЗатрат следует заполнить отдельно (значением текущего месяца)
		
		// Иногда для определения внешних затрат данные в учете утеряны.
		// Например, это может быть, если данные внешних источников не соответствуют данным на счетах бухгалтерского учета,
		// а также при корректировках на счетах затрат, в ходе которых может быть утеряна детальная информация о структуре затрат.
		// Потеря может произойти только в вершинах, содержащих внешние по отношению к графу затрат суммы.
		// Поэтому ключи всех таких вершины также включаем в состав основных элементов затрат.
		
		ВершиныВнешниеСуммы = Новый Массив;
		Для Каждого ОписаниеВершины Из Затраты.Вершины Цикл
			
			Если ОписаниеВершины.РазделУчета <> "Расходы" Тогда
				Продолжить;
			КонецЕсли;
			
			Если КоллекцииСумм.Пустая(ОписаниеВершины, Вариант.ОписаниеСводныхСумм) Тогда
				Продолжить;
			КонецЕсли;
			
			ВершиныВнешниеСуммы.Добавить(ОписаниеВершины.Идентификатор);
			
		КонецЦикла;
		
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	КлючиВершин.Идентификатор КАК Идентификатор,
		|	ДАТАВРЕМЯ(1, 1, 1) КАК ПериодЗатрат,
		|	КлючиВершин.Счет КАК СчетРасходов,
		|	ЕСТЬNULL(КорСчетаЭлементовЗатрат.Элемент, ЗНАЧЕНИЕ(Перечисление.ЭлементыЗатрат.ПрочиеЗатраты)) КАК ЭлементЗатрат,
		|	ЕСТЬNULL(ВЫРАЗИТЬ(ВЫБОР
		|				КОГДА СубконтоЗатрат.ВидСубконто1 = ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыСубконтоХозрасчетные.СтатьиЗатрат)
		|					ТОГДА КлючиВершин.Субконто1
		|				КОГДА СубконтоЗатрат.ВидСубконто2 = ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыСубконтоХозрасчетные.СтатьиЗатрат)
		|					ТОГДА КлючиВершин.Субконто2
		|				КОГДА СубконтоЗатрат.ВидСубконто3 = ЗНАЧЕНИЕ(ПланВидовХарактеристик.ВидыСубконтоХозрасчетные.СтатьиЗатрат)
		|					ТОГДА КлючиВершин.Субконто3
		|			КОНЕЦ КАК Справочник.СтатьиЗатрат), ЗНАЧЕНИЕ(Справочник.СтатьиЗатрат.ПустаяСсылка)) КАК СтатьяЗатрат,
		|	ВЫБОР
		|		КОГДА СчетаПрямыхРасходов.Счет ЕСТЬ NULL
		|			ТОГДА ЗНАЧЕНИЕ(Справочник.Номенклатура.ПустаяСсылка)
		|		ИНАЧЕ КлючиВершин.Номенклатура
		|	КОНЕЦ КАК Материал
		|ПОМЕСТИТЬ ВТ_ЭлементыСтруктурыЗатрат
		|ИЗ
		|	КлючиВершин КАК КлючиВершин
		|		ЛЕВОЕ СОЕДИНЕНИЕ СубконтоЗатрат КАК СубконтоЗатрат
		|		ПО КлючиВершин.Счет = СубконтоЗатрат.Счет
		|		ЛЕВОЕ СОЕДИНЕНИЕ ВТ_КорСчетаЭлементовЗатрат КАК КорСчетаЭлементовЗатрат
		|		ПО КлючиВершин.КорСчет = КорСчетаЭлементовЗатрат.КорСчет
		|		ЛЕВОЕ СОЕДИНЕНИЕ СчетаПрямыхРасходов КАК СчетаПрямыхРасходов
		|		ПО КлючиВершин.Счет = СчетаПрямыхРасходов.Счет
		|ГДЕ
		|	КлючиВершин.РазделУчета = ""Расходы""
		|	И (КлючиВершин.КорСчет <> ЗНАЧЕНИЕ(ПланСчетов.Хозрасчетный.ПустаяСсылка)
		|			ИЛИ КлючиВершин.Номенклатура <> ЗНАЧЕНИЕ(Справочник.Номенклатура.ПустаяСсылка)
		|			ИЛИ КлючиВершин.Идентификатор В (&ВершиныВнешниеСуммы))
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	ПериодЗатрат,
		|	СчетРасходов,
		|	ЭлементЗатрат,
		|	СтатьяЗатрат,
		|	Материал";
		
		ТекстЗапросаКорСчетаЭлементовЗатрат =
		"ВЫБРАТЬ
		|	КорСчетаЭлементовЗатрат.КорСчет КАК КорСчет,
		|	КорСчетаЭлементовЗатрат.Элемент КАК Элемент
		|ПОМЕСТИТЬ ВТ_КорСчетаЭлементовЗатрат
		|ИЗ
		|	&КорСчетаЭлементовЗатрат КАК КорСчетаЭлементовЗатрат
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	КорСчет";
		
		Если ЭтоСтандартныйВариант(Вариант)
			Или ОбщегоНазначения.ДанныеСовпадают(Вариант.СоставКлюча, ДопустимыеЭлементыКлюча) Тогда
			// Частый случай, в котором не требуется использовать СхемаЗапроса
			ИспользуетсяКорСчетаЭлементовЗатрат = Истина;
		Иначе
			
			// Модифицируем запрос
			
			ИсточникиДанныхПолей = Новый Соответствие;
			ИсточникиДанныхПолей.Вставить("СтатьяЗатрат",  "СубконтоЗатрат");
			ИсточникиДанныхПолей.Вставить("Материал",      "СчетаПрямыхРасходов");
			ИсточникиДанныхПолей.Вставить("ЭлементЗатрат", "КорСчетаЭлементовЗатрат");
			
			СхемаЗапроса = Новый СхемаЗапроса;
			СхемаЗапроса.УстановитьТекстЗапроса(ТекстЗапроса);
			
			ЗапросСхемыЗапроса = СхемаЗапроса.ПакетЗапросов[0];
			Оператор           = ЗапросСхемыЗапроса.Операторы[0];
			
			УдалитьКолонкиЗапроса(ЗапросСхемыЗапроса, Вариант.СоставКлюча, ДопустимыеЭлементыКлюча);

			// Удалим невостребованные источники данных
			Для Каждого ОписаниеИсточникаДанных Из ИсточникиДанныхПолей Цикл
				
				Если ЗапросСхемыЗапроса.Колонки.Найти(ОписаниеИсточникаДанных.Ключ) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				Источник = Оператор.Источники.НайтиПоПсевдониму(ОписаниеИсточникаДанных.Значение);
				Если Источник <> Неопределено Тогда
					Оператор.Источники.Удалить(Оператор.Источники.Индекс(Источник));
				КонецЕсли;
					
			КонецЦикла;
			
			ИспользуетсяКорСчетаЭлементовЗатрат = (Оператор.Источники.НайтиПоИмени("ВТ_КорСчетаЭлементовЗатрат") <> Неопределено);
			
			// Порядок полей в индексе приведем в соответствие порядку полей ключа
			ЗапросСхемыЗапроса.Индекс.Очистить();
			Для Каждого ЭлементКлюча Из Вариант.СоставКлюча Цикл
				ЗапросСхемыЗапроса.Индекс.Добавить(ЭлементКлюча.Ключ);
			КонецЦикла;
			
			ТекстЗапроса = СхемаЗапроса.ПолучитьТекстЗапроса();
			
		КонецЕсли;
		
		Запрос = Новый Запрос;
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
		Запрос.УстановитьПараметр("ВершиныВнешниеСуммы", ВершиныВнешниеСуммы);
		
		ПакетЗапросов = Новый Массив;
		ПакетЗапросов.Добавить(ТекстЗапроса);
		
		Если ИспользуетсяКорСчетаЭлементовЗатрат И Не СозданаКорСчетаЭлементовЗатрат Тогда
			СозданаКорСчетаЭлементовЗатрат =  Истина;
			Запрос.УстановитьПараметр("КорСчетаЭлементовЗатрат", Перечисления.ЭлементыЗатрат.КорСчета());
			ПакетЗапросов.Вставить(0, ТекстЗапросаКорСчетаЭлементовЗатрат);
		КонецЕсли;
		
		Запрос.Текст = СтрСоединить(ПакетЗапросов, ";" + Символы.ПС + Символы.ПС);
		Запрос.Выполнить();// Создана ВТ_ЭлементыСтруктурыЗатрат и, если необходимо, ВТ_КорСчетаЭлементовЗатрат
		
		// Теперь пронумеруем наборы элементов (назначим идентификаторы).
		// Для этого выберем их на сервер бизнес-логики.
		
		// Текст далее модифицируется схемой запроса:
		// - могут быть удалены неиспользуемые поля
		// - может быть дополнен источниками
		ТекстЗапроса = 
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ЭлементыСтруктурыЗатрат.ПериодЗатрат КАК ПериодЗатрат,
		|	ЭлементыСтруктурыЗатрат.СчетРасходов КАК СчетРасходов,
		|	ЭлементыСтруктурыЗатрат.ЭлементЗатрат КАК ЭлементЗатрат,
		|	ЭлементыСтруктурыЗатрат.СтатьяЗатрат КАК СтатьяЗатрат,
		|	ЭлементыСтруктурыЗатрат.Материал КАК Материал
		|ИЗ
		|	ВТ_ЭлементыСтруктурыЗатрат КАК ЭлементыСтруктурыЗатрат
		|ИТОГИ ПО
		|	ПериодЗатрат,
		|	СчетРасходов,
		|	ЭлементЗатрат,
		|	СтатьяЗатрат";
		// Детальные записи - Материал, см. ниже ГруппироватьМатериалы
		
		СхемаЗапроса = Новый СхемаЗапроса;
		СхемаЗапроса.УстановитьТекстЗапроса(ТекстЗапроса);
		ЗапросСхемыЗапроса = СхемаЗапроса.ПакетЗапросов[0];
		Оператор           = ЗапросСхемыЗапроса.Операторы[0];
		
		УдалитьКолонкиЗапроса(ЗапросСхемыЗапроса, Вариант.СоставКлюча, ДопустимыеЭлементыКлюча);
		
		Для Каждого ИмяТаблицы Из Вариант.ВнешниеИсточники Цикл
			
			НовыйОператор = ЗапросСхемыЗапроса.Операторы.Добавить();
			НовыйОператор.ВыбиратьРазличные = Истина;
			НовыйОператор.ТипОбъединения    = ТипОбъединенияСхемыЗапроса.Объединить;
			
			Источник = НовыйОператор.Источники.Добавить(Тип("ОписаниеВременнойТаблицыСхемыЗапроса"), ИмяТаблицы, ИмяТаблицы);
			
			Для Каждого ЭлементКлюча Из Вариант.СоставКлюча Цикл
				Источник.Источник.ДоступныеПоля.Добавить(ЭлементКлюча.Ключ, ЭлементКлюча.Значение);
				Колонка = ЗапросСхемыЗапроса.Колонки.Найти(ЭлементКлюча.Ключ);
				НовыйОператор.ВыбираемыеПоля.Добавить(ЭлементКлюча.Ключ, ЗапросСхемыЗапроса.Колонки.Индекс(Колонка));
			КонецЦикла;
			
		КонецЦикла;
		
		ГруппироватьМатериалы = Вариант.СоставКлюча.Свойство("Материал");
		Если Не ГруппироватьМатериалы Тогда
			ЗапросСхемыЗапроса.КонтрольныеТочкиИтогов.Очистить();
		КонецЕсли;
		
		Запрос = Новый Запрос;
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
		Запрос.Текст = СхемаЗапроса.ПолучитьТекстЗапроса();
		
		ОписаниеКлючей = ЭлементыПротокола[Вариант.Имя];
		Если ОписаниеКлючей = Неопределено Тогда
			ОписаниеКлючей = НовыйОписаниеКлючей(Вариант);
		КонецЕсли;
		
		РезультатЗапроса = Запрос.Выполнить();
		Если ГруппироватьМатериалы Тогда
			ДополнитьОписаниеКлючейГруппироватьМатериалы(ОписаниеКлючей, РезультатЗапроса, Вариант.СоставКлюча.Количество() - 1);
		Иначе
			Выборка = РезультатЗапроса.Выбрать();
			Пока Выборка.Следующий() Цикл
				ДополнитьОписаниеКлючей(ОписаниеКлючей, Выборка);
			КонецЦикла;
		КонецЕсли;
		
		// Создадим результирующие временные таблицы
		
		// Текст запроса обеспечивает максимально возможный набор данных, которые могут быть получены из вершины:
		// - см. ДопустимыеЭлементыКлюча.
		// Затем он может быть сокращен: приведен в соответствие с СоставКлюча с помощью СхемаЗапроса.
		// Кроме того, могут быть изменены имена создаваемых временных таблиц.
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ЭлементыСтруктурыЗатрат.Идентификатор КАК Идентификатор,
		|	ЭлементыСтруктурыЗатрат.ПериодЗатрат КАК ПериодЗатрат,
		|	ЭлементыСтруктурыЗатрат.СчетРасходов КАК СчетРасходов,
		|	ЭлементыСтруктурыЗатрат.СтатьяЗатрат КАК СтатьяЗатрат,
		|	ЭлементыСтруктурыЗатрат.ЭлементЗатрат КАК ЭлементЗатрат,
		|	ЭлементыСтруктурыЗатрат.Материал КАК Материал
		|ПОМЕСТИТЬ СтатьиКалькуляции
		|ИЗ
		|	&ОписаниеКлючей КАК ЭлементыСтруктурыЗатрат
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	ПериодЗатрат,
		|	СчетРасходов,
		|	ЭлементЗатрат,
		|	СтатьяЗатрат,
		|	Материал
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	КлючиАналитики.Идентификатор КАК ИдентификаторКлючаАналитики,
		|	ЭлементыСтруктурыЗатрат.Идентификатор КАК ИдентификаторВершины
		|ПОМЕСТИТЬ ОсновныеСтатьиКалькуляции
		|ИЗ
		|	СтатьиКалькуляции КАК КлючиАналитики
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТ_ЭлементыСтруктурыЗатрат КАК ЭлементыСтруктурыЗатрат
		|		ПО КлючиАналитики.ПериодЗатрат = ЭлементыСтруктурыЗатрат.ПериодЗатрат
		|			И КлючиАналитики.СчетРасходов = ЭлементыСтруктурыЗатрат.СчетРасходов
		|			И КлючиАналитики.ЭлементЗатрат = ЭлементыСтруктурыЗатрат.ЭлементЗатрат
		|			И КлючиАналитики.СтатьяЗатрат = ЭлементыСтруктурыЗатрат.СтатьяЗатрат
		|			И КлючиАналитики.Материал = ЭлементыСтруктурыЗатрат.Материал
		|
		|ИНДЕКСИРОВАТЬ ПО
		|	ИдентификаторКлючаАналитики
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|УНИЧТОЖИТЬ ВТ_ЭлементыСтруктурыЗатрат";
		
		Если ЭтоСтандартныйВариант(Вариант) Тогда
			// Частый случай, в котором не требуется использование СхемаЗапроса
		Иначе
			СхемаЗапроса = Новый СхемаЗапроса;
			СхемаЗапроса.УстановитьТекстЗапроса(ТекстЗапроса);
			
			ЗапросСоздатьКлючи         = СхемаЗапроса.ПакетЗапросов[0];
			ОператорСоздатьКлючи       = ЗапросСоздатьКлючи.Операторы[0];
			
			ЗапросСоздатьОсновныеКлючи = СхемаЗапроса.ПакетЗапросов[1];
			
			УдалитьКолонкиЗапроса(ЗапросСоздатьКлючи, Вариант.СоставКлюча, ДопустимыеЭлементыКлюча);
			
			ЗапросСоздатьКлючи.ТаблицаДляПомещения         = Вариант.Имя;
			ЗапросСоздатьОсновныеКлючи.ТаблицаДляПомещения = Вариант.ИмяТаблицыОсновныеКлючи;
			
			ТекстЗапроса = СхемаЗапроса.ПолучитьТекстЗапроса();
		КонецЕсли;
		
		Запрос = Новый Запрос;
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
		Запрос.Текст                   = ТекстЗапроса;
		Запрос.УстановитьПараметр("ОписаниеКлючей", ОписаниеКлючей);
		Запрос.Выполнить();
		
	КонецЦикла;
	
	Если СозданаКорСчетаЭлементовЗатрат Тогда
		Запрос = Новый Запрос;
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
		Запрос.Текст = "УНИЧТОЖИТЬ ВТ_КорСчетаЭлементовЗатрат";
		Запрос.Выполнить();
	КонецЕсли;
	
КонецПроцедуры

Функция ДополнитьОписаниеКлючей(ОписаниеКлючей, ДанныеЗаполнения, ИдентификаторГруппы = -1)
	
	НоваяСтрока = ОписаниеКлючей.Добавить();
	
	ЗаполнитьЗначенияСвойств(НоваяСтрока, ДанныеЗаполнения);
	
	НоваяСтрока.Идентификатор       = ОписаниеКлючей.Индекс(НоваяСтрока);
	НоваяСтрока.ИдентификаторГруппы = ИдентификаторГруппы;
	
	Возврат НоваяСтрока;
	
КонецФункции

Процедура ДополнитьОписаниеКлючейГруппироватьМатериалы(ОписаниеКлючей, ИсточникДанных, УровеньИтогов)
	
	Выборка = ИсточникДанных.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Если УровеньИтогов > 0 Тогда
		// Идем ниже
		Пока Выборка.Следующий() Цикл
			ДополнитьОписаниеКлючейГруппироватьМатериалы(ОписаниеКлючей, Выборка, УровеньИтогов - 1);
		КонецЦикла;
	Иначе
		// Материалы
		Если Выборка.Количество() < 3 Тогда
			// Группировать не требуется
			Пока Выборка.Следующий() Цикл
				ДополнитьОписаниеКлючей(ОписаниеКлючей, Выборка);
			КонецЦикла;
		Иначе
			ГрупповаяЗапись = ДополнитьОписаниеКлючей(ОписаниеКлючей, ИсточникДанных);
			Пока Выборка.Следующий() Цикл
				Если Выборка.Материал = ГрупповаяЗапись.Материал Тогда
					Продолжить;
				КонецЕсли;
				ДополнитьОписаниеКлючей(ОписаниеКлючей, Выборка, ГрупповаяЗапись.Идентификатор);
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Заполняет в графе затрат исходные данные для расчета структуры затрат
// - данные внешних источников
// - основные ключи структуры затрат
//
// Параметры см. в СоздатьКлючи()
//
Процедура ДополнитьГрафЗатрат(Затраты, МенеджерВременныхТаблиц) Экспорт
	
	Для Каждого Вариант Из Затраты.ВариантыСтруктурыЗатрат Цикл
		
		// Данные о ранее рассчитанной структуре запасов или НЗП, содержащиеся во внешних источниках,
		// поместим в граф затрат
		ЗаполнитьДаннымиВнешнихИсточников(Затраты.Вершины, Вариант, МенеджерВременныхТаблиц);
		
		// Расставляем метки основных ключей (идентифицируем затраты текущего периода)
		ТекстЗапроса =
		"ВЫБРАТЬ
		|	ОсновныеЭлементыСтруктурыЗатрат.ИдентификаторВершины КАК ИдентификаторВершины,
		|	ОсновныеЭлементыСтруктурыЗатрат.ИдентификаторКлючаАналитики КАК ИдентификаторКлючаАналитики
		|ИЗ
		|	ИмяТаблицы КАК ОсновныеЭлементыСтруктурыЗатрат";
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ИмяТаблицы", Вариант.ИмяТаблицыОсновныеКлючи);
		
		Запрос = Новый Запрос;
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
		Запрос.Текст = ТекстЗапроса;
		
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			
			Вершина = Затраты.Вершины.Найти(Выборка.ИдентификаторВершины, "Идентификатор");
			Если Вершина = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			Вершина[Вариант.ИмяКолонкиУстановленОсновнойКлюч] = Истина;
			Вершина[Вариант.ИмяКолонкиОсновнойКлюч]           = Выборка.ИдентификаторКлючаАналитики;
			
			// Данные основного элемента "переложим" в переменный набор сумм
			УстановитьОсновнойЭлемент(Вершина, Вариант);
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьДаннымиВнешнихИсточников(Вершины, Вариант, МенеджерВременныхТаблиц)
	
	Если Не ЗначениеЗаполнено(Вариант.ВнешниеИсточники) Тогда
		Возврат;
	КонецЕсли;
	
	// Запрос может быть модифицирован при помощи СхемаЗапроса:
	// - заменены таблицы исходных данных - см. Вариант.ВнешниеИсточники
	// - заменена таблица ОсновныеКлючиСтруктурыЗатрат на таблицу Вариант.Имя с другим составом полей (Вариант.СоставКлюча)
	// - изменен состав ресурсов - см. Вариант.ОписаниеСумм
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	ИсходныеДанные.Счет КАК Счет,
	|	ИсходныеДанные.Подразделение КАК Подразделение,
	|	ИсходныеДанные.Субконто1 КАК Субконто1,
	|	ИсходныеДанные.Субконто2 КАК Субконто2,
	|	ИсходныеДанные.Субконто3 КАК Субконто3,
	|	ИсходныеДанные.Номенклатура КАК Номенклатура,
	|	ИсходныеДанные.КорСчет КАК КорСчет,
	|	ИсходныеДанные.ПериодЗатрат КАК ПериодЗатрат,
	|	ИсходныеДанные.СчетРасходов КАК СчетРасходов,
	|	ИсходныеДанные.ЭлементЗатрат КАК ЭлементЗатрат,
	|	ИсходныеДанные.СтатьяЗатрат КАК СтатьяЗатрат,
	|	ИсходныеДанные.Материал КАК Материал,
	|	СУММА(ИсходныеДанные.КоличествоМатериала) КАК КоличествоМатериала,
	|	СУММА(ИсходныеДанные.Сумма) КАК Сумма,
	|	СУММА(ИсходныеДанные.СуммаНУ) КАК СуммаНУ,
	|	СУММА(ИсходныеДанные.СуммаПР) КАК СуммаПР,
	|	СУММА(ИсходныеДанные.СуммаВР) КАК СуммаВР
	|ПОМЕСТИТЬ ВТ_ИсходныеДанные
	|ИЗ
	|	СтатьиКалькуляцииНачальноеСальдо КАК ИсходныеДанные
	|
	|СГРУППИРОВАТЬ ПО
	|	ИсходныеДанные.Счет,
	|	ИсходныеДанные.Подразделение,
	|	ИсходныеДанные.Субконто1,
	|	ИсходныеДанные.Субконто2,
	|	ИсходныеДанные.Субконто3,
	|	ИсходныеДанные.Номенклатура,
	|	ИсходныеДанные.КорСчет,
	|	ИсходныеДанные.ПериодЗатрат,
	|	ИсходныеДанные.СчетРасходов,
	|	ИсходныеДанные.ЭлементЗатрат,
	|	ИсходныеДанные.СтатьяЗатрат,
	|	ИсходныеДанные.Материал
	|
	|ИНДЕКСИРОВАТЬ ПО
	|	Счет,
	|	Подразделение,
	|	Субконто1,
	|	Субконто2,
	|	Субконто3,
	|	Номенклатура,
	|	КорСчет
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	КлючиВершин.Идентификатор КАК ИдентификаторВершины,
	|	КлючиСтруктурыЗатрат.Идентификатор КАК ИдентификаторКлючаАналитики,
	|	ИсходныеДанные.КоличествоМатериала КАК КоличествоМатериала,
	|	ИсходныеДанные.Сумма КАК Сумма,
	|	ИсходныеДанные.СуммаНУ КАК СуммаНУ,
	|	ИсходныеДанные.СуммаПР КАК СуммаПР,
	|	ИсходныеДанные.СуммаВР КАК СуммаВР
	|ИЗ
	|	ВТ_ИсходныеДанные КАК ИсходныеДанные
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ КлючиВершин КАК КлючиВершин
	|		ПО ИсходныеДанные.Счет = КлючиВершин.Счет
	|			И ИсходныеДанные.Подразделение = КлючиВершин.Подразделение
	|			И ИсходныеДанные.Субконто1 = КлючиВершин.Субконто1
	|			И ИсходныеДанные.Субконто2 = КлючиВершин.Субконто2
	|			И ИсходныеДанные.Субконто3 = КлючиВершин.Субконто3
	|			И ИсходныеДанные.Номенклатура = КлючиВершин.Номенклатура
	|			И ИсходныеДанные.КорСчет = КлючиВершин.КорСчет
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ СтатьиКалькуляции КАК КлючиСтруктурыЗатрат
	|		ПО ИсходныеДанные.ПериодЗатрат = КлючиСтруктурыЗатрат.ПериодЗатрат
	|			И ИсходныеДанные.СчетРасходов = КлючиСтруктурыЗатрат.СчетРасходов
	|			И ИсходныеДанные.ЭлементЗатрат = КлючиСтруктурыЗатрат.ЭлементЗатрат
	|			И ИсходныеДанные.СтатьяЗатрат = КлючиСтруктурыЗатрат.СтатьяЗатрат
	|			И ИсходныеДанные.Материал = КлючиСтруктурыЗатрат.Материал
	|
	|УПОРЯДОЧИТЬ ПО
	|	Сумма УБЫВ
	|ИТОГИ
	|	СУММА(Сумма),
	|	СУММА(СуммаНУ),
	|	СУММА(СуммаПР),
	|	СУММА(СуммаВР)
	|ПО
	|	ИдентификаторВершины
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|УНИЧТОЖИТЬ ВТ_ИсходныеДанные";
	
	Если Не ЭтоСтандартныйВариант(Вариант) Тогда
		// Текст по-умолчанию не подходит
		
		СхемаЗапроса = Новый СхемаЗапроса;
		СхемаЗапроса.УстановитьТекстЗапроса(ТекстЗапроса);
		
		// МОДИФИЦИРУЕМ ПЕРВЫЙ ЗАПРОС ПАКЕТА - создающий ВТ_ИсходныеДанные
		ЗапросИсходныеДанные = СхемаЗапроса.ПакетЗапросов[0];
		
		// Удаляем колонки, не соответствующие составу ключа - одновременно удалятся и в условии соединения второго запроса
		УдалитьКолонкиЗапроса(ЗапросИсходныеДанные, Вариант.СоставКлюча, ДопустимыеЭлементыКлюча());
		
		// Удаляем ненужные суммы  - одновременно удалятся и во втором запросе
		УдалитьКолонкиЗапроса(
			ЗапросИсходныеДанные,
			Вариант.ОписаниеСумм.НаборыСумм[Вариант.Имя].Шаблон,
			ДопустимыеСвойстваСумм());
		
		// Предполагаем, что в этом случае будет несколько источников.
		// Поэтому делаем вложенный запрос, объединяющий несколько источников, с тем,
		// чтобы сгруппировать по ключевым полям во внешнем запросе.
		// Для замены таблицы на вложенный запрос применяем трюк:
		// сначала добавляем объединение с вложенной таблицей, копируя в нее исходную
		// затем удаляем исходную (невложенную).
			
		ИсходныйОператор    = ЗапросИсходныеДанные.Операторы[0]; // Далее будет удален
		НаборПолейИсточника = ИсходныйОператор.Источники[0].Источник.ДоступныеПоля;
		
		ОператорВнешнегоЗапроса = ЗапросИсходныеДанные.Операторы.Добавить();
		НовыйИсточник = ОператорВнешнегоЗапроса.Источники.Добавить(Тип("ВложенныйЗапросСхемыЗапроса"));
		НовыйИсточник.Источник.Псевдоним = "ИсходныеДанные";
		ВложенныйЗапрос = НовыйИсточник.Источник.Запрос;
		// Для удобства прикладного разработчика СхемаЗапроса автоматически добавляет первый неудаляемый оператор
		// Добавим остальные
		Для Индекс = 1 По Вариант.ВнешниеИсточники.ВГраница() Цикл
			ИмяТаблицы = Вариант.ВнешниеИсточники[Индекс];
			ВложенныйЗапрос.Операторы.Добавить();
		КонецЦикла;
			
		// Теперь заполним свойства этих операторов
		Для Индекс = 0 По Вариант.ВнешниеИсточники.ВГраница() Цикл
			
			ИмяТаблицы      = Вариант.ВнешниеИсточники[Индекс];
			ОператорЗапроса = ВложенныйЗапрос.Операторы[Индекс];
			
			ИсточникВременнойТаблицы = ОператорЗапроса.Источники.Добавить(Тип("ОписаниеВременнойТаблицыСхемыЗапроса"), ИмяТаблицы);
			ВременнаяТаблицаЗапроса  = ИсточникВременнойТаблицы.Источник;
			
			Для Каждого ОписаниеПоля Из НаборПолейИсточника Цикл
				ВременнаяТаблицаЗапроса.ДоступныеПоля.Добавить(ОписаниеПоля.Имя, ОписаниеПоля.ТипЗначения);
			КонецЦикла;
			
			Для Каждого ОписаниеПоля Из ЗапросИсходныеДанные.Колонки Цикл
				ОператорЗапроса.ВыбираемыеПоля.Добавить(ОписаниеПоля.Псевдоним);// При объединении сопоставляются по именам полей
			КонецЦикла;
			
		КонецЦикла;
		
		// Заполняем поля внешнего запроса
		Для Индекс = 0 По ИсходныйОператор.ВыбираемыеПоля.Количество()-1 Цикл
			ОписаниеПоля = ИсходныйОператор.ВыбираемыеПоля[Индекс];
			ОператорВнешнегоЗапроса.ВыбираемыеПоля.Добавить(Строка(ОписаниеПоля), Индекс);
		КонецЦикла;
		
		// Заполняем группировки
		Для Каждого ОписаниеГруппировки Из ИсходныйОператор.Группировка Цикл
			ОператорВнешнегоЗапроса.Группировка.Добавить(Строка(ОписаниеГруппировки));
		КонецЦикла;
		
		// Удаляем ИсходныйОператор
		ИсходныйОператор = Неопределено;
		ЗапросИсходныеДанные.Операторы.Удалить(0); 
		
		// МОДИФИЦИРУЕМ ВТОРОЙ ЗАПРОС - выбирающий данные на сервер приложения:
		// заменяем имя временной таблицы
		ЗапросВыборки = СхемаЗапроса.ПакетЗапросов[1];
		ИсточникиЗапроса = ЗапросВыборки.Операторы[0].Источники;
		МодифицируемыйИсточник = ИсточникиЗапроса.НайтиПоПсевдониму("КлючиСтруктурыЗатрат");
		
		// Для замены временной таблицы следует обеспечить ее нахождение в ДоступныеТаблицы.
		// Чтобы добиться этого, создаем фиктивный запрос, описывающий структуру правильной таблицы
		// (она такая же, как у заменяемой).
		// Затем в ИсточникВременнойТаблицы заменяем таблицу на правильную.
		// Фиктивный запрос удаляем.
		
		ФиктивныйЗапросОписанияВременнойТаблицы = СхемаЗапроса.ПакетЗапросов.Добавить(Тип("ЗапросВыбораСхемыЗапроса"));
		СхемаЗапроса.ПакетЗапросов.Переместить(ФиктивныйЗапросОписанияВременнойТаблицы, 0);
			
		ФиктивныйЗапросОписанияВременнойТаблицы.ТаблицаДляПомещения = Вариант.Имя;
		ОператорОписанияВременнойТаблицы = ФиктивныйЗапросОписанияВременнойТаблицы.Операторы[0];
		СчетчикКолонок = 0;
		Для Каждого ОписаниеПоля Из МодифицируемыйИсточник.Источник.ДоступныеПоля Цикл
			ОператорОписанияВременнойТаблицы.ВыбираемыеПоля.Добавить("NULL");
			ФиктивныйЗапросОписанияВременнойТаблицы.Колонки[СчетчикКолонок].Псевдоним = ОписаниеПоля.Имя;
			СчетчикКолонок = СчетчикКолонок + 1;
		КонецЦикла;
		
		ИсточникиЗапроса.Заменить(
			ИсточникиЗапроса.Индекс(МодифицируемыйИсточник),
			ЗапросВыборки.ДоступныеТаблицы.Найти(Вариант.Имя));
			
		СхемаЗапроса.ПакетЗапросов.Удалить(СхемаЗапроса.ПакетЗапросов.Индекс(ФиктивныйЗапросОписанияВременнойТаблицы));
			
		ТекстЗапроса = СхемаЗапроса.ПолучитьТекстЗапроса();
		
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.Текст = ТекстЗапроса;
	
	ВыборкаВершин = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
	Пока ВыборкаВершин.Следующий() Цикл
		
		Если КоллекцииСумм.Пустая(ВыборкаВершин, Вариант.ОписаниеСводныхСумм) Тогда
			// Такая структура не имеет смысла
			Продолжить;
		КонецЕсли;
		
		Вершина = Вершины.Найти(ВыборкаВершин.ИдентификаторВершины, "Идентификатор");
		Если Вершина = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ОписаниеНабораСумм = Вариант.ОписаниеСумм.НаборыСумм[Вариант.Имя];
		
		// Структура может не соответствовать оценке вершины.
		// В этом случае структуру не используем.
		ФильтрНекорректнойСтруктуры = Новый Структура;
		Для Каждого ИмяСвойства Из ОписаниеНабораСумм.ИменаСвойств Цикл
			Если Вершина[ИмяСвойства] < 0 И ВыборкаВершин[ИмяСвойства] > 0
				Или Вершина[ИмяСвойства] > 0 И ВыборкаВершин[ИмяСвойства] < 0 Тогда
				// Структура совсем не соответствует оценке вершины
				ФильтрНекорректнойСтруктуры.Вставить(ИмяСвойства, 0);
			КонецЕсли;
		КонецЦикла;
		
		Выборка = ВыборкаВершин.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		
		НаборСумм = КоллекцииСумм.ИнициализироватьПеременныйНаборСумм(Вершина, Вариант.Имя, Вариант.ОписаниеСумм);
		
		Пока Выборка.Следующий() Цикл
			
			НоваяСтрока = КоллекцииСумм.ДобавитьВПеременныйНаборСумм(
				НаборСумм, 
				Выборка.ИдентификаторКлючаАналитики, 
				Выборка,
				ОписаниеНабораСумм);
			
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ФильтрНекорректнойСтруктуры);// Очистим некорректные суммы
			
		КонецЦикла;
		
		Исправить(Вершина, Вариант);
		
	КонецЦикла;
	
КонецПроцедуры

// Удаляет из текста запроса колонки, не требуемые для конкретного выполнения расчета.
// 
// Параметры:
//  ЗапросСхемыЗапроса	 - ЗапросВыбораСхемыЗапроса - объект схемы запроса, содержащий модифицируемый запрос
//  РазрешенныеКолонки	 - Структура - Ключ - псевдоним колонки. 
//                         Описывает перечень колонок, которые нужны для выполнения расчета и должны остаться в запросе.
//  ВсеКолонки			 - Структура - Ключ - псевдоним колонки. 
//                         Описывает перечень колонок, которые предусмотрены текстом запроса и имеют схожее назначение.
//                         Все колонки из этого перечня, кроме РазрешенныеКолонки, будут удалены из текста запроса.
//
Процедура УдалитьКолонкиЗапроса(ЗапросСхемыЗапроса, РазрешенныеКолонки, ВсеКолонки)
	
	// Обходим с конца коллекции колонок для удаления
	
	КоличествоКолонок = ЗапросСхемыЗапроса.Колонки.Количество();
	Для НомерСКонца = 1 По КоличествоКолонок Цикл
		
		Индекс = КоличествоКолонок - НомерСКонца;
		ОписаниеПоля = ЗапросСхемыЗапроса.Колонки[Индекс];
		
		Если Не ВсеКолонки.Свойство(ОписаниеПоля.Псевдоним) Тогда
			// поле, не относящееся к теме
			Продолжить;
		КонецЕсли;
			
		Если РазрешенныеКолонки.Свойство(ОписаниеПоля.Псевдоним) Тогда
			// нужное поле
			Продолжить;
		КонецЕсли;
		
		ЗапросСхемыЗапроса.Колонки.Удалить(Индекс);
		
	КонецЦикла;

КонецПроцедуры

#КонецОбласти

#Область ОценкаСтоимости

// Основные алгоритмы, которые при оценке стоимости обеспечивают расчет структуры затрат -
// это алгоритмы коллекций сумм, которые позволяют работать с переменными наборами сумм.

// Здесь - дополнительные алгоритмы, обеспечивающие инициализацию наборов сумм и,
// если необходимо, соответствие итогов набора основным суммам вершин.
// Последнее нужно, в частности, для исправления погрешностей округления,
// а также отличий сохраненной структуры затрат от сумм начального сальдо.

// Инициализирует структуры затрат вершины: назначает ей структуру, состоящую из основного элемента структуры затрат.
// Технически, для этого элементу, назначенному вершине, добавляется разница между сводной суммой
// и суммой по элементам структуры затрат.
//
// Параметры:
//  Вершина					 - СтрокаТаблицыЗначений - см. в НовыйГрафЗатрат()
//                             Граф затрат должен быть предварительно проинициализирован - см. ИнициализироватьГрафЗатрат()
//                             а его вершины содержать наборы сводных сумм и переменные наборы сумм с данными о структурах затрат
//                             (это обеспечивается с помощью ДополнитьОписаниеКоллекцииСумм() и ДобавитьВариантСтруктурыЗатрат())
//  ВариантыСтруктурыЗатрат	 - НовыйВариантыСтруктурыЗатрат() - управляющая коллекция.
//                             Допускается передавать массив элементов коллекции.
//
Процедура УстановитьОсновныеЭлементы(Вершина, ВариантыСтруктурыЗатрат) Экспорт
	
	Для Каждого Вариант Из ВариантыСтруктурыЗатрат Цикл
		УстановитьОсновнойЭлемент(Вершина, Вариант);
	КонецЦикла;
	
КонецПроцедуры

// См. УстановитьОсновныеЭлементы()
Процедура УстановитьОсновнойЭлемент(Вершина, Вариант)
	
	Если Не Вершина[Вариант.ИмяКолонкиУстановленОсновнойКлюч] Тогда
		Возврат;
	КонецЕсли;
	
	// Разницу между сводной суммой и суммой по элементам структуры затрат запишем на элемент, назначенный вершине
	Превышение = КоллекцииСумм.ИтогПеременногоНабораСумм(Вершина, Вариант.Имя, Вариант.ОписаниеСумм);
	КоллекцииСумм.Вычесть(Превышение, Вершина, Вариант.ОписаниеСводныхСумм);
	
	Если КоллекцииСумм.Пустая(Превышение, Вариант.ОписаниеСводныхСумм) Тогда
		Возврат;
	КонецЕсли;
	
	ОсновнойЭлемент = КоллекцииСумм.ЭлементПеременногоНабораСумм(
		Вершина,
		Вариант.Имя,
		Вершина[Вариант.ИмяКолонкиОсновнойКлюч],
		Вариант.ОписаниеСумм);
		
	КоллекцииСумм.Вычесть(ОсновнойЭлемент, Превышение, Вариант.ОписаниеСводныхСумм);
	
КонецПроцедуры

// Обеспечивает корректность абсолютных суммовых показателей структуры затрат,
// сохраняя при этом относительные показатели.
// Для этого обеспечивается соответствие сумм по элементам структуры затрат сводным суммам.
// Если они расходятся, то увеличим (уменьшим) оценку каждого элемента 
// в одинаковой пропорции так, чтобы сумма элементов стала равна сводной сумме.
//
// Параметры:
//  Суммы					 - коллекция сумм - см. модуль КоллекцииСумм; 
//                             содержит сводные суммы и переменные наборы сумм с данными о структурах затрат
//  ВариантыСтруктурыЗатрат	 - НовыйВариантыСтруктурыЗатрат() - управляющая коллекция.
//                             Допускается передавать массив элементов коллекции.
//
Процедура ИсправитьВсе(Суммы, ВариантыСтруктурыЗатрат) Экспорт
	
	Для Каждого Вариант Из ВариантыСтруктурыЗатрат Цикл
		
		Исправить(Суммы, Вариант);
		
	КонецЦикла;
	
КонецПроцедуры

// См. ИсправитьВсе()
Процедура Исправить(Суммы, Вариант, Отбор = Неопределено)
	
	Элементы = Суммы[Вариант.Имя];
	Если Отбор = Неопределено Тогда
		
		Если Не ЗначениеЗаполнено(Элементы) Тогда
			Возврат;
		КонецЕсли;
		
		Если КоллекцииСумм.Пустая(Суммы, Вариант.ОписаниеСводныхСумм) Тогда
			// Структура не важна
			Элементы.Очистить();
			Возврат;
		КонецЕсли;
		
	КонецЕсли;
			
	СуммыВсехЭлементов = КоллекцииСумм.ИтогПеременногоНабораСумм(Суммы, Вариант.Имя, Вариант.ОписаниеСумм);
		
	Если Отбор = Неопределено И КоллекцииСумм.Пустая(СуммыВсехЭлементов, Вариант.ОписаниеСводныхСумм) Тогда
		// Такая структура не имеет смысла
		Элементы.Очистить();
		Возврат;
	КонецЕсли;
		
	Корректировка = КоллекцииСумм.НовыйКоллекцияСумм(Вариант.ОписаниеСводныхСумм, Истина);
	КоллекцииСумм.Заполнить(Корректировка, Суммы, Вариант.ОписаниеСводныхСумм);
	КоллекцииСумм.Вычесть(Корректировка, СуммыВсехЭлементов, Вариант.ОписаниеСводныхСумм);
	
	Если Отбор = Неопределено И КоллекцииСумм.Пустая(Корректировка, Вариант.ОписаниеСводныхСумм) Тогда
		// Все уже хорошо
		Возврат;
	КонецЕсли;
		
	Если Отбор = Неопределено Тогда
		ИменаСвойств = КоллекцииСумм.ИменаСвойств(Вариант.ОписаниеСводныхСумм);
	Иначе
		ИменаСвойств = Отбор;
	КонецЕсли;
	
	// Скорректируем элементы
	Для Каждого ИмяСвойства Из ИменаСвойств Цикл
		
		// Сортировать следует начиная с сумм того знака, как у итоговой суммы:
		Если СуммыВсехЭлементов[ИмяСвойства] < 0 Тогда
			Элементы.Сортировать(ИмяСвойства);
		Иначе
			Элементы.Сортировать(ИмяСвойства + " УБЫВ");
		КонецЕсли;
		
		Для Каждого ОписаниеЭлемента Из Элементы Цикл
			КорректировкаСуммыЭлемента = КорректировкаСуммыЭлемента(
				ОписаниеЭлемента[ИмяСвойства],
				Корректировка[ИмяСвойства],
				СуммыВсехЭлементов[ИмяСвойства]);
			ОписаниеЭлемента[ИмяСвойства] = ОписаниеЭлемента[ИмяСвойства] + КорректировкаСуммыЭлемента;
			
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Функция КорректировкаСуммыЭлемента(Знач ЗначениеЭлемента, ОстатокКорректировки, ОстатокСуммыЭлементов)
	
	// При определенной последовательности положительных и отрицательных сумм
	// может возникнуть эффект "качелей", при которых этот алгоритм не сможет учесть все элементы.
	// Пример такой последовательности: 400 -100 200 -200; 400 -500 100 300
	// Для того, чтобы избежать проблемы, на вход функции следует подавать сначала все элементы
	// одного знака, затем - все элементы другого знака.
	// Другими словами, элементы следует упорядочить по суммам (для случая, когда итог суммы положительный - по убыванию)
	
	Если ЗначениеЭлемента = ОстатокКорректировки Тогда
		Корректировка = ЗначениеЭлемента;
	ИначеЕсли ЗначениеЭлемента = ОстатокСуммыЭлементов Тогда
		Корректировка = ОстатокКорректировки;
	ИначеЕсли ОстатокСуммыЭлементов = 0 Тогда
		Корректировка = 0;
	Иначе
		Корректировка = Окр(
			ЗначениеЭлемента * ОстатокКорректировки / ОстатокСуммыЭлементов,
			БухгалтерскийУчетКлиентСервер.РазрядностьДробнойЧастиСумм());
	КонецЕсли;
	
	ОстатокСуммыЭлементов = ОстатокСуммыЭлементов - ЗначениеЭлемента;
	ОстатокКорректировки  = ОстатокКорректировки - Корректировка;
	
	Возврат Корректировка;
	
КонецФункции

Процедура РассчитатьДолю(Результат, ИсходныеСуммы, Числитель, Знаменатель, ВариантыСтруктурыЗатрат) Экспорт
	
	Если Числитель = Знаменатель Или Знаменатель = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого Вариант Из ВариантыСтруктурыЗатрат Цикл
		ИсходныеДанныеНабора = ИсходныеСуммы[Вариант.Имя];
		Если Не ЗначениеЗаполнено(ИсходныеДанныеНабора) Тогда
			Продолжить;
		КонецЕсли;
		
		РаспределяемыеСуммы = Новый Структура;
		
		Для Каждого ИмяСвойства Из Вариант.ОписаниеСводныхСумм.ИменаСвойств Цикл
			Значение = Результат[ИмяСвойства];
			Если Значение <> 0 Тогда
				РаспределяемыеСуммы.Вставить(ИмяСвойства, Значение);
			КонецЕсли;
		КонецЦикла;
		
		Если Не ЗначениеЗаполнено(РаспределяемыеСуммы) Тогда
			Продолжить;
		КонецЕсли;
		// Сначала рассчитаем доли без учета структуры.
		// Если общая сумма в какой-то из колонок не совпадет, то уточним ее дальше.
		ПропущенныеЭлементыНабора = Новый Массив;
		
		НаборСумм      = Неопределено;
		ОписаниеНабора = Вариант.ОписаниеСумм.НаборыСумм[Вариант.Имя];
		
		Для Каждого ЭлементИсходногоНабора Из ИсходныеДанныеНабора Цикл
			
			СуммыЭлемента = Новый Структура;
			
			// Рассчитаем основные суммы набора сумм
			Для Каждого ОписаниеСуммы Из РаспределяемыеСуммы Цикл
				ДополнитьДоли(
					СуммыЭлемента,
					ЭлементИсходногоНабора,
					ОписаниеСуммы.Ключ,
					Числитель,
					Знаменатель);
			КонецЦикла;
			
			// Для основных значений поддерживаем структуру, поэтому скорректируем остаток сводной суммы
			Для Каждого ЭлементСумм Из СуммыЭлемента Цикл
				РаспределяемыеСуммы[ЭлементСумм.Ключ] = РаспределяемыеСуммы[ЭлементСумм.Ключ] - ЭлементСумм.Значение;
			КонецЦикла;
			
			// Дополнительные значения не хранят структуру, поэтому их рассчитываем отдельно
			Для Каждого ОписаниеЗначения Из ОписаниеНабора.ДополнительныеЗначения Цикл
				ДополнитьДоли(
					СуммыЭлемента,
					ЭлементИсходногоНабора,
					ОписаниеЗначения.Ключ,
					Числитель,
					Знаменатель,
					ОписаниеЗначения.Значение);
			КонецЦикла;
			
			Если Не ЗначениеЗаполнено(СуммыЭлемента) Тогда
				ПропущенныеЭлементыНабора.Добавить(ЭлементИсходногоНабора);
				Продолжить;
			КонецЕсли;
			
			Если НаборСумм = Неопределено Тогда
				НаборСумм = КоллекцииСумм.ИнициализироватьПеременныйНаборСумм(Результат, Вариант.Имя, Вариант.ОписаниеСумм);
			КонецЕсли;
			
			ВсеСуммы = Новый Структура(ОписаниеНабора.Шаблон);
			ЗаполнитьЗначенияСвойств(ВсеСуммы, СуммыЭлемента);
			КоллекцииСумм.ДобавитьВПеременныйНаборСумм(НаборСумм, ЭлементИсходногоНабора.Идентификатор, ВсеСуммы, ОписаниеНабора);
			
		КонецЦикла;
		// Убедимся, что структура корректная
		ИсправитьСтруктуру = Новый Массив;
		Для Каждого ОписаниеСуммы Из РаспределяемыеСуммы Цикл
			Если ОписаниеСуммы.Значение <> 0 Тогда
				ИсправитьСтруктуру.Добавить(ОписаниеСуммы.Ключ);
			КонецЕсли;
		КонецЦикла;
		Если Не ЗначениеЗаполнено(ИсправитьСтруктуру) Тогда
			Продолжить;
		КонецЕсли;
		
		// Для исправления вернем забракованные колонки в исходное состояние (без внесенных погрешностей округления)
		Если НаборСумм = Неопределено Тогда
			НаборСумм = КоллекцииСумм.ИнициализироватьПеременныйНаборСумм(Результат, Вариант.Имя, Вариант.ОписаниеСумм);
		КонецЕсли;
		Для Каждого ЭлементИсходногоНабора Из ПропущенныеЭлементыНабора Цикл
			ВосстановленнаяСтрока = НаборСумм.Вставить(ИсходныеДанныеНабора.Индекс(ЭлементИсходногоНабора));
			ВосстановленнаяСтрока.Идентификатор = ЭлементИсходногоНабора.Идентификатор;
		КонецЦикла;
		Для Каждого ИмяКолонки Из ИсправитьСтруктуру Цикл
			НаборСумм.ЗагрузитьКолонку(ИсходныеДанныеНабора.ВыгрузитьКолонку(ИмяКолонки), ИмяКолонки);
		КонецЦикла;
		Исправить(Результат, Вариант, ИсправитьСтруктуру);
	КонецЦикла;
	
КонецПроцедуры

// Рассчитывает долю суммы и дополняет коллекцию рассчитанным значением.
// Используется в РассчитатьДолю()
//
// Параметры:
//  Доли				 - Структура - ключ - ИмяСуммы, значение - доля делимой суммы
//  ДелимыеСуммы		 - Структура, СтрокаТаблицыЗначений - коллекция делимых сумм, доля одной из которых рассчитывается
//  ИмяСуммы			 - Строка - имя элемента коллекции сумм, для которого выполняется расчет
//  Числитель			 - Число - определяет коэффициент доли
//  Знаменатель			 - Число - определяет коэффициент доли
//  ОписаниеТипаЗначения - ОписаниеТипов - описывает число с квалификатором, определяющим точность округления результата арифметических операций
//                       - Неопределено - используется стандартный тип для сумм
// 
Процедура ДополнитьДоли(Доли, ДелимыеСуммы, ИмяСуммы, Числитель, Знаменатель, ОписаниеТипаЗначения = Неопределено)
	
	ДелимаяСумма = ДелимыеСуммы[ИмяСуммы];
	
	Если ДелимаяСумма = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Доля = КоллекцииСумм.ДоляСуммы(ДелимаяСумма, Числитель, Знаменатель, ОписаниеТипаЗначения);
	
	Если Доля = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Доли.Вставить(ИмяСуммы, Доля);
	
КонецПроцедуры

#КонецОбласти
