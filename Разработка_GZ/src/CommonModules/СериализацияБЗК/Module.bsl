#Область СлужебныйПрограммныйИнтерфейс

#Область DOM

// На основании XML получает структуру с документом DOM и разыменователем пространств имен DOM.
//   Полученную структуру можно передавать в другие методы модуля в качестве параметра СтруктураDOM.
//
// Параметры:
//   XMLСтрокаИлиДвоичныеДанные - Строка, ДвоичныеДанные - Строка в формате XML или двоичные данные XML документа.
//
// Возвращаемое значение:
//   Структура - Информация о документе DOM.
//       * ДокументDOM - ДокументDOM
//       * Разыменователь - РазыменовательПространствИменDOM
//
Функция СтруктураDOM(XMLСтрокаИлиДвоичныеДанные) Экспорт
	Если ТипЗнч(XMLСтрокаИлиДвоичныеДанные) = Тип("ДвоичныеДанные") Тогда
		БуферДвоичныхДанных = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(XMLСтрокаИлиДвоичныеДанные);
		ПотокВПамяти = Новый ПотокВПамяти(БуферДвоичныхДанных);
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.ОткрытьПоток(ПотокВПамяти);
	ИначеЕсли ТипЗнч(XMLСтрокаИлиДвоичныеДанные) = Тип("Строка") Тогда
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку(XMLСтрокаИлиДвоичныеДанные);
	КонецЕсли;
	
	ПостроительDOM = Новый ПостроительDOM;
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	ЧтениеXML.Закрыть();
	
	СтруктураDOM = Новый Структура;
	СтруктураDOM.Вставить("ДокументDOM", ДокументDOM);
	СтруктураDOM.Вставить("Разыменователь", Новый РазыменовательПространствИменDOM(ДокументDOM));
	Возврат СтруктураDOM;
КонецФункции

// Находит узел документа DOM используя выражение XPath.
//
// Параметры:
//   СтруктураDOM - Структура - См. СериализацияБЗК.СтруктураDOM.
//   ВыражениеXPath - Строка - См. в синтакс-помощнике "ДокументDOM.ВычислитьВыражениеXPath", параметр "Выражение".
//   ЭлементDOM - Произвольный - Элемент документа, в контексте которого выполняется поиск.
//       См. в синтакс-помощнике "ДокументDOM.ВычислитьВыражениеXPath", параметр "УзелКонтекста".
//
// Возвращаемое значение:
//   Неопределено - Если элемент не найден.
//   ЭлементDOM, Произвольный - См. в синтакс-помощнике "РезультатXPath.ПолучитьСледующий", возвращаемое значение.
//
Функция НайтиУзелDOM(Знач СтруктураDOM, Знач ВыражениеXPath, Знач ЭлементDOM = Неопределено) Экспорт
	Возврат ВычислитьВыражениеXPath(СтруктураDOM, ВыражениеXPath, ЭлементDOM).ПолучитьСледующий();
КонецФункции

// Вычисляет выражение XPath для документа DOM.
//
// Параметры:
//   СтруктураDOM - Структура - См. СериализацияБЗК.СтруктураDOM.
//   ВыражениеXPath - Строка - См. в синтакс-помощнике "ДокументDOM.ВычислитьВыражениеXPath", параметр "Выражение".
//   ЭлементDOM - Произвольный - Элемент документа, в контексте которого выполняется поиск.
//       См. в синтакс-помощнике "ДокументDOM.ВычислитьВыражениеXPath", параметр "УзелКонтекста".
//
// Возвращаемое значение:
//   РезультатXPath - См. в синтакс-помощнике "ДокументDOM.ВычислитьВыражениеXPath".
//
Функция ВычислитьВыражениеXPath(Знач СтруктураDOM, Знач ВыражениеXPath, Знач ЭлементDOM = Неопределено) Экспорт
	Если ЭлементDOM = Неопределено Тогда
		ЭлементDOM = СтруктураDOM.ДокументDOM;
	КонецЕсли;
	Возврат СтруктураDOM.ДокументDOM.ВычислитьВыражениеXPath(ВыражениеXPath, ЭлементDOM, СтруктураDOM.Разыменователь);
КонецФункции

// Преобразует (сериализует) объект DOM в строку в формате XML.
//
// Параметры:
//   ОбъектDOM - ЭлементDOM, ДокументDOM - Объект, который требуется сериализовать в строку XML.
//
// Возвращаемое значение:
//   Строка
//
Функция ОбъектDOMВСтрокуXML(ОбъектDOM) Экспорт
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку();
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьDOM.Записать(ОбъектDOM, ЗаписьXML);
	Возврат ЗаписьXML.Закрыть();
КонецФункции

#КонецОбласти

#Область XDTO

// Получает (десериализует) объект XDTO из строки в формате XML.
//
// Параметры:
//   СтрокаXML - Строка
//
// Возвращаемое значение:
//   ОбъектXDTO
//
Функция ОбъектXDTOИзСтрокиXML(СтрокаXML) Экспорт
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(СтрокаXML);
	ОбъектXDTO = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);
	ЧтениеXML.Закрыть();
	Возврат ОбъектXDTO;
КонецФункции

// Получает значение списочного свойства объекта XDTO.
//
// Параметры:
//   ОбъектXDTO - ОбъектXDTO
//   ПутьКСвойству - Строка
//
// Возвращаемое значение:
//   Массив
//
Функция СписокXDTO(ОбъектXDTO, ПутьКСвойству) Экспорт
	Если ОбъектXDTO = Неопределено Тогда
		Возврат Новый Массив;
	КонецЕсли;
	Значение = ОбщегоНазначенияБЗК.ЗначениеСвойства(ОбъектXDTO, ПутьКСвойству);
	Если Значение = Неопределено Тогда
		Возврат Новый Массив;
	ИначеЕсли ТипЗнч(Значение) = Тип("СписокXDTO") Тогда
		Возврат Значение;
	Иначе
		Массив = Новый Массив;
		Массив.Добавить(Значение);
		Возврат Массив;
	КонецЕсли;
КонецФункции

// Записывает (сериализует) объект XDTO в строку в формате XML.
//
// Параметры:
//   ОбъектXDTO - ОбъектXDTO
//   ИмяКорневогоУзла - Строка
//   ЗаписатьОбъявлениеXML - Булево
//
// Возвращаемое значение:
//   Строка - Строка XML.
//
Функция ОбъектXDTOВСтрокуXML(ОбъектXDTO, ИмяКорневогоУзла, ЗаписатьОбъявлениеXML = Ложь) Экспорт
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку("UTF-8");
	Если ЗаписатьОбъявлениеXML Тогда
		ЗаписьXML.ЗаписатьОбъявлениеXML();
	КонецЕсли;
	ФабрикаXDTO.ЗаписатьXML(ЗаписьXML, ОбъектXDTO, ИмяКорневогоУзла);
	Возврат ЗаписьXML.Закрыть();
КонецФункции

#КонецОбласти

#Область XML

// Преобразует строку XML (полученную из текста элемента или значения атрибута XML) в значение указанного типа.
//
// Параметры:
//   * СтрокаXML - Строка, Неопределено - Строка, полученная из XML.
//   * Тип - Тип - Тип ожидаемого значения.
//
// Возвращаемое значение:
//   Произвольный - В соответствии с указанным типом.
//       Если параметр "СтрокаXML" не заполнен, то значение параметра СтрокаXML возвращается без приведения к типу.
//       Например, если передать Неопределено, то на выходе тоже будет Неопределено.
//
Функция ЗначениеXML(СтрокаXML, ТипВозвращаемогоЗначения) Экспорт
	ТипЗначенияXML = ТипЗнч(СтрокаXML);
	Если ТипЗначенияXML = ТипВозвращаемогоЗначения Тогда
		Возврат СтрокаXML;
	ИначеЕсли ТипЗначенияXML = Тип("Строка") И Не ПустаяСтрока(СтрокаXML) Тогда
		Возврат XMLЗначение(ТипВозвращаемогоЗначения, СтрокаXML);
	ИначеЕсли СтрокаXML = Неопределено Или ТипЗначенияXML = Тип("ОбъектXDTO") Тогда
		Возврат Неопределено;
	Иначе
		Возврат СтрокаXML;
	КонецЕсли;
КонецФункции

// Получает строку XML из значения типа "Строка" или "ДвоичныеДанные", размещенного во временном хранилище.
Функция СтрокаXMLИзВременногоХранилища(Адрес) Экспорт
	
	СтрокаИлиДвоичныеДанные = ПолучитьИзВременногоХранилища(Адрес);
	Тип = ТипЗнч(СтрокаИлиДвоичныеДанные);
	
	Если Тип = Тип("ДвоичныеДанные") Тогда
		
		// Определение кодировки.
		Кодировка = КодировкаДвоичныхДанных(СтрокаИлиДвоичныеДанные);
		Если Не ЗначениеЗаполнено(Кодировка) Тогда
			Кодировка = "UTF-8";
		КонецЕсли;
		
		// Получение строки.
		Возврат ПолучитьСтрокуИзДвоичныхДанных(СтрокаИлиДвоичныеДанные, Кодировка);
		
	ИначеЕсли Тип = Тип("Строка") Тогда
		
		Возврат СтрокаИлиДвоичныеДанные;
		
	Иначе
		
		ТекстОшибки = СтрШаблон(
			НСтр("ru = 'Функция %1 не поддерживает получение строки XML из типа %2'"),
			"СтрокаXMLИзВременногоХранилища",
			Тип);
		ВызватьИсключение ТекстОшибки;
		
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область JSON

// Преобразует (сериализует) значение в строку в формате JSON.
// Внимание. В формат JSON допускается записывать только значения следующих типов:
//     * Строка,
//     * Число,
//     * Булево,
//     * Дата (преобразованная в строку),
//     * Массив,
//     * ФиксированныйМассив,
//     * Структура,
//     * ФиксированнаяСтруктура,
//     * Соответствие,
//     * ФиксированноеСоответствие.
//   Данное требование рекурсивно.
//
// Параметры:
//   Значение - Булево, Число, Строка, Массив, Структура, Соответствие - Объект, сериализуемый в JSON.
//   ПорядокКлючейВКоллекциях - Соответствие - Определяет порядок записи ключей коллекций в JSON.
//
// Возвращаемое значение:
//   Строка
//
Функция ЗначениеВСтрокуJSON(Значение, ПорядокКлючейВКоллекциях = Неопределено) Экспорт
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку(ПараметрыЗаписиJSON());
	
	Если ПорядокКлючейВКоллекциях <> Неопределено Тогда
		ПродолжитьЗаписьЗначенияВJSON(ЗаписьJSON, Значение, ПорядокКлючейВКоллекциях);
	Иначе
		ЗаписатьJSON(ЗаписьJSON, Значение);
	КонецЕсли;
	
	Возврат ЗаписьJSON.Закрыть();
КонецФункции

// Получает (десериализует) объект значение из строки в формате JSON.
//
// Параметры:
//   СтрокаJSON - Строка
//   ПрочитатьВСоответствие - Булево - Если Истина, то коллекции с ключами и значениями будут получены в Соответствие.
//       Если Ложь, то в Структуру.
//       Подробнее см. в синтакс-помощнике описание одноименного параметра метода глобального контекста "ПрочитатьJSON".
//   ПорядокКлючейВКоллекциях - Соответствие - Используется в случае, если важно запомнить порядок прочитанных ключей,
//       например, для использования в параметрах метода ЗначениеВСтрокуJSON.
//       На входе передается пустое соответствие.
//       После выполнения функции в ключи соответствия помещаются коллекции типа Структура и Соответствие,
//       а в значение порядок их ключей в виде массива.
//       Внимание. При удалении ключей из коллекции их также необходимо удалить и из порядка ключей.
//   ИменаСвойствСоЗначениямиДата - Массив, Строка, ФиксированныйМассив - Имена свойств, которые должны загружаться как
//       тип "Дата". Подробнее см. в синтакс-помощнике описание одноименного параметра метода глобального контекста "ПрочитатьJSON".
//
// Возвращаемое значение:
//   Булево, Число, Строка, Массив, Структура, Соответствие
//
Функция ЗначениеИзСтрокиJSON(СтрокаJSON, ПрочитатьВСоответствие = Ложь, ПорядокКлючейВКоллекциях = Неопределено, ИменаСвойствСоЗначениямиДата = "") Экспорт
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(СтрокаJSON);
	
	Если ПорядокКлючейВКоллекциях = Неопределено Тогда
		Возврат ПрочитатьJSON(ЧтениеJSON, ПрочитатьВСоответствие, ИменаСвойствСоЗначениямиДата);
	Иначе
		Возврат ПродолжитьЧтениеЗначенияИзJSON(ЧтениеJSON, ПрочитатьВСоответствие, Неопределено, ПорядокКлючейВКоллекциях);
	КонецЕсли;
КонецФункции

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПараметрыЗаписиJSON()
	Возврат Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Unix, "  ");
КонецФункции

Процедура ПродолжитьЗаписьЗначенияВJSON(ЗаписьJSON, Значение, ПорядокКлючейВКоллекциях)
	
	Если ТипЗнч(Значение) = Тип("Массив") Тогда
		
		ЗаписьJSON.ЗаписатьНачалоМассива();
		Для Каждого ВложенноеЗначение Из Значение Цикл
			ПродолжитьЗаписьЗначенияВJSON(ЗаписьJSON, ВложенноеЗначение, ПорядокКлючейВКоллекциях);
		КонецЦикла;
		ЗаписьJSON.ЗаписатьКонецМассива();
		
	ИначеЕсли ТипЗнч(Значение) = Тип("Структура")
		Или ТипЗнч(Значение) = Тип("Соответствие") Тогда
		
		ЗаписьJSON.ЗаписатьНачалоОбъекта();
		ПорядокКлючейТекущейКоллекции = ПорядокКлючейВКоллекциях[Значение];
		Для Каждого Ключ Из ПорядокКлючейТекущейКоллекции Цикл
			ЗаписьJSON.ЗаписатьИмяСвойства(Ключ);
			ПродолжитьЗаписьЗначенияВJSON(ЗаписьJSON, Значение[Ключ], ПорядокКлючейВКоллекциях);
		КонецЦикла;
		ЗаписьJSON.ЗаписатьКонецОбъекта();
		
	Иначе
		
		ЗаписьJSON.ЗаписатьЗначение(Значение);
		
	КонецЕсли;
	
КонецПроцедуры

Функция ПродолжитьЧтениеЗначенияИзJSON(ЧтениеJSON, ПрочитатьВСоответствие, ТекущаяКоллекция, ПорядокКлючейВКоллекциях, ПорядокКлючейТекущейКоллекции = Неопределено)
	Значение = Неопределено;
	КлючУзлаJSON = Неопределено;
	
	Пока ЧтениеJSON.Прочитать() Цикл
		ТипУзлаJSON = ЧтениеJSON.ТипТекущегоЗначения;
		
		Если ТипУзлаJSON = ТипЗначенияJSON.КонецОбъекта Или ТипУзлаJSON = ТипЗначенияJSON.КонецМассива Тогда
			
			Возврат ТекущаяКоллекция;
			
		ИначеЕсли ТипУзлаJSON = ТипЗначенияJSON.ИмяСвойства Тогда
			
			КлючУзлаJSON = ЧтениеJSON.ТекущееЗначение;
			
			Если ПорядокКлючейТекущейКоллекции <> Неопределено Тогда
				ПорядокКлючейТекущейКоллекции.Добавить(КлючУзлаJSON);
			КонецЕсли;
			
		Иначе
			
			Если ТипУзлаJSON = ТипЗначенияJSON.НачалоОбъекта Тогда
				
				// Упорядоченное соответствие.
				Значение = ?(ПрочитатьВСоответствие, Новый Соответствие, Новый Структура);
				ПорядокКлючейВложеннойКоллекции = Новый Массив;
				ПорядокКлючейВКоллекциях.Вставить(Значение, ПорядокКлючейВложеннойКоллекции);
				ПродолжитьЧтениеЗначенияИзJSON(ЧтениеJSON, ПрочитатьВСоответствие, Значение, ПорядокКлючейВКоллекциях, ПорядокКлючейВложеннойКоллекции);
				
			ИначеЕсли ТипУзлаJSON = ТипЗначенияJSON.НачалоМассива Тогда
				
				// Вложенный массив.
				Значение = Новый Массив;
				ПродолжитьЧтениеЗначенияИзJSON(ЧтениеJSON, ПрочитатьВСоответствие, Значение, ПорядокКлючейВКоллекциях);
				
			Иначе
				
				Значение = ЧтениеJSON.ТекущееЗначение;
				
			КонецЕсли;
			
			Если ТипЗнч(ТекущаяКоллекция) = Тип("Массив") Тогда
				ТекущаяКоллекция.Добавить(Значение);
			ИначеЕсли ТекущаяКоллекция <> Неопределено Тогда
				ТекущаяКоллекция.Вставить(КлючУзлаJSON, Значение);
			Иначе
				Возврат Значение;
			КонецЕсли;
			
			КлючУзлаJSON = Неопределено;
			
		КонецЕсли;
	КонецЦикла;
	
КонецФункции

Функция КодировкаДвоичныхДанных(ДвоичныеДанные)
	// Если есть BOM, то это первичная информация о том, в каком формате записан текст.
	КодировкаBOM = КодировкаBOM(ДвоичныеДанные);
	Если ЗначениеЗаполнено(КодировкаBOM) Тогда
		Возврат КодировкаBOM;
	КонецЕсли;
	Возврат КодировкаXML(ДвоичныеДанные);
КонецФункции

Функция КодировкаXML(XMLСтрокаИлиДвоичныеДанные) Экспорт
	// Список кодировок XML см. в https://msdn.microsoft.com/en-us/library/dd317756.aspx
	Если ТипЗнч(XMLСтрокаИлиДвоичныеДанные) = Тип("ДвоичныеДанные") Тогда
		БуферДвоичныхДанных = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(XMLСтрокаИлиДвоичныеДанные);
		ПотокВПамяти = Новый ПотокВПамяти(БуферДвоичныхДанных);
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.ОткрытьПоток(ПотокВПамяти);
	ИначеЕсли ТипЗнч(XMLСтрокаИлиДвоичныеДанные) = Тип("Строка") Тогда
		ЧтениеXML = Новый ЧтениеXML;
		ЧтениеXML.УстановитьСтроку(XMLСтрокаИлиДвоичныеДанные);
	КонецЕсли;
	
	Попытка
		ЧтениеXML.ПерейтиКСодержимому();
		КодировкаXML = ЧтениеXML.КодировкаXML;
	Исключение
		КодировкаXML = "";
	КонецПопытки;
	
	ЧтениеXML.Закрыть();
	
	Если ТипЗнч(XMLСтрокаИлиДвоичныеДанные) = Тип("ДвоичныеДанные") Тогда
		ПотокВПамяти.Закрыть();
	КонецЕсли;
	
	Возврат КодировкаXML;
КонецФункции

Функция КодировкаBOM(ДвоичныеДанные)
	ЧтениеДанных = Новый ЧтениеДанных(ДвоичныеДанные);
	БуферДвоичныхДанных = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(5);
	ПрочитанныеБайты = Новый Массив(5);
	
	ВГраница = БуферДвоичныхДанных.Размер - 1;
	Для Индекс = 0 По 4 Цикл
		Если Индекс < БуферДвоичныхДанных.Размер Тогда
			ПрочитанныеБайты[Индекс] = БуферДвоичныхДанных[Индекс];
		Иначе // Неинициализированные байты считаем равными 0xA5, чтобы в случае меньшего размера файла не ошибиться в кодировке.
			ПрочитанныеБайты[Индекс] = ЧислоИзШестнадцатеричнойСтроки("0xA5");
		КонецЕсли;
	КонецЦикла;
	
	Если ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0xFE")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0xFF") Тогда
		КодировкаBOM = "UTF-16BE";
	ИначеЕсли ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0xFF")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0xFE") Тогда
		Если ПрочитанныеБайты[2] = ЧислоИзШестнадцатеричнойСтроки("0x00")
			И ПрочитанныеБайты[3] = ЧислоИзШестнадцатеричнойСтроки("0x00") Тогда
			КодировкаBOM = "UTF-32LE";
		Иначе
			КодировкаBOM = "UTF-16LE";
		КонецЕсли;
	ИначеЕсли ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0xEF")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0xBB")
		И ПрочитанныеБайты[2] = ЧислоИзШестнадцатеричнойСтроки("0xBF") Тогда
		КодировкаBOM = "UTF-8";
	ИначеЕсли ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0x00")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0x00")
		И ПрочитанныеБайты[2] = ЧислоИзШестнадцатеричнойСтроки("0xFE")
		И ПрочитанныеБайты[3] = ЧислоИзШестнадцатеричнойСтроки("0xFF") Тогда
		КодировкаBOM = "UTF-32BE";
	ИначеЕсли ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0x0E")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0xFE")
		И ПрочитанныеБайты[2] = ЧислоИзШестнадцатеричнойСтроки("0xFF") Тогда
		КодировкаBOM = "SCSU";
	ИначеЕсли ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0xFB")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0xEE")
		И ПрочитанныеБайты[2] = ЧислоИзШестнадцатеричнойСтроки("0x28") Тогда
		КодировкаBOM = "BOCU-1";
	ИначеЕсли ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0x2B")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0x2F")
		И ПрочитанныеБайты[2] = ЧислоИзШестнадцатеричнойСтроки("0x76")
		И (ПрочитанныеБайты[3] = ЧислоИзШестнадцатеричнойСтроки("0x38")
			Или ПрочитанныеБайты[3] = ЧислоИзШестнадцатеричнойСтроки("0x39")
			Или ПрочитанныеБайты[3] = ЧислоИзШестнадцатеричнойСтроки("0x2B")
			Или ПрочитанныеБайты[3] = ЧислоИзШестнадцатеричнойСтроки("0x2F")) Тогда
		КодировкаBOM = "UTF-7";
	ИначеЕсли ПрочитанныеБайты[0] = ЧислоИзШестнадцатеричнойСтроки("0xDD")
		И ПрочитанныеБайты[1] = ЧислоИзШестнадцатеричнойСтроки("0x73")
		И ПрочитанныеБайты[2] = ЧислоИзШестнадцатеричнойСтроки("0x66")
		И ПрочитанныеБайты[3] = ЧислоИзШестнадцатеричнойСтроки("0x73") Тогда
		КодировкаBOM = "UTF-EBCDIC";
	Иначе
		КодировкаBOM = "";
	КонецЕсли;
	
	Возврат КодировкаBOM;
КонецФункции

#КонецОбласти

