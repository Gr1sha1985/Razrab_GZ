
#Область СлужебныйПрограммныйИнтерфейс

Процедура СформироватьДвиженияИнтервальногоРегистра(ИмяРегистра, ПараметрыПостроения) Экспорт
	
	ИмяИнтервальногоРегистра = ИнтервальныеРегистрыБЗК.ИмяИнтервальногоРегистра(ИмяРегистра);
	ОписаниеИнтервальногоРегистра = РегистрыСведений[ИмяРегистра].ОписаниеИнтервальногоРегистра();
	
	ИзмерениеЗаписи = ОписаниеИнтервальногоРегистра.ОсновноеИзмерение;
	ИзмеренияРасчета = ОписаниеИнтервальногоРегистра.ИзмеренияРасчета;
	
	ПолноеПереформирование = ПараметрыПостроения.ПолноеПереформирование;
	
	МассивПолейРегистра = МассивПолейРегистраПоОписанию(ИмяИнтервальногоРегистра);
	ВыборкаИнтервалы = ВыбратьИнтервалы(ИмяРегистра, ИзмеренияРасчета, МассивПолейРегистра, ПараметрыПостроения);
	
	КлючиОбновляемыхИнтервалов = КлючиОбновляемыхИнтервалов(ВыборкаИнтервалы, ПараметрыПостроения, ИзмерениеЗаписи);
	КлючиОтбора = КлючиОбновляемыхИнтервалов.КлючиОтбора;
	
	Если КлючиОтбора.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ТекущиеДанныеРегистра = ТекущиеДанныеРегистра(
		КлючиОбновляемыхИнтервалов, ИмяИнтервальногоРегистра, ОписаниеИнтервальногоРегистра, МассивПолейРегистра, ПараметрыПостроения);
		
	СтруктураПоиска = Новый Структура(ИзмерениеЗаписи);
	
	Для Каждого ЗначениеИзмерения Из КлючиОтбора Цикл
		РассчитанныеПериоды = РассчитанныеИнтервалыПоИзмерению(
			ИмяРегистра, ВыборкаИнтервалы, ЗначениеИзмерения, ОписаниеИнтервальногоРегистра, МассивПолейРегистра, ПараметрыПостроения);
			
		// Необходимо объединить существующие записи регистра с рассчитанными
		Если ТекущиеДанныеРегистра <> Неопределено Тогда
			СтруктураПоиска[ИзмерениеЗаписи] = ЗначениеИзмерения;
			ДанныеРегистра = ТекущиеДанныеРегистра.Скопировать(СтруктураПоиска);
			ДополнитьРассчитанныеИнтервалыДаннымиРегистра(ДанныеРегистра, РассчитанныеПериоды, ИзмеренияРасчета, ПолноеПереформирование); 
		КонецЕсли;
		
		ЗаписатьРассчитанныеИнтервалы(ИмяИнтервальногоРегистра, РассчитанныеПериоды, ИзмерениеЗаписи, ЗначениеИзмерения, ПараметрыПостроения);
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьЗапросСрезаДляПолученияДвиженийПервичногоРегистра(ОписаниеПакетаЗапросов, ТолькоРазрешенные, ОписаниеРегистра,
	ОписаниеФильтра, ПараметрыПостроения, ИмяДополняемойВТ) Экспорт
	
	ИмяВТОтборСреза= "ВТОтборСрезаНаНачалоПериода" + ОписаниеРегистра.ИмяРегистра;	
	ПостфиксИменПараметров = ИмяВТОтборСреза;
	
	ОписаниеРезультирующегоЗапроса = ЗарплатаКадрыПериодическиеРегистры.ОписаниеЗапросаПакетаПоИмениВТ(ОписаниеПакетаЗапросов, ИмяДополняемойВТ);
	ИндексРезультирующегоЗапроса = ОписаниеПакетаЗапросов.ЗапросыПолученияДанных.Найти(ОписаниеРезультирующегоЗапроса);
	
	ВключатьЗаписиНаНачалоПериода = ЗарплатаКадрыПериодическиеРегистры.ВключатьЗаписиНаНачалоПериода(ПараметрыПостроения, ОписаниеРегистра);
	ФормироватьСПериодичностьДень = ЗарплатаКадрыПериодическиеРегистры.ФормироватьСПериодичностьДень(ПараметрыПостроения, ОписаниеРегистра);
	
	ИмяСоздаваемойТаблицыСрезПоследних = ЗарплатаКадрыПериодическиеРегистры.ИмяСоздаваемойТаблицыСрезПоследнихВПараметрахПостроения(
		ОписаниеРегистра.ИмяРегистра, ПараметрыПостроения);
				
	ШаблонЗапросаФильтра = 
	"ВЫБРАТЬ
	|	РегистрСведений.ДействуетДо КАК ДатаНачала,
	|	&ШаблонИзмеренияФильтра КАК Измерения
	|ПОМЕСТИТЬ ВТОтборСреза
	|ИЗ
	|	#РегистрСведений КАК РегистрСведений
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТИзмеренияДаты КАК ИзмеренияДаты
	|		ПО (РегистрСведений.ДействуетДо >= &ФильтрДатаНачалаПриведенная_)
	|			И (РегистрСведений.ДействуетДо <= &ФильтрДатаОкончанияПриведенная_)
	|			И (&ШаблонУсловияСвязиПоИзмерениямФильтра)
	|		ЛЕВОЕ СОЕДИНЕНИЕ #РегистрСведений КАК РегистрСведенийПересечения
	|		ПО РегистрСведений.Период < РегистрСведенийПересечения.Период
	|			И РегистрСведений.ДействуетДо >= РегистрСведенийПересечения.Период
	|			И (РегистрСведенийПересечения.ДействуетДо = ДАТАВРЕМЯ(1, 1, 1)
	|				ИЛИ РегистрСведений.ДействуетДо <= РегистрСведенийПересечения.ДействуетДо)
	|			И (&ШаблонУсловияСвязиПоИзмерениям)
	|ГДЕ
	|	РегистрСведений.ДействуетДо <> ДАТАВРЕМЯ(1, 1, 1)
	|	И РегистрСведенийПересечения.Период ЕСТЬ NULL
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	&ШаблонФильтрДатаНачала,
	|	&ШаблонИзмеренияФильтра
	|ИЗ
	|	ВТИзмеренияДаты КАК ИзмеренияДаты";
	
	Если Не ОписаниеРегистра.ЕстьВозвратныеСобытия Тогда
		ШаблонЗапросаФильтра = СтрЗаменить(ШаблонЗапросаФильтра, "РегистрСведений.ДействуетДо", "ДАТАВРЕМЯ(1, 1, 1)");
		ШаблонЗапросаФильтра = СтрЗаменить(ШаблонЗапросаФильтра, "РегистрСведенийПересечения.ДействуетДо", "ДАТАВРЕМЯ(1, 1, 1)");
	КонецЕсли;
	
	ШаблонТекстаУсловия = "&ФильтрДатаНачала_ <> ДАТАВРЕМЯ(1, 1, 1)";

	ОписаниеЗапроса = ЗарплатаКадрыПериодическиеРегистры.ОписаниеЗапросаПоТексту(ШаблонЗапросаФильтра);
	ОписаниеПакетаЗапросов.ЗапросыПолученияДанных.Вставить(ИндексРезультирующегоЗапроса, ОписаниеЗапроса);
	ОписаниеЗапроса.ТаблицаДляПомещения = ИмяВТОтборСреза;
	
	ЗарплатаКадрыПериодическиеРегистры.ЗаменитьТаблицуВОператореЗапроса(
		ОписаниеЗапроса.Операторы[0], "РегистрСведений", "РегистрСведений." + ОписаниеРегистра.ИмяРегистра);
		
	ЗарплатаКадрыПериодическиеРегистры.ЗаменитьТаблицуВОператореЗапроса(
		ОписаниеЗапроса.Операторы[0], "РегистрСведенийПересечения", "РегистрСведений." + ОписаниеРегистра.ИмяРегистра);
		
	ОписаниеИспользованияФильтраПересечения = ЗарплатаКадрыПериодическиеРегистры.ОписаниеИспользованиеФильтра();
	ЗарплатаКадрыПериодическиеРегистры.ИнициализироватьИспользованиеФильтра(
		ОписаниеИспользованияФильтраПересечения,
		ОписаниеФильтра,
		ОписаниеРегистра,
		"ДатаНачала, ДатаОкончания",
		ОписаниеЗапроса.Операторы[0],
		ПостфиксИменПараметров);
		
	
	ОписаниеИспользованияФильтраВсеЗаписи = ЗарплатаКадрыПериодическиеРегистры.ОписаниеИспользованиеФильтра(, Неопределено);
	ЗарплатаКадрыПериодическиеРегистры.ИнициализироватьИспользованиеФильтра(
		ОписаниеИспользованияФильтраВсеЗаписи,
		ОписаниеФильтра,
		ОписаниеРегистра,
		"ДатаНачала",
		ОписаниеЗапроса.Операторы[1],
		ПостфиксИменПараметров,
		Истина);
			
	ФильтрДатаНачалаПриведенная =  ЗарплатаКадрыПериодическиеРегистры.ДобавитьОписаниеПоляПериодФильтра(
		ОписаниеИспользованияФильтраПересечения, "ДатаНачала", "ФильтрДатаНачалаПриведенная");
		
	ФильтрДатаОкончания =  ЗарплатаКадрыПериодическиеРегистры.ДобавитьОписаниеПоляПериодФильтра(
		ОписаниеИспользованияФильтраПересечения, "ДатаОкончания", "ФильтрДатаОкончания");
		
	ФильтрДатаОкончанияПриведенная = ЗарплатаКадрыПериодическиеРегистры.ДобавитьОписаниеПоляПериодФильтра(
		ОписаниеИспользованияФильтраПересечения, "ДатаОкончания", "ФильтрДатаОкончанияПриведенная");

	ФильтрДатаНачала =  ЗарплатаКадрыПериодическиеРегистры.ДобавитьОписаниеПоляПериодФильтра(
		ОписаниеИспользованияФильтраВсеЗаписи, "ДатаНачала", "ФильтрДатаНачала");
	
	ФильтрДатаОкончанияПриведенная.ПустоеЗначениеКакМаксимальное = Истина;	
	Если ФормироватьСПериодичностьДень Тогда
		ФильтрДатаНачалаПриведенная.Кратность = "ДЕНЬ";
		ФильтрДатаНачалаПриведенная.ВариантПриведенияПериода = "НАЧАЛОПЕРИОДА";
		ФильтрДатаОкончанияПриведенная.Кратность = "ДЕНЬ";
		ФильтрДатаОкончанияПриведенная.ВариантПриведенияПериода = "КОНЕЦПЕРИОДА";
	КонецЕсли;	
	
	Если ВключатьЗаписиНаНачалоПериода Тогда
		ФильтрДатаНачалаПриведенная.Сдвиг = 1;
	КонецЕсли;
	
	ЗарплатаКадрыПериодическиеРегистры.УстановитьВыражениеПериодаВТекстШаблонаУсловияСвязи(
		ОписаниеИспользованияФильтраПересечения, "&ФильтрДатаНачалаПриведенная_", ФильтрДатаНачалаПриведенная);
		
	ЗарплатаКадрыПериодическиеРегистры.УстановитьВыражениеПериодаВТекстШаблонаУсловияСвязи(
		ОписаниеИспользованияФильтраПересечения, "&ФильтрДатаОкончанияПриведенная_", ФильтрДатаОкончанияПриведенная);
		
	ЗарплатаКадрыПериодическиеРегистры.УстановитьВыражениеПериодаВТекстШаблонаУсловияСвязи(
		ОписаниеИспользованияФильтраПересечения, "&ФильтрДатаОкончания_", ФильтрДатаОкончания);
		
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(
		ОписаниеЗапроса, 1, ЗарплатаКадрыПериодическиеРегистры.ВыражениеПоляПериод(ФильтрДатаНачала), "ДатаНачала"); 
	
	УсловиеПоПериоду = СтрЗаменить(ШаблонТекстаУсловия, "&ФильтрДатаНачала_", ЗарплатаКадрыПериодическиеРегистры.ВыражениеПоляПериод(ФильтрДатаНачала));
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьУсловие(ОписаниеЗапроса.Операторы[1], УсловиеПоПериоду);
	
	Для Каждого Измерение Из ОписаниеРегистра.Измерения Цикл
		ТекстУсловия = "РегистрСведений." + Измерение + " = РегистрСведенийПересечения." + Измерение;
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьУсловиеСоединения(ОписаниеЗапроса.Операторы[0], "РегистрСведенийПересечения", ТекстУсловия);
		
		Если ОписаниеФильтра.ИзмеренияФильтра.Найти(Измерение) <> Неопределено Тогда
			ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(ОписаниеЗапроса, 0, "РегистрСведений." + Измерение, Измерение); 
			
			ВыражениеПоляИзмерения = ЗарплатаКадрыПериодическиеРегистры.ВыражениеИзмерениеФильтра(ОписаниеИспользованияФильтраВсеЗаписи, Измерение);
			ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(ОписаниеЗапроса, 1, ВыражениеПоляИзмерения, Измерение); 
		КонецЕсли;
	КонецЦикла;	
	
	ЗарплатаКадрыПериодическиеРегистры.УстановитьФильтрВОписаниеПакетаЗапросовКРегистру(
		ОписаниеПакетаЗапросов, ОписаниеФильтра, ОписаниеИспользованияФильтраВсеЗаписи, ПараметрыПостроения);
		
	ЗарплатаКадрыПериодическиеРегистры.УстановитьФильтрВОписаниеПакетаЗапросовКРегистру(
		ОписаниеПакетаЗапросов, ОписаниеФильтра, ОписаниеИспользованияФильтраПересечения, ПараметрыПостроения);
	
	Если Не ВключатьЗаписиНаНачалоПериода Тогда
		ОписаниеЗапроса.Операторы.Удалить(1);
	КонецЕсли;	
	
	ОписаниеФильтраСреза = ЗарплатаКадрыПериодическиеРегистры.ОписаниеФильтраДляСоздатьВТИмяРегистраПоВременнойТаблице(
		ИмяВТОтборСреза, ОписаниеФильтра.ИзмеренияФильтра);
		
	ОписаниеФильтраСреза.СоответствиеИзмеренийРегистраИзмерениямФильтра = 
		ОбщегоНазначения.СкопироватьРекурсивно(ОписаниеФильтра.СоответствиеИзмеренийРегистраИзмерениямФильтра);
		
	ОписаниеФильтраСреза.СоответствиеИзмеренийРегистраИзмерениямФильтра.Вставить("ДатаНачала", "ДатаНачала");
	
	ПараметрыПолученияЗаписейНаНачало = ЗарплатаКадрыПериодическиеРегистры.ПараметрыПостроенияДляСоздатьВТИмяРегистра();
	ЗаполнитьЗначенияСвойств(ПараметрыПолученияЗаписейНаНачало, ПараметрыПостроения);
	
	// Отбор записей применяемых к срезу установим сами, т.к. тут мы получаем не только срез на начало
	// но еще данные для возвратных записей
	ПараметрыПолученияЗаписейНаНачало.ОтборыЗаписейНаНачалоПериода = Неопределено;
	
	ДобавленныйОператор = ЗарплатаКадрыПериодическиеРегистры.ДобавитьЗапросПолученияЗаписейНаНачалоПериода(
		ОписаниеПакетаЗапросов, ТолькоРазрешенные, ОписаниеРегистра, ОписаниеФильтраСреза, ПараметрыПолученияЗаписейНаНачало, ИмяДополняемойВТ);
	
	ВыраженияПоляПериод = ЗарплатаКадрыПериодическиеРегистры.ВыражениеПоляПоПсевдониму(ДобавленныйОператор, "Период"); 
	ВыраженияПоляПериодЗаписи = ЗарплатаКадрыПериодическиеРегистры.ВыражениеПоляПоПсевдониму(ДобавленныйОператор, "ПериодЗаписи"); 
		
	ПредикатОтбораЗаписейНаНачалоПериода = ВыраженияПоляПериодЗаписи + " >= " + ВыраженияПоляПериод + " ИЛИ ";
	
	ОписаниеЗапроса = ИнтервальныеРегистрыБЗК.ВладелецОператораЗапроса(ОписаниеПакетаЗапросов, ДобавленныйОператор);

	ЗарплатаКадрыПериодическиеРегистры.УстановитьОтборВОператорЗапросаДанныхРегистра(
		ДобавленныйОператор, 
		ПараметрыПостроения.ОтборыЗаписейНаНачалоПериода,
		ОписаниеПакетаЗапросов.Параметры, 
		"ОтборСрезаНаНачало" + ОписаниеРегистра.ИмяРегистра,
		, 
		ПредикатОтбораЗаписейНаНачалоПериода,
		Неопределено);
	
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьЗапросУничтоженияВТ(ОписаниеПакетаЗапросов, ИмяВТОтборСреза);
КонецПроцедуры	

Процедура ДобавитьЗапросВТСрезПервичныйРегистр(ОписаниеПакетаЗапросов, ИмяРегистра, ТолькоРазрешенные, ОписаниеФильтра,
	ПараметрыПостроения = Неопределено, ИмяСоздаваемойТаблицы = Неопределено) Экспорт
	
	Если ПараметрыПостроения = Неопределено Тогда
		ПараметрыПостроения = ЗарплатаКадрыПериодическиеРегистры.ПараметрыПостроенияДляСоздатьВТИмяРегистраСрез();
	КонецЕсли;	
	
	ПостфиксИменПараметров = ИмяСоздаваемойТаблицы;
	Если ПостфиксИменПараметров = Неопределено Тогда
		ПостфиксИменПараметров = "СрезПоследних" + ИмяРегистра;
	КонецЕсли;
	
	ОписаниеРегистра = ЗарплатаКадрыОбщиеНаборыДанных.ОписаниеРегистраСведений(
		ИмяРегистра, ОписаниеФильтра.ИзмеренияФильтра, ПараметрыПостроения.ИсключатьНеИспользуемыеПоля);
	ПараметрыНаследованияРесурсов = РегистрыСведений[ИмяРегистра].ПараметрыНаследованияРесурсов();
	ФормироватьСПериодичностьДень = ЗарплатаКадрыПериодическиеРегистры.ФормироватьСПериодичностьДень(ПараметрыПостроения, ОписаниеРегистра);
	
	ШаблонЗапросаВТРегистрСведений = 
	"ВЫБРАТЬ
	|	РегистрСведений.Период КАК Период,
	|	ВЫБОР
	|		КОГДА РегистрСведений.ДействуетДо = ДАТАВРЕМЯ(1, 1, 1)
	|			ТОГДА ДАТАВРЕМЯ(3999, 12, 31, 23, 59, 59)
	|		ИНАЧЕ РегистрСведений.ДействуетДо
	|	КОНЕЦ КАК ДействуетДо,
	|	&ШаблонИзмерения КАК Измерения
	|ПОМЕСТИТЬ ВТРегистрСведений
	|ИЗ
	|	ВТИзмеренияДаты КАК ИзмеренияДаты
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ #РегистрСведений КАК РегистрСведений
	|		ПО (РегистрСведений.Период <= &ФильтрПериодПриведенный_)
	|			И (&ШаблонУсловияСвязиПоИзмерениямФильтра)";
	
	Если Не ОписаниеРегистра.ЕстьВозвратныеСобытия Тогда
		ШаблонЗапросаВТРегистрСведений = СтрЗаменить(ШаблонЗапросаВТРегистрСведений, "РегистрСведений.ДействуетДо", "ДАТАВРЕМЯ(1, 1, 1)");		
	КонецЕсли;
	
	ОписаниеЗапросаВТРегистрСведений = ЗарплатаКадрыПериодическиеРегистры.ОписаниеЗапросаПоТексту(ШаблонЗапросаВТРегистрСведений);
	ОписаниеПакетаЗапросов.ЗапросыПолученияДанных.Добавить(ОписаниеЗапросаВТРегистрСведений);
	ОписаниеЗапросаВТРегистрСведений.ВыбиратьРазрешенные = ТолькоРазрешенные;
	
	ОператорЗапросаВТРегистрСведений = ОписаниеЗапросаВТРегистрСведений.Операторы[0];
	ЗарплатаКадрыПериодическиеРегистры.ЗаменитьТаблицуВОператореЗапроса(
		ОператорЗапросаВТРегистрСведений, "РегистрСведений", "РегистрСведений." + ИмяРегистра);
	
	ОписаниеИспользованияФильтраДанныеРегистра = ЗарплатаКадрыПериодическиеРегистры.ОписаниеИспользованиеФильтра();
	ЗарплатаКадрыПериодическиеРегистры.ИнициализироватьИспользованиеФильтра(
		ОписаниеИспользованияФильтраДанныеРегистра,
		ОписаниеФильтра,
		ОписаниеРегистра,
		"Период",
		ОператорЗапросаВТРегистрСведений,
		ПостфиксИменПараметров,
		ПараметрыПостроения.ВсеЗаписи);
	
	ШаблонЗапросаВТМаксимальныеПериоды =	
	"ВЫБРАТЬ
	|	&ШаблонФильтрПериод КАК ЗаданныйПериод,
	|	&ШаблонИзмерения КАК Измерения,
	|	&ШаблонМаксимальныйПериодРесурсы КАК МаксимальныйПериодРесурсы,
	|	МАКСИМУМ(РегистрСведений.Период) КАК МаксимальныйПериодИзмерения
	|ПОМЕСТИТЬ ВТМаксимальныеПериоды
	|ИЗ
	|	ВТИзмеренияДаты КАК ИзмеренияДаты
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТРегистрСведений КАК РегистрСведений
	|		ПО (&ФильтрПериодПриведенный_ >= РегистрСведений.Период)
	|			И (&ШаблонУсловияСвязиПоИзмерениям)";
	
	ШаблонПоляМаксимальныйПериодРесурсы = "
	|МАКСИМУМ(ВЫБОР
	|		КОГДА &ФильтрПериодПриведенный_ <= РегистрСведений.ДействуетДо
	|			ТОГДА РегистрСведений.Период
	|		ИНАЧЕ ДАТАВРЕМЯ(1, 1, 1)
	|	КОНЕЦ)";
	
	ОписаниеЗапросаВТМаксимальныеПериоды = ЗарплатаКадрыПериодическиеРегистры.ОписаниеЗапросаПоТексту(ШаблонЗапросаВТМаксимальныеПериоды);
	ОписаниеПакетаЗапросов.ЗапросыПолученияДанных.Добавить(ОписаниеЗапросаВТМаксимальныеПериоды);
	ОписаниеЗапросаВТМаксимальныеПериоды.ВыбиратьРазрешенные = ТолькоРазрешенные;
	
	ОператорЗапросаВТМаксимальныеПериоды = ОписаниеЗапросаВТМаксимальныеПериоды.Операторы[0];
	
	ОписаниеИспользованияФильтраМаксимальныеПериоды = ЗарплатаКадрыПериодическиеРегистры.ОписаниеИспользованиеФильтра();
	ЗарплатаКадрыПериодическиеРегистры.ИнициализироватьИспользованиеФильтра(
		ОписаниеИспользованияФильтраМаксимальныеПериоды,
		ОписаниеФильтра,
		ОписаниеРегистра,
		"Период",
		ОператорЗапросаВТМаксимальныеПериоды,
		ПостфиксИменПараметров);
	
	ШаблонЗапросВТСрез = 
	"ВЫБРАТЬ
	|	ИзмеренияДаты.ЗаданныйПериод КАК Период,
	|	РегистрСведенийИзмерения.Период КАК ПериодЗаписи,
	|	ВЫБОР
	|		КОГДА ИзмеренияДаты.МаксимальныйПериодИзмерения = ИзмеренияДаты.МаксимальныйПериодРесурсы
	|			ТОГДА ЛОЖЬ
	|		ИНАЧЕ ИСТИНА
	|	КОНЕЦ КАК ЭтоВозвратноеСобытие,
	|	РегистрСведенийИзмерения.ДействуетДо КАК ПериодВозвратногоСобытия,
	|	РегистрСведенийИзмерения.Регистратор КАК Регистратор,
	|	РегистрСведенийИзмерения.Регистратор КАК РегистраторЗаписи,
	|	&ШаблонИзмерения КАК Измерения,
	|	&ШаблонРесурсы КАК Ресурсы,
	|	&ШаблонРеквизиты КАК Реквизиты
	|ПОМЕСТИТЬ ВТРезультат
	|ИЗ
	|	ВТМаксимальныеПериоды КАК ИзмеренияДаты
	|		ЛЕВОЕ СОЕДИНЕНИЕ #РегистрСведений КАК РегистрСведенийИзмерения
	|		ПО ИзмеренияДаты.МаксимальныйПериодИзмерения = РегистрСведенийИзмерения.Период
	|			И &ШаблонУсловияСвязиПоИзмерениям
	|		ЛЕВОЕ СОЕДИНЕНИЕ #РегистрСведений КАК РегистрСведенийРесурсы
	|		ПО ИзмеренияДаты.МаксимальныйПериодРесурсы = РегистрСведенийРесурсы.Период
	|			И &ШаблонУсловияСвязиПоИзмерениям";			
	
	Если Не ОписаниеРегистра.ЕстьВозвратныеСобытия Тогда
		ШаблонЗапросВТСрез = СтрЗаменить(ШаблонЗапросВТСрез, "РегистрСведенийИзмерения.ДействуетДо", "ДАТАВРЕМЯ(1, 1, 1)");		
	КонецЕсли;
	
	ОписаниеЗапросаВТСрез = ЗарплатаКадрыПериодическиеРегистры.ОписаниеЗапросаПоТексту(ШаблонЗапросВТСрез);
	ОписаниеПакетаЗапросов.ЗапросыПолученияДанных.Добавить(ОписаниеЗапросаВТСрез);
	ОписаниеЗапросаВТСрез.ВыбиратьРазрешенные = ТолькоРазрешенные;
	ОписаниеЗапросаВТСрез.ТаблицаДляПомещения = ИмяСоздаваемойТаблицы;
	
	ОператорЗапросаВТСрез = ОписаниеЗапросаВТСрез.Операторы[0];
	ЗарплатаКадрыПериодическиеРегистры.ЗаменитьТаблицуВОператореЗапроса(
		ОператорЗапросаВТСрез, "РегистрСведенийИзмерения", "РегистрСведений." + ИмяРегистра);
	ЗарплатаКадрыПериодическиеРегистры.ЗаменитьТаблицуВОператореЗапроса(
		ОператорЗапросаВТСрез, "РегистрСведенийРесурсы", "РегистрСведений." + ИмяРегистра);
	
	ФильтрПериодПриведенный = ЗарплатаКадрыПериодическиеРегистры.ДобавитьОписаниеПоляПериодФильтра(
		ОписаниеИспользованияФильтраДанныеРегистра, "Период", "ПериодПриведенный");
	ФильтрПериод = ЗарплатаКадрыПериодическиеРегистры.ДобавитьОписаниеПоляПериодФильтра(
		ОписаниеИспользованияФильтраДанныеРегистра, "Период", "Период");
	
	ФильтрПериодПриведенный.ПустоеЗначениеКакМаксимальное = Истина;
	
	Если ФормироватьСПериодичностьДень Тогда
		ФильтрПериодПриведенный.Кратность = "ДЕНЬ";
		ФильтрПериодПриведенный.ВариантПриведенияПериода = "КОНЕЦПЕРИОДА";
	КонецЕсли;
	
	Если Не ПараметрыПостроения.ВключаяГраницу Тогда
		ФильтрПериодПриведенный.Сдвиг = -1;
		ФильтрПериодПриведенный.КратностьСдвига = "СЕКУНДА";
		ФильтрПериодПриведенный.ВариантПриведенияПериода = "НАЧАЛОПЕРИОДА";
	КонецЕсли;	

	ЗарплатаКадрыПериодическиеРегистры.УстановитьВыражениеПериодаВТекстШаблонаУсловияСвязи(
		ОписаниеИспользованияФильтраДанныеРегистра, "&ФильтрПериодПриведенный_", ФильтрПериодПриведенный);
		
	ЗарплатаКадрыПериодическиеРегистры.УстановитьВыражениеПериодаВТекстШаблонаУсловияСвязи(
		ОписаниеИспользованияФильтраДанныеРегистра, "&ФильтрПериод_", ФильтрПериод);
		
	ЗарплатаКадрыПериодическиеРегистры.УстановитьВыражениеПериодаВТекстШаблонаУсловияСвязи(
		ОписаниеИспользованияФильтраМаксимальныеПериоды, "&ФильтрПериодПриведенный_", ФильтрПериодПриведенный);
		
	ЗарплатаКадрыПериодическиеРегистры.УстановитьВыражениеПериодаВТекстШаблонаУсловияСвязи(
		ОписаниеИспользованияФильтраМаксимальныеПериоды, "&ФильтрПериод_", ФильтрПериод);
	
	Если ПараметрыПостроения.ВсеЗаписи Тогда
		ЗарплатаКадрыПериодическиеРегистры.УстановитьТипСоединения(ОператорЗапросаВТМаксимальныеПериоды, "РегистрСведений", "ЛЕВОЕ");
	КонецЕсли;	
	
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(
		ОписаниеЗапросаВТМаксимальныеПериоды, 0, ЗарплатаКадрыПериодическиеРегистры.ВыражениеПоляПериод(ФильтрПериод), "ЗаданныйПериод");
		
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьГруппировку(
		ОператорЗапросаВТМаксимальныеПериоды, ЗарплатаКадрыПериодическиеРегистры.ВыражениеПоляПериод(ФильтрПериод));
	
	ВыражениеПоляМаксимальныйПериодРесурсы = СтрЗаменить(
		ШаблонПоляМаксимальныйПериодРесурсы,
		"&ФильтрПериодПриведенный_",
		ЗарплатаКадрыПериодическиеРегистры.ВыражениеПоляПериод(ФильтрПериодПриведенный));
		
	ВыражениеПоляМаксимальныйПериодРесурсы = СтрЗаменить(
		ВыражениеПоляМаксимальныйПериодРесурсы,
		"&ФильтрПериод_",
		ЗарплатаКадрыПериодическиеРегистры.ВыражениеПоляПериод(ФильтрПериод));
		
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(
		ОписаниеЗапросаВТМаксимальныеПериоды, 0, ВыражениеПоляМаксимальныйПериодРесурсы, "МаксимальныйПериодРесурсы");
	
	Для Каждого Измерение Из ОписаниеРегистра.Измерения Цикл
		ВыражениеИзмерениеВТРегистрСведений = "РегистрСведений." + Измерение;		
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(
			ОписаниеЗапросаВТРегистрСведений, 0, ВыражениеИзмерениеВТРегистрСведений, Измерение);
				
		Если ОписаниеФильтра.ИзмеренияФильтра.Найти(Измерение) <> Неопределено И ПараметрыПостроения.ВсеЗаписи Тогда
			ВыражениеИзмерениеВТМаксимальныеПериоды = ЗарплатаКадрыПериодическиеРегистры.ВыражениеИзмерениеФильтра(
				ОписаниеИспользованияФильтраМаксимальныеПериоды, Измерение); 	
		Иначе
			ВыражениеИзмерениеВТМаксимальныеПериоды = "РегистрСведений." + Измерение;	
		КонецЕсли;	
		
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(
			ОписаниеЗапросаВТМаксимальныеПериоды, 0, ВыражениеИзмерениеВТМаксимальныеПериоды, Измерение);
			
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьГруппировку(ОператорЗапросаВТМаксимальныеПериоды, ВыражениеИзмерениеВТМаксимальныеПериоды);
		
		ВыражениеИзмерениеВТСрез = "ИзмеренияДаты." + Измерение;
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(ОписаниеЗапросаВТСрез, 0, ВыражениеИзмерениеВТСрез, Измерение);
				
		УсловиеСвязи = ВыражениеИзмерениеВТСрез + " = РегистрСведенийИзмерения." + Измерение;
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьУсловиеСоединения(ОператорЗапросаВТСрез, "РегистрСведенийИзмерения", УсловиеСвязи);
		
		УсловиеСвязи = ВыражениеИзмерениеВТСрез + " = РегистрСведенийРесурсы." + Измерение;
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьУсловиеСоединения(ОператорЗапросаВТСрез, "РегистрСведенийРесурсы", УсловиеСвязи);
	КонецЦикла;	
	
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьДополнительныеПоляПоОписаниюИспользованияФильтра(
		ОписаниеЗапросаВТРегистрСведений, 0, ОписаниеИспользованияФильтраДанныеРегистра);
		
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьДополнительныеПоляПоОписаниюИспользованияФильтра(
		ОписаниеЗапросаВТМаксимальныеПериоды, 0, ОписаниеИспользованияФильтраМаксимальныеПериоды, Истина);
		
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьДополнительныеПоляПоПсевдонимуИсточника(
		ОписаниеЗапросаВТСрез, 0, "ИзмеренияДаты", ОписаниеФильтра.ДополнительныеПоляФильтра);

	ЗарплатаКадрыПериодическиеРегистры.ДобавитьПостоянныеПоляВОписаниеЗапроса(
		ОписаниеПакетаЗапросов, ОписаниеЗапросаВТСрез, ПараметрыПостроения.ПостоянныеПоля, ИмяСоздаваемойТаблицы);
			
	Для Каждого Ресурс Из ОписаниеРегистра.Ресурсы Цикл
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(
			ОписаниеЗапросаВТСрез,
			0,
			ИнтервальныеРегистрыБЗК.ВыражениеПоляНаследуемыйРесурс(Ресурс, ПараметрыНаследованияРесурсов, ОписаниеПакетаЗапросов.Параметры), Ресурс);	
	КонецЦикла;	
	
	Для Каждого Ресурс Из ОписаниеРегистра.ВозвратныеРесурсы Цикл
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(ОписаниеЗапросаВТСрез, 0, "РегистрСведенийРесурсы." + Ресурс, Ресурс);	
	КонецЦикла;	
	
	Для Каждого Реквизит Из ОписаниеРегистра.Реквизиты Цикл
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(ОписаниеЗапросаВТСрез, 0, "РегистрСведенийРесурсы." + Реквизит, Реквизит);	
	КонецЦикла;	
	
	ИнтервальныеРегистрыБЗК.ПриПолученииВыраженийРесурсаВозвратныхЗаписейПервичногоРегистра(ИмяРегистра, ОписаниеЗапросаВТСрез, ОператорЗапросаВТСрез);
	
	ЗарплатаКадрыПериодическиеРегистры.УстановитьФильтрВОписаниеПакетаЗапросовКРегистру(
		ОписаниеПакетаЗапросов, ОписаниеФильтра, ОписаниеИспользованияФильтраДанныеРегистра, ПараметрыПостроения);
		
	ЗарплатаКадрыПериодическиеРегистры.УстановитьФильтрВОписаниеПакетаЗапросовКРегистру(
		ОписаниеПакетаЗапросов, ОписаниеФильтра, ОписаниеИспользованияФильтраМаксимальныеПериоды, ПараметрыПостроения);
	
	СчПараметров = 1;
	ЗарплатаКадрыПериодическиеРегистры.УстановитьОтборВОператорЗапросаДанныхРегистра(
		ОператорЗапросаВТРегистрСведений, ПараметрыПостроения.Отборы, ОписаниеПакетаЗапросов.Параметры, ПостфиксИменПараметров, СчПараметров,,,,Истина);
		
	// Это условие позволяет отработать ситуация когда запрос используется и для получения записей на начало периода и для
	// получения возвратных движений
	ПредикатУсловияСрезаНаНачало = "РегистрСведений.Период >= ИзмеренияДаты.ЗаданныйПериод ИЛИ ";
	ЗарплатаКадрыПериодическиеРегистры.УстановитьОтборВОператорЗапросаДанныхРегистра(
		ОператорЗапросаВТСрез,
		ПараметрыПостроения.ОтборыПрименяемыеКСрезу,
		ОписаниеПакетаЗапросов.Параметры,
		ПостфиксИменПараметров + "ОтборыКСрезу",
		СчПараметров,
		,
		,
		,
		Истина);
	                      
	ЗарплатаКадрыПериодическиеРегистры.УстановитьПсевдонимыПолей(ОписаниеЗапросаВТСрез, ПараметрыПостроения);
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьПоляИндексированияВОписаниеЗапроса(ОписаниеЗапросаВТСрез, ПараметрыПостроения.ИндексироватьПо);	
	
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьЗапросУничтоженияВТ(ОписаниеПакетаЗапросов, "ВТРегистрСведений");
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьЗапросУничтоженияВТ(ОписаниеПакетаЗапросов, "ВТМаксимальныеПериоды");
	
КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ВыбратьИнтервалы(ИмяРегистра, ИзмеренияОтбора, МассивПолейРегистраПоОписанию, ПараметрыПостроения)
	
	МассивИзмерений = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИзмеренияОтбора, ",", Истина, Истина);
	
	Если ПараметрыПостроения.ПолноеПереформирование Тогда
		Запрос = ЗапросДанныеПоПервичномуРегистру(ИмяРегистра, МассивИзмерений, МассивПолейРегистраПоОписанию, ПараметрыПостроения);
	Иначе
		Запрос = ЗапросДанныеПоИнтервальномуРегистру(ИмяРегистра, МассивИзмерений, МассивПолейРегистраПоОписанию, ПараметрыПостроения);
	КонецЕсли; 
	
	Если ПараметрыПостроения.ФильтрВВидеВТ Тогда
		Запрос.МенеджерВременныхТаблиц = ПараметрыПостроения.ТаблицаФильтра;
	КонецЕсли;
		
	Возврат Запрос.Выполнить().Выбрать();
	
КонецФункции

Функция ЗапросДанныеПоПервичномуРегистру(ИмяРегистра, МассивИзмерений, МассивПолейРегистраПоОписанию, ПараметрыПостроения)

	ШаблонЗапроса = 
	"ВЫБРАТЬ
	|	ВЫБОР
	|		КОГДА ТаблицаРегистра.ДействуетДо = ДАТАВРЕМЯ(1, 1, 1)
	|			ТОГДА &МаксимальнаяДата
	|		ИНАЧЕ ДОБАВИТЬКДАТЕ(ТаблицаРегистра.ДействуетДо, СЕКУНДА, -1)
	|	КОНЕЦ КАК ДатаОкончания,
	|	ЕСТЬNULL(ТаблицаРегистра.Период, ДАТАВРЕМЯ(1, 1, 1)) КАК ДатаНачала,
	|	ТаблицаРегистра.Период КАК ПериодЗаписи,
	|	ТаблицаРегистра.Регистратор КАК РегистраторЗаписи,
	|	ТаблицаРегистра.Регистратор КАК РегистраторСобытия,
	|	ЛОЖЬ КАК ПустойИнтервал,
	|	ЛОЖЬ КАК ОтложенныйИнтервал,
	|	ДАТАВРЕМЯ(1, 1, 1) КАК ПериодПредыдущейЗаписи,
	|	ТаблицаРегистра.ДействуетДо КАК ДействуетДо,
	|	ВЫБОР
	|		КОГДА ТаблицаРегистра.Период ЕСТЬ NULL
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ КАК ВсеЗаписиУдалены,
	|	&ШаблонПоля КАК Поля
	|ИЗ
	|	ВТОтборДляПереформирования КАК ВТОтборДляПереформирования
	|		ЛЕВОЕ СОЕДИНЕНИЕ #РегистрСведений КАК ТаблицаРегистра
	|		ПО (&ШаблонСвязьПоИзмерениям)";
	
	ОписаниеРегистра = ЗарплатаКадрыОбщиеНаборыДанных.ОписаниеРегистра(ИмяРегистра);
	ОписаниеПакетаЗапросов = ЗарплатаКадрыПериодическиеРегистры.НовыйОписаниеПакетаЗапросовКРегистру();
	ОписаниеЗапроса = ЗарплатаКадрыПериодическиеРегистры.ОписаниеЗапросаПоТексту(ШаблонЗапроса);
	ОписаниеПакетаЗапросов.ЗапросыПолученияДанных.Добавить(ОписаниеЗапроса);
	ОператорЗапроса = ОписаниеЗапроса.Операторы[0];
	
	ОписаниеПериода = ЗарплатаКадрыПериодическиеРегистры.ОписаниеПериодаДляСоздатьВТИмяРегистра();
	Если ПараметрыПостроения.ФильтрВВидеВТ Тогда
		ОписаниеФильтра = ЗарплатаКадрыПериодическиеРегистры.ОписаниеФильтраДляСоздатьВТИмяРегистраПоВременнойТаблице(
			"ВТОтборДляПереформирования",
			МассивИзмерений);
	Иначе
		ОписаниеФильтра = ЗарплатаКадрыПериодическиеРегистры.ОписаниеФильтраДляСоздатьВТИмяРегистраПоТаблицеЗначений(
			ПараметрыПостроения.ТаблицаФильтра,
			МассивИзмерений);
	КонецЕсли;
		
	ОписаниеИспользованияФильтра = ЗарплатаКадрыПериодическиеРегистры.ОписаниеИспользованиеФильтра("ВТОтборДляПереформирования", "ТаблицаРегистра");
	ЗарплатаКадрыПериодическиеРегистры.ИнициализироватьИспользованиеФильтра(
		ОписаниеИспользованияФильтра, 
		ОписаниеФильтра,
		ОписаниеРегистра,
		"",
		ОператорЗапроса);
	
	ЗарплатаКадрыПериодическиеРегистры.ЗаменитьТаблицуВОператореЗапроса(ОператорЗапроса, "ТаблицаРегистра", "РегистрСведений." + ИмяРегистра);
	
	ОписаниеРегистра = ЗарплатаКадрыОбщиеНаборыДанных.ОписаниеРегистра(ИмяРегистра);
	Если Не ОписаниеРегистра.ЕстьВозвратныеСобытия Тогда
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(ОписаниеЗапроса, 0, "&МаксимальнаяДата", "ДатаОкончания");
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(ОписаниеЗапроса, 0, "ДАТАВРЕМЯ(1, 1, 1)", "ДействуетДо");
	КонецЕсли; 
	
	Для Каждого Измерение Из МассивИзмерений Цикл
		ВыражениеПоля = "ВТОтборДляПереформирования." + Измерение;
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(ОписаниеЗапроса, 0, ВыражениеПоля, Измерение);
	КонецЦикла;
	
	Для Каждого Поле Из МассивПолейРегистраПоОписанию Цикл
		Если МассивИзмерений.Найти(Поле) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ВыражениеПоля = "ТаблицаРегистра." + Поле;
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(ОписаниеЗапроса, 0, ВыражениеПоля, Поле);
	КонецЦикла;
	
	ЗарплатаКадрыПериодическиеРегистры.УстановитьФильтрВОписаниеПакетаЗапросовКРегистру(
		ОписаниеПакетаЗапросов, 
		ОписаниеФильтра,
		ОписаниеИспользованияФильтра);
		
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьПоляУпорядочиванияВОписаниеЗапроса(ОписаниеЗапроса, МассивИзмерений);
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьПоляУпорядочиванияВОписаниеЗапроса(ОписаниеЗапроса, "ДатаНачала");
	
	ОписаниеПакетаЗапросов.Параметры.Вставить("МаксимальнаяДата", ЗарплатаКадрыПериодическиеРегистры.МаксимальнаяДата());
	
	Возврат ЗарплатаКадрыПериодическиеРегистры.ЗапросПоОписаниюПакета(ОписаниеПакетаЗапросов, Ложь);
	
КонецФункции

Функция ЗапросДанныеПоИнтервальномуРегистру(ИмяРегистра, МассивИзмерений, МассивПолейРегистраПоОписанию, ПараметрыПостроения)
	
	ШаблонЗапроса = 
	"ВЫБРАТЬ
	|	ТаблицаРегистра.ДатаОкончания КАК ДатаОкончания,
	|	ТаблицаРегистра.ДатаНачала КАК ДатаНачала,
	|	ТаблицаРегистра.ПериодПредыдущейЗаписи КАК ПериодПредыдущейЗаписи,
	|	ТаблицаРегистра.ПериодЗаписи КАК ПериодЗаписи,
	|	ТаблицаРегистра.РегистраторЗаписи КАК РегистраторЗаписи,
	|	ТаблицаРегистра.РегистраторСобытия КАК РегистраторСобытия,
	|	ТаблицаРегистра.ПустойИнтервал КАК ПустойИнтервал,
	|	ТаблицаРегистра.ДействуетДо КАК ДействуетДо,
	|	ВЫБОР
	|		КОГДА ТаблицаРегистра.ПериодЗаписи < ВТОтбор.Период
	|				И ТаблицаРегистра.ПериодЗаписи < ТаблицаРегистра.ДатаНачала
	|				И НЕ ТаблицаРегистра.ПустойИнтервал
	|			ТОГДА ИСТИНА
	|		ИНАЧЕ ЛОЖЬ
	|	КОНЕЦ КАК ОтложенныйИнтервал,
	|	ЛОЖЬ КАК ВсеЗаписиУдалены,
	|	&ШаблонПолей КАК ШаблонПолей
	|ИЗ
	|	#ИнтервальныйРегистрСведений КАК ТаблицаРегистра
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТОтбор КАК ВТОтбор
	|		ПО ТаблицаРегистра.ДатаОкончания >= ВТОтбор.Период";
	
	ОписаниеРегистра = ЗарплатаКадрыОбщиеНаборыДанных.ОписаниеРегистра(ИмяРегистра);
	ОписаниеПакетаЗапросов = ЗарплатаКадрыПериодическиеРегистры.НовыйОписаниеПакетаЗапросовКРегистру();
	ОписаниеЗапроса = ЗарплатаКадрыПериодическиеРегистры.ОписаниеЗапросаПоТексту(ШаблонЗапроса);
	ОписаниеПакетаЗапросов.ЗапросыПолученияДанных.Добавить(ОписаниеЗапроса);
	ОператорЗапроса = ОписаниеЗапроса.Операторы[0];
	
	ОписаниеПериода = ЗарплатаКадрыПериодическиеРегистры.ОписаниеПериодаДляСоздатьВТИмяРегистра();
	ОписаниеФильтра = ЗарплатаКадрыПериодическиеРегистры.ОписаниеФильтраДляСоздатьВТИмяРегистраПоТаблицеЗначений(
		ПараметрыПостроения.ТаблицаФильтра,
		МассивИзмерений);
		
	ОписаниеИспользованияФильтра = ЗарплатаКадрыПериодическиеРегистры.ОписаниеИспользованиеФильтра("ВТОтбор", "ТаблицаРегистра");
	ЗарплатаКадрыПериодическиеРегистры.ИнициализироватьИспользованиеФильтра(
		ОписаниеИспользованияФильтра, 
		ОписаниеФильтра,
		ОписаниеРегистра,
		"Период",
		ОператорЗапроса);
		
	ЗарплатаКадрыПериодическиеРегистры.ЗаменитьТаблицуВОператореЗапроса(
		ОператорЗапроса,
		"ТаблицаРегистра",
		"РегистрСведений." + ИнтервальныеРегистрыБЗК.ИмяИнтервальногоРегистра(ИмяРегистра));
		
	Если Не ОписаниеРегистра.ЕстьВозвратныеСобытия Тогда
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(ОписаниеЗапроса, 0, "ДАТАВРЕМЯ(1, 1, 1)", "ДействуетДо");
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(ОписаниеЗапроса, 0, "&МаксимальнаяДата", "ДатаОкончания");
	КонецЕсли;
	
	Для Каждого Поле Из МассивПолейРегистраПоОписанию Цикл
		ВыражениеПоля = "ТаблицаРегистра." + Поле;
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(ОписаниеЗапроса, 0, ВыражениеПоля, Поле);
	КонецЦикла;
	
	ЗарплатаКадрыПериодическиеРегистры.УстановитьФильтрВОписаниеПакетаЗапросовКРегистру(
		ОписаниеПакетаЗапросов, 
		ОписаниеФильтра,
		ОписаниеИспользованияФильтра);
		
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьПоляУпорядочиванияВОписаниеЗапроса(ОписаниеЗапроса, МассивИзмерений);
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьПоляУпорядочиванияВОписаниеЗапроса(ОписаниеЗапроса, "ДатаНачала");
	
	ОписаниеПакетаЗапросов.Параметры.Вставить("МаксимальнаяДата", ЗарплатаКадрыПериодическиеРегистры.МаксимальнаяДата());
	
	Возврат ЗарплатаКадрыПериодическиеРегистры.ЗапросПоОписаниюПакета(ОписаниеПакетаЗапросов, Ложь);
	
КонецФункции
	
Функция ТекущиеДанныеРегистра(КлючиОбновляемыхИнтервалов, ИмяРегистра, ОписаниеИнтервальногоРегистра, МассивПолейРегистраПоОписанию, ПараметрыПостроения)
	
	ИзмерениеЗаписи = ОписаниеИнтервальногоРегистра.ОсновноеИзмерение;
	ИзмеренияРасчета = ОписаниеИнтервальногоРегистра.ИзмеренияРасчета;
	ПолноеПереформирование = ПараметрыПостроения.ПолноеПереформирование;
	Если ИзмерениеЗаписи = ИзмеренияРасчета И ПолноеПереформирование Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МинимальныйГод = КлючиОбновляемыхИнтервалов.МинимальныйГод;
	КлючиОтбора = КлючиОбновляемыхИнтервалов.КлючиОтбора;
	
	ШаблонЗапроса = 
		"ВЫБРАТЬ
		|	ТаблицаРегистра.ДатаОкончания КАК ДатаОкончания,
		|	ТаблицаРегистра.ДатаНачала КАК ДатаНачала,
		|	ТаблицаРегистра.ПериодЗаписи КАК ПериодЗаписи,
		|	ТаблицаРегистра.РегистраторЗаписи КАК РегистраторЗаписи,
		|	ТаблицаРегистра.РегистраторСобытия КАК РегистраторСобытия,
		|	ТаблицаРегистра.Год КАК Год,
		|	ТаблицаРегистра.ПериодПредыдущейЗаписи КАК ПериодПредыдущейЗаписи,
		|	ТаблицаРегистра.ПустойИнтервал КАК ПустойИнтервал,
		|	ТаблицаРегистра.ДействуетДо КАК ДействуетДо,
		|	&ШаблонПоля
		|ИЗ
		|	#РегистрСведений КАК ТаблицаРегистра
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТОтбор КАК Отбор
		|		ПО ТаблицаРегистра.ДатаОкончания > &МинимальныйГод
		|			И ТаблицаРегистра.ДатаНачала >= &МинимальныйГод
		|			И &ШаблонУсловияСоединения";
	
	ОписаниеПакетаЗапросов = ЗарплатаКадрыПериодическиеРегистры.НовыйОписаниеПакетаЗапросовКРегистру();
	ОписаниеЗапроса = ЗарплатаКадрыПериодическиеРегистры.ОписаниеЗапросаПоТексту(ШаблонЗапроса);
	ОписаниеПакетаЗапросов.ЗапросыПолученияДанных.Добавить(ОписаниеЗапроса);
	ОператорЗапроса = ОписаниеЗапроса.Операторы[0];
	ОписаниеРегистра = ЗарплатаКадрыОбщиеНаборыДанных.ОписаниеРегистра(ИмяРегистра);
	ЗарплатаКадрыПериодическиеРегистры.ЗаменитьТаблицуВОператореЗапроса(ОператорЗапроса, "ТаблицаРегистра", "РегистрСведений." + ИмяРегистра);
	
	ОписаниеПериода = ЗарплатаКадрыПериодическиеРегистры.ОписаниеПериодаДляСоздатьВТИмяРегистра();
	ОписаниеФильтра = ЗарплатаКадрыПериодическиеРегистры.ОписаниеФильтраДляСоздатьВТИмяРегистраПоСпискуЗначений(
		ОписаниеПериода, ИзмерениеЗаписи, КлючиОтбора);
		
	ОписаниеИспользованияФильтра = ЗарплатаКадрыПериодическиеРегистры.ОписаниеИспользованиеФильтра("Отбор", "ТаблицаРегистра");
	ЗарплатаКадрыПериодическиеРегистры.ИнициализироватьИспользованиеФильтра(
		ОписаниеИспользованияФильтра, 
		ОписаниеФильтра,
		ОписаниеРегистра,
		"",
		ОператорЗапроса);
		
	Для Каждого Поле Из МассивПолейРегистраПоОписанию Цикл
		ВыражениеПоля = "ТаблицаРегистра." + Поле;
		ЗарплатаКадрыПериодическиеРегистры.ДобавитьПолеВОписаниеЗапроса(ОписаниеЗапроса, 0, ВыражениеПоля, Поле);
	КонецЦикла;
		
	ЗарплатаКадрыПериодическиеРегистры.УстановитьФильтрВОписаниеПакетаЗапросовКРегистру(
		ОписаниеПакетаЗапросов, 
		ОписаниеФильтра,
		ОписаниеИспользованияФильтра);	
		
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьПоляУпорядочиванияВОписаниеЗапроса(ОписаниеЗапроса, ИзмерениеЗаписи);
	ЗарплатаКадрыПериодическиеРегистры.ДобавитьПоляУпорядочиванияВОписаниеЗапроса(ОписаниеЗапроса, "Год");
	
	Запрос = ЗарплатаКадрыПериодическиеРегистры.ЗапросПоОписаниюПакета(ОписаниеПакетаЗапросов, Ложь);
	Запрос.УстановитьПараметр("МинимальныйГод", МинимальныйГод);
	ДанныеРегистра = Запрос.Выполнить().Выгрузить();
	ДанныеРегистра.Индексы.Добавить(ИзмерениеЗаписи+",Год");
	
	Возврат ДанныеРегистра;
	
КонецФункции 

Функция РассчитанныеИнтервалыПоИзмерению(ИмяРегистра, ВыборкаИнтервалы, ЗначениеИзмерения, ОписаниеИнтервальногоРегистра,
	МассивПолейРегистра, ПараметрыПостроения)
	
	РассчитанныеПериоды = НовыйТаблицаЗначенийИнтервальногоРегистра(МассивПолейРегистра);
	МаксимальнаяДата = ЗарплатаКадрыПериодическиеРегистры.МаксимальнаяДата();
	ИзмеренияРасчета = ОписаниеИнтервальногоРегистра.ИзмеренияРасчета;
	ПараметрыНаследованияРесурсов = ОписаниеИнтервальногоРегистра.ПараметрыНаследованияРесурсов;
	
	ТаблицаСобытий = ТаблицаСобытийПоВыборкеИнтервалов(
		ВыборкаИнтервалы, ЗначениеИзмерения, МассивПолейРегистра, ОписаниеИнтервальногоРегистра, ПараметрыПостроения);
	
	ПоляРегистраСтрокой = СтрСоединить(СлужебныеПоляИнтервальногоРегистра(), ",");
	ПоляРегистраСтрокой = ПоляРегистраСтрокой + "," + СтрСоединить(МассивПолейРегистра, ",");
	
	ТекущийИнтервал	= Новый Структура(ПоляРегистраСтрокой);
	ТекущийИнтервал.Вставить("ЗначениеЗаполнено", Ложь);
	ЗначенияИзмерений = Неопределено;
	МассивОжиданий = Новый Массив;
	
	Для Каждого Событие Из ТаблицаСобытий Цикл
		Если ИнтервальныеРегистрыБЗК.ЗначенияИзмеренийОтличны(ЗначенияИзмерений, Событие) Тогда
			Если ЗначенияИзмерений <> Неопределено Тогда
				ЗакрытьИнтервал(ТекущийИнтервал, РассчитанныеПериоды, МаксимальнаяДата);
			КонецЕсли;
			
			ИнициализироватьДанныеДляРасчета(ЗначенияИзмерений, МассивОжиданий, ТекущийИнтервал, Событие, ИзмеренияРасчета);
		КонецЕсли;

		// Если запись удалена, добавляем ее в рассчитанные периоды с пометкой удаления,
		// чтобы в дальнейшем по ней был записан пустой набор
		Если Событие.ЗаписьУдалена = Истина Тогда
			НоваяСтрока = РассчитанныеПериоды.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Событие);
			Продолжить;
		КонецЕсли;
		
		// Если запись началась до момента расчета, а ее возвратное событие попало в период расчета,
		// то помещаем такую запись в начало стека ожиданий
		Если Событие.ОтложенныйИнтервал Тогда
			ПоместитьВОжидание(МассивОжиданий, Событие, ПоляРегистраСтрокой);
			Продолжить;
		КонецЕсли;
		
		Если Событие.ЭтоНачалоИнтервала Тогда
			ПриОткрытииИнтервала(ИмяРегистра, ТекущийИнтервал, Событие, МассивОжиданий, РассчитанныеПериоды, ПоляРегистраСтрокой);
		Иначе
			ПриЗакрытииИнтервала(ИмяРегистра, ТекущийИнтервал, Событие, МассивОжиданий, РассчитанныеПериоды, ПараметрыНаследованияРесурсов);
		КонецЕсли;
	КонецЦикла;
	
	ЗакрытьИнтервал(ТекущийИнтервал, РассчитанныеПериоды, МаксимальнаяДата);
	
	Возврат РассчитанныеПериоды;
	
КонецФункции

Функция ТаблицаСобытийПоВыборкеИнтервалов(ВыборкаИнтервалы, ЗначениеИзмерения, МассивПолей, ОписаниеИнтервальногоРегистра, ПараметрыПостроения)
	
	ИзмерениеЗаписи = ОписаниеИнтервальногоРегистра.ОсновноеИзмерение;
	ИзмеренияРасчета = ОписаниеИнтервальногоРегистра.ИзмеренияРасчета;
	ТаблицаСобытий = НовыйТаблицаЗначенийИнтервальногоРегистра(МассивПолей);
	ТаблицаСобытий.Колонки.Удалить("ДатаНачала");
	ТаблицаСобытий.Колонки.Удалить("Год");
	ТаблицаСобытий.Колонки.Добавить("ДатаСобытия", Новый ОписаниеТипов("Дата"));
	ТаблицаСобытий.Колонки.Добавить("ЭтоНачалоИнтервала", Новый ОписаниеТипов("Булево"));
	ТаблицаСобытий.Колонки.Добавить("ОтложенныйИнтервал", Новый ОписаниеТипов("Булево"));
	
	Пока ВыборкаИнтервалы.НайтиСледующий(ЗначениеИзмерения, ИзмерениеЗаписи) Цикл
		
		Если ВыборкаИнтервалы.ВсеЗаписиУдалены Тогда
			НоваяСтрока = ТаблицаСобытий.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ВыборкаИнтервалы);
			НоваяСтрока.ЗаписьУдалена = Истина;
			Продолжить;
		КонецЕсли;
		
		// Исключение некорректных записей
		Если ВыборкаИнтервалы.ДатаНачала > ВыборкаИнтервалы.ДатаОкончания Тогда
			Продолжить;
		КонецЕсли;
		
		НоваяСтрока = ТаблицаСобытий.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, ВыборкаИнтервалы);
		НоваяСтрока.ДатаСобытия = ВыборкаИнтервалы.ДатаНачала;
		НоваяСтрока.ЭтоНачалоИнтервала = Истина;
		НоваяСтрока.ОтложенныйИнтервал = Ложь;
		
		Если ВыборкаИнтервалы.ДатаОкончания <> ЗарплатаКадрыПериодическиеРегистры.МаксимальнаяДата() Тогда
			НоваяСтрока = ТаблицаСобытий.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ВыборкаИнтервалы);
			НоваяСтрока.ДатаСобытия = ВыборкаИнтервалы.ДатаОкончания;
			НоваяСтрока.ЭтоНачалоИнтервала = Ложь;
			НоваяСтрока.ОтложенныйИнтервал = Ложь;
		КонецЕсли;
		
		// Если запись началась до момента расчета, а ее возвратное событие попало в период расчета,
		// то такую запись необходимо поместить в начало стека ожиданий
		Если ВыборкаИнтервалы.ОтложенныйИнтервал Тогда
			НоваяСтрока = ТаблицаСобытий.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, ВыборкаИнтервалы);
			НоваяСтрока.ДатаСобытия = ВыборкаИнтервалы.ПериодЗаписи;
			НоваяСтрока.ЭтоНачалоИнтервала = Истина;
		КонецЕсли;
	КонецЦикла;
	
	Если Не ПараметрыПостроения.ПолноеПереформирование Тогда
		ДополнитьТаблицуСобытийДаннымиНабора(ТаблицаСобытий, ПараметрыПостроения.ТаблицаНабора, ИзмерениеЗаписи, ЗначениеИзмерения);
	КонецЕсли;
	
	ТаблицаСобытий.Сортировать(ИзмеренияРасчета + ",ДатаСобытия,ПериодЗаписи", Новый СравнениеЗначений);
	
	Возврат ТаблицаСобытий;
	
КонецФункции

Процедура ДополнитьТаблицуСобытийДаннымиНабора(ТаблицаСобытий, ТаблицаНабора, ИзмерениеЗаписи, ЗначениеИзмерения)
	
	СтруктураПоиска = Новый Структура(ИзмерениеЗаписи, ЗначениеИзмерения);
	НайденныеСтроки = ТаблицаНабора.НайтиСтроки(СтруктураПоиска);
	ЕстьПолеДействуетДо = ТаблицаНабора.Колонки.Найти("ДействуетДо") <> Неопределено;
	Для Каждого Запись Из НайденныеСтроки Цикл
		Если ЕстьПолеДействуетДо
			И ЗначениеЗаполнено(Запись.ДействуетДо) Тогда
			
			ДатаОкончания = Запись.ДействуетДо - 1;
		Иначе
			ДатаОкончания = ЗарплатаКадрыПериодическиеРегистры.МаксимальнаяДата();
		КонецЕсли;
			
		// Исключение некорректных записей	
		Если Запись.Период > ДатаОкончания Тогда
			Продолжить;
		КонецЕсли;
		
		НоваяСтрока = ТаблицаСобытий.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока, Запись);
		НоваяСтрока.ДатаСобытия = Запись.Период;
		НоваяСтрока.ДатаОкончания = ДатаОкончания;
		НоваяСтрока.ПериодЗаписи = Запись.Период;
		НоваяСтрока.РегистраторЗаписи = Запись.Регистратор;
		НоваяСтрока.РегистраторСобытия = Запись.Регистратор;
		НоваяСтрока.ЭтоНачалоИнтервала = Истина;
		НоваяСтрока.ПустойИнтервал = Ложь;
		
		Если ЕстьПолеДействуетДо
			И ЗначениеЗаполнено(Запись.ДействуетДо) Тогда
			
			НоваяСтрока = ТаблицаСобытий.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Запись);
			НоваяСтрока.ДатаСобытия = Запись.ДействуетДо - 1;
			НоваяСтрока.ДатаОкончания = Запись.ДействуетДо - 1;
			НоваяСтрока.ПериодЗаписи = Запись.Период;
			НоваяСтрока.РегистраторЗаписи = Запись.Регистратор;
			НоваяСтрока.РегистраторСобытия = Запись.Регистратор;
			НоваяСтрока.ЭтоНачалоИнтервала = Ложь;
			НоваяСтрока.ПустойИнтервал = Ложь;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Функция КлючиОбновляемыхИнтервалов(ВыборкаИнтервалы, ПараметрыПостроения, ИзмерениеЗаписи)
	
	ПолноеПереформирование = ПараметрыПостроения.ПолноеПереформирование;
	ТаблицаНабора = ПараметрыПостроения.ТаблицаНабора;
	
	КлючиОтбора = Новый Массив;
	МинимальныйГод = ?(ПолноеПереформирование, Дата(1, 1, 1), ЗарплатаКадрыПериодическиеРегистры.МаксимальнаяДата());
	Пока ВыборкаИнтервалы.СледующийПоЗначениюПоля(ИзмерениеЗаписи) Цикл
		КлючиОтбора.Добавить(ВыборкаИнтервалы[ИзмерениеЗаписи]);
		МинимальныйГод = Мин(НачалоГода(ВыборкаИнтервалы.ДатаНачала), МинимальныйГод);	
	КонецЦикла;
	
	ВыборкаИнтервалы.Сбросить();
	
	Если Не ПолноеПереформирование Тогда
		Для Каждого Запись Из ТаблицаНабора Цикл
			КлючиОтбора.Добавить(Запись[ИзмерениеЗаписи]);
			МинимальныйГод = Мин(НачалоГода(Запись.Период), МинимальныйГод);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Новый Структура("КлючиОтбора, МинимальныйГод", ОбщегоНазначенияКлиентСервер.СвернутьМассив(КлючиОтбора), МинимальныйГод);
	
КонецФункции

Процедура ОткрытьИнтервал(ИмяРегистра, ТекущийИнтервал, Источник, ДатаНачала, ПериодПредыдущейЗаписи = Неопределено) 
	
	ТекущийИнтервал.ПериодПредыдущейЗаписи = ПериодПредыдущейЗаписи;
	ЗаполнитьЗначенияСвойств(ТекущийИнтервал, Источник, , "ПериодПредыдущейЗаписи");
	
	ТекущийИнтервал.ДатаНачала 			= ДатаНачала;
	ТекущийИнтервал.ЗначениеЗаполнено 	= Истина;	

	РегистрыСведений.КадроваяИсторияСотрудниковИнтервальный.ОткрытьИнтервал(
		ИмяРегистра, ТекущийИнтервал, Источник, ДатаНачала);
	
КонецПроцедуры

Процедура ОткрытьПустойИнтервал(ТекущийИнтервал, Источник, ДатаНачала, ПараметрыРесурсов, ПериодПредыдущейЗаписи = Неопределено)
	
	Для каждого КлючИЗначение Из ПараметрыРесурсов Цикл
		
		Ресурс = КлючИЗначение.Ключ;
		Наследование = КлючИЗначение.Значение;
		Если Наследование <> Неопределено 
			И ТипЗнч(Наследование) = Тип("Структура") 
			И ТекущийИнтервал.Свойство(Ресурс) Тогда
			
			ПравилоНаследования = Неопределено;
			Наследование.Свойство("ПравилоНаследования", ПравилоНаследования);
			
			Если ПравилоНаследования = ЗарплатаКадрыПериодическиеРегистры.ПравилоНаследованияФиксированное() Тогда
				ТекущийИнтервал[Ресурс] = Наследование.Значение;
			ИначеЕсли ПравилоНаследования = ЗарплатаКадрыПериодическиеРегистры.ПравилоНаследованияПустое() Тогда
			    ТекущийИнтервал[Ресурс] = Неопределено;
			КонецЕсли; 
		КонецЕсли; 
	КонецЦикла; 
	
	ТекущийИнтервал.ДатаНачала				= ДатаНачала;
	ТекущийИнтервал.ДействуетДо				= Дата(1, 1, 1);
	ТекущийИнтервал.ПериодПредыдущейЗаписи 	= ПериодПредыдущейЗаписи;
	ТекущийИнтервал.ПустойИнтервал			= Истина;
	ТекущийИнтервал.ЗначениеЗаполнено 		= Истина;

КонецПроцедуры

Процедура ЗакрытьИнтервал(ТекущийИнтервал, РассчитанныеПериоды, ДатаОкончания)

	Если Не ТекущийИнтервал.ЗначениеЗаполнено Тогда
		Возврат;
	КонецЕсли;
	
	Если ТекущийИнтервал.ДатаНачала > ДатаОкончания Тогда
		Возврат;
	КонецЕсли;
	
	НоваяСтрока = РассчитанныеПериоды.Добавить();
	ЗаполнитьЗначенияСвойств(НоваяСтрока, ТекущийИнтервал);
	НоваяСтрока.ДатаОкончания = ДатаОкончания;
	НоваяСтрока.Год = НачалоГода(НоваяСтрока.ДатаНачала);
	ТекущийИнтервал.ЗначениеЗаполнено = Ложь;
	
КонецПроцедуры
 
Процедура ПоместитьВОжидание(МассивОжиданий, ТекущийИнтервал, ПоляРегистра)
		
	Если ТекущийИнтервал.ПустойИнтервал = Истина Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураОжидания = Новый Структура(ПоляРегистра);
	ЗаполнитьЗначенияСвойств(СтруктураОжидания, ТекущийИнтервал);
	МассивОжиданий.Добавить(СтруктураОжидания);
	
КонецПроцедуры

Функция ПоследнийОткрытыйИнтервал(МассивОжиданий, ДатаСобытия)
	
	СтруктураОжидания = Неопределено;
	
	Если МассивОжиданий.Количество() = 0 Тогда
		Возврат СтруктураОжидания;
	КонецЕсли;
	
	Сч = МассивОжиданий.ВГраница();
	Пока Сч >= 0 Цикл
		Если Не ЗначениеЗаполнено(МассивОжиданий[Сч].ДействуетДо)
			Или МассивОжиданий[Сч].ДействуетДо - 1 >= ДатаСобытия Тогда
			
			СтруктураОжидания = МассивОжиданий[Сч];
			Прервать;
		КонецЕсли;
		
		МассивОжиданий.Удалить(Сч);
		Сч = Сч - 1;
	КонецЦикла;
	
	Возврат СтруктураОжидания;
	
КонецФункции

Процедура ДополнитьРассчитанныеИнтервалыДаннымиРегистра(ДанныеРегистра, РассчитанныеПериоды, ИзмеренияРасчета, ПолноеПереформирование)
	
	КлючиРассчитанныхПериодов = КоллекцииБЗК.СгруппироватьТаблицу(
		РассчитанныеПериоды, ИзмеренияРасчета + ",ЗаписьУдалена", "МИНИМУМ(ДатаНачала)");
		
	КлючиРассчитанныхПериодовПоГодам = РассчитанныеПериоды.Скопировать();
	КлючиРассчитанныхПериодовПоГодам.Свернуть(ИзмеренияРасчета + ",Год");
	ДанныеРегистра.Сортировать(ИзмеренияРасчета + ",Год");
	СтруктураПоиска = Новый Структура(ИзмеренияРасчета);
	ЗначенияИзмерений = Новый Структура(ИзмеренияРасчета);
	
	Для Каждого СтрокаРегистра Из ДанныеРегистра Цикл
		Если ИнтервальныеРегистрыБЗК.ЗначенияИзмеренийОтличны(ЗначенияИзмерений, СтрокаРегистра) Тогда
			ЗаполнитьЗначенияСвойств(ЗначенияИзмерений, СтрокаРегистра);
			ЗаполнитьЗначенияСвойств(СтруктураПоиска, СтрокаРегистра);
			НайденныеСтроки = КлючиРассчитанныхПериодов.НайтиСтроки(СтруктураПоиска);
			НайденныеСтрокиПоГодам = КлючиРассчитанныхПериодовПоГодам.НайтиСтроки(СтруктураПоиска);
			РассчитанныеГода = ОбщегоНазначения.ВыгрузитьКолонку(НайденныеСтрокиПоГодам, "Год", Истина);
		КонецЕсли;
		
		Если НайденныеСтроки.Количество() = 0 Тогда
			ЗаполнитьЗначенияСвойств(РассчитанныеПериоды.Добавить(), СтрокаРегистра);
			Продолжить;
		КонецЕсли;
		
		Если НайденныеСтроки[0].ЗаписьУдалена = Истина Тогда
			Продолжить;
		КонецЕсли;
		
		Если ПолноеПереформирование Тогда
			Продолжить;
		КонецЕсли;
		
		Если СтрокаРегистра.ДатаОкончания < НайденныеСтроки[0].ДатаНачала Тогда
			ЗаполнитьЗначенияСвойств(РассчитанныеПериоды.Добавить(), СтрокаРегистра);
			Продолжить;
		КонецЕсли;
		
		Если РассчитанныеГода.Найти(СтрокаРегистра.Год) = Неопределено Тогда
			НоваяСтрока = РассчитанныеПериоды.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаРегистра);
			НоваяСтрока.ЗаписьУдалена = Истина;
			РассчитанныеГода.Добавить(СтрокаРегистра.Год);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаписатьРассчитанныеИнтервалы(ИмяИнтервальногоРегистра, РассчитанныеПериоды, ИзмерениеЗаписи, ЗначениеИзмерения, ПараметрыПостроения)
	
	РежимЗагрузки = ПараметрыПостроения.РежимЗагрузки;
	ПолноеПереформирование = ПараметрыПостроения.ПолноеПереформирование;
	
	НаборЗаписей = РегистрыСведений[ИмяИнтервальногоРегистра].СоздатьНаборЗаписей();
	НаборЗаписей.Отбор[ИзмерениеЗаписи].Установить(ЗначениеИзмерения);
	НаборЗаписей.ОбменДанными.Загрузка = РежимЗагрузки;
	
	РассчитанныеПериоды.Сортировать("Год");
	ТекущийГод = Неопределено;
	
	Для Каждого РассчитанныйИнтервал Из РассчитанныеПериоды Цикл
		Если Не ПолноеПереформирование
			И ТекущийГод <> РассчитанныйИнтервал.Год Тогда
			
			Если ТекущийГод <> Неопределено Тогда
				НаборЗаписей.Записать();
				НаборЗаписей.Очистить();
			КонецЕсли;
			ТекущийГод = РассчитанныйИнтервал.Год;
			НаборЗаписей.Отбор.Год.Установить(ТекущийГод);
		КонецЕсли;
		
		Если РассчитанныйИнтервал.ЗаписьУдалена = Истина Тогда
			Продолжить;
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(НаборЗаписей.Добавить(), РассчитанныйИнтервал);
	КонецЦикла;
	
	Если ТекущийГод <> Неопределено
		Или ПолноеПереформирование Тогда
		
		НаборЗаписей.Записать();
	КонецЕсли;
	
КонецПроцедуры

Функция МассивПолейРегистраПоОписанию(ИмяИнтервальногоРегистра)
	
	ОписаниеРегистра = ЗарплатаКадрыОбщиеНаборыДанных.ОписаниеРегистра(ИмяИнтервальногоРегистра);
	
	МассивСтрокПолейРегистра = Новый Массив;
	Для каждого Измерение Из ОписаниеРегистра.Измерения Цикл
		Если Измерение = "ДатаОкончания"
			Или Измерение = "ДатаНачала"
			Или Измерение = "ПериодЗаписи" 
			Или Измерение = "Год" Тогда
			
			Продолжить;
		КонецЕсли;
		
		МассивСтрокПолейРегистра.Добавить(Измерение);
	КонецЦикла; 
	
	Для каждого Ресурс Из ОписаниеРегистра.Ресурсы Цикл
		Если Ресурс = "ПериодПредыдущейЗаписи" 
			Или Ресурс = "ДействуетДо" Тогда
			
			Продолжить;
		КонецЕсли; 
		
		МассивСтрокПолейРегистра.Добавить(Ресурс);
	КонецЦикла; 
	
	Для каждого Реквизит Из ОписаниеРегистра.Реквизиты Цикл
		Если Реквизит = "ПустойИнтервал" 
			Или Реквизит = "РегистраторЗаписи" 
			Или Реквизит = "РегистраторСобытия" Тогда
			Продолжить;
		КонецЕсли;
		
		МассивСтрокПолейРегистра.Добавить(Реквизит);
	КонецЦикла;
	
	Возврат МассивСтрокПолейРегистра;
	
КонецФункции

Функция НовыйТаблицаЗначенийИнтервальногоРегистра(МассивПолейРегистра)
	
	ТаблицаЗначенийИнтервальногоРегистра = Новый ТаблицаЗначений;
	Для Каждого Поле Из МассивПолейРегистра Цикл
		ТаблицаЗначенийИнтервальногоРегистра.Колонки.Добавить(Поле);
	КонецЦикла;
	
	Для Каждого Поле Из СлужебныеПоляИнтервальногоРегистра() Цикл
		ТаблицаЗначенийИнтервальногоРегистра.Колонки.Добавить(Поле);
	КонецЦикла;
	
	Возврат ТаблицаЗначенийИнтервальногоРегистра;
	
КонецФункции

Функция СлужебныеПоляИнтервальногоРегистра()
	
	СлужебныеПоля = Новый Массив;
	СлужебныеПоля.Добавить("ДатаОкончания");
	СлужебныеПоля.Добавить("ДатаНачала");
	СлужебныеПоля.Добавить("Год");
	СлужебныеПоля.Добавить("ПериодЗаписи");
	СлужебныеПоля.Добавить("РегистраторЗаписи");
	СлужебныеПоля.Добавить("РегистраторСобытия");
	СлужебныеПоля.Добавить("ПериодПредыдущейЗаписи");
	СлужебныеПоля.Добавить("ПустойИнтервал");
	СлужебныеПоля.Добавить("ДействуетДо");
	СлужебныеПоля.Добавить("ЗаписьУдалена");
	
	Возврат СлужебныеПоля;
	
КонецФункции

Процедура ИнициализироватьДанныеДляРасчета(ЗначенияИзмерений, МассивОжиданий, ТекущийИнтервал, Событие, ИзмеренияРасчета)
	
	ЗначенияИзмерений 	= Новый Структура(ИзмеренияРасчета);
	МассивОжиданий 		= Новый Массив;
	ЗаполнитьЗначенияСвойств(ЗначенияИзмерений, Событие);
	
	Для Каждого КлючИЗначение Из ТекущийИнтервал Цикл
		ТекущийИнтервал.Вставить(КлючИЗначение.Ключ, Неопределено);
	КонецЦикла;
	
	ТекущийИнтервал.ЗначениеЗаполнено = Ложь;
	
КонецПроцедуры

Процедура ПриОткрытииИнтервала(ИмяРегистра, ТекущийИнтервал, Событие, МассивОжиданий, РассчитанныеПериоды, ПоляРегистра)
	
	// Если нет открытых интервалов, просто открываем новый
	Если Не ТекущийИнтервал.ЗначениеЗаполнено Тогда
		ОткрытьИнтервал(ИмяРегистра, ТекущийИнтервал, Событие, Событие.ДатаСобытия, Событие.ПериодПредыдущейЗаписи);
		Возврат;
	КонецЕсли;
	
	Если Событие.ПустойИнтервал Тогда
		Возврат;
	КонецЕсли;
	
	Если ТекущийИнтервал.ПериодЗаписи > Событие.ПериодЗаписи
		И Не ТекущийИнтервал.ПустойИнтервал Тогда
		
		// Открытие интервала на самом деле является возвратной записью,
		// вытеснений нет, такой интервал следует поместить в стек
		ПоместитьВОжидание(МассивОжиданий, Событие, ПоляРегистра);
	Иначе
		// Закрываем вытесненный интервал и помещаем в стек ожиданий, открываем новый интервал
		ЗакрытьИнтервал(ТекущийИнтервал, РассчитанныеПериоды, Событие.ДатаСобытия - 1);
		ПоместитьВОжидание(МассивОжиданий, ТекущийИнтервал, ПоляРегистра);
		ПериодПредыдущейЗаписи = ПериодПредыдущейЗаписи(ТекущийИнтервал, Событие);
		ОткрытьИнтервал(ИмяРегистра, ТекущийИнтервал, Событие, Событие.ДатаСобытия, ПериодПредыдущейЗаписи);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПриЗакрытииИнтервала(ИмяРегистра, ТекущийИнтервал, Событие, МассивОжиданий, РассчитанныеПериоды, ПараметрыНаследованияРесурсов)
	
	// При завершении вытесненного интервала, у текущего интервала необходимо обновить ссылку на предыдущую запись
	// если ссылка на предыдущую запись изменилась, то разделяем интервал
	Если НеобходимоРазделитьТекущийИнтервал(ТекущийИнтервал, Событие, МассивОжиданий) Тогда
		РазделитьТекущийИнтервал(ИмяРегистра, ТекущийИнтервал, Событие, МассивОжиданий, РассчитанныеПериоды);
		Возврат;
	КонецЕсли;
	
	// Если это не окончательное завершение интервала, то не закрываем текущий интервал
	Если ТекущийИнтервал.ДатаОкончания <> ТекущийИнтервал.ДействуетДо - 1 Тогда
		Возврат;
	КонецЕсли;
	
	ЗакрытьИнтервал(ТекущийИнтервал, РассчитанныеПериоды, Событие.ДатаСобытия);
	ОткрытьНовыйИнтервалПослеЗакрытияТекущего(ИмяРегистра, ТекущийИнтервал, Событие, МассивОжиданий, ПараметрыНаследованияРесурсов);
	
КонецПроцедуры

Функция НеобходимоРазделитьТекущийИнтервал(ТекущийИнтервал, Событие, МассивОжиданий)
	
	// Если закрытие текущего интервала, тогда разделений не требуется
	Если ТекущийИнтервал.ПериодЗаписи = Событие.ПериодЗаписи Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Проверяем, что происходит закрытие последнего вытесненного интервала
	СтруктураОжидания = ПоследнийОткрытыйИнтервал(МассивОжиданий, Событие.ДатаСобытия + 1);
	ПериодПредыдущейЗаписи = ?(СтруктураОжидания = Неопределено, Неопределено, СтруктураОжидания.ПериодЗаписи);
	Если ТекущийИнтервал.ПериодПредыдущейЗаписи = Событие.ПериодЗаписи
		И ТекущийИнтервал.ПериодПредыдущейЗаписи <> ПериодПредыдущейЗаписи Тогда
		
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

Процедура РазделитьТекущийИнтервал(ИмяРегистра, ТекущийИнтервал, Событие, МассивОжиданий, РассчитанныеПериоды)
	
	СтруктураОжидания = ПоследнийОткрытыйИнтервал(МассивОжиданий, Событие.ДатаСобытия + 1);
	ПериодПредыдущейЗаписи = ?(СтруктураОжидания = Неопределено, Неопределено, СтруктураОжидания.ПериодЗаписи);
	ЗакрытьИнтервал(ТекущийИнтервал, РассчитанныеПериоды, Событие.ДатаСобытия);
	ОткрытьИнтервал(ИмяРегистра, ТекущийИнтервал, ТекущийИнтервал, Событие.ДатаСобытия + 1, ПериодПредыдущейЗаписи);
	
КонецПроцедуры

Процедура ОткрытьНовыйИнтервалПослеЗакрытияТекущего(ИмяРегистра, ТекущийИнтервал, Событие, МассивОжиданий, ПараметрыНаследованияРесурсов)
	
	СтруктураОжидания = ПоследнийОткрытыйИнтервал(МассивОжиданий, Событие.ДатаСобытия + 1);
	
	Если СтруктураОжидания <> Неопределено Тогда
		// Есть вытесненный интервал, восстанавливаем его
		МассивОжиданий.Удалить(МассивОжиданий.ВГраница());
		ОткрытьИнтервал(ИмяРегистра, ТекущийИнтервал, СтруктураОжидания, Событие.ДатаСобытия + 1, СтруктураОжидания.ПериодПредыдущейЗаписи);
		ТекущийИнтервал.РегистраторСобытия = Событие.РегистраторЗаписи;
	ИначеЕсли ПараметрыНаследованияРесурсов <> Неопределено Тогда
		// Открываем пустой интервал, если это указано в настройках формирования регистра
		ОткрытьПустойИнтервал(ТекущийИнтервал, Событие, Событие.ДатаСобытия + 1, ПараметрыНаследованияРесурсов);
		ТекущийИнтервал.РегистраторСобытия = Событие.РегистраторЗаписи;
	КонецЕсли;
	
КонецПроцедуры

Функция ПериодПредыдущейЗаписи(ТекущийИнтервал, Событие)
	
	Если ТекущийИнтервал.ПустойИнтервал Тогда
		// Текущий интервал пустой, у пустых интервалов нет своего периода записи,
		// поэтому запоминаем ссылку на дату начала пустого интервала
		Возврат ?(ТекущийИнтервал.ДатаНачала < Событие.ДатаСобытия, ТекущийИнтервал.ДатаНачала, Неопределено);
	ИначеЕсли ТекущийИнтервал.ПериодЗаписи = Событие.ПериодЗаписи Тогда
		// Открытие интервала вызвано той же записью, что и текущий интервал - наследуем ссылку на предыдущую запись
		Возврат Событие.ПериодПредыдущейЗаписи;
	Иначе
		// Запоминаем ссылку на вытесненный интервал
		Возврат ТекущийИнтервал.ПериодЗаписи;
	КонецЕсли;
	
КонецФункции

#КонецОбласти