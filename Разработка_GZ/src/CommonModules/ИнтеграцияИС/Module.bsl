////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Универсальные механизмы библиотек интеграции с государственными информационными системами:
//  * ЕГАИС,
//  * ГИСМ,
//  * ВетИС,
//  * ИСМП
// Состав модуля:
//
//  * Функции работы с прикладными документами (вывод привязки библиотечных документов, оповещений итп).
//  * Общие функции проведения документов.
//  * Общие функции для работы с протоколом обмена (Присоединенные файлы)
//  * Функции общего назначения.
//

#Область ПрограммныйИнтерфейс

// Вычисляет пересечение массивов. Пересечением массивов А и В является массив, содержащий
// все элементы массива А, существующие также и в массиве В.
//
// Параметры:
//  Массив1 - Массив - массив элементов;
//  Массив2 - Массив - массив элементов.
// 
// Возвращаемое значение:
//  Массив - пересечение массивов В и А.
//
// Пример:
//	//А = [1, 3, 5, 7];
//	//В = [3, 7, 9];
//	Результат = ПересечениеМассивов(А, В);
//	//Результат = [3, 7];
//
Функция ПересечениеМассивов(Массив1, Массив2) Экспорт
	
	Результат = Новый Массив;
	
	Ключи = Новый Соответствие;
	Для Каждого Элемент Из Массив1 Цикл
		Ключи.Вставить(Элемент, Истина);
	КонецЦикла;
	Для Каждого Элемент Из Массив2 Цикл
		Если Ключи.Получить(Элемент)<>Неопределено Тогда
			Результат.Добавить(Элемент);
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

// Преобразует массив структур в таблицу значений.
//   Первая строка массива содержит только структуру полей.
//
// Параметры:
//  Массив          - Массив               - коллекция строк таблицы в виде структур.
//  ТаблицаЗначений - ТаблицаЗначений - заполняемая таблица значений.
//
Процедура МассивВТаблицуЗначений(Массив, ТаблицаЗначений) Экспорт
	
	ЗаполнениеКолонок = Истина;
	
	Для Каждого Строка Из Массив Цикл
		
		Если ЗаполнениеКолонок Тогда
			ЗаполнениеКолонок = Ложь;
			Для Каждого КлючИЗначение Из Строка Цикл
				ТаблицаЗначений.Колонки.Добавить(КлючИЗначение.Ключ);
			КонецЦикла;
		Иначе
			НоваяСтрока = ТаблицаЗначений.Добавить();
			ЗаполнитьЗначенияСвойств(НоваяСтрока, Строка);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Текст исключения обработки статуса
//
// Параметры:
//  Документ - ДокументСсылка - Документ.
//  Операция - ПеречислениеСсылка - Операция.
// 
// Возвращаемое значение:
//  Строка - Текст исключения.
//
Функция ТекстИсключенияОбработкиСтатуса(Документ, Операция) Экспорт
	
	Возврат СтрШаблон(
		НСтр("ru = 'При изменении статуса документа %1 не обработана операция %2'"),
		Документ,
		Операция);
	
КонецФункции

// Возвращает массив/список значений пустых значений составного типа, включая Неопределено
// 
// Параметры:
// 	ВходящееОписаниеТипа - ОписаниеТипов - Описание типов метаданного для получения типов.
// 	ВозвращатьСписокЗначений - Булево - Выбор возвращаемого значения Масси или СписокЗначений.
// Возвращаемое значение:
// 	Массив, СписокЗначений - коллекция пустых значений составного типа.
//
Функция МассивПустыхЗначенийСоставногоТипа(ВходящееОписаниеТипа, ВозвращатьСписокЗначений=Ложь) Экспорт
	
	МассивТипов = Новый Массив;
	
	Для Каждого ЭлементТип Из ВходящееОписаниеТипа.Типы() Цикл
		МассивТиповПоЭлементу = Новый Массив;
		МассивТиповПоЭлементу.Добавить(ЭлементТип);
		ОписаниеТипаПоЭлементу = Новый ОписаниеТипов(МассивТиповПоЭлементу);
		МассивТипов.Добавить(ОписаниеТипаПоЭлементу.ПривестиЗначение(Неопределено));
	КонецЦикла;
	
	Если МассивТипов.Найти(Неопределено) = Неопределено Тогда
		МассивТипов.Добавить(Неопределено);
	КонецЕсли;
	
	Если ВозвращатьСписокЗначений Тогда
		СписокЗначенийИтог = Новый СписокЗначений;
		СписокЗначенийИтог.ЗагрузитьЗначения(МассивТипов);
		Возврат СписокЗначенийИтог;
	Иначе
		Возврат МассивТипов;
	КонецЕсли;
	
КонецФункции

// Рассчитать хеш для строки
// 
// Параметры:
//  СтрокаДляРасчетаХеша - Строка - Строка для расчета хеша
// Возвращаемое значение:
//  Строка - Описание
Функция ХешированиеДанныхSHA256(СтрокаДляРасчетаХеша) Экспорт
	
	ХешированиеДанныхОбъект = Новый ХешированиеДанных(ХешФункция.SHA256);
	ХешированиеДанныхОбъект.Добавить(СтрокаДляРасчетаХеша);
	
	Возврат Base64Строка(ХешированиеДанныхОбъект.ХешСумма);
	
КонецФункции

#Область ОбменСИспользованиемЭДО

// Получает структуру настроек обмена через ЭДО, извлекая из константы НастройкиОбменаГосИС.
// 
// Возвращаемое значение:
//  ТаблицаЗначений, Неопределено - Настройки обмена.
//
Функция НастройкиОбменаГосИС() Экспорт
	
	ХранилищеЗначения = Константы.НастройкиОбменаГосИС.Получить();
	
	Если ХранилищеЗначения = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НастройкиОбмена = ХранилищеЗначения.Получить();
	
	Возврат НастройкиОбмена;
	
КонецФункции

#КонецОбласти

#Область ФорматированиеXML

// Инициализирует объект ПараметрыЗаписиXML.
//
// Параметры:
//  ИспользоватьОтступы - Булево - признак использования отступов, по умолчанию Истина.
//  СимволОтступа       - Строка - символ, которым отображается отступ, по умолчанию два пробела.
//  Кодировка           - Строка - Кодировка текста.
// 
// Возвращаемое значение:
//  ПараметрыЗаписиXML - набор параметров, который используется при записи XML.
//
Функция ПараметрыФорматированияXML(ИспользоватьОтступы = Истина, СимволОтступа = "  ", Кодировка = "UTF-8") Экспорт
	
	ПараметрыЗаписи = Новый ПараметрыЗаписиXML(
		Кодировка,
		"1.0",
		ИспользоватьОтступы,
		ИспользоватьОтступы,
		СимволОтступа);
	
	Возврат ПараметрыЗаписи;
	
КонецФункции

// Форматирует текст сообщения в формате XML
//
// Параметры:
//  ТекстСообщенияXML       - Строка - текст сообщения, который.
//  ПараметрыФорматирования - ПараметрыЗаписиXML - параметры записи XML.
// 
// Возвращаемое значение:
//  Строка - отформатированная строка XML.
//
Функция ФорматироватьXMLСПараметрами(ТекстСообщенияXML, ПараметрыФорматирования) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ТекстСообщенияXML);
	
	ПостроительDOM = Новый ПостроительDOM;
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	
	ЗаписьXML = Новый ЗаписьXML;
	ЗаписьXML.УстановитьСтроку(ПараметрыФорматирования);
	
	ЗаписьDOM = Новый ЗаписьDOM;
	ЗаписьDOM.Записать(ДокументDOM, ЗаписьXML);
	
	Возврат ЗаписьXML.Закрыть();
	
КонецФункции

// Форматирует текст сообщения в формате XML
//
// Параметры:
//  ТекстСообщенияXML   - Строка - текст сообщения, который.
//  ИспользоватьОтступы - Булево - признак использования отступов, по умолчанию Истина.
//  СимволОтступа       - Строка - символ, которым отображается отступ, по умолчанию два пробела.
// 
// Возвращаемое значение:
//  Строка - отформатированная строка XML.
//
Функция ФорматироватьXML(ТекстСообщенияXML, ИспользоватьОтступы = Истина, СимволОтступа = " ") Экспорт
	
	ПараметрыФорматирования = ПараметрыФорматированияXML(ИспользоватьОтступы, СимволОтступа);
	
	Возврат ФорматироватьXMLСПараметрами(ТекстСообщенияXML, ПараметрыФорматирования);
	
КонецФункции

#КонецОбласти

#Область РаботаСXDTO

// Возвращает все пространства зависимые пространства имен из коллекции пакетов.
//
Процедура ЗависимыеПространстваИмен(ЗависимыеПакеты, ПространстваИмен) Экспорт
	
	Для Каждого ПакетXDTO Из ЗависимыеПакеты Цикл
		Если ПространстваИмен.Найти(ПакетXDTO.URIПространстваИмен) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ПространстваИмен.Добавить(ПакетXDTO.URIПространстваИмен);
		
		ЗависимыеПространстваИмен(ПакетXDTO.Зависимости, ПространстваИмен);
	КонецЦикла;
	
КонецПроцедуры

// Создает ОбъектXDTO из пространства имен по имени свойства.
//
Функция ОбъектXDTOПоИмениТипа(ОбъектXDTOРодитель, ИмяТипа) Экспорт
	
	Если ТипЗнч(ОбъектXDTOРодитель) = Тип("СписокXDTO") Тогда
		ТипОбъекта = ОбъектXDTOРодитель.ВладеющееСвойство.Тип.Свойства.Получить(ИмяТипа).Тип;
	Иначе
		ТипОбъекта = ОбъектXDTOРодитель.Тип().Свойства.Получить(ИмяТипа).Тип;
	КонецЕсли; 
	
	Возврат ФабрикаXDTO.Создать(ТипОбъекта);
	
КонецФункции

// Создает ОбъектXDTO из пространства имен по имени свойства.
//
Функция ОбъектXDTOПоИмениСвойства(ПространствоИмен, ИмяСвойства, ОбъектXDTOРодитель = Неопределено) Экспорт
	
	Если ОбъектXDTOРодитель = Неопределено Тогда
		ТипОбъекта = ФабрикаXDTO.Пакеты.Получить(ПространствоИмен).КорневыеСвойства.Получить(ИмяСвойства).Тип;
	Иначе
		ТипОбъекта = ОбъектXDTOРодитель.Тип().Свойства.Получить(ИмяСвойства).Тип;
	КонецЕсли;
	
	Возврат ФабрикаXDTO.Создать(ТипОбъекта);
	
КонецФункции

// Преобразует объект XDTO в структуру
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - Объект XDTO.
// 
// Возвращаемое значение:
//  Структура - Структура объекта.
//
Функция ОбъектXDTOВСтруктуру(ОбъектXDTO, ПараметрыПреобразования = Неопределено) Экспорт
	
	Структура      = Новый Структура;
	ТипОбъектаXDTO = ОбъектXDTO.Тип();
	
	Для Каждого Свойство Из ОбъектXDTO.Свойства() Цикл
		
		ИмяСвойства      = Свойство.Имя;
		ЗначениеСвойства = ОбъектXDTO[ИмяСвойства];
		
		Если ТипЗнч(ЗначениеСвойства) = Тип("ОбъектXDTO") Тогда
			
			Структура.Вставить(ИмяСвойства, ИнтеграцияИС.ОбъектXDTOВСтруктуру(ЗначениеСвойства, ПараметрыПреобразования));
			
		ИначеЕсли ТипЗнч(ЗначениеСвойства) = Тип("СписокXDTO") Тогда
			
			Структура.Вставить(ИмяСвойства, Новый Массив);
			Для Индекс = 0 По ЗначениеСвойства.Количество() - 1 Цикл
				
				ЭлементСписка = ЗначениеСвойства.Получить(Индекс);
				Если ТипЗнч(ЭлементСписка) = Тип("ОбъектXDTO") Тогда
					Структура[ИмяСвойства].Добавить(ИнтеграцияИС.ОбъектXDTOВСтруктуру(ЭлементСписка, ПараметрыПреобразования));
				Иначе
					Структура[ИмяСвойства].Добавить(ЭлементСписка);
				КонецЕсли;
				
			КонецЦикла;
			
		Иначе
			
			Структура.Вставить(ИмяСвойства, ЗначениеСвойства);
			
			Если ПараметрыПреобразования <> Неопределено
				И ПараметрыПреобразования.НайтиИдентификаторы
				И Свойство.Тип = ПараметрыПреобразования.ТипUUID Тогда
				
				РезультатПоиска = ПараметрыПреобразования.ТипыИдентификаторов[ТипОбъектаXDTO];
				Если РезультатПоиска <> Неопределено
					И РезультатПоиска.ИмяПоля = ИмяСвойства Тогда
					ПараметрыПреобразования.Идентификаторы[РезультатПоиска.ИмяТаблицы].Вставить(ЗначениеСвойства, РезультатПоиска.ПустоеЗначение);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Структура;
	
КонецФункции

// Устанавливает значение свойства объекта XDTO, 
//с проверкой на наличие свойства и необходимость заполнения.
//
// Параметры:
//  ОбъектXDTO       - ОбъектXDTO   - объект в котором заполняется свойство
//  ИмяСвойства      - Строка       - имя свойства
//  ЗначениеСвойства - Произвольный - значение свойства
//  КешОшибок        - Структура    - см. ИнтеграцияИСКлиентСервер.ДобавитьТекстОшибки()
//  Расшифровки      - Структура    - см. ДанныеДляРасшифровкиОшибок()
//  ТребуетсяЗаполнить - Булево     - Признак необходимости заполнения свойства.
//
Процедура ЗаполнитьСвойствоXDTO(ОбъектXDTO, ИмяСвойства, ЗначениеСвойства, КешОшибок, Расшифровки, ТребуетсяЗаполнить = Неопределено) Экспорт
	
	Если Не ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(ОбъектXDTO, ИмяСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТребуетсяЗаполнить = Неопределено Тогда
		РазрешеноНеЗаполнять = ОбъектXDTO.Тип().Свойства.Получить(ИмяСвойства).НижняяГраница = 0;
	Иначе
		РазрешеноНеЗаполнять = Не ТребуетсяЗаполнить;
	КонецЕсли;
	
	Если ТипЗнч(ЗначениеСвойства) <> Тип("ОбъектXDTO") И ТипЗнч(ЗначениеСвойства) <> Тип("СписокXDTO") Тогда
		Если Не ЗначениеЗаполнено(ЗначениеСвойства)
			И РазрешеноНеЗаполнять Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	УстановитьСвойствоXDTO(ОбъектXDTO, ИмяСвойства, ЗначениеСвойства, КешОшибок, Расшифровки);
	
КонецПроцедуры

// Устанавливает значение свойства объекта XDTO (для списка - добавляет элемент в список), без проверок
//
// Параметры:
//  ОбъектXDTO       - ОбъектXDTO   - объект в котором заполняется свойство
//  ИмяСвойства      - Строка       - имя свойства
//  ЗначениеСвойства - Произвольный - значение свойства
//  КешОшибок        - Структура    - см ИнтеграцияИСКлиентСервер.ДобавитьТекстОшибки()
//  Расшифровки      - Структура    - см ДанныеДляРасшифровкиОшибок()
//
Процедура УстановитьСвойствоXDTO(ОбъектXDTO, ИмяСвойства, ЗначениеСвойства, КешОшибок, Расшифровки) Экспорт
	
	Попытка
		Если ТипЗнч(ОбъектXDTO[ИмяСвойства]) = Тип("СписокXDTO") Тогда
			ОбъектXDTO[ИмяСвойства].Добавить(ЗначениеСвойства);
		Иначе
			ОбъектXDTO[ИмяСвойства] = ЗначениеСвойства;
		КонецЕсли;
	Исключение
		ЧтениеXML = Новый Структура;
		ЧтениеXML.Вставить("Имя"                , ИмяСвойства);
		ЧтениеXML.Вставить("ЛокальноеИмя"       , ИмяСвойства);
		ЧтениеXML.Вставить("Значение"           , ЗначениеСвойства);
		ЧтениеXML.Вставить("ТипУзла"            , ТипУзлаXML.КонецЭлемента);
		ЧтениеXML.Вставить("URIПространстваИмен", ОбъектXDTO.Тип().URIПространстваИмен);
		
		ТекстОшибки = КраткоеПредставлениеОшибки(ИнформацияОбОшибке());
		ТекстОшибки = ПредставлениеОшибкиXDTO(ТекстОшибки, ЧтениеXML, Расшифровки);
		
		Если КешОшибок <> Неопределено Тогда
			ИнтеграцияИСКлиентСервер.ДобавитьТекстОшибки(КешОшибок, ТекстОшибки);
		КонецЕсли;
		
	КонецПопытки;
	
КонецПроцедуры

// Возвращает пользовательское представление ошибки
//
// Параметры:
//  ПредставлениеОшибки	 - Строка               - представление ошибки до обработки
//  ЧтениеXML            - ЧтениеXML, Структура - ошибочный узел данных
//  Расшифровки          - Структура            - см. ДанныеДляРасшифровкиОшибок()
// 
// Возвращаемое значение:
//  Строка - представление ошибки после обработки
//
Функция ПредставлениеОшибкиXDTO(ПредставлениеОшибки, ЧтениеXML, Расшифровки) Экспорт
	
	Если СтрНайти(ПредставлениеОшибки, НСтр("ru = 'Ошибка проверки данных XDTO'")) = 0
		И СтрНайти(ПредставлениеОшибки, НСтр("ru = 'Несоответствие типов XDTO'")) = 0 Тогда
		Возврат ПредставлениеОшибки;
	КонецЕсли;
	
	ЗначениеПоля = ЧтениеXML.Значение;
	Если ЧтениеXML.ТипУзла = ТипУзлаXML.Текст Тогда
		ЧтениеXML.Прочитать();
	КонецЕсли;
	
	Если Расшифровки.Таблица = Неопределено Тогда
		Расшифровки.Таблица = ПредставленияПолей(Расшифровки.ИмяМакета);
	КонецЕсли;
	
	Отбор = Новый Структура;
	Отбор.Вставить("ПространствоИмен", ЧтениеXML.URIПространстваИмен);
	Отбор.Вставить("ЛокальноеИмя",     ЧтениеXML.ЛокальноеИмя);
	
	МассивСтрок = Расшифровки.Таблица.НайтиСтроки(Отбор);
	
	СтрокаТаблицы = Неопределено;
	Если МассивСтрок.Количество() = 1 Тогда
		СтрокаТаблицы = МассивСтрок[0];
	ИначеЕсли МассивСтрок.Количество() > 1 И НЕ Расшифровки.Глубина = Неопределено Тогда
		Отбор.Вставить("Глубина", Расшифровки.Глубина);
		МассивСтрокПоГлубине = Расшифровки.Таблица.НайтиСтроки(Отбор);
		Если МассивСтрокПоГлубине.Количество() > 0 Тогда
			СтрокаТаблицы = МассивСтрокПоГлубине[0];
		Иначе
			СтрокаТаблицы = МассивСтрок[0];
		КонецЕсли;
	КонецЕсли;
	
	Если СтрокаТаблицы <> Неопределено Тогда
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			Если НЕ ЗначениеЗаполнено(ЗначениеПоля) Тогда
				ПредставлениеОшибки = НСтр("ru = 'Не заполнено значение поля ""%1"" (%2)'");
				ПредставлениеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ПредставлениеОшибки, СтрокаТаблицы.Представление, ЧтениеXML.Имя);
			Иначе
				ПредставлениеОшибки = НСтр("ru = 'Некорректное значение ""%1"" поля ""%2"" (%3)'");
				ПредставлениеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ПредставлениеОшибки, ЗначениеПоля, СтрокаТаблицы.Представление, ЧтениеXML.Имя);
			КонецЕсли;
		Иначе
			ИндексСтроки = Расшифровки.Таблица.Индекс(СтрокаТаблицы);
			
			Пока ИндексСтроки > 0 Цикл
				ПредыдущееПоле = Расшифровки.Таблица[ИндексСтроки - 1];
				Если ПредыдущееПоле.ПространствоИмен <> СтрокаТаблицы.ПространствоИмен Тогда
					Прервать;
				КонецЕсли;
				Если ПредыдущееПоле.Обязательное Тогда
					ПредставлениеОшибки = НСтр("ru = 'Отсутствует обязательное поле ""%1"" (%2)'");
					ПредставлениеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ПредставлениеОшибки, ПредыдущееПоле.Представление, ПредыдущееПоле.ЛокальноеИмя);
					Прервать;
				КонецЕсли;
				ИндексСтроки = ИндексСтроки - 1;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПредставлениеОшибки;
	
КонецФункции

// Возвращает Объект XDTO, получаемый из текста сообщения XML
//
// Параметры:
//  ТекстСообщенияXML - Строка - Текст сообщения XML
// 
// Возвращаемое значение:
//  ОбъектXDTO - Объект XDTO
//
Функция ПроизвольныйОбъектXDTOПоТекстуСообщенияXML(ТекстСообщенияXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ТекстСообщенияXML);
	
	ОбъектXDTO = ФабрикаXDTO.ПрочитатьXML(ЧтениеXML);
	
	Возврат ОбъектXDTO;
	
КонецФункции

#КонецОбласти

#Область РаботаСЗапросами

// Формирует пакет запросов и возвращает результат каждого запроса
//
// Параметры:
//  Запрос				 - Запрос	 - запрос, параметры которого предварительно установлены.
//  ТекстыЗапроса		 - СписокЗначений	 - в списке перечислены тексты запросов и их имена.
//  ВыгрузитьРезультат	 - Булево			 - Истина, если результат запроса нужно выгрузить в таблицы значений.
// 
// Возвращаемое значение:
//  Структура - структура в которую помещены полученные таблицы
//
Функция ВыполнитьПакетЗапросов(Запрос, ТекстыЗапроса, ВыгрузитьРезультат = Ложь) Экспорт

	Таблицы = Новый Структура;
	
	МассивТекстаЗапроса = Новый Массив;
	
	// Формирование текст запроса.
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			МассивТекстаЗапроса.Добавить("// " + ТекстЗапроса.Представление);
		КонецЕсли;
		МассивТекстаЗапроса.Добавить(ТекстЗапроса.Значение);
		
		МассивТекстаЗапроса.Добавить(
		";
		|
		|////////////////////////////////////////////////////////////////////////////////
		|");
	КонецЦикла;
	
	Запрос.Текст = СтрСоединить(МассивТекстаЗапроса, Символы.ПС);
	
	// Выполнение запроса.
	Результат = Запрос.ВыполнитьПакет();

	КоличествоЗапросовВПакете = 0;
	
	// Помещение результатов запроса в таблицы
	Для Каждого ТекстЗапроса из ТекстыЗапроса Цикл
		
		Если СтрЧислоВхождений(ТекстЗапроса.Значение, ";") > 0 Тогда
			Подзапросы = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ТекстЗапроса.Значение, ";");
			КоличествоПодзапросов = Подзапросы.Количество();
			ИндексЗапросаРезультате = Неопределено;
			Для Индекс = -(КоличествоПодзапросов - 1) По 0 Цикл
				Если Найти(Подзапросы[-Индекс], "#РезультатЗапроса#") > 0 Тогда
					ИндексЗапросаРезультате = -Индекс;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если ИндексЗапросаРезультате = Неопределено Тогда
				ИндексЗапросаРезультате = КоличествоПодзапросов - 1;
			КонецЕсли;
		Иначе
			КоличествоПодзапросов = 1;
			ИндексЗапросаРезультате = 0;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ТекстЗапроса.Представление) Тогда
			РезультатТаблица = Результат[КоличествоЗапросовВПакете + ИндексЗапросаРезультате];
			РезультатТаблица = ?(ВыгрузитьРезультат, РезультатТаблица.Выгрузить(), РезультатТаблица);
			Таблицы.Вставить(ТекстЗапроса.Представление, РезультатТаблица);
		КонецЕсли;
		
		КоличествоЗапросовВПакете = КоличествоЗапросовВПакете + КоличествоПодзапросов;
		
	КонецЦикла;
	
	Возврат Таблицы;
	
КонецФункции

#КонецОбласти

#Область ФормыДокументовОснований

// Параметры вывода гиперссылок на документы ИС в форме документа-основания.
//
// Параметры:
//  ИменаПодсистем           - Строка - имена подсистем (через запятую), на объекты которых нужны гиперссылки
//  ИмяЭлементаДляРазмещения - Строка - имя реквизита формы, для размещения гиперссылок
// 
// Возвращаемое значение:
//  Структура - согласно параметрам
//
Функция ПараметрыИнтеграцииВФорме(ИменаПодсистем = "", ИмяЭлементаДляРазмещения = "") Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ИменаПодсистем",           ИменаПодсистем);
	Результат.Вставить("ИмяЭлементаДляРазмещения", ИмяЭлементаДляРазмещения);
	Возврат Результат;
	
КонецФункции

Функция ИмяЭлементаДляРазмещения() Экспорт
	
	Возврат "ГруппаИнтеграция";
	
КонецФункции

// Процедура - При создании на сервере в форме документа основания
//
// Параметры:
//  Форма               - ФормаКлиентскогоПриложения     - форма прикладного объекта для встраивания библиотечной гиперссылки
//  Объект              - ДанныеФормыСтруктура - данные прикладного объекта
//  ПараметрыИнтеграции - Структура            - (См. ПараметрыИнтеграцииВФорме)
//
Процедура ПриСозданииНаСервереВФормеДокументаОснования(Форма, Объект, Знач ПараметрыИнтеграции) Экспорт
	
	ИнтегрируемыеПодсистемы = Новый Структура;
	Реквизиты = Новый Массив;
	
	Для Каждого КлючИЗначение Из Новый Структура(ПараметрыИнтеграции.ИменаПодсистем) Цикл
		
		// Проверим использование подсистемы.
		ИмяПодсистемы = КлючИЗначение.Ключ;
		
		ИспользованиеПодсистемы = Ложь;
		Если ПодсистемаСуществует(ИмяПодсистемы) Тогда
			
			МодульИнтеграции = ОбщийМодуль(ИмяПодсистемы);
			ИспользованиеПодсистемы = МодульИнтеграции.ИспользуетсяИнтеграцияВФормеДокументаОснования(Форма, Объект);
			
		КонецЕсли;
		
		Если НЕ ИспользованиеПодсистемы Тогда
			Продолжить;
		КонецЕсли;
		
		ИнтегрируемыеПодсистемы.Вставить(ИмяПодсистемы);
		
		// Добавим реквизит формы для подсистемы.
		Реквизиты.Добавить(Новый РеквизитФормы(
			ИнтеграцияИСКлиентСервер.ИмяПоляИнтеграцииВФормеДокументаОснования(ИмяПодсистемы),
			Новый ОписаниеТипов("ФорматированнаяСтрока")));
		
	КонецЦикла;
	
	Если ИнтегрируемыеПодсистемы.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Добавим служебный реквизит описания всех используемых подсистем.
	Реквизиты.Добавить(Новый РеквизитФормы(
		ИнтеграцияИСКлиентСервер.ИмяПоляОписанияИнтеграцийВФормеДокументаОснования(),
		Новый ОписаниеТипов()));
	
	// Создадим реквизиты формы.
	Форма.ИзменитьРеквизиты(Реквизиты);
	
	Форма[ИнтеграцияИСКлиентСервер.ИмяПоляОписанияИнтеграцийВФормеДокументаОснования()] =
		Новый ФиксированнаяСтруктура(ИнтегрируемыеПодсистемы);
		
	ЭлементРодитель = Форма.Элементы.Найти(ПараметрыИнтеграции.ИмяЭлементаДляРазмещения);
	Если ЭлементРодитель <> Неопределено Тогда
		Для Каждого КлючИЗначение Из ИнтегрируемыеПодсистемы Цикл
			
			ИмяПодсистемы = КлючИЗначение.Ключ;
			
			// Создадим элемент формы для подсистемы.
			ПолеНадписи = Форма.Элементы.Добавить(
				ИнтеграцияИСКлиентСервер.ИмяПоляИнтеграцииВФормеДокументаОснования(ИмяПодсистемы),
				Тип("ПолеФормы"),
				ЭлементРодитель);
			
			ПолеНадписи.Вид                     = ВидПоляФормы.ПолеНадписи;
			ПолеНадписи.ПутьКДанным             = ИнтеграцияИСКлиентСервер.ИмяПоляИнтеграцииВФормеДокументаОснования(ИмяПодсистемы);
			ПолеНадписи.ПоложениеЗаголовка      = ПоложениеЗаголовкаЭлементаФормы.Нет;
			ПолеНадписи.АвтоМаксимальнаяШирина  = Ложь;
			ПолеНадписи.АвтоМаксимальнаяВысота  = Ложь;
			ПолеНадписи.МаксимальнаяВысота      = 2;
			
			ПолеНадписи.УстановитьДействие(
				"ОбработкаНавигационнойСсылки",
				"Подключаемый_ПолеИнтеграцииИСОбработкаНавигационнойСсылки");
			
		КонецЦикла;
	КонецЕсли;
	
	ОбновитьПолеИнтеграцииВФормеДокументаОснования(Форма, Объект);
	
КонецПроцедуры

Процедура ОбновитьПолеИнтеграцииВФормеДокументаОснования(Форма, Объект, ДополнительныеПараметры = Неопределено)
	
	ИнтегрируемыеПодсистемы = ИнтеграцияИСКлиентСервер.ИнтегрируемыеПодсистемыВФормеДокументаОснования(Форма);
	
	Если НЕ ЗначениеЗаполнено(ИнтегрируемыеПодсистемы) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(ДополнительныеПараметры) = Тип("Структура") И ДополнительныеПараметры.Свойство("ИмяПодсистемы") Тогда
		ИмяПодсистемыИзПараметров = ДополнительныеПараметры.ИмяПодсистемы;
	Иначе
		ИмяПодсистемыИзПараметров = Неопределено;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из ИнтегрируемыеПодсистемы Цикл
		
		ИмяПодсистемы = КлючИЗначение.Ключ;
		
		Если ЗначениеЗаполнено(ИмяПодсистемыИзПараметров) И ИмяПодсистемыИзПараметров <> ИмяПодсистемы Тогда
			Продолжить;
		КонецЕсли;
		
		ИмяПоляФормы = ИнтеграцияИСКлиентСервер.ИмяПоляИнтеграцииВФормеДокументаОснования(ИмяПодсистемы);
		
		Если Форма.Элементы.Найти(ИмяПоляФормы) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		// Получим текст надписи на форме.
		ТекстНадписи = "<Удалить>";
		
		Форма[ИмяПоляФормы] = ТекстНадписи;
		Форма.Элементы[ИмяПоляФормы].Видимость = ЗначениеЗаполнено(ТекстНадписи);
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область ФормыДокументовИС

Процедура ПослеЗаписиНаСервереВФормеОбъектаДокументаИС(Форма, Объект, ИмяПодсистемы, ПараметрыЗаписи) Экспорт
	
	Если Объект.ДополнительныеСвойства.Свойство("ПредыдущийДокументОснование") Тогда
		
		// Заполняется в подписках РассчитатьСтатусОформления[]ПередЗаписьюДокумента
		ПараметрыЗаписи.Вставить(
			"ПредыдущийДокументОснование",
			Объект.ДополнительныеСвойства.ПредыдущийДокументОснование);
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ДокументыИС

// Функция возвращает оформленные документы по документу-основанию
//   * в документе должен быть реквизит "ДокументОснование".
//   * допустимый тип документа определяется из регистра статусов.
// Параметры:
//  ДокументОснование					 - ДокументСсылка   - значение реквизита "ДокументОснование".
//  МетаданныеРегистраСтатусовДокументов - ОбъектМетаданных - используемый регистр статусов документов
//   * Должен содержать измерение "Документ".
//   * Должен содержать поле "Статус"
// Возвращаемое значение:
//  Структура - описание документов по основанию с полями
//   * [ИмяДокумента] - имя метаданных оформленного документа - массив структур с полями:
//     ** Ссылка - [ИмяДокумента]Ссылка - ссылка на оформленный документ
//     ** Дата   - Дата                 - дата документа
//     ** Статус - Произвольный         - статус документа по регистру
//
Функция ДокументыИСПоДокументуОснованию(ДокументОснование, МетаданныеРегистраСтатусовДокументов) Экспорт
	
	ДокументыИС = Новый Структура;
	
	ИмяРегистра = МетаданныеРегистраСтатусовДокументов.Имя;
	МассивТекстов = Новый Массив;
	
	ШаблонВыборки =
	"ВЫБРАТЬ
	|	""%1""									КАК ИмяДокумента,
	|	Таблица.Ссылка							КАК Ссылка,
	|	Таблица.Дата							КАК Дата,
	|	ЕСТЬNULL(Статусы.Статус, НЕОПРЕДЕЛЕНО) 	КАК Статус
	|ИЗ
	|	Документ.%1 КАК Таблица
	|	ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.%2 КАК Статусы
	|		ПО Статусы.Документ = Таблица.Ссылка
	|ГДЕ
	|	Таблица.ДокументОснование = &ДокументОснование
	|	И НЕ Таблица.ПометкаУдаления";
	
	ШаблонОбъединения = "
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|";
	
	Для Каждого ТипДокумента Из МетаданныеРегистраСтатусовДокументов.Измерения.Документ.Тип.Типы() Цикл
		
		МетаданныеДокумента = Метаданные.НайтиПоТипу(ТипДокумента);
		
		Если РеквизитДокументОснованиеДокументаИС(МетаданныеДокумента) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ДокументыИС.Вставить(МетаданныеДокумента.Имя, Новый Массив);
		МассивТекстов.Добавить(СтрШаблон(ШаблонВыборки,МетаданныеДокумента.Имя,ИмяРегистра));
		
	КонецЦикла;
	
	Если НЕ ЗначениеЗаполнено(ДокументОснование) Тогда
		Возврат ДокументыИС;
	ИначеЕсли ДокументыИС.Количество() = 0 Тогда 
		Возврат ДокументыИС;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.Текст = СтрСоединить(МассивТекстов,ШаблонОбъединения);
	Запрос.УстановитьПараметр("ДокументОснование", ДокументОснование);
	
	УстановитьПривилегированныйРежим(Истина);
	Выборка = Запрос.Выполнить().Выбрать();
	УстановитьПривилегированныйРежим(Ложь);
	
	Пока Выборка.Следующий() Цикл
		
		ОписаниеДокумента = Новый Структура("Ссылка, Дата, Статус");
		ЗаполнитьЗначенияСвойств(ОписаниеДокумента, Выборка);
		
		ДокументыИС[Выборка.ИмяДокумента].Добавить(ОписаниеДокумента);
		
	КонецЦикла;
	
	Возврат ДокументыИС;
	
КонецФункции

#КонецОбласти

#Область МетаданныеИС

// Возвращает описание типов из указанного ссылочного типа по полному имени метаданных
//
// Параметры:
//   ПолноеИмя - Строка - полное имя объекта для получения ссылочного типа
//
// Возвращаемое значение:
//   ОписаниеТипов
Функция ОписаниеТиповПоПолномуИмени(ПолноеИмя) Экспорт
	
	МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмя);
	МассивТипов = Новый Массив;
	МассивТипов.Добавить(ТипЗнч(МенеджерОбъекта.ПустаяСсылка()));
	Возврат Новый ОписаниеТипов(МассивТипов);
	
КонецФункции

// Возвращает менеджер (модуль менеджера или общий модуль) по полному имени метаданных
// 
// Параметры:
//   ПолноеИмя - Строка - полное имя объекта для получения модуля менеджера
//
// Возвращаемое значение:
//   СправочникМенеджер, ДокументМенеджер, ОбщийМодуль итп
Функция МенеджерОбъектаПоПолномуИмени(ПолноеИмя) Экспорт
	
	МенеджерОбъекта = Неопределено;
	ИнтеграцияИСПереопределяемый.ПриОпределенииМенеджераОбъектаПоПолномуИмени(МенеджерОбъекта, ПолноеИмя);
	
	Если МенеджерОбъекта = Неопределено Тогда
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмя);
	КонецЕсли;
	
	Возврат МенеджерОбъекта;
	
КонецФункции

// Возвращает менеджер (модуль менеджера или общий модуль) объекта по ссылке на объект.
// Ограничение: не обрабатываются точки маршрутов бизнес-процессов.
// См. также ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - объект, менеджер которого требуется получить.
//
// Возвращаемое значение:
//  СправочникМенеджер, ДокументМенеджер, ОбработкаМенеджер, РегистрСведенийМенеджер - менеджер объекта.
//
// Пример:
//  МенеджерСправочника = ОбщегоНазначения.МенеджерОбъектаПоСсылке(СсылкаНаОрганизацию);
//
Функция МенеджерОбъектаПоСсылке(Ссылка) Экспорт
	
	МенеджерОбъекта = Неопределено;
	ИнтеграцияИСПереопределяемый.ПриОпределенииМенеджераОбъектаПоСсылке(МенеджерОбъекта, Ссылка);
	
	Если МенеджерОбъекта = Неопределено Тогда
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Ссылка);
	КонецЕсли;
	
	Возврат МенеджерОбъекта;
	
КонецФункции

Функция РеквизитДокументОснованиеДокументаИС(МетаданныеДокумента) Экспорт
	
	Возврат МетаданныеДокумента.Реквизиты.Найти("ДокументОснование");
	
КонецФункции

// Возвращает значение по умолчанию переданного определяемого типа.
//
Функция ПустоеЗначениеОпределяемогоТипа(ОпределяемыйТипИлиИмяТипа) Экспорт
	
	Если ТипЗнч(ОпределяемыйТипИлиИмяТипа) = Тип("Строка") Тогда
		ОпределяемыйТип = Метаданные.ОпределяемыеТипы[ОпределяемыйТипИлиИмяТипа];
	Иначе
		ОпределяемыйТип = ОпределяемыйТипИлиИмяТипа;
	КонецЕсли;
	
	Возврат ОпределяемыйТип.Тип.ПривестиЗначение();
	
КонецФункции

// Формирует массив пустых значений определяемого типа.
// 
// Возвращаемое значение:
//  Массив - Пустые значения определяемого типа.
//
Функция НезаполненныеЗначенияОпределяемогоТипа(ОпределяемыйТипИлиИмяТипа) Экспорт
	
	Если ТипЗнч(ОпределяемыйТипИлиИмяТипа) = Тип("Строка") Тогда
		ОпределяемыйТип = Метаданные.ОпределяемыеТипы[ОпределяемыйТипИлиИмяТипа];
	Иначе
		ОпределяемыйТип = ОпределяемыйТипИлиИмяТипа;
	КонецЕсли;
	
	МассивПустыхЗначений = Новый Массив;
	Для Каждого ТипЗначения Из ОпределяемыйТип.Тип.Типы() Цикл
		МассивТипов = Новый Массив;
		МассивТипов.Добавить(ТипЗначения);
		ОписаниеТипа = Новый ОписаниеТипов(МассивТипов);
		МассивПустыхЗначений.Добавить(ОписаниеТипа.ПривестиЗначение());
	КонецЦикла;
	
	Если МассивПустыхЗначений.Количество() > 1 Тогда
		МассивПустыхЗначений.Добавить(Неопределено);
	КонецЕсли;
	
	Возврат МассивПустыхЗначений;
	
КонецФункции

// Проверяет наличие права изменения документов определяемого типа у текущего пользователя.
//
// Возвращаемое значение:
//  Булево - Истина, если есть право изменения хотя бы одного документа, Ложь в обратном случае.
//
Функция ПравоИзмененияДокументовИзОпределяемогоТипа(ОпределяемыйТип) Экспорт

	Для Каждого ВозможныйТип Из ОпределяемыйТип.Тип.Типы() Цикл
		МетаданныеТипа = Метаданные.НайтиПоТипу(ВозможныйТип);
		Если МетаданныеТипа <> Неопределено Тогда
			Если ПравоДоступа("Изменение", МетаданныеТипа) Тогда
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;

КонецФункции

Функция ПодсистемаСуществует(КраткоеИмяПодсистемы)
	
	ПолноеИмяПодсистемы = ИнтеграцияИСКлиентСервер.ПолноеИмяПодсистемы(КраткоеИмяПодсистемы);
	Возврат ОбщегоНазначения.ПодсистемаСуществует(ПолноеИмяПодсистемы);
	
КонецФункции

Функция ОбщийМодуль(КраткоеИмяПодсистемы)
	
	ИмяМодуля = ИнтеграцияИСКлиентСервер.МодульСервер(КраткоеИмяПодсистемы);
	Возврат ОбщегоНазначения.ОбщийМодуль(ИмяМодуля);
	
КонецФункции

// Позволяет определить есть ли среди реквизитов табличной части объекта реквизит с переданным именем.
//
// Параметры:
//  ИмяРеквизита - Строка - Строковое имя искомого реквизита.
//  МетаданныеОбъекта - ОбъектМетаданных - описание метаданных объекта, среди реквизитов которого производится поиск.
//  ИмяТабЧасти  - Строка - Строковое имя табличной части объекта, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Булево - Истина, нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитТабЧастиОбъекта(ИмяРеквизита, МетаданныеОбъекта, ИмяТабЧасти) Экспорт

	ТабЧасть = МетаданныеОбъекта.ТабличныеЧасти.Найти(ИмяТабЧасти);

	Если ТабЧасть = Неопределено Тогда // нет такой таб. части
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ТабЧасть.Реквизиты.Найти(ИмяРеквизита) <> Неопределено;
	
КонецФункции

#КонецОбласти

#Область ПодготовкаИЗаписьДвиженийДокумента

// Процедура инициализирует общие структуры, используемые при проведении документов.
// Вызывается из модуля документов при проведении.
//
Процедура ИнициализироватьДополнительныеСвойстваДляПроведения(ДокументСсылка, ДополнительныеСвойства, РежимПроведения = Неопределено) Экспорт

	// В структуре "ДополнительныеСвойства" создаются свойства с ключами "ТаблицыДляДвижений", "ДляПроведения".

	// "ТаблицыДляДвижений" - структура, которая будет содержать таблицы значений с данными для выполнения движений.
	ДополнительныеСвойства.Вставить("ТаблицыДляДвижений", Новый Структура);

	// "ДляПроведения" - структура, содержащая свойства и реквизиты документа, необходимые для проведения.
	ДополнительныеСвойства.Вставить("ДляПроведения", Новый Структура);
	
	// Структура, содержащая ключ с именем "МенеджерВременныхТаблиц", в значении которого хранится менеджер временных таблиц.
	// Содержит для каждой временной таблицы ключ (имя временной таблицы) и значение (признак наличия записей во временной таблице).
	ДополнительныеСвойства.ДляПроведения.Вставить("СтруктураВременныеТаблицы", Новый Структура("МенеджерВременныхТаблиц", Новый МенеджерВременныхТаблиц));
	ДополнительныеСвойства.ДляПроведения.Вставить("РежимПроведения",           РежимПроведения);
	ДополнительныеСвойства.ДляПроведения.Вставить("МетаданныеДокумента",       ДокументСсылка.Метаданные());
	ДополнительныеСвойства.ДляПроведения.Вставить("Ссылка",                    ДокументСсылка);
	
КонецПроцедуры

// Процедура выполняет подготовку наборов записей документа к записи движений.
// 1. Очищает наборы записей от "старых записей" (ситуация возможна только в толстом клиенте)
// 2. Взводит флаг записи у наборов, по которым документ имеет движения
// Вызывается из модуля документов при проведении.
//
Процедура ПодготовитьНаборыЗаписейКРегистрацииДвижений(Объект, ЭтоНовый = Ложь) Экспорт
	Перем ЭтоНовыйДокумент, МетаданныеДвижения;
	
	Для Каждого НаборЗаписей Из Объект.Движения Цикл

		Если НаборЗаписей.Количество() > 0 Тогда
			НаборЗаписей.Очистить();
		КонецЕсли;

	КонецЦикла;
	
	Если НЕ Объект.ДополнительныеСвойства.Свойство("ЭтоНовый", ЭтоНовыйДокумент) Тогда
		ЭтоНовыйДокумент = ЭтоНовый;
	КонецЕсли;
	
	Если НЕ ЭтоНовыйДокумент Тогда

		Если Объект.ДополнительныеСвойства.Свойство("ДляПроведения")
		 И Объект.ДополнительныеСвойства.ДляПроведения.Свойство("МетаданныеДокумента") Тогда
			МетаданныеДвижения = Объект.ДополнительныеСвойства.ДляПроведения.МетаданныеДокумента.Движения;
		Иначе
			МетаданныеДвижения = Объект.Метаданные().Движения;
		КонецЕсли;
		
		МассивИменРегистров = ПолучитьИспользуемыеРегистры(Объект.Ссылка, МетаданныеДвижения);

		Для Каждого ИмяРегистра Из МассивИменРегистров Цикл
			Объект.Движения[ИмяРегистра].Записывать = Истина;
		КонецЦикла;

	КонецЕсли;

КонецПроцедуры

// Функция формирует массив имен регистров, по которым документ имеет движения.
// Вызывается при подготовке записей к регистрации движений.
//
Функция ПолучитьИспользуемыеРегистры(Регистратор, Движения, МассивИсключаемыхРегистров = Неопределено) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Регистратор", Регистратор);

	Результат = Новый Массив;
	МаксимумТаблицВЗапросе = 256;

	СчетчикТаблиц   = 0;
	СчетчикДвижений = 0;

	ВсегоДвижений = Движения.Количество();
	МассивТекстаЗапроса = Новый Массив;
	
	Разделитель = 
	"
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|";
	
	Для Каждого Движение Из Движения Цикл

		СчетчикДвижений = СчетчикДвижений + 1;

		ПропуститьРегистр = МассивИсключаемыхРегистров <> Неопределено
							И МассивИсключаемыхРегистров.Найти(Движение.Имя) <> Неопределено;

		Если Не ПропуститьРегистр Тогда

			СчетчикТаблиц = СчетчикТаблиц + 1;

			МассивТекстаЗапроса.Добавить(
			"
			|ВЫБРАТЬ ПЕРВЫЕ 1
			|""" + Движение.Имя + """ КАК ИмяРегистра
			|
			|ИЗ " + Движение.ПолноеИмя() + "
			|
			|ГДЕ Регистратор = &Регистратор
			|");

		КонецЕсли;

		Если СчетчикТаблиц = МаксимумТаблицВЗапросе Или СчетчикДвижений = ВсегоДвижений Тогда

			Запрос.Текст = СтрСоединить(МассивТекстаЗапроса, Разделитель);
			МассивТекстаЗапроса.Очистить();
			
			СчетчикТаблиц = 0;

			Если Результат.Количество() = 0 Тогда

				Результат = Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("ИмяРегистра");

			Иначе

				Выборка = Запрос.Выполнить().Выбрать();
				Пока Выборка.Следующий() Цикл
					Результат.Добавить(Выборка.ИмяРегистра);
				КонецЦикла;

			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

	Возврат Результат;

КонецФункции

// Процедура записывает движения документа. Дополнительно происходит копирование параметров
// в модули наборов записей для выполнения регистрации изменений в движениях.
// Процедура вызывается из модуля документов при проведении.
//
Процедура ЗаписатьНаборыЗаписей(Объект) Экспорт
	Перем РегистрыДляКонтроля, РассчитыватьИзменения;
	
	Для Каждого Движение Из Объект.Движения Цикл
		
		Движение.ДополнительныеСвойства.Вставить("ЭтоНовый", Объект.ДополнительныеСвойства.ЭтоНовый);
		Движение.ДополнительныеСвойства.Вставить("РежимЗаписи", Объект.ДополнительныеСвойства.РежимЗаписи);
		Движение.ДополнительныеСвойства.Вставить("ДатаРегистратора", Объект.Дата);
		
		Движение.ДополнительныеСвойства.Вставить("ДляПроведения", 
			Новый Структура("СтруктураВременныеТаблицы",
				// Структура для передачи данных в модули наборов записей.
				Объект.ДополнительныеСвойства.ДляПроведения.СтруктураВременныеТаблицы));
		
	КонецЦикла;
	
	// Регистры, для которых будут рассчитаны таблицы изменений движений.
	Если Объект.ДополнительныеСвойства.ДляПроведения.Свойство("РегистрыДляКонтроля", РегистрыДляКонтроля) Тогда
		
		// Установка флага регистрации изменений в наборе записей.
		Если НЕ Объект.ДополнительныеСвойства.Свойство("РассчитыватьИзменения", РассчитыватьИзменения) Тогда
			РассчитыватьИзменения = Истина;
		КонецЕсли;
		
		Для Каждого НаборЗаписей Из РегистрыДляКонтроля Цикл
			Если НаборЗаписей.Записывать Тогда
				
				НаборЗаписей.ДополнительныеСвойства.Вставить("РассчитыватьИзменения", РассчитыватьИзменения);
				
			КонецЕсли;
		КонецЦикла;

	КонецЕсли;
	
	Объект.Движения.Записать();
	
КонецПроцедуры

// Выполняет закрытие менеджера временных таблиц в структуре дополнительных свойств документа, используемых 
// при проведении.
//
// Параметры:
//	ДополнительныеСвойства - Структура - структура с дополнительными свойствами документа, используемыми
//		при проведении.
//
Процедура ОчиститьДополнительныеСвойстваДляПроведения(ДополнительныеСвойства) Экспорт

	ДополнительныеСвойства.ДляПроведения.СтруктураВременныеТаблицы.МенеджерВременныхТаблиц.Закрыть();

КонецПроцедуры

#КонецОбласти

#Область ПрисоединенныеФайлы

// Получает текст сообщения XML из присоединенного файла, в котором хранится сообщение протокола обмена.
//
// Параметры:
//  Сообщение - ОпределяемыйТип.ПрисоединенныйФайл, Строка - хранимый файл сообщения, из которого извлекается текст сообщения XML.
// 
// Возвращаемое значение:
//  Строка - полученный текст сообщения XML.
//
Функция ТекстСообщенияXMLИзПротокола(Сообщение) Экспорт
	
	Если ТипЗнч(Сообщение) = Тип("Строка") Тогда
		Возврат Сообщение;
	КонецЕсли;
	
	ДвоичныеДанные = РаботаСФайлами.ДвоичныеДанныеФайла(Сообщение);
	Если ДвоичныеДанные = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
	ДвоичныеДанные.Записать(ИмяВременногоФайла);
	
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.Прочитать(ИмяВременногоФайла, КодировкаТекста.UTF8, "");
	ТекстСообщенияXML = ТекстовыйДокумент.ПолучитьТекст();
	
	Попытка
		УдалитьФайлы(ИмяВременногоФайла);
	Исключение
		ИнтеграцияИСВызовСервера.ЗаписатьОшибкуВЖурналРегистрации(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Возврат ТекстСообщенияXML;
	
КонецФункции

// Добавить запись в протокол обмена.
//
// Параметры:
//   Протокол              - ОбъектМетаданныхСправочник - протокол обмена
//   ТекстСообщенияXML     - Строка                     - Текст сообщения XML.
//   Реквизиты - Структура                              - Значения реквизитов сообщения, с обязательными полями:
//    * Документ       - документ по которому ведется протокол обмена,
//    * ВладелецФайлов - элемент по которому ведется обмен с ГосИС.
//   ПроверятьХешБезСсылки - Булево                     - Признак проверки хеша без ссылки.
// 
// Возвращаемое значение:
//   Структура - Структура со свойствами:
//    * НовоеСообщение - Булево - Это новое сообщение.
//    * Ссылка - СправочникСсылка[Протокол.Имя] - Ссылка на присоединенный файл.
//
Функция ДобавитьЗаписьВПротоколОбмена(Протокол, ТекстСообщенияXML, Реквизиты, ПроверятьХешБезСсылки, ЗаписатьПринудительно = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если Не ЗаписатьПринудительно Тогда
		
		ХешированиеДанныхОбъект = Новый ХешированиеДанных(ХешФункция.SHA256);
		ХешированиеДанныхОбъект.Добавить(ТекстСообщенияXML);
		ХешСуммаBase64 = Base64Строка(ХешированиеДанныхОбъект.ХешСумма);
		
		Если ПроверятьХешБезСсылки Тогда
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	Протокол.Ссылка КАК Ссылка,
			|	Протокол.Документ КАК Документ
			|ИЗ
			|	&Протокол КАК Протокол
			|ГДЕ
			|	Протокол.ХешСумма = &ХешСумма
			|	И Протокол.Документ ССЫЛКА &ИмяТаблицы");
			
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Протокол",   Протокол.ПолноеИмя());
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИмяТаблицы", Реквизиты.Документ.Метаданные().ПолноеИмя());
			Запрос.УстановитьПараметр("ХешСумма", ХешСуммаBase64);
			
		Иначе
			
			СообщениеОснование = Справочники[Протокол.Имя].ПустаяСсылка();
			Если Реквизиты.Свойство("СообщениеОснование") Тогда
				СообщениеОснование = Реквизиты.СообщениеОснование;
			КонецЕсли;
			
			Запрос = Новый Запрос(
			"ВЫБРАТЬ ПЕРВЫЕ 1
			|	Протокол.Ссылка КАК Ссылка,
			|	Протокол.Документ КАК Документ
			|ИЗ
			|	&Протокол КАК Протокол
			|ГДЕ
			|	Протокол.Документ = &Документ
			|	И Протокол.СообщениеОснование = &СообщениеОснование
			|	И Протокол.ХешСумма = &ХешСумма");
			
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "&Протокол",   Протокол.ПолноеИмя());
			Запрос.УстановитьПараметр("Документ",           Реквизиты.Документ);
			Запрос.УстановитьПараметр("ХешСумма",           ХешСуммаBase64);
			Запрос.УстановитьПараметр("СообщениеОснование", СообщениеОснование);
			
		КонецЕсли;
		
		Выборка = Запрос.Выполнить().Выбрать();
		
	КонецЕсли;
	
	ДокументОснование = Неопределено;
	
	Если Выборка <> Неопределено
		И Выборка.Следующий() Тогда
		
		НовоеСообщение = Ложь;
		
		Ссылка   = Выборка.Ссылка;
		Документ = Выборка.Документ;
		
		Если ЗначениеЗаполнено(Выборка.Документ)
			И Выборка.Документ.Метаданные().Реквизиты.Найти("ДокументОснование") <> Неопределено Тогда
			ДокументОснование = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Выборка.Документ, "ДокументОснование");
		КонецЕсли;
		
	Иначе
		
		НовоеСообщение = Истина;
		
		ИмяВременногоФайла = ПолучитьИмяВременногоФайла();
		ТекстовыйДокумент = Новый ТекстовыйДокумент;
		ТекстовыйДокумент.УстановитьТекст(ТекстСообщенияXML);
		ТекстовыйДокумент.Записать(ИмяВременногоФайла, КодировкаТекста.UTF8, "");
		ДвоичныеДанные = Новый ДвоичныеДанные(ИмяВременногоФайла);
		АдресФайлаВоВременномХранилище = ПоместитьВоВременноеХранилище(ДвоичныеДанные);
		
		Попытка
			УдалитьФайлы(ИмяВременногоФайла);
		Исключение
			ИнтеграцияИСВызовСервера.ЗаписатьОшибкуВЖурналРегистрации(ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		КонецПопытки;
		
		ПараметрыФайла = Новый Структура();
		ПараметрыФайла.Вставить("Автор",              Пользователи.АвторизованныйПользователь());
		ПараметрыФайла.Вставить("ВладелецФайлов",     Реквизиты.ВладелецФайлов);
		ПараметрыФайла.Вставить("ИмяБезРасширения",   Строка(Новый УникальныйИдентификатор));
		ПараметрыФайла.Вставить("РасширениеБезТочки", "xml");
		ПараметрыФайла.Вставить("ВремяИзмененияУниверсальное");
		
		ПрисоединенныйФайл = РаботаСФайлами.ДобавитьФайл(
			ПараметрыФайла,
			АдресФайлаВоВременномХранилище,,,
			Справочники[Протокол.Имя].ПолучитьСсылку());
		
		ПрисоединенныйФайлОбъект = ПрисоединенныйФайл.ПолучитьОбъект();
		ПрисоединенныйФайлОбъект.ХешСумма = ХешСуммаBase64;
		
		ЗаполнитьЗначенияСвойств(ПрисоединенныйФайлОбъект, Реквизиты);
		
		ПрисоединенныйФайлОбъект.Записать();
		
		Ссылка   = ПрисоединенныйФайлОбъект.Ссылка;
		Документ = ПрисоединенныйФайлОбъект.Документ;
		
	КонецЕсли;
	
	ВозвращаемоеЗначение = Новый Структура;
	ВозвращаемоеЗначение.Вставить("НовоеСообщение",    НовоеСообщение);
	ВозвращаемоеЗначение.Вставить("Ссылка",            Ссылка);
	ВозвращаемоеЗначение.Вставить("Документ",          Документ);
	ВозвращаемоеЗначение.Вставить("ДокументОснование", ДокументОснование);
	
	Возврат ВозвращаемоеЗначение;
	
КонецФункции

// Вызывает исключение при открытии формы протокола обмена с незаполненным параметром "Документ"
//  (форма предназначается для просмотра протокола обмена по конкретному объекту)
//
// Параметры:
//  Форма - ФормаКлиентскогоПриложения - форма протокола обмена
//
Процедура ОтработатьВходящийДокументПротоколаОбмена(Форма) Экспорт
	
	Если ЗначениеЗаполнено(Форма.Параметры.Документ) Тогда
		Форма.Документ = Форма.Параметры.Документ;
	Иначе
		ВызватьИсключение НСтр("ru = 'Протокол обмена может быть открыт только в контексте документа.'");
	КонецЕсли;
	
КонецПроцедуры

// Устанавливает типовое условное оформление протокола обмена
//
// Параметры:
//  Форма	 - ФормаКлиентскогоПриложения - форма протокола обмена
//
Процедура УстановитьУсловноеОформлениеПротоколаОбмена(Форма) Экспорт
	
	УсловноеОформление = Форма.УсловноеОформление;
	Элементы = Форма.Элементы;
	
	УсловноеОформление.Элементы.Очистить();
	
#Область ДеревоЗачеркнутый
	
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Элементы.ДеревоФайловПредставление.Имя);
	
	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ДеревоФайлов.УсловноеОформление");
	ОтборЭлемента.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = "УсловноеОформлениеЗачеркнутый";
	
	Элемент.Оформление.УстановитьЗначениеПараметра("Шрифт", Новый Шрифт(,,,,,Истина));
	
#КонецОбласти

#Область ДеревоСерый

	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Элементы.ДеревоФайловПредставление.Имя);
	
	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ДеревоФайлов.УсловноеОформление");
	ОтборЭлемента.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = "УсловноеОформлениеСерый";
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ЦветТекстаНеТребуетВниманияГосИС);
	
#КонецОбласти

#Область ДеревоЖирный

	Элемент = УсловноеОформление.Элементы.Добавить();

	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Элементы.ДеревоФайловПредставление.Имя);

	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ДеревоФайлов.УсловноеОформление");
	ОтборЭлемента.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = "УсловноеОформлениеЖирный";

	Элемент.Оформление.УстановитьЗначениеПараметра("Шрифт", Новый Шрифт(,,Истина));
	
#КонецОбласти

#Область ДеревоОтказ
	
	Элемент = УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(Элементы.ДеревоФайловПредставление.Имя);
	
	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение  = Новый ПолеКомпоновкиДанных("ДеревоФайлов.УсловноеОформление");
	ОтборЭлемента.ВидСравнения   = ВидСравненияКомпоновкиДанных.Равно;
	ОтборЭлемента.ПравоеЗначение = "УсловноеОформлениеОшибка";
	
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.СтатусОбработкиОшибкаПередачиГосИС);
	
#КонецОбласти

#Область ДатаНеПередана
	
	СтандартныеПодсистемыСервер.УстановитьУсловноеОформлениеПоляДата(Форма, "ДеревоФайлов.Дата", Элементы.ДеревоФайловДата.Имя);
	
	// Представление даты "<не передано>"
	ЭлементУсловногоОформления = УсловноеОформление.Элементы.Добавить();
	ЭлементУсловногоОформления.Использование = Истина;
	
	ПолеЭлемента = ЭлементУсловногоОформления.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных("ДеревоФайловДата");
	
	ПредставлениеЭлемента = НСтр("ru = 'Представление даты ""<не передано>""'");
	ЭлементУсловногоОформления.Представление = ПредставлениеЭлемента;
	
	ЭлементОтбораДанных = ЭлементУсловногоОформления.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ЭлементОтбораДанных.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("ДеревоФайлов.Дата");
	ЭлементОтбораДанных.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	ЭлементОтбораДанных.ПравоеЗначение = '00010101';
	ЭлементОтбораДанных.Использование = Истина;
	
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = '<не передано>'"));
	ЭлементУсловногоОформления.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ЦветТекстаНеТребуетВниманияГосИС);
	
#КонецОбласти

КонецПроцедуры

// Возвращает индекс картинки запроса в коллекции "ПротоколОбменаИС"
//
// Параметры:
//  СтрокаПоследовательности - Произвольный - коллекция с типом запроса (входящий, исходящий)
//  НеВыполнен				 - Булево - серые стрелки (по умолчанию Ложь)
// 
// Возвращаемое значение:
//  Число - индекс соответствующей картинки запроса
//
Функция ИндексКартинкиЗапроса(СтрокаПоследовательности, НеВыполнен = Ложь) Экспорт
	
	ИндексКартинки = 0;
	
	Смещение = 0;
	Если НеВыполнен Тогда
		Смещение = 6;
	КонецЕсли;
	
	Если СтрокаПоследовательности = Неопределено Тогда
	ИначеЕсли СтрокаПоследовательности.ТипСообщения = Перечисления.ТипыЗапросовИС.Исходящий Тогда
		ИндексКартинки = 1 + Смещение;
	ИначеЕсли СтрокаПоследовательности.ТипСообщения = Перечисления.ТипыЗапросовИС.Входящий Тогда
		ИндексКартинки = 2 + Смещение;
	КонецЕсли;
	
	Возврат ИндексКартинки;
	
КонецФункции

#КонецОбласти

#Область ПоследовательностьСообщений

// Создает таблицу последовательности операций.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - Таблица с колонками:
//   * Операция - ПеречислениеСсылка.ВидыДокументовВЕТИС, ПеречислениеСсылка.ВидыОперацийИСМП - Операция.
//   * Индекс - Число - Индекс операции в последовательности.
//   * ТипСообщения - ПеречислениеСсылка.ТипыЗапросовИС - Тип сообщения.
//   * ДальнейшиеДействия - Массив Из ПеречислениеСсылка - Дальнейшие действия при операции.
//
Функция ПустаяТаблицаПоследовательностьОпераций() Экспорт
	
	ПоследовательностьОпераций = Новый ТаблицаЗначений;
	
	ПоследовательностьОпераций.Колонки.Добавить("Операция");
	ПоследовательностьОпераций.Колонки.Добавить("Индекс");
	ПоследовательностьОпераций.Колонки.Добавить("ТипСообщения");
	ПоследовательностьОпераций.Колонки.Добавить("ДальнейшиеДействия");
	ПоследовательностьОпераций.Колонки.Добавить("АбстрактнаяОперация", Новый ОписаниеТипов("Булево"));
	
	Возврат ПоследовательностьОпераций;
	
КонецФункции

// Возвращает предыдущую операцию последовательности операций.
//
// Параметры:
//  ПоследовательностьОпераций - ТаблицаЗначений - см. функцию ПустаяТаблицаПоследовательностьОпераций().
//  СтрокаПоследовательности - СтрокаТаблицыЗначений - см. функцию ПустаяТаблицаПоследовательностьОпераций().
//  ИсходныйИндекс - Число - Индекс текущей операции.
// 
// Возвращаемое значение:
//  СтрокаТаблицыЗначений - см. функцию ПустаяТаблицаПоследовательностьОпераций().
//
Функция ПредыдущаяОперация(ПоследовательностьОпераций, СтрокаПоследовательности, Знач ИсходныйИндекс = Неопределено) Экспорт
	
	ИндексСтроки = ПоследовательностьОпераций.Индекс(СтрокаПоследовательности);
	
	Если ИндексСтроки = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ПредыдущаяОперация = ПоследовательностьОпераций.Получить(ИндексСтроки - 1);
	
	Если ИсходныйИндекс = Неопределено Тогда
		ИсходныйИндекс = СтрокаПоследовательности.Индекс;
	КонецЕсли;
	
	// Пропускаем абстрактные операции
	Если ПредыдущаяОперация.АбстрактнаяОперация Тогда
		Возврат ПредыдущаяОперация(ПоследовательностьОпераций, ПредыдущаяОперация, ИсходныйИндекс);
	КонецЕсли;
	
	АнализироватьПредыдущуюОперацию = ПроверитьИндекс(
		Формат(ПредыдущаяОперация.Индекс, "ЧГ=0;ЧН=0"),
		Формат(ИсходныйИндекс, "ЧГ=0;ЧН=0"));
	
	Если АнализироватьПредыдущуюОперацию
		И ПредыдущаяОперация.Индекс <> 0 Тогда
		Возврат ПредыдущаяОперация(ПоследовательностьОпераций, ПредыдущаяОперация, ИсходныйИндекс);
	КонецЕсли;
	
	Возврат ПредыдущаяОперация;
	
КонецФункции

// Добавляет операцию в последовательность операций.
//
// Параметры:
//  ПоследовательностьОпераций - ТаблицаЗначений - (см. ПустаяТаблицаПоследовательностьОпераций).
//  Индекс - Число - Индекс добавляемой операции.
//  ТипСообщения - ПеречислениеСсылка.ТипыЗапросовИС - Тип сообщения.
//  Операция - ПеречислениеСсылка.ВидыДокументовВЕТИС, ПеречислениеСсылка.ВидыОперацийИСМП - Операция.
//  РассчитатьДействияДляДокумента - ДокументСсылка - Документ, для которого нужно вычислить дальнейшие действия.
// 
// Возвращаемое значение:
//  СтрокаТаблицыЗначений - см. функцию ПустаяТаблицаПоследовательностьОпераций().
//
Функция ДобавитьОперациюВПоследовательность(ПоследовательностьОпераций,
			Индекс, ТипСообщения, Операция, РассчитатьДействияДляДокумента = Неопределено) Экспорт

	НоваяСтрока = ПоследовательностьОпераций.Добавить();
	НоваяСтрока.Операция           = Операция;
	НоваяСтрока.Индекс             = Индекс;
	НоваяСтрока.ТипСообщения       = ТипСообщения;
	НоваяСтрока.ДальнейшиеДействия = Новый Массив;
	
	Если ЗначениеЗаполнено(РассчитатьДействияДляДокумента) Тогда
		
		ПолноеИмя = РассчитатьДействияДляДокумента.Метаданные().ПолноеИмя();
		МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмя);
		
		Если ПоследовательностьОпераций.Количество() = 1 Тогда
			
			НоваяСтрока.ДальнейшиеДействия.Добавить(МенеджерОбъекта.ДальнейшееДействиеПоУмолчанию());
			
		Иначе
			
			ПредыдущаяОперация = ПредыдущаяОперация(ПоследовательностьОпераций, НоваяСтрока);
			
			Если ПредыдущаяОперация = Неопределено Тогда
				
				НоваяСтрока.ДальнейшиеДействия.Добавить(МенеджерОбъекта.ДальнейшееДействиеПоУмолчанию());
				
			Иначе
				
				Если ПредыдущаяОперация.ТипСообщения = Перечисления.ТипыЗапросовИС.Исходящий Тогда
					Статусы = МенеджерОбъекта.СтатусПослеПередачиДанных(
						РассчитатьДействияДляДокумента,
						ПредыдущаяОперация.Операция,
						Неопределено);
				Иначе
					Статусы = МенеджерОбъекта.СтатусПослеПолученияДанных(
						РассчитатьДействияДляДокумента,
						ПредыдущаяОперация.Операция);
				КонецЕсли;
				
				Если Статусы.Количество() Тогда
					МенеджерСтатусов = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(Статусы[0]);
					НоваяСтрока.ДальнейшиеДействия = МенеджерСтатусов.ДальнейшиеДействия(Статусы);
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат НоваяСтрока;
	
КонецФункции

// Выполняет отмену операции.
// 
// Параметры:
// 	ДокументСсылка - ДокументСсылка - Ссылка на документ, операцию которого необходимо отменить.
// 	ДанныеПоследнегоСообщения - Структура - Данные последнего сообщения, например структура, возвращаемая функцией См. Справочники.ЕГАИСПрисоединенныеФайлы.ПоследнееСообщение.
// Возвращаемое значение:
// 	Неопределено - Описание
Функция ОтменитьОперацию(ДокументСсылка, ДанныеПоследнегоСообщения) Экспорт
	
	МенеджерОбъекта = ОбщегоНазначения.МенеджерОбъектаПоСсылке(ДокументСсылка);
	ПоследовательностьОпераций = МенеджерОбъекта.ПоследовательностьОпераций(ДокументСсылка);
	
	СтрокаПоследовательности = ПоследовательностьОпераций.Найти(ДанныеПоследнегоСообщения.Операция, "Операция");
	
	ПредыдущаяОперация = ИнтеграцияИС.ПредыдущаяОперация(ПоследовательностьОпераций, СтрокаПоследовательности);
	Если ПредыдущаяОперация = Неопределено Тогда
		
		НовыйСтатусПослеОбновления = МенеджерОбъекта.ОбновитьСтатус(
			ДокументСсылка, Неопределено, Неопределено);
		
	Иначе
		
		Если ПредыдущаяОперация.ТипСообщения = Перечисления.ТипыЗапросовИС.Исходящий Тогда
			ПараметрыОбновления = МенеджерОбъекта.СтатусПослеПередачиДанных(
				ДокументСсылка,
				ПредыдущаяОперация.Операция,
				Неопределено);
		Иначе
			ПараметрыОбновления = МенеджерОбъекта.СтатусПослеПолученияДанных(
				ДокументСсылка,
				ПредыдущаяОперация.Операция,
				Неопределено);
		КонецЕсли;
		
		Если ПараметрыОбновления = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		НовыйСтатусПослеОбновления = МенеджерОбъекта.ОбновитьСтатус(
			ДокументСсылка,
			ПараметрыОбновления,
			Неопределено);
		
	КонецЕсли;
	
	Возврат НовыйСтатусПослеОбновления;
	
КонецФункции

#КонецОбласти

#Область СправочникиИКлассификаторы

// Получает список стран ЕАЭС
// 
// Параметры:
// 	ВключатьКодВПредставление - Булево - Включает в представление код страны.
// Возвращаемое значение:
// 	СписокЗначений - Список стран участников ЕАЭС.
Процедура ДополнитьСписокСтранЕАЭС(СписокСтран, ВключатьКодВПредставление = Истина) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	СтраныМира.Ссылка                КАК Ссылка,
		|	СтраныМира.Код                   КАК Код,
		|	Представление(СтраныМира.Ссылка) КАК Представление
		|ИЗ
		|	Справочник.СтраныМира КАК СтраныМира
		|ГДЕ
		|	СтраныМира.УчастникЕАЭС
		|	И НЕ СтраныМира.ПометкаУдаления
		|УПОРЯДОЧИТЬ ПО
		|	Код";
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Пока ВыборкаДетальныеЗаписи.Следующий() Цикл
		Если СписокСтран.НайтиПоЗначению(ВыборкаДетальныеЗаписи.Ссылка) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если ВключатьКодВПредставление Тогда
			Представление = СтрШаблон("%1 - %2", ВыборкаДетальныеЗаписи.Код, ВыборкаДетальныеЗаписи.Представление);
		Иначе
			Представление = ВыборкаДетальныеЗаписи.Представление;
		КонецЕсли;
		СписокСтран.Добавить(ВыборкаДетальныеЗаписи.Ссылка, Представление);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

// Возвращает структуру параметров заполнения табличной части.
// 
// Параметры:
//  ВходноеЗначение - Массив Из ПеречислениеСсылка.ВидыПродукцииИС, ПеречислениеСсылка.ВидыПродукцииИС - виды продукции, которые поддерживает документ.
// Возвращаемое значение:
//  Структура - 
Функция ПараметрыЗаполненияТабличнойЧастиТовары(ВходноеЗначение) Экспорт
	
	Если ТипЗнч(ВходноеЗначение) = Тип("ПеречислениеСсылка.ВидыПродукцииИС") Тогда
		ВидыПродукции = Новый Массив();
		ВидыПродукции.Добавить(ВходноеЗначение);
	Иначе
		ВидыПродукции = ВходноеЗначение;
	КонецЕсли;
	
	ПараметрыЗаполнения = БазовыеПараметрыОбработкиТабличнойЧастиТовары(ВидыПродукции);
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ЕГАИС") Тогда
		
		Если ВидыПродукции.Найти(Перечисления.ВидыПродукцииИС.Алкогольная) <> Неопределено Тогда
			МодульШтрихкодированиеЕГАИС = ОбщегоНазначения.ОбщийМодуль("ШтрихкодированиеЕГАИС");
			МодульШтрихкодированиеЕГАИС.ДополнитьПараметрыЗаполненияТабличнойЧастиТовары(ПараметрыЗаполнения);
		КонецЕсли;
		
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ИСМП") Тогда
		
		Если ШтрихкодированиеИС.ПрисутствуетПродукцияИСМП(ВидыПродукции)
			Или ШтрихкодированиеИС.ПрисутствуетТабачнаяПродукция(ВидыПродукции) Тогда
			
			МодульШтрихкодированиеИСМПКлиентСервер = ОбщегоНазначения.ОбщийМодуль("ШтрихкодированиеИСМПКлиентСервер");
			МодульШтрихкодированиеИСМПКлиентСервер.ДополнитьПараметрыЗаполненияТабличнойЧастиТовары(ПараметрыЗаполнения);
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат ПараметрыЗаполнения;
	
КонецФункции

#Область МаркируемаяПродукция

// Определяет ведение учета маркируемой продукции.
//
Функция ИспользуетсяМаркируемаяПродукция() Экспорт
	
	Результат = Ложь;
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ЕГАИС") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияЕГАИС");
		Результат = Результат Или Модуль.ИспользуетсяМаркируемаяПродукция();
	КонецЕсли;
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ИСМП") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияИСМП");
		Результат = Результат Или Модуль.ИспользуетсяМаркируемаяПродукция();
	КонецЕсли;
	Возврат Результат;
	
КонецФункции

// Возвращает свойства маркируемой продукции по номенклатуре и характеристике.
// 
// Параметры:
// 	Номенклатура - ОпределяемыйТип.Номенклатура - Номенклатура.
// 	Характеристика - ОпределяемыйТип.ХарактеристикаНоменклатуры - Характеристика.
// Возвращаемое значение:
// 	Структура - Описание:
//	 * Номенклатура - ОпределяемыйТип.Номенклатура - Номенклатура.
//	 * Характеристика - ОпределяемыйТип.ХарактеристикаНоменклатуры - Характеристика.
//	 * МаркируемаяПродукция - Булево - Истина, если продукция маркируемая.
//	 * ВидПродукции - ПеречислениеСсылка.ВидыПродукцииИС - Вид маркируемой продукции.
Функция СвойстваМаркируемойПродукции(Номенклатура, Характеристика) Экспорт
	
	ТекстЗапроса =
	"ВЫБРАТЬ
	|	&Номенклатура   КАК Номенклатура,
	|	&Характеристика КАК Характеристика
	|ПОМЕСТИТЬ ДанныеШтрихкодовУпаковок
	|;
	|
	|/////////////////////////////////////////////
	|"
	+
	ШтрихкодированиеИС.ОпределитьТекстЗапросаСвойстваМаркируемойПродукции()
	+
	"
	|;
	|/////////////////////////////////////////////
	|
	|ВЫБРАТЬ
	|	ДанныеПоВидуПродукции.Номенклатура         КАК Номенклатура,
	|	ДанныеПоВидуПродукции.Характеристика       КАК Характеристика,
	|	ДанныеПоВидуПродукции.МаркируемаяПродукция КАК МаркируемаяПродукция,
	|	ДанныеПоВидуПродукции.ВидПродукции         КАК ВидПродукции
	|ИЗ
	|	СвойстваМаркируемойПродукции КАК ДанныеПоВидуПродукции
	|";
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	Запрос.УстановитьПараметр("Номенклатура",   Номенклатура);
	Запрос.УстановитьПараметр("Характеристика", Характеристика);
	ДанныеТаблица = Запрос.Выполнить().Выгрузить();
	
	Если ДанныеТаблица.Количество() = 0 Тогда
		ДанныеТаблица.Добавить();
	КонецЕсли;
	СвойстваМаркируемойПродукции = ОбщегоНазначения.СтрокаТаблицыЗначенийВСтруктуру(ДанныеТаблица[0]);
	
	Возврат СвойстваМаркируемойПродукции;
	
КонецФункции

//Получает вид продукции по номенклатуре
//
//Параметры:
//   Номенклатура - ОпределяемыйТип.Номенклатура - Номенклатура.
//
//Возвращаемое значение:
//   ПеречислениеСсылка.ВидыПродукцииИС - вид продукции по номенклатуре
//
Функция ВидПродукцииПоНоменклатуре(Номенклатура) Экспорт
	
	Возврат СвойстваМаркируемойПродукции(Номенклатура, Неопределено).ВидПродукции;
	
КонецФункции

#КонецОбласти

#Область Прочее

// Возвращает пароль к сертификату, если доступен текущему пользователю.
// При вызове в привилегированном режиме текущий пользователь не учитывается.
//
// Параметры:
//  Сертификат - Неопределено - вернуть пароли ко всем сертификатам, доступным текущему пользователю.
//             - СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования - вернуть пароль
//                 к указанному сертификату.
//              
// Возвращаемое значение:
//  Неопределено - пароль для указанного сертификата не указан.
//  Строка       - пароль для указанного сертификата.
//  Соответствие - все заданные пароли, доступные текущему пользователю
//                 в виде ключ - сертификат и значение - пароль.
//
Функция ПарольКСертификату(Сертификат = Неопределено) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	Данные = Константы.КонтекстРаботыИС.Получить().Получить();
	УстановитьПривилегированныйРежим(Ложь);
	
	Если Не Пользователи.РолиДоступны("ДобавлениеИзменениеЭлектронныхПодписейИШифрование") Тогда
		Если Сертификат <> Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		Возврат Новый СписокЗначений;
	КонецЕсли;
	
	Если Сертификат <> Неопределено Тогда
		Если ТипЗнч(Данные) <> Тип("Соответствие") Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Свойства = Данные.Получить(Сертификат);
		
		Если ТипЗнч(Свойства) = Тип("Структура")
		   И Свойства.Свойство("Пароль")
		   И ТипЗнч(Свойства.Пароль) = Тип("Строка")
		   И Свойства.Свойство("Пользователь")
		   И ТипЗнч(Свойства.Пользователь) = Тип("СправочникСсылка.Пользователи") Тогда
			
		   Если Свойства.Пользователь = Пользователи.ТекущийПользователь()
			   ИЛИ Свойства.Пользователь = Справочники.Пользователи.ПустаяСсылка() Тогда
				
				Возврат Свойства.Пароль;
			КонецЕсли;
		КонецЕсли;
		
		Возврат Неопределено;
	КонецЕсли;
	
	ПаролиСертификатов = Новый Соответствие;
	
	Если ТипЗнч(Данные) <> Тип("Соответствие") Тогда
		Возврат ПаролиСертификатов;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из Данные Цикл
		Свойства = КлючИЗначение.Значение;
		
		Если ТипЗнч(Свойства) = Тип("Структура")
		   И Свойства.Свойство("Пароль")
		   И ТипЗнч(Свойства.Пароль) = Тип("Строка")
		   И Свойства.Свойство("Пользователь")
		   И ТипЗнч(Свойства.Пользователь) = Тип("СправочникСсылка.Пользователи") Тогда
			
		   Если Свойства.Пользователь = Пользователи.ТекущийПользователь()
			   ИЛИ Свойства.Пользователь = Справочники.Пользователи.ПустаяСсылка()
			 Или ПривилегированныйРежим() Тогда
				ПаролиСертификатов.Вставить(КлючИЗначение.Ключ, Свойства.Пароль);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПаролиСертификатов;
	
КонецФункции

//Серверное ожидание перед очередным действием в соответствии с ограничениями сервиса
//
//Параметры:
//   ВремяОжидания   - Число     - длительность паузы
//   ПараметрыОбмена - Структура - параметры обмена с обязательным свойством:
//   * ФоновоеЗадание - Неопределено, ФоновоеЗадание - задание ожидания
//
Процедура Ожидать(ВремяОжидания, ПараметрыОбмена) Экспорт
	
	Если ВремяОжидания <= 0 Тогда
		Возврат;
	КонецЕсли;
	
	ФоновоеЗадание = Неопределено;
	Если ПараметрыОбмена.ФоновоеЗадание = Неопределено Тогда
		
		ТекущийСеансИнформационнойБазы = ПолучитьТекущийСеансИнформационнойБазы();
		ФоновоеЗадание = ТекущийСеансИнформационнойБазы.ПолучитьФоновоеЗадание();
		
		Если ФоновоеЗадание = Неопределено Тогда
			Если ОбщегоНазначения.РазделениеВключено()
				И ОбщегоНазначения.ПодсистемаСуществует("ТехнологияСервиса.БазоваяФункциональность") Тогда
				ОбщийМодульОбщегоНазначенияБТС = ОбщегоНазначения.ОбщийМодуль("ОбщегоНазначенияБТС");
				ОбщийМодульОбщегоНазначенияБТС.Пауза(ВремяОжидания);
				Возврат;
			КонецЕсли;
		Иначе
			ПараметрыОбмена.ФоновоеЗадание = ФоновоеЗадание;
		КонецЕсли;
		
	Иначе
		ФоновоеЗадание = ПараметрыОбмена.ФоновоеЗадание;
	КонецЕсли;
	
	Если ФоновоеЗадание <> Неопределено Тогда
		Попытка
			ФоновоеЗадание.ОжидатьЗавершения(ВремяОжидания);
		Исключение
			ВремяОжидания = 0;
		КонецПопытки;
	КонецЕсли;
	
	Если ВремяОжидания = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ОбщегоНазначения.ЭтоWindowsСервер() Тогда
		
		НастройкиПрокси = Новый ИнтернетПрокси(Ложь);
		НастройкиПрокси.НеИспользоватьПроксиДляЛокальныхАдресов = Истина;
		НастройкиПрокси.НеИспользоватьПроксиДляАдресов.Добавить("127.0.0.0");
		
		Попытка
			Loopback = Новый HTTPСоединение(
				"127.0.0.0",,,,НастройкиПрокси,
				ВремяОжидания);
			Loopback.Получить(Новый HTTPЗапрос());
		Исключение
			ВремяОжидания = 0;
		КонецПопытки;
		
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

#Область РаботаСXDTO

// Функция - Данные для расшифровки ошибок
//
// Параметры:
//  ИмяМакета - Строка - макет в котором искать описание ошибки
//  Глубина   - Число  - уровень вложенности ошибки в макете
// 
// Возвращаемое значение:
//  Структура - из переданных параметров
//
Функция ДанныеДляРасшифровкиОшибок(ИмяМакета = Неопределено, Глубина = Неопределено) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ИмяМакета", ИмяМакета);
	Результат.Вставить("Глубина",   Глубина);
	Результат.Вставить("Таблица",   Неопределено);
	Возврат Результат;
	
КонецФункции

// Функция возвращает пустую таблицу значений пользовательских представлений полей
// 
// Возвращаемое значение:
//  ТаблицаЗначений - пустая таблица (отсутствия пользовательской расшифровки полей)
//
Функция ПустаяТаблицаПредставленийПолей() Экспорт
	
	ТаблицаПредставлений = Новый ТаблицаЗначений;
	ТаблицаПредставлений.Колонки.Добавить("ПространствоИмен", Новый ОписаниеТипов("Строка"));
	ТаблицаПредставлений.Колонки.Добавить("ЛокальноеИмя",     Новый ОписаниеТипов("Строка"));
	ТаблицаПредставлений.Колонки.Добавить("Представление",    Новый ОписаниеТипов("Строка"));
	ТаблицаПредставлений.Колонки.Добавить("Обязательное",     Новый ОписаниеТипов("Булево"));
	ТаблицаПредставлений.Колонки.Добавить("Глубина",          Новый ОписаниеТипов("Число"));
	Возврат ТаблицаПредставлений;
	
КонецФункции

#КонецОбласти

#Область РаботаСЧасовымиПоясами

Функция ДатаИзСтрокиISO(Значение) Экспорт
	
	Конвертор = ИнтеграцияИС.ОбъектXDTOПоИмениСвойства("http://gosis.1c.ru/Convertor", "query");
	Конвертор.ХранилищеДаты = ИнтеграцияИС.ОбъектXDTOПоИмениТипа(Конвертор, "ХранилищеДаты");
	Конвертор.ХранилищеДаты.Значение = Значение;
	Возврат Конвертор.ХранилищеДаты.Значение;
	
КонецФункции

Функция ДатаИзСтрокиUNIX(Значение, Делитель = 1000, ПриводитьКМестномуВремени = Истина) Экспорт
	
	Значение = '19700101' + Цел(Значение / Делитель);
	
	Если ПриводитьКМестномуВремени Тогда
		Возврат МестноеВремя(Значение);
	Иначе
		Возврат Значение;
	КонецЕсли;
	
КонецФункции

Функция ДатаИзСтроки(Значение, Делитель = 1000, ПриводитьКМестномуВремени = Истина) Экспорт
	
	Если СтрНайти(Значение, "T") > 0 Тогда
		Возврат ДатаИзСтрокиISO(Значение);
	Иначе
		Возврат ДатаИзСтрокиUNIX(Значение, Делитель, ПриводитьКМестномуВремени);
	КонецЕсли;
	
КонецФункции

Функция ДатаВСтрокуUNIX(Дата, Делитель = 1000) Экспорт
	
	Значение = (УниверсальноеВремя(Дата) - '19700101') * Делитель;
	
	Возврат Значение;
	
КонецФункции

// Формирует представление даты с часовым поясом.
//
// Параметры:
//  Дата        - ДатаВремя - дата, для которой нужно вывести представление.
//  ЧасовойПояс - Строка - идентификатор часового пояса.
// 
// Возвращаемое значение:
//  Строка - представление даты с часовым поясом.
//
Функция ДатаСЧасовымПоясом(Дата, Знач ЧасовойПояс = Неопределено) Экспорт
	
	Если ЧасовойПояс = Неопределено Тогда
		ЧасовойПояс = ЧасовойПоясСеанса();
	КонецЕсли;
	
	Смещение = (Дата - УниверсальноеВремя(Дата, ЧасовойПояс)) / 3600;
	Если Смещение > 0 Тогда
		Результат = Формат(Дата, "ДФ=yyyy-MM-ddTЧЧ:мм:сс") + "+" + Формат(+Смещение, "ЧЦ=2; ЧН=; ЧВН=") + ":00";
	Иначе
		Результат = Формат(Дата, "ДФ=yyyy-MM-ddTЧЧ:мм:сс") + "-" + Формат(-Смещение, "ЧЦ=2; ЧН=; ЧВН=") + ":00";
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Формирует представление даты в формате Coordinated Universal Time
//
// Параметры:
//  Дата - ДатаВремя - дата, представление которой необходимо получить.
// 
// Возвращаемое значение:
//  Строка - представление даты в формате Coordinated Universal Time(UTC).
//
Функция ДатаUTC(Знач Дата, ЧасовойПояс = Неопределено) Экспорт
	
	Если ЧасовойПояс <> Неопределено Тогда
		Дата = УниверсальноеВремя(Дата, ЧасовойПояс);
	КонецЕсли;
	
	Результат = Формат(Дата, "ДФ=yyyy-MM-ddTЧЧ:мм:сс") + ".000Z";
	
	Возврат Результат;
	
КонецФункции

// Возвращает временную дату, которая будет в дальнейшем преобразована в дату с часовым поясом.
//
// Параметры:
//  Дата - Дата - Дата для преобразования.
// 
// Возвращаемое значение:
//  Дата - Временная дата
//
Функция ВременнаяДата(Дата) Экспорт
	
	Возврат ДобавитьМесяц(Дата, -12 * 1000);
	
КонецФункции

// Устанавливает в ОбъектXDTO вместо даты со смещением временную дату. В дальнейшем временная дата будет заменена датой
// со смещением в результирующем ХМL. Тем самым обходится ограничение ОбъектXDTO, который не позволяет устанавливать в
// свойство дату со смещением.
//
// Параметры:
//  ОбъектXDTO            - ОбъектXDTO - в свойство данного объекта помещается дата.
//  ИмяСвойства           - ИмяСвойства - имя свойства, в которое устанавливается дата.
//  Дата                  - ДатаВремя - дата, которая устанавливается в свойство.
//  ХранилищеВременныхДат - Соответствие - в нем хранится соответствие временных дат и дат со смещением.
//
Процедура УстановитьДатуСЧасовымПоясом(ОбъектXDTO, ИмяСвойства, Дата, ХранилищеВременныхДат) Экспорт
	
	ДатаСЧасовымПоясом = ДатаСЧасовымПоясом(Дата);
	
	ВременнаяДатаUTC = ДатаUTC(ВременнаяДата(Дата));
	
	ОбъектXDTO[ИмяСвойства] = ВременнаяДатаUTC;
	ЛексическоеЗначениеВременнойДаты = ОбъектXDTO.ПолучитьXDTO(ИмяСвойства).ЛексическоеЗначение;
	
	ХранилищеВременныхДат.Вставить(ЛексическоеЗначениеВременнойДаты, ДатаСЧасовымПоясом);
	
КонецПроцедуры

// Заменяет временные даты в тексте сообщения в формате XML на даты со смещением, согласно соответствию.
//
// Параметры:
//  ХранилищеВременныхДат - Соответствие - хранит временные даты, которые нужно заменить на даты со смещением
//  ТекстСообщенияXML     - Строка - текст сообщения, в котором выполняется замена.
// 
// Возвращаемое значение:
//  Строка - ТекстСообщенияXML, в котором выполнена замена.
//
Функция ПреобразоватьВременныеДаты(ХранилищеВременныхДат, Знач ТекстСообщенияXML) Экспорт
	
	Текст = ТекстСообщенияXML;
	
	Для Каждого КлючИЗначение Из ХранилищеВременныхДат Цикл
		
		ВременнаяДата = КлючИЗначение.Ключ;
		Дата = КлючИЗначение.Значение;
		
		Текст = СтрЗаменить(Текст, ВременнаяДата, Дата);
		
	КонецЦикла;
	
	Возврат Текст;
	
КонецФункции

#КонецОбласти

#Область ПроцедурыИФункцииДляПечати

// Функция раскладывает переданный массив ссылок в соответствие по типам этих ссылок.
//
//	Параметры:
//		МассивСсылок - Массив - массив ссылок на объекты информационной базы
//  Возвращаемое значение:
//		Соответствие:
//			Ключ - полное имя типа ссылки
//	        Значение - массив ссылок этого типа.
//
Функция СоответствиеМассивовПоТипамОбъектов(МассивСсылок) Экспорт
	
	СоответствиеТипов = Новый Соответствие;
	
	Для Каждого Объект Из МассивСсылок Цикл
		
		ТипОбъекта = Объект.Метаданные().ПолноеИмя();
		ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		
		Если ТекущийТипОбъекта = Неопределено Тогда
			СоответствиеТипов.Вставить(ТипОбъекта, Новый Массив);
			ТекущийТипОбъекта = СоответствиеТипов.Получить(ТипОбъекта);
		КонецЕсли;
		ТекущийТипОбъекта.Добавить(Объект);
		
	КонецЦикла;
	
	Возврат СоответствиеТипов;
	
КонецФункции

#КонецОбласти

#Область ОбщиеПредставления

// Заполняет представление регламентного задания (реквизиты ЗаданиеАктивно, ТекстРасписания)
//
// Параметры:
//  Задание				 - РегламентноеЗадание, Неопределено - регламентное задание представление которого необходимо получить
//  ТекстРасписания		 - Строка - представление расписания (выходной)
//  РасписаниеАктивно	 - Булево - использование задания (выходной)
//
Процедура ПолучитьТекстЗаголовкаИРасписанияРегламентнойНастройки(Задание, ТекстРасписания, РасписаниеАктивно) Экспорт
	
	РасписаниеАктивно = Ложь;
	
	Если Задание = Неопределено Тогда
		
		ТекстРасписания = НСтр("ru = '<Расписание не задано>'");
		
	Иначе
		
		Если Задание.Использование Тогда
			РасписаниеАктивно = Истина;
			ТекстРасписания = СтрШаблон(НСтр("ru = 'Расписание: %1'"), Строка(Задание.Расписание));
		Иначе
			ТекстРасписания = СтрШаблон(НСтр("ru = 'Расписание (НЕ АКТИВНО): %1'"), Строка(Задание.Расписание));
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Иницициализирует таблицу для расчета содержимого упаковки
//
// Возвращаемое значение:
//  ТаблицаЗначений - Описание:
//   * Номенклатура - ОпределяемыйТип.Номенклатура
//                - Строка
//   * Характеристика - ОпределяемыйТип.ХарактеристикаНоменклатуры
//                  - Строка
//   * Серия - ОпределяемыйТип.СерияНоменклатуры
//         - Строка
//   * Количество - Число - Количество
Функция ИнициализироватьСодержимоеУпаковки() Экспорт
	
	ТипСтрока = ОбщегоНазначения.ОписаниеТипаСтрока(200);
	
	СодержимоеУпаковки = Новый ТаблицаЗначений;
	СодержимоеУпаковки.Колонки.Добавить("Номенклатура",   Новый ОписаниеТипов(ТипСтрока, Метаданные.ОпределяемыеТипы.Номенклатура.Тип.Типы()));
	СодержимоеУпаковки.Колонки.Добавить("Характеристика", Новый ОписаниеТипов(ТипСтрока, Метаданные.ОпределяемыеТипы.ХарактеристикаНоменклатуры.Тип.Типы()));
	СодержимоеУпаковки.Колонки.Добавить("Серия",          Новый ОписаниеТипов(ТипСтрока, Метаданные.ОпределяемыеТипы.СерияНоменклатуры.Тип.Типы()));
	СодержимоеУпаковки.Колонки.Добавить("Количество",     Новый ОписаниеТипов("Число"));
	
	Возврат СодержимоеУпаковки;
	
КонецФункции

// Возвращает строку, состоящую из различных частей наименований номенклатуры, входящей в состав упаковки
//
// Параметры:
//  Таблица - См. ИнициализироватьСодержимоеУпаковки - ссылки на элементы справочника номенклатуры.
//
// ВозвращаемоеЗначение:
//  Строка - строка, состоящая из различных наименований переданной номенклатуры.
Функция ПредставлениеСоставаУпаковки(Таблица) Экспорт
	
	Таблица.Сортировать("Количество УБЫВ, Номенклатура ВОЗР, Характеристика ВОЗР, Серия ВОЗР");
	
	ДеревоЧастейНаименований = Новый ДеревоЗначений();
	
	Для Каждого ЭлементДанных Из Таблица Цикл
		
		ПредставлениеНоменклатуры = ИнтеграцияИС.ПредставлениеНоменклатуры(
			ЭлементДанных.Номенклатура, ЭлементДанных.Характеристика);
		
		ЧастиНаименования = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов(ПредставлениеНоменклатуры);
		
		НомерТекущейЧасти  = 1;
		СтрокиТекущейЧасти = ДеревоЧастейНаименований.Строки;
		
		Для Каждого ЧастьНаименования Из ЧастиНаименования Цикл
			
			ИмяТекущейКолонки = "ЧастьНаименования" + НомерТекущейЧасти;
			
			Если ДеревоЧастейНаименований.Колонки.Найти(ИмяТекущейКолонки) = Неопределено Тогда
				ДеревоЧастейНаименований.Колонки.Добавить(ИмяТекущейКолонки, ОбщегоНазначения.ОписаниеТипаСтрока(100));
			КонецЕсли;
			
			СтрокаЧастиНаименования = СтрокиТекущейЧасти.Найти(СокрЛП(ЧастьНаименования), ИмяТекущейКолонки, Ложь);
			
			Если СтрокаЧастиНаименования = Неопределено Тогда
				СтрокаЧастиНаименования = СтрокиТекущейЧасти.Добавить();
				СтрокаЧастиНаименования[ИмяТекущейКолонки] = СокрЛП(ЧастьНаименования);
			КонецЕсли;
			
			НомерТекущейЧасти  = НомерТекущейЧасти + 1;
			СтрокиТекущейЧасти = СтрокаЧастиНаименования.Строки;
			
		КонецЦикла;
		
	КонецЦикла;
	
	СтрокаСоставаУпаковки = "";
	ОграничительСостава   = 7;
	
	Если ДеревоЧастейНаименований.Строки.Количество() > 0 Тогда
		СоставитьСтрокуСоставаУпаковки(СтрокаСоставаУпаковки, ДеревоЧастейНаименований.Строки, ОграничительСостава);
	КонецЕсли;
	
	Если Прав(СтрокаСоставаУпаковки, 1) = "," Тогда
		СтрокаСоставаУпаковки = Сред(СтрокаСоставаУпаковки, 1, СтрДлина(СтрокаСоставаУпаковки) - 1);
	КонецЕсли;
	
	Возврат СтрокаСоставаУпаковки;
	
КонецФункции

#КонецОбласти

#Область ВызовыИзБСП

// (См. ПодключаемыеКомандыПереопределяемый.ПриОпределенииКомандПодключенныхКОбъекту)
//
Процедура ПриОпределенииКомандПодключенныхКОбъекту(НастройкиФормы, Источники, ПодключенныеОтчетыИОбработки, Команды) Экспорт
	
	Если НастройкиФормы.ИмяФормы = "Обработка.ГенерацияШтрихкодовУпаковок.Форма.Форма" Тогда
		Обработки.ГенерацияШтрихкодовУпаковок.ПриОпределенииКомандПодключенныхКОбъекту(Команды);
	ИначеЕсли СтрНачинаетсяС(НастройкиФормы.ИмяФормы, "Справочник.ШтрихкодыУпаковокТоваров.Форма") Тогда
		Справочники.ШтрихкодыУпаковокТоваров.ПриОпределенииКомандПодключенныхКОбъекту(Команды);
	КонецЕсли;
	
КонецПроцедуры

// (См. ЗапретРедактированияРеквизитовОбъектовПереопределяемый.ПриОпределенииКомандПодключенныхКОбъекту)
//
Процедура ПриОпределенииОбъектовСЗаблокированнымиРеквизитами(Объекты) Экспорт

	Объекты.Вставить(
		Метаданные.Справочники.ШтрихкодыУпаковокТоваров.ПолноеИмя(),
		"ПолучитьБлокируемыеРеквизитыОбъекта");

КонецПроцедуры

Процедура ПодключитьВерсионирование(Форма) Экспорт
	
	// СтандартныеПодсистемы.ВерсионированиеОбъектов
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.ВерсионированиеОбъектов") Тогда
		МодульВерсионированиеОбъектов = ОбщегоНазначения.ОбщийМодуль("ВерсионированиеОбъектов");
		МодульВерсионированиеОбъектов.ПриСозданииНаСервере(Форма);
	КонецЕсли;
	// Конец СтандартныеПодсистемы.ВерсионированиеОбъектов
	
КонецПроцедуры

#КонецОбласти

#Область ФункцииИспользующиеПереопределение

#Область Номенклатура

Функция ТекстЗапросаПризнакаМаркируемаяПродукцияПоНоменклатуре(ИмяТаблицыНоменклатура = "Товары", ИмяПоляНоменклатура = "Номенклатура") Экспорт
	
	ТекстЗапроса = "";
	ИнтеграцияИСПереопределяемый.ПриЗаполненииТекстаЗапросаПризнакаМаркируемаяПродукцияПоНоменклатуре(ТекстЗапроса, ИмяТаблицыНоменклатура, ИмяПоляНоменклатура);
	Возврат ТекстЗапроса;
	
КонецФункции

Функция ПравоРегистрацииШтрихкодовНоменклатуры() Экспорт
	
	ПравоДоступа = Ложь;
	ИнтеграцияИСПереопределяемый.ПравоРегистрацииШтрихкодовНоменклатуры(ПравоДоступа);
	Возврат ПравоДоступа;
	
КонецФункции

//Формирует представление строки номенклатуры. Переопределяется.
//   Значение по-умолчанию: непустые представления составляющих, через запятую.
//
//Параметры:
//   Номенклатура   - ОпределяемыйТип.Номенклатура               - ссылка на номенклатуру.
//   Характеристика - ОпределяемыйТип.ХарактеристикаНоменклатуры - ссылка на характеристику номенклатуры.
//   Упаковка       - ОпределяемыйТип.Упаковка                   - ссылка на упаковку.
//   Серия          - ОпределяемыйТип.СерияНоменклатуры          - ссылка на серию номенклатуры.
//   ПоУмолчанию    - Строка                                     - Значение, если номенклатура не заполнена.
//
//Возвращаемое значение:
//   Строка - представление строки номенклатуры
//
Функция ПредставлениеНоменклатуры(Номенклатура, Характеристика, Упаковка = Неопределено, Серия = Неопределено, ПоУмолчанию = Неопределено) Экспорт
	
	Представление = "";
	ИнтеграцияИСПереопределяемый.ЗаполнитьПредставлениеНоменклатуры(
		Представление, Номенклатура, Характеристика, Упаковка, Серия);
	
	Если Представление = "" Тогда
		МассивФормированияПредставления = Новый Массив;
		Если ЗначениеЗаполнено(Номенклатура) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Номенклатура));
		КонецЕсли;
		Если ЗначениеЗаполнено(Характеристика) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Характеристика));
		КонецЕсли;
		Если ЗначениеЗаполнено(Упаковка) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Упаковка));
		КонецЕсли;
		Если ЗначениеЗаполнено(Серия) Тогда
			МассивФормированияПредставления.Добавить(СокрЛП(Серия));
		КонецЕсли;
		Представление = СтрСоединить(МассивФормированияПредставления, ", ");
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(Представление) И ЗначениеЗаполнено(ПоУмолчанию) Тогда
		Представление = Строка(ПоУмолчанию);
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции

#Область ХарактеристикиНоменклатуры

Функция ПризнакИспользованияХарактеристик(Номенклатура) Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеХарактеристик(Используются, Номенклатура);
	Возврат Используются;
	
КонецФункции

Функция ХарактеристикиИспользуются() Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеХарактеристик(Используются, Неопределено);
	Возврат Используются;
	
КонецФункции

#КонецОбласти

#Область СерииНоменклатуры

Функция СерииИспользуются() Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеСерий(Используются, Неопределено);
	Возврат Используются;
	
КонецФункции

Функция ПризнакИспользованияСерий(Номенклатура) Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеСерий(Используются, Номенклатура);
	Возврат Используются;
	
КонецФункции

// Возвращает параметры указания серий для товаров, указанных в объекте.
//
// Параметры:
//	Объект   - ДанныеФормыСтруктура - Объект, для формы которого нужно сформировать параметры указания серий.
//	Менеджер - Произвольный - Менеджер объекта, для формы которого нужно сформировать параметры указания серий.
//
// Возвращаемое значение:
//	Произвольный - параметры, уточняющие особенности указания серий в каждом объекте
//
Функция ПараметрыУказанияСерийФормыОбъекта(Объект, Менеджер) Экспорт
	
	Параметры = Неопределено;
	ИнтеграцияИСПереопределяемый.ЗаполнитьПараметрыУказанияСерийФормыОбъекта(Параметры, Объект, Менеджер);
	Возврат Параметры;
	
КонецФункции

// Имена реквизитов, от значений которых зависят параметры указания серий.
//
// Возвращаемое значение:
//	Строка - Имена реквизитов, перечисленные через запятую.
//
Функция ИменаРеквизитовДляЗаполненияПараметровУказанияСерий(ТипОбъекта) Экспорт
	
	ИменаРеквизитов = "";
	ИнтеграцияИСПереопределяемый.ЗаполнитьИменаРеквизитовДляЗаполненияПараметровУказанияСерий(ИменаРеквизитов, ТипОбъекта);
	Возврат ИменаРеквизитов;
	
КонецФункции

//Возвращает параметры указания серий для товаров, указанных в объекте.
//
//Параметры:
//   ТипОбъекта - ОбъектМетаданных - Тип объекта коллекции объектов метаданных.
//   Объект     - Структура        - Структура значений реквизитов объекта, необходимых для заполнения параметров указания серий.
//
// Возвращаемое значение:
//  Произвольный - (См. ИнтеграцияИСПереопределяемый.ЗаполнитьПараметрыУказанияСерий) - особенности указания серий.
//
Функция ПараметрыУказанияСерий(ТипОбъекта, Объект) Экспорт
	
	Параметры = Неопределено;
	ИнтеграцияИСПереопределяемый.ЗаполнитьПараметрыУказанияСерий(Параметры, ТипОбъекта, Объект);
	Возврат Параметры;
	
КонецФункции

// Возвращает текст запроса заполнения статусов указания серий для товаров, указанных в документе.
//
// Параметры:
//   ТипОбъекта             - ОбъектМетаданных - Тип документа коллекции объектов метаданных.
//   ПараметрыУказанияСерий - (см. ИнтеграцияИСПереопределяемый.ЗаполнитьПараметрыУказанияСерий).
//
// Возвращаемое значение:
//   Строка - Текст запроса заполнения статусов указания серий для товаров, указанных в объекте.
//
Функция ТекстЗапросаЗаполненияСтатусовУказанияСерий(ТипОбъекта, ПараметрыУказанияСерий) Экспорт
	
	ТекстЗапроса = "";
	ИнтеграцияИСПереопределяемый.ЗаполнитьТекстЗапросаЗаполненияСтатусовУказанияСерий(
		ТекстЗапроса,
		ТипОбъекта,
		ПараметрыУказанияСерий);
	Возврат ТекстЗапроса;
	
КонецФункции

// Возвращает текст запроса для проверки заполнения серий
//
// Параметры:
//   ТипОбъекта             - ОбъектМетаданных - Тип документа коллекции объектов метаданных.
//   ПараметрыУказанияСерий - (см. ИнтеграцияИСПереопределяемый.ЗаполнитьПараметрыУказанияСерий) - параметры указания серий
//
// Возвращаемое значение:
//   Строка - текст запроса.
//
Функция ТекстЗапросаПроверкиЗаполненияСерий(ТипОбъекта, ПараметрыУказанияСерий) Экспорт
	
	ТекстЗапроса = "";
	ИнтеграцияИСПереопределяемый.ЗаполнитьТекстЗапросаПроверкиЗаполненияСерий(
		ТекстЗапроса,
		ТипОбъекта,
		ПараметрыУказанияСерий);
	Возврат ТекстЗапроса;
	
КонецФункции

// Определяет необходимость указания серии для маркиремой продукции.
// 
// Параметры:
//  Товар - Структура - данные строки номенклатуры. Содержит обязательные поля:
//   * Номенклатура   - ОпределяемыйТип.Номенклатура               - номенклатура,
//   * Характеристика - ОпределяемыйТип.ХарактеристикаНоменклатуры - характеристика.
//  ПараметрыСканирования - (См. ШтрихкодированиеИСКлиент.ПараметрыСканирования).
// Возвращаемое значение:
//  Булево - Истина, если требуется указать серию.
Функция ТребуетсяВыборСерии(Товар, ПараметрыСканирования) Экспорт
	
	Если ПараметрыСканирования.ДополнительныеПараметры <> Неопределено
			И ПараметрыСканирования.ДополнительныеПараметры.Свойство("ДанныеУточнения") Тогда
		Возврат ЗначениеЗаполнено(ПараметрыСканирования.ДополнительныеПараметры.ДанныеУточнения.Серия);
	КонецЕсли;
	
	ТребуетсяВыбор = Ложь;
	
	ПараметрыУказанияСерий = ПараметрыСканирования.ПараметрыУказанияСерий;
	Склад                  = ПараметрыСканирования.Склад;
	
	Номенклатура           = Товар.Номенклатура;
	Характеристика         = Товар.Характеристика;
	
	ДанныеДляРасчетаСерии  = Новый Структура("Склад, Номенклатура, Характеристика", Склад, Номенклатура, Характеристика);
	ШтрихкодированиеИСПереопределяемый.ПриОпределенииНеобходимостиВыбораСерии(
		ДанныеДляРасчетаСерии, ПараметрыУказанияСерий, ТребуетсяВыбор, ПараметрыСканирования.КэшированныеЗначения);
	
	Возврат ТребуетсяВыбор;
	
КонецФункции

#КонецОбласти

#Область ВидыНоменклатуры

Функция ВидыНоменклатурыИспользуются() Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеВидовНоменклатуры(Используются);
	Возврат Используются;
	
КонецФункции

#КонецОбласти

#Область УпаковкиНоменклатуры

Функция УпаковкиИспользуются() Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеУпаковок(Используются, Неопределено);
	Возврат Используются;
	
КонецФункции

Функция ПризнакИспользованияУпаковок(Номенклатура) Экспорт
	
	Используются = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеУпаковок(Используются, Номенклатура);
	Возврат Используются;
	
КонецФункции

#КонецОбласти

#КонецОбласти

#Область ОрганизацииКонтрагенты

// Проверяет использование подразделений в информационной базе.
// 
// Возвращаемое значение:
//  Булево - Подразделения используются.
//
Функция ИспользоватьПодразделения() Экспорт
	
	Использовать = Ложь;
	ИнтеграцияИСПереопределяемый.ИспользованиеПодразделений(Использовать);
	Возврат Использовать;
	
КонецФункции

// Выполняет поиск организации предприятия по ИНН и/или КПП.
//
// Параметры:
//   ИНН - Строка - ИНН искомой организации,
//   КПП - Строка - КПП искомой организации.
// 
// Возвращаемое значение:
//   ОпределяемыйТип.ОрганизацияКонтрагентГосИС, Неопределено - найденная организация
//
Функция ОрганизацияПоИННКПП(ИНН, КПП) Экспорт
	
	Организация = Неопределено;
	ИнтеграцияИСПереопределяемый.ЗаполнитьОрганизациюПоИННКПП(Организация, ИНН, КПП);
	Возврат Организация;
	
КонецФункции

// Определяет контрагента по ИНН и КПП
//
// Параметры:
//  ИНН  - Строка - ИНН контрагента.
//  КПП  - Строка - КПП контрагента.
//
// Возвращаемое значение:
//   ОпределяемыйТип.КонтрагентГосИС, ОпределяемыйТип.ОрганизацияКонтрагентГосИС, Неопределено  - Найденный контрагент или Неопределено, если поиск завершился неудачей.
//
Функция КонтрагентПоИННКПП(ИНН, КПП) Экспорт
	
	Контрагент = Неопределено;
	ИнтеграцияИСПереопределяемый.ЗаполнитьКонтрагентаПоИННКПП(Контрагент, ИНН, КПП);
	Возврат Контрагент;
	
КонецФункции

// Возвращает строковое представление руководителя организации.
//
// Параметры:
//  Организация - ОпределяемыйТип.ОрганизацияКонтрагентГосИС - ссылка на собственную организацию или контрагента,
//  ДатаСведений - Дата - дата, на которую требуется получить информацию.
//
// Возвращаемое значение:
//  Структура - данные руководителя:
//   * Руководитель - Строка - ФИО руководителя,
//   * Должность - Строка - должность руководителя.
//
Функция ДанныеРуководителяОрганизации(Организация, ДатаСведений = Неопределено) Экспорт
	
	ПредставлениеРуководителя = Новый Структура("Руководитель, Должность", "", "");
	ИнтеграцияИСПереопределяемый.ОпределитьДанныеРуководителяОрганизации(ПредставлениеРуководителя,Организация,ДатаСведений);
	Возврат ПредставлениеРуководителя;
	
КонецФункции

// Возвращает ссылку на организацию прикладного объекта (документа)
//   Используется в библиотеке для определяемых типов "Основание[Документ]"
//
// Параметры:
//   Объект - Произвольный - объект конфигурации из которого требуется получить организацию
//
// Возвращаемое значение:
//   Неопределено                - отсутствует
//   ОпределяемыйТип.Организация - ссылка на организацию
//
Функция ОрганизацияИзПрикладногоОбъекта(Объект) Экспорт
	
	Организация = Неопределено;
	ИнтеграцияИСПереопределяемый.ПриОпределенииОрганизацииИзПрикладногоОбъекта(Организация, Объект);
	Возврат Организация;
	
КонецФункции

#КонецОбласти

#Область ПраваДоступа

Функция ЕстьПравоСозданияКонтрагента() Экспорт
	
	ДоступРазрешен = Ложь;
	ИнтеграцияИСПереопределяемый.ПравоСозданияКонтрагента(ДоступРазрешен);
	Возврат  ДоступРазрешен;
	
КонецФункции

#КонецОбласти

Функция ПредставлениеОбъекта(ПараметрОбъект) Экспорт
	
	Представление = НСтр("ru = '<Не задано>'");
	ИнтеграцияИСПереопределяемый.УстановитьПредставлениеОбъекта(Представление, ПараметрОбъект);
	Возврат Представление;
	
КонецФункции

#КонецОбласти

// Возвращает количество строк в дереве значений с учетом их вложенности
// 
// Параметры:
//  ДеревоЗначений - ДеревоЗначений - Дерево значений, в котором требуется определить количество строк
// Возвращаемое значение:
//  Число - количество строк
// 	
Функция КоличествоСтрокДереваЗначений(ДеревоЗначений) Экспорт
	
	СтрокиДерева    = ДеревоЗначений.Строки;
	КоличествоСтрок = СтрокиДерева.Количество();
	
	Для Каждого ПодчиненнаяСтрока Из СтрокиДерева Цикл
		КоличествоСтрок = КоличествоСтрок + КоличествоСтрокДереваЗначений(ПодчиненнаяСтрока);
	КонецЦикла;
	
	Возврат КоличествоСтрок;
	
КонецФункции

// Возвращает признак вхождения переданного объекта метаданных в переданную подсистему
//
// Параметры:
//   ПолноеИмяИлиМетаданныеПодсистемы - Строка           - полное имя подсистемы с учетом родительских подсистем через "."
//                                    - ОбъектМетаданных - сама подсистема
//   ОбъектМетаданных                 - ОбъектМетаданных - объект метаданных для которого определяется принадлежность к подсистеме
//
// Возвращаемое значение:
//   Булево - признак вхождения объекта метаданных в подсистему
//
Функция СодержитсяВПодсистеме(ПолноеИмяИлиМетаданныеПодсистемы, ОбъектМетаданных) Экспорт
	
	Если ТипЗнч(ПолноеИмяИлиМетаданныеПодсистемы) = Тип("Строка") Тогда
		
		ИменаПодсистем = СтрРазделить(ПолноеИмяИлиМетаданныеПодсистемы, ".");
		Если ИменаПодсистем.Количество() = 0 Тогда
			Возврат Ложь;
		КонецЕсли;
		
		МетаданныеПодсистемы = Метаданные;
		
		Для Каждого ИмяПодсистемы Из ИменаПодсистем Цикл
			МетаданныеПодсистемы = МетаданныеПодсистемы.Подсистемы[ИмяПодсистемы];
		КонецЦикла;
		
	Иначе
		
		МетаданныеПодсистемы = ПолноеИмяИлиМетаданныеПодсистемы;
		
	КонецЕсли;
	
	Если МетаданныеПодсистемы.Состав.Содержит(ОбъектМетаданных) Тогда
		Возврат Истина;
	КонецЕсли;

	Для Каждого ПодчиненнаяПодсистема Из МетаданныеПодсистемы.Подсистемы Цикл
		Если СодержитсяВПодсистеме(ПодчиненнаяПодсистема, ОбъектМетаданных) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

#Область РаботаСФормойСпискаДокументов

// Устанавливает отбор в списке по указанному значению для нужной колонки
// с учетом переданной структуры быстрого отбора.
//
// Параметры:
//  Список - ТаблицаФормы - динамический список, для которого требуется установить отбор
//  ИмяКолонки - Строка - Имя колонки, по которой устанавливается отбор
//  Значение - Произвольный - устанавливаемое значение отбора
//  СтруктураБыстрогоОтбора - Неопределено, Структура - Структура, содержащая ключи и значения отбора
//  Использование - Неопределено, Булево - Признак использования элемента отбора
//  ВидСравнения - Неопределено, ВидСравненияКомпоновкиДанных - вид сравнения, устанавливаемый для элемента отбора
//  ПриводитьЗначениеКЧислу - Булево - Признак приведения значения к числу.
//
Процедура ОтборПоЗначениюСпискаПриСозданииНаСервере(Список, ИмяКолонки, Значение, Знач СтруктураБыстрогоОтбораРасширенная,
			Использование = Неопределено, ВидСравнения = Неопределено, ПриводитьЗначениеКЧислу = Ложь) Экспорт
	
	Если СтруктураБыстрогоОтбораРасширенная <> Неопределено Тогда
		
		Если СтруктураБыстрогоОтбораРасширенная.Количество() = 2
			И СтруктураБыстрогоОтбораРасширенная.Свойство("ИмяПоля")
			И СтруктураБыстрогоОтбораРасширенная.Свойство("Настройки") Тогда
			СтруктураБыстрогоОтбора = СтруктураБыстрогоОтбораРасширенная.Настройки;
			ИмяКолонкиДляПоиска = СтруктураБыстрогоОтбораРасширенная.ИмяПоля;
		Иначе
			СтруктураБыстрогоОтбора = СтруктураБыстрогоОтбораРасширенная;
			ИмяКолонкиДляПоиска = ИмяКолонки;
		КонецЕсли;
		
		Если СтруктураБыстрогоОтбора <> Неопределено
			И СтруктураБыстрогоОтбора.Свойство(ИмяКолонкиДляПоиска) Тогда
			
			ЗначениеОтбора = СтруктураБыстрогоОтбора[ИмяКолонкиДляПоиска];
			Если ТипЗнч(Значение) = Тип("СписокЗначений") Тогда
				
				Если ТипЗнч(ЗначениеОтбора) = Тип("СписокЗначений") Тогда
					Значение.ЗагрузитьЗначения(ЗначениеОтбора.ВыгрузитьЗначения());
				ИначеЕсли ТипЗнч(ЗначениеОтбора) = Тип("Массив") Тогда
					Значение.ЗагрузитьЗначения(ЗначениеОтбора);
				Иначе
					Значение.Очистить();
					Если ЗначениеЗаполнено(ЗначениеОтбора) Тогда
						Значение.Добавить(ЗначениеОтбора);
					КонецЕсли;
				КонецЕсли;
				
			Иначе
				
				Значение = ЗначениеОтбора;
				
			КонецЕсли;
			
			Если ПриводитьЗначениеКЧислу Тогда
				Значение = ?(ЗначениеЗаполнено(Значение), Число(Значение), Значение);
			КонецЕсли;
			
			Если ТипЗнч(Значение) = Тип("СписокЗначений") Тогда
				ИспользованиеЭлементаОтбора = ?(Использование = Неопределено, Значение.Количество() > 0, Использование);
			Иначе
				ИспользованиеЭлементаОтбора = ?(Использование = Неопределено, ЗначениеЗаполнено(Значение), Использование);
			КонецЕсли;
			
			Если Список <> Неопределено Тогда
				ОбщегоНазначенияКлиентСервер.УстановитьЭлементОтбораДинамическогоСписка(Список, ИмяКолонки, Значение, ВидСравнения,,ИспользованиеЭлементаОтбора);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Возвращает настройки оформления формы списка документов ГосИС
//
// Возвращаемое значение:
//   Структура - Описание:
// * ЭлементыСтраницы    - Строка          - реквизиты формы - страницы (изменить тип если нет страниц к оформлению)
// * Списки              - Строка          - реквизиты формы - динамические списки документов (через запятую)
// * КОформлению         - Строка          - реквизиты формы - динамические списки к оформлению (через запятую)
// * ТипыКОформлению     - Неопределено    - списки к оформлению безусловно не используются
//                       - ОпределяемыйТип - документы, для которых используются списки к оформлению
// * ЭлементыКОформлению - Строка          - элементы формы, связанные со списками к оформлению (скрыть если не используются)
// * ТипыКОбмену         - Неопределено    - команда "Выполнить обмен" недоступна
//                       - ОпределяемыйТип - документы, при праве изменения которых доступна команда "Выполнить обмен"
// * ЭлементыКОбмену     - Строка          - элементы формы реализующие команду "Выполнить обмен" (через запятую)
//
Функция НастройкиФормыСпискаДокументов() Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("ЭлементыСтраницы",    "Страницы");
	Результат.Вставить("Списки",              "Список");
	Результат.Вставить("КОформлению",         "СписокКОформлению");
	Результат.Вставить("ТипыКОформлению",     Неопределено);
	Результат.Вставить("ЭлементыКОформлению", "СтраницаКОформлению");
	Результат.Вставить("ТипыКОбмену",         Неопределено);
	Результат.Вставить("ЭлементыКОбмену",     "СписокВыполнитьОбмен");
	
	Возврат Результат;
	
КонецФункции

// Обработчик одноименного события в формах списков документов ГосИС
//
// Параметры:
//   Форма     - ФормаКлиентскогоПриложения - источник события
//   Настройки - Структура        - (См. НастройкиФормыСпискаДокументов)
//
Процедура ПриСозданииНаСервереФормыСпискаДокументов(Форма, Настройки) Экспорт
	
	ИмяДокумента = ИнтеграцияИСКлиентСервер.ИмяОбъектаИзИмениФормы(Форма, Ложь);
	ИспользоватьСпискиКОформлению = Настройки.ТипыКОформлению <> Неопределено
		И Настройки.ТипыКОформлению.Тип.СодержитТип(Тип("ДокументСсылка." + ИмяДокумента));
	
	МетаРеквизитОснование      = ИнтеграцияИС.РеквизитДокументОснованиеДокументаИС(Метаданные.Документы[ИмяДокумента]);
	ТипыДокументаОснования     = МетаРеквизитОснование.Тип.Типы();
	СтрокиСоединенияДокументов = Новый Массив;
	СтрокиОтбораДокументов     = Новый Массив;
	ДокументИмеетОснования       = Ложь;
	
	// Подготовим строки соединения и отбора по доступным документам-основаниям.
	Для Каждого ТипОснования Из ТипыДокументаОснования Цикл
		
		МетаданныеОснования = Метаданные.НайтиПоТипу(ТипОснования);
		
		Если МетаданныеОснования = Неопределено Тогда
			Продолжить;
		ИначеЕсли Не Метаданные.Документы.Содержит(МетаданныеОснования) Тогда
			Продолжить;
		Иначе
			ДокументИмеетОснования = Истина;
		КонецЕсли;
		
		Если НЕ ПравоДоступа("Чтение", МетаданныеОснования) Тогда
			Продолжить;
		КонецЕсли;
		
		// Добавим соединение с документом-основанием для RLS.
		СтрокиСоединенияДокументов.Добавить("	ЛЕВОЕ СОЕДИНЕНИЕ Документ." + МетаданныеОснования.Имя + " КАК ДоступКДокументу" + МетаданныеОснования.Имя + "
			|		ПО Таблица.ДокументОснование = ДоступКДокументу" + МетаданныеОснования.Имя + ".Ссылка");
		
		СтрокиОтбораДокументов.Добавить("ДоступКДокументу" + МетаданныеОснования.Имя + ".Ссылка ЕСТЬ НЕ NULL");
		
	КонецЦикла;
	
	Если Не ДокументИмеетОснования Тогда
		
		// Документ не имеет основания
		ТекстСоединения               = "";
		ТекстОтбора                   = " ИЛИ ИСТИНА";
		ТекстОтбораКОформлению        = " И ЛОЖЬ";
		ИспользоватьСпискиКОформлению = Ложь;
		
	ИначеЕсли СтрокиОтбораДокументов.Количество() = 0 Тогда
		
		// Нет ни одного доступного документа-основания.
		ТекстСоединения               = "";
		ТекстОтбора                   = "";
		ТекстОтбораКОформлению        = " И ЛОЖЬ";
		ИспользоватьСпискиКОформлению = Ложь;
		
	Иначе
		
		ТекстСоединения         = СтрСоединить(СтрокиСоединенияДокументов, Символы.ПС);
		ТекстОтбора             = " ИЛИ " + СтрСоединить(СтрокиОтбораДокументов, Символы.ПС + " ИЛИ ");
		ТекстОтбораКОформлению  = " И ЛОЖЬ ИЛИ " + СтрСоединить(СтрокиОтбораДокументов, Символы.ПС + " ИЛИ ");
		
	КонецЕсли;
	
	ИменаВсехСписков                    = Новый Массив;
	СоответствеиИменСписковКОфоррмлению = Новый Соответствие;
	
	Если ЗначениеЗаполнено(Настройки.Списки) Тогда
		ИменаВсехСписков.Добавить(Настройки.Списки);
	КонецЕсли;
	
	СпискиКОформлению = Новый Структура(Настройки.КОформлению);
	
	Если ЗначениеЗаполнено(Настройки.КОформлению) И ИспользоватьСпискиКОформлению Тогда
		ИменаВсехСписков.Добавить(Настройки.КОформлению);
		Для Каждого ИмяСписка Из СпискиКОформлению Цикл
			СоответствеиИменСписковКОфоррмлению.Вставить(СокрЛП(ИмяСписка.Ключ), Истина);
		КонецЦикла;
	КонецЕсли;
	
	ИменаВсехСписков = СтрСоединить(ИменаВсехСписков, ",");
	
	//Выполним общие действия для всех динамических список формы.
	
	Для Каждого ИмяСписка Из Новый Структура(ИменаВсехСписков) Цикл
		
		Список = Форма[ИмяСписка.Ключ];
		
		ОбщегоНазначенияКлиентСервер.УстановитьПараметрДинамическогоСписка(
			Список,
			"ПустойДокументОснование",
			ИнтеграцияИС.МассивПустыхЗначенийСоставногоТипа(МетаРеквизитОснование.Тип));
		
		ОбщегоНазначенияКлиентСервер.УстановитьПараметрДинамическогоСписка(
			Список,
			"БезОтбораПоОрганизации",
			Истина);
		
		Список.ТекстЗапроса = СтрЗаменить(
			Список.ТекстЗапроса,
			"//%СоединениеСОснованиями%",
			?(СпискиКОформлению.Свойство(ИмяСписка.Ключ),
				СтрЗаменить(ТекстСоединения, ".ДокументОснование", ".Основание"),
				ТекстСоединения));
		
		Если СоответствеиИменСписковКОфоррмлению.Получить(ИмяСписка.Ключ) = Неопределено Тогда
			Список.ТекстЗапроса = СтрЗаменить(
				Список.ТекстЗапроса, "//%ОтборПоДоступнымОснованиям%", ТекстОтбора);
		Иначе
			Список.ТекстЗапроса = СтрЗаменить(
				Список.ТекстЗапроса, "//%ОтборПоДоступнымОснованиям%", ТекстОтбораКОформлению);
		КонецЕсли;
		
	КонецЦикла;
	
	Если Не ИспользоватьСпискиКОформлению Тогда
		
		Для Каждого ИмяСписка Из СпискиКОформлению Цикл
			
			Список = Форма[ИмяСписка.Ключ];
			Список.ОсновнаяТаблица = Неопределено;
			Список.ТекстЗапроса = 
			"ВЫБРАТЬ
			|Неопределено КАК Документ,
			|Неопределено КАК Ответственный,
			|Неопределено КАК СтатусОформления
			|ГДЕ ЛОЖЬ"
			
		КонецЦикла;
		
		Для Каждого ИмяЭлемента Из СтрРазделить(Настройки.ЭлементыКОформлению, ",", Ложь) Цикл
			
			Форма.Элементы[ИмяЭлемента].Видимость = Ложь;
			
		КонецЦикла;
		
		Для Каждого ИмяЭлемента Из СтрРазделить(Настройки.ЭлементыСтраницы, ",", Ложь) Цикл
			
			Форма.Элементы[ИмяЭлемента].ОтображениеСтраниц = ОтображениеСтраницФормы.Нет;
			
		КонецЦикла;
		
	КонецЕсли;
	
	УстановитьВидимостьКомандыВыполнитьОбмен(Форма, Настройки.ТипыКОбмену, Настройки.ЭлементыКОбмену);
	
	ИнтеграцияИСКлиентСервер.НастроитьОтборПоОрганизации(Форма, Форма.Организации, "Отбор");
	
КонецПроцедуры

// Устанавливает признак есть ли право на изменение списка документов у текущего пользователя 
//
Процедура УстановитьПризнакПравоИзмененияФормыСписка(ФормаСписка, ИмяРеквизита = "ПравоИзменения") Экспорт
	
	МассивРеквизитовФормы = ФормаСписка.ПолучитьРеквизиты();
	РеквизитНайден = Ложь;
	Для Каждого Реквизит Из МассивРеквизитовФормы Цикл
		Если Реквизит.Имя = ИмяРеквизита Тогда
			РеквизитНайден = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если Не РеквизитНайден Тогда
		Возврат;
	КонецЕсли;
	
	ИмяОсновнойТаблицыСписка = ФормаСписка.Список.ОсновнаяТаблица;
	ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ИмяОсновнойТаблицыСписка);
	ФормаСписка[ИмяРеквизита] = ПравоДоступа("Изменение", ОбъектМетаданных);
	
КонецПроцедуры

#КонецОбласти

// Определяет включение режима использования фоновых заданий при обмене с сервисами.
//
// Возвращаемое значение:
//  Булево - Ложь, если фоновые задания не используются.
//
Функция РежимРаботыБезФоновыхЗаданий() Экспорт
	
	ПараметрЗапускаПриложения = ПараметрыСеанса.ПараметрыКлиентаНаСервере.Получить("ПараметрЗапуска");
	
	Возврат СтрНайти(ВРег(ПараметрЗапускаПриложения), ВРег("РежимРаботыБезФоновыхЗаданийИС")) > 0;
	
КонецФункции

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
// Параметры:
//  ИдентификаторНазначения    - УникальныйИдентификатор, Неопределено - уникальный идентификатор формы для показа сообщения.
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных                 - ЛюбаяСсылка - объект или ключ записи информационной базы, к которому это сообщение относится.
//  Поле                       - Строка - наименование реквизита формы.
//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы).
//  Отказ                      - Булево - выходной параметр, всегда устанавливается в значение Истина.
//
// Примеры : см ОбщегоНазначенияКлиентСервер.СообщитьПользователю
//
Процедура СообщитьПользователюВФорму(
		Знач ИдентификаторНазначения = Неопределено,
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Если ИдентификаторНазначения <> Неопределено Тогда
		Сообщение.ИдентификаторНазначения = ИдентификаторНазначения;
	КонецЕсли;
	
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	ЭтоОбъект = Ложь;
	
	Если КлючДанных <> Неопределено
		И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = СтрНайти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры

Функция УчитываемыеВидыМаркируемойПродукции() Экспорт
	
	ВидыПродукции = Новый Массив;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ЕГАИС") Тогда
		ОбщийМодуль = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияЕГАИСВызовСервера");
		ВидыПродукцииЕГАИС = ОбщийМодуль.УчитываемыеВидыМаркируемойПродукции();
		ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ВидыПродукции, ВидыПродукцииЕГАИС);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ГосИС.ИСМП") Тогда
		ОбщийМодуль = ОбщегоНазначения.ОбщийМодуль("ИнтеграцияИСМПВызовСервера");
		ВидыПродукцииИСМП = ОбщийМодуль.УчитываемыеВидыМаркируемойПродукции();
		ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ВидыПродукции, ВидыПродукцииИСМП);
	КонецЕсли;
	
	Возврат ВидыПродукции;
	
КонецФункции

//Возвращает поля поиска строки табличной части по номенклутаре, характеристикике, опционально серии.
//
//Параметры:
//   ЕстьСерии - Булево - наличие колонки "Серия" в табличной части.
//   ЕстьGTIN - Булево - наличие колонки "GTIN" в табличной части.
//   ВидПродукции - ПеречислениеСсылка.ВидыПродукцииИС - специфика в табличной части
//      (молочная продукция с/без ВетИС - срок годности с/без идентификатора ВетИС, соответственно).
//
//Возвращаемое значение:
//   Структура - поля поиска:
// * Номенклатура - ОпределяемыйТип.Номенклатура - Пустоне значение номенклатуры.
// * Характеристика  - ОпределяемыйТип.ХарактеристикаНоменклатуры - Пустое значение характеристики.
// * Серия - ОпределяемыйТип.СерияНоменклатуры - Пустое значение серии. Может отсутствовать.
// * GTIN  - ОпределяемыйТип.GTIN - Пустое значение GTIN. Может отсутствовать.
// * ИдентификаторПроисхожденияВЕТИС - ОпределяемыйТип.ИдентификаторПроисхожденияВЕТИС - пустое значение идентификатора. Может отсутствовать.
// * СрокГодности - Дата - пустое значение срока годности. Может отсутствовать.
Функция ПоляПоискаМаркируемойПродукции(ЕстьСерии = Истина, ЕстьGTIN = Ложь, ВидПродукции = Неопределено) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Номенклатура",   ПустоеЗначениеОпределяемогоТипа("Номенклатура"));
	Результат.Вставить("Характеристика", ПустоеЗначениеОпределяемогоТипа("ХарактеристикаНоменклатуры"));
	
	Если ЕстьСерии Тогда
		Результат.Вставить("Серия", ПустоеЗначениеОпределяемогоТипа("СерияНоменклатуры"));
	КонецЕсли;
	
	Если ЕстьGTIN Тогда
		Результат.Вставить("GTIN", ПустоеЗначениеОпределяемогоТипа("GTIN"));
	КонецЕсли;
	
	Если ВидПродукции = Перечисления.ВидыПродукцииИС.МолочнаяПродукцияПодконтрольнаяВЕТИС Тогда
		Результат.Вставить("ИдентификаторПроисхожденияВЕТИС", ПустоеЗначениеОпределяемогоТипа("ИдентификаторПроисхожденияВЕТИС"));
		Результат.Вставить("СрокГодности", '00010101');
	ИначеЕсли ВидПродукции = Перечисления.ВидыПродукцииИС.МолочнаяПродукцияБезВЕТИС Тогда
		Результат.Вставить("СрокГодности", '00010101');
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область РаботаСXDTO

// Функция возвращает таблицу значений пользовательских представлений полей из макета
//
// Параметры:
//  ИмяМакета - Строка - имя общего макета из которого берутся представления
//    Структура макета: Табличный документ с XML:
//     * Элементы (список): Items,
//       * Вложенный элемент списка: Item, с атрибутами соответствующими колонкам результата
// Возвращаемое значение:
//  ТаблицаЗначений - см. ПустаяТаблицаПредставленийПолей()
//
Функция ПредставленияПолей(ИмяМакета)
	
	ТаблицаПредставлений = ПустаяТаблицаПредставленийПолей();
	
	Если ИмяМакета = Неопределено Тогда
		Возврат ТаблицаПредставлений;
	КонецЕсли;
	
	Макет = УправлениеПечатью.МакетПечатнойФормы(ИмяМакета);
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(Макет.ПолучитьТекст());
	
	Если Не ЧтениеXML.Прочитать() Тогда //пустой макет вполне валиден
		Возврат ТаблицаПредставлений;
	ИначеЕсли ЧтениеXML.Имя <> "Items" Тогда
		ВызватьИсключение НСтр("ru = 'Ошибка в структуре XML'");
	КонецЕсли;
	
	Пока ЧтениеXML.Прочитать() Цикл
		
		Если ЧтениеXML.ТипУзла = ТипУзлаXML.КонецЭлемента И ЧтениеXML.Имя = "Items" Тогда
			Прервать;
		ИначеЕсли ЧтениеXML.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли ЧтениеXML.Имя <> "Item" Тогда
			ВызватьИсключение НСтр("ru = 'Ошибка в структуре XML'");
		КонецЕсли;
		
		СтрокаПредставления = ТаблицаПредставлений.Добавить();
		СтрокаПредставления.ПространствоИмен = ЧтениеXML.ПолучитьАтрибут("ПространствоИмен");
		СтрокаПредставления.ЛокальноеИмя     = ЧтениеXML.ПолучитьАтрибут("ЛокальноеИмя");
		СтрокаПредставления.Представление    = ЧтениеXML.ПолучитьАтрибут("Представление");
		СтрокаПредставления.Глубина          = СтроковыеФункцииКлиентСервер.СтрокаВЧисло(ЧтениеXML.ПолучитьАтрибут("Глубина"));
		СтрокаПредставления.Обязательное     = Булево(СтроковыеФункцииКлиентСервер.СтрокаВЧисло(ЧтениеXML.ПолучитьАтрибут("Обязательное")));
		
	КонецЦикла;
	
	ТаблицаПредставлений.Сортировать("ПространствоИмен Возр");
	
	Возврат ТаблицаПредставлений;
	
КонецФункции

#КонецОбласти

Процедура ПеренестиДеревоРекурсивно(ДеревоИсточник, ДеревоПриемник, ОчищатьПриемник = Истина) Экспорт
	
	Если ОчищатьПриемник Тогда 
		ДеревоПриемник.ПолучитьЭлементы().Очистить();
	КонецЕсли;
	
	Для Каждого Элемент Из ДеревоИсточник.ПолучитьЭлементы() Цикл
		
		НовыйЭлемент = ДеревоПриемник.ПолучитьЭлементы().Добавить();
		ЗаполнитьЗначенияСвойств(НовыйЭлемент, Элемент);
		ПеренестиДеревоРекурсивно(Элемент,НовыйЭлемент,Ложь);
		
	КонецЦикла;
	
КонецПроцедуры

// Устанавливает видимость команды "Выполнить обмен" в формах документов, протокола и панели обмена.
//
Процедура УстановитьВидимостьКомандыВыполнитьОбмен(Форма, ТипыДляОбмена, ИменаЭлементов) Экспорт
	
	Если ТипыДляОбмена=Неопределено Или НЕ ИнтеграцияИС.ПравоИзмененияДокументовИзОпределяемогоТипа(ТипыДляОбмена) Тогда
		Для Каждого ЭлементФормы Из СтрРазделить(ИменаЭлементов, ",", Ложь) Цикл
			Кнопка = Форма.Элементы.Найти(ЭлементФормы);
			Если Кнопка <> Неопределено Тогда
				Кнопка.Видимость = Ложь;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры

Процедура СоставитьСтрокуСоставаУпаковки(СтрокаСостава, СтрокиТекущейЧасти, Знач ОграничительСостава, Уровень = 1)
	
	ЭтоПоследнийУровень = Не Уровень = 1;
	ОграничительСостава = Цел(ОграничительСостава / СтрокиТекущейЧасти.Количество());
	
	Для Каждого СтрокаЧастиНаименования Из СтрокиТекущейЧасти Цикл
		
		Если Не ПустаяСтрока(СтрокаСостава) Тогда
			Если Уровень = 1 Тогда
				Если Прав(СтрокаСостава, 1) = "," Тогда
					СтрокаСостава = Сред(СтрокаСостава, 1, СтрДлина(СтрокаСостава) - 1);
				КонецЕсли;
				СтрокаСостава = СтрокаСостава + ";";
			КонецЕсли;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(СтрокаЧастиНаименования["ЧастьНаименования" + Уровень]) Тогда
			СтрокаСостава = СтрШаблон("%1 %2", СтрокаСостава, СтрокаЧастиНаименования["ЧастьНаименования" + Уровень]);
		КонецЕсли;
		
		СтрокиСледующейЧасти = СтрокаЧастиНаименования.Строки;
		
		Если СтрокиСледующейЧасти.Количество() > 0
			И Цел(ОграничительСостава / СтрокиСледующейЧасти.Количество()) > 0 Тогда
			СоставитьСтрокуСоставаУпаковки(СтрокаСостава, СтрокиСледующейЧасти, ОграничительСостава, Уровень + 1);
			ЭтоПоследнийУровень = Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ЭтоПоследнийУровень Тогда
		СтрокаСостава = СтрокаСостава + ",";
	КонецЕсли;
	
КонецПроцедуры

// Проверяет, что проверяемый индекс операции является более общим для исходного индекса операции последовательности.
//
// Параметры:
//  ИндексОперации - Число - Индекс операции.
//  ИсходныйИндекс - Число - Исходный индекс операции.
// 
// Возвращаемое значение:
//  Булево - Исходный индекс операции принадлежит к индексу текущий операции.
//
Функция ПроверитьИндекс(ИндексОперации, ИсходныйИндекс)
	
	Если ИндексОперации <> ИсходныйИндекс Тогда
		Если СтрДлина(ИсходныйИндекс) = СтрДлина(ИндексОперации) Тогда
			Возврат Истина;
		Иначе
			Если СтрДлина(ИсходныйИндекс) > 1 Тогда
				Возврат ПроверитьИндекс(ИндексОперации, Лев(ИсходныйИндекс, СтрДлина(ИсходныйИндекс) - 1));
			Иначе
				Возврат Истина;
			КонецЕсли;
		КонецЕсли;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

Функция БазовыеПараметрыОбработкиТабличнойЧастиТовары(ВидыПродукции = Неопределено)
	
	ПараметрыЗаполнения = Новый Структура;
	
	ПараметрыЗаполнения.Вставить("ВидыПродукцииИС",                Новый Массив);
	ПараметрыЗаполнения.Вставить("ЗаполнитьАртикул",               Ложь);
	ПараметрыЗаполнения.Вставить("ЗаполнитьКод",                   Ложь);
	ПараметрыЗаполнения.Вставить("ЗаполнитьЕдиницуИзмерения",      Истина);
	ПараметрыЗаполнения.Вставить("ЗаполнитьТипНоменклатуры",       Истина);
	ПараметрыЗаполнения.Вставить("ОбработатьУпаковки",             Истина);
	ПараметрыЗаполнения.Вставить("ПересчитатьКоличествоЕдиниц",    Истина);
	ПараметрыЗаполнения.Вставить("ПересчитатьКоличествоУпаковок",  Истина);
	ПараметрыЗаполнения.Вставить("ПересчитатьСумму",               Ложь);
	ПараметрыЗаполнения.Вставить("ПересчитатьЦенуПоСумме",         Ложь);
	ПараметрыЗаполнения.Вставить("ПроверитьСериюРассчитатьСтатус", Ложь);
	ПараметрыЗаполнения.Вставить("ШтрихкодыВТЧ",                   Ложь);
	ПараметрыЗаполнения.Вставить("МаркируемаяПродукцияВТЧ",        Ложь);
	ПараметрыЗаполнения.Вставить("ЗаполнитьКодТНВЭД",              Ложь);
	
	Если ВидыПродукции <> Неопределено Тогда
		ПараметрыЗаполнения.ВидыПродукцииИС = ВидыПродукции;
	КонецЕсли;
	
	Возврат ПараметрыЗаполнения;
	
КонецФункции

#КонецОбласти