#Область ПрограммныйИнтерфейс

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой.
// Вызов процедуры необходимо выполнять в обработчике ПриСозданииНаСервере
// формы организации.
Процедура ОрганизацииФормаЭлементаПриСозданииНаСервере(Форма) Экспорт
	
	Если Форма.Параметры.Ключ.Пустая() Тогда
		РедактированиеПериодическихСведений.ИнициализироватьЗаписьДляРедактированияВФорме(Форма, "ИсторияРегистрацийВОрганеПФР", Форма.ОрганизацияСсылка);
		РедактированиеПериодическихСведений.ИнициализироватьЗаписьДляРедактированияВФорме(Форма, "ТерриториальныеУсловияПФР", Форма.ОрганизацияСсылка);
	КонецЕсли;
	
	Форма.УстановитьПараметрыФункциональныхОпцийФормы(Новый Структура("Организация", Форма.Объект.Ссылка));
	
	// Позиционирование на элементах формы
	// см. ЭлектронныйДокументооборотСКонтролирующимиОрганамиКлиентПереопределяемый.ОткрытьФормуОрганизацииНаРеквизите.
	
	Если Форма.Параметры.Свойство("ИмяРеквизита") И Не ПустаяСтрока(Форма.Параметры.ИмяРеквизита) Тогда
		
		Если Не ПустаяСтрока(Форма.Параметры.ИмяРеквизита) Тогда
			
			ИмяРеквизита = "";
			ИмяСтраницы = "";
			Если Форма.Параметры.ИмяРеквизита = "КраткоеНаименование" Тогда
				ИмяРеквизита = "НаименованиеСокращенное";
			ИначеЕсли Форма.Параметры.ИмяРеквизита = "ПолноеНаименование" Тогда
				ИмяРеквизита = "НаименованиеПолное";
			ИначеЕсли Форма.Параметры.ИмяРеквизита = "ИНН" Тогда
				ИмяРеквизита = "ИНН";
			ИначеЕсли Форма.Параметры.ИмяРеквизита = "РегНомерПФР" Тогда
				ИмяРеквизита = "ОрганизацияРегистрационныйНомерПФР";
				ИмяСтраницы = "ГруппаФонды";
			ИначеЕсли Форма.Параметры.ИмяРеквизита = "РегНомерФСС" Тогда
				ИмяРеквизита = "ОрганизацияРегистрационныйНомерФСС";
				ИмяСтраницы = "ГруппаФонды";
			ИначеЕсли Форма.Параметры.ИмяРеквизита = "ДополнительныйКодФСС" Тогда
				ИмяРеквизита = "ОрганизацияДополнительныйКодФСС";
				ИмяСтраницы = "ГруппаФонды";
			ИначеЕсли Форма.Параметры.ИмяРеквизита = "ОГРН" Тогда
				ИмяРеквизита = "ОГРН";
			КонецЕсли;
	
			Если Не ПустаяСтрока(ИмяСтраницы) Тогда
				ТекущаяСтраница = Форма.Элементы.Найти(ИмяСтраницы);
				Если ТекущаяСтраница <> Неопределено Тогда
					Форма.Элементы.ГруппаСтраницы.ТекущаяСтраница = ТекущаяСтраница;
				КонецЕсли;
			КонецЕсли;
			
			Если Не ПустаяСтрока(ИмяРеквизита) Тогда
				ТекущийЭлемент = Форма.Элементы.Найти(ИмяРеквизита);
				Если ТекущийЭлемент <> Неопределено Тогда
					Форма.ТекущийЭлемент = ТекущийЭлемент;
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой.
// Вызов процедуры необходимо выполнять в обработчике ПриЧтенииНаСервере
// формы организации.
Процедура ОрганизацииФормаЭлементаПриЧтенииНаСервере(Форма) Экспорт
	
	ПрочитатьПериодическиеСведенияОрганизации(Форма);
	
КонецПроцедуры

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой.
// Вызов процедуры необходимо выполнять в обработчике ПередЗаписьюНаСервере
// формы организации.
Процедура ОрганизацииФормаЭлементаПередЗаписьюНаСервере(Форма) Экспорт
	
	ЗаписатьПериодическиеСведенияОрганизации(Форма);
	
КонецПроцедуры

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой.
// Вызов процедуры необходимо выполнять в обработчике ПослеЗаписиНаСервере
// формы организации.
Процедура ОрганизацииФормаЭлементаПослеЗаписиНаСервере(Форма) Экспорт
	
	ПрочитатьПериодическиеСведенияОрганизации(Форма);
	
	ОбновитьПовторноИспользуемыеЗначения();
	
КонецПроцедуры

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой.
// Вызов процедуры необходимо выполнять в обработчике ОбработкаПроверкиЗаполненияНаСервере
// формы организации.
Процедура ОрганизацииФормаЭлементаОбработкаПроверкиЗаполненияНаСервере(Форма, Отказ) Экспорт
	
	РедактированиеПериодическихСведений.ПроверитьЗаписьВФорме(Форма, "ИсторияРегистрацийВОрганеПФР", Форма.ОрганизацияСсылка, Отказ);
	РедактированиеПериодическихСведений.ПроверитьЗаписьВФорме(Форма, "ТерриториальныеУсловияПФР", Форма.ОрганизацияСсылка, Отказ);
	
КонецПроцедуры

// Регистрация оплаты ведомостей.
//
// Параметры:
//		ПлатежныйДокумент - ДокументОбъект - платежный документ.
//		Организация       - СправочникСсылка.Организации - организация, выплачивающая зарплату.
//		Ведомости         - Массив - оплачиваемые ведомости (ОпределяемыйТип.ВедомостьЗарплатаКадры)  
//		ФизическиеЛица    - Массив - физические лица (СправочникСсылка.ФизическиеЛица), получившие выплаты по ведомостям 
//		ДатаОперации      - Дата   - дата фактического выполнения оплаты. Если не указана, используется дата платежного документа.
//		Отказ             - Булево - признак отказа от выполнения операции.
//
Процедура ЗарегистрироватьОплатуВедомостей(ПлатежныйДокумент, Организация, Ведомости, ФизическиеЛица = Неопределено, ДатаОперации = Неопределено, Отказ = Ложь) Экспорт
	ЗарплатаКадрыВнутренний.ЗарегистрироватьОплатуВедомостей(ПлатежныйДокумент, Организация, Ведомости, ФизическиеЛица, ДатаОперации, Отказ);
КонецПроцедуры

// Выполняет формирование таблицы с набором значений доступа объекта (документа), 
// содержащего ссылки на организацию и сотрудника (сотрудников).
// Вызывается из процедуры ЗаполнитьНаборыЗначенийДоступа, реализованной в модуле таких 
// документов, доступ к которым выполняется через наборы значений доступа.
// Параметры:
//		Объект
//		Таблица - переданная таблица значений.
//		ПутьОрганизация - строка с именем реквизита, содержащего организацию.
//		ПутьСотрудник - строка с именем реквизита, содержащего сотрудника.
//			Может быть идентификатором реквизита объекта (например, "Сотрудник") или
//			путем к реквизиту табличной части в 
//			формате <ИмяТабличнойЧасти>.<ИмяРеквизита> 
//			(например, "Начисления.Сотрудник").
//
Процедура ЗаполнитьНаборыПоОрганизацииИСотрудникам(Объект, Таблица, ПутьОрганизация, ПутьСотрудник) Экспорт
	
	// Логика ограничения:
	// объект доступен, если доступна организация и все физические лица.
	
	СтрокаТаб = Таблица.Добавить();
	СтрокаТаб.ЗначениеДоступа = Объект[ПутьОрганизация];
	
	СтрокиПутиСотрудника = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьСотрудник, ".");
	Если СтрокиПутиСотрудника.Количество() = 1 Тогда
		СтрокаТаб = Таблица.Добавить();
		СтрокаТаб.ЗначениеДоступа = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Объект[ПутьСотрудник], "ФизическоеЛицо");
		
	Иначе
		Сотрудники = Новый Массив;
		Для Каждого СтрокаТаблицы Из Объект[СтрокиПутиСотрудника[0]] Цикл
			Сотрудники.Добавить(СтрокаТаблицы[СтрокиПутиСотрудника[1]]);
		КонецЦикла;
		// Получим значения физлиц
		ФизлицаСотрудников = ОбщегоНазначения.ЗначениеРеквизитаОбъектов(Сотрудники, "ФизическоеЛицо");
		МассивФизлицСотрудников = ОбщегоНазначения.ВыгрузитьКолонку(ФизлицаСотрудников, "Значение", Истина);
		
		Для Каждого ФизическоеЛицо Из МассивФизлицСотрудников Цикл
			СтрокаТаб = Таблица.Добавить();
			СтрокаТаб.ЗначениеДоступа = ФизическоеЛицо;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Функция возвращает сведения о сотрудниках (застрахованных в ПФР), работавших в организации в указанном отчетном
// периоде.
//
// Параметры:
//  Организация - СправочникСсылка.Организации, организация (головная, 
//				либо обособленное подразделение с выделенным балансом) 
//				по которой требуется получить сведения.
//  ОтчетныйПериод - дата, определяет отчетный период ПФР (квартал).
//
// Возвращаемое значение:
//  ТаблицаЗначений с колонками "Фамилия", "Имя", "Отчество" и "СтраховойНомерПФР", в которых
//  содержится информация о фамилии, имени, отчестве и страховом номере (СНИЛС) каждого
//  из сотрудников (застрахованных лиц) организации соответственно.
//
Функция СписокЗастрахованныхЛицОрганизацииЗаОтчетныйПериодПФР(Организация, ОтчетныйПериод) Экспорт 

  НачалоПериода = ПерсонифицированныйУчетКлиентСервер.ПолучитьНачалоОтчетногоПериода(ОтчетныйПериод);
  ОкончаниеПериода = ПерсонифицированныйУчетКлиентСервер.ОкончаниеОтчетногоПериодаПерсУчета(ОтчетныйПериод);
  
  Возврат УчетСтраховыхВзносов.СписокЗастрахованныхЛицОрганизации(Организация, НачалоПериода, ОкончаниеПериода);
  
КонецФункции

// Возвращает ссылку на "Регистрацию в налоговом органе" по состоянию на некоторую ДатаАктуальности.
//
// Параметры:
//		СтруктурнаяЕдиница	- организация или подразделение.
//		ДатаАктуальности	- дата, на которую берется регистрация в налоговом органе.
//
//	Возвращаемое значение:
//		СправочникСсылка.РегистрацииВНалоговомОргане
//
Функция РегистрацияВНалоговомОргане(СтруктурнаяЕдиница, Знач ДатаАктуальности = Неопределено) Экспорт
	Возврат ЗарплатаКадрыПовтИсп.РегистрацияВНалоговомОргане(СтруктурнаяЕдиница, ДатаАктуальности)
КонецФункции

// Используется для получения ссылки на регистрацию в налоговом органе организации.
//
// Параметры:
//  Организация             - СправочникСсылка.Организации  - организация, для которой нужно получить регистрацию.
//  ДатаАктуальности        - Дата                          - дата, на которую необходимо получить регистрацию в НО.
// 
// Возвращаемое значение:
//  СправочникСсылка.РегистрацииВНалоговомОргане - ссылка на существующую регистрацию, либо ПустаяСсылка().
//
Функция РегистрацияВНалоговомОрганеОрганизации(Организация, Знач ДатаАктуальности = Неопределено) Экспорт
	
	ПоследняяРегистрацияВНалоговомОргане = РегистрыСведений.ИсторияРегистрацийВНалоговомОргане.ПолучитьПоследнее(
		ДатаАктуальности,
 		Новый Структура("СтруктурнаяЕдиница", Организация));
		
	Если ЗначениеЗаполнено(ПоследняяРегистрацияВНалоговомОргане.РегистрацияВНалоговомОргане) Тогда
		Возврат ПоследняяРегистрацияВНалоговомОргане.РегистрацияВНалоговомОргане;
	КонецЕсли;
	
	Возврат Справочники.РегистрацииВНалоговомОргане.ПустаяСсылка();

КонецФункции

// Используется для получения ссылки на регистрацию в налоговом органе подразделения.
//
// Параметры:
//  ПодразделениеОрганизации - СправочникСсылка.ПодразделенияОрганизаций  - подразделение, для которого нужно получить регистрацию.
//  ДатаАктуальности         - Дата                                       - дата, на которую необходимо получить
//                                                                          регистрацию в НО.
// 
// Возвращаемое значение:
//  СправочникСсылка.РегистрацииВНалоговомОргане - ссылка на существующую регистрацию, либо ПустаяСсылка().
//
Функция РегистрацияВНалоговомОрганеПодразделения(ПодразделениеОрганизации, Знач ДатаАктуальности = Неопределено) Экспорт
	
	ПоследняяРегистрацияВНалоговомОргане = РегистрыСведений.ИсторияРегистрацийВНалоговомОргане.ПолучитьПоследнее(
		ДатаАктуальности,
 		Новый Структура("СтруктурнаяЕдиница", ПодразделениеОрганизации));
	
	Если ЗначениеЗаполнено(ПоследняяРегистрацияВНалоговомОргане.РегистрацияВНалоговомОргане) Тогда
		Возврат ПоследняяРегистрацияВНалоговомОргане.РегистрацияВНалоговомОргане;
	КонецЕсли;
	
	Если ПодразделениеОрганизации.ОбособленноеПодразделение Тогда
		Возврат Справочники.РегистрацииВНалоговомОргане.ПустаяСсылка();
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ПодразделениеОрганизации.Родитель) Тогда
		Возврат РегистрацияВНалоговомОргане(ПодразделениеОрганизации.Родитель, ДатаАктуальности);
	ИначеЕсли ЗначениеЗаполнено(ПодразделениеОрганизации.Владелец) Тогда
		Возврат РегистрацияВНалоговомОргане(ПодразделениеОрганизации.Владелец, ДатаАктуальности);
	КонецЕсли;
	
КонецФункции

// Функция возвращает значение настройки использования учета по статьям финансирования.
//
//	Возвращаемое значение:
//		Булево
//
Функция ИспользоватьСтатьиФинансированияЗарплата() Экспорт

	УстановитьПривилегированныйРежим(Истина);
	Возврат Константы.ИспользоватьСтатьиФинансированияЗарплата.Получить();

КонецФункции

#Область ДляВызоваИзДругихПодсистем

// См. ОбщегоНазначенияПереопределяемый.ПриДобавленииИсключенийПоискаСсылок.
Процедура ПриДобавленииИсключенийПоискаСсылок(ИсключенияПоискаСсылок) Экспорт
	УчетПособийСоциальногоСтрахования.ПриДобавленииИсключенийПоискаСсылок(ИсключенияПоискаСсылок);
КонецПроцедуры

// Конец СтандартныеПодсистемы.БазоваяФункциональность

// СтандартныеПодсистемы.ВариантыОтчетов

// См. ВариантыОтчетовПереопределяемый.ПередДобавлениемКомандОтчетов.
Процедура ОпределитьОбъектыСКомандамиОтчетов(Объекты) Экспорт
	ЗарплатаКадрыВнутренний.ОпределитьОбъектыСКомандамиОтчетов(Объекты);
КонецПроцедуры

// Конец СтандартныеПодсистемы.ВариантыОтчетов

// СтандартныеПодсистемы.ДатыЗапретаИзменения

// См. ДатыЗапретаИзмененияПереопределяемый.ПриЗаполненииРазделовДатЗапретаИзменения.
Процедура ПриЗаполненииРазделовДатЗапретаИзменения(Разделы) Экспорт
	ЗарплатаКадрыВнутренний.ПриЗаполненииРазделовДатЗапретаИзменения(Разделы);
КонецПроцедуры

// См. ДатыЗапретаИзмененияПереопределяемый.ЗаполнитьИсточникиДанныхДляПроверкиЗапретаИзменения.
Процедура ЗаполнитьИсточникиДанныхДляПроверкиЗапретаИзменения(ИсточникиДанных) Экспорт
	
	// ЗарплатаКадрыПодсистемы.ПособияСоциальногоСтрахования
	УчетПособийСоциальногоСтрахования.ЗаполнитьИсточникиДанныхДляПроверкиЗапретаИзменения(ИсточникиДанных);
	// Конец ЗарплатаКадрыПодсистемы.ПособияСоциальногоСтрахования
	
	ЗарплатаКадрыВнутренний.ЗаполнитьИсточникиДанныхДляПроверкиЗапретаИзменения(ИсточникиДанных);
	
КонецПроцедуры

// См. ДатыЗапретаИзмененияПереопределяемый.ПередПроверкойЗапретаИзменения.
//  Проверяет дополнительное свойство объекта с ключом ОтключитьПроверкуДатыЗапретаИзменения.
//  Если значение свойства Истина, то проверка даты запрета изменения не производится.
//
Процедура ПередПроверкойЗапретаИзменения(Объект, ПроверкаЗапретаИзменения, УзелПроверкиЗапретаЗагрузки, ВерсияОбъекта) Экспорт
	
	Если Объект.ДополнительныеСвойства.Свойство("ОтключитьПроверкуДатыЗапретаИзменения")
		И Объект.ДополнительныеСвойства.ОтключитьПроверкуДатыЗапретаИзменения Тогда
		
		ПроверкаЗапретаИзменения = Ложь;
		УзелПроверкиЗапретаЗагрузки = Неопределено;
		
	КонецЕсли;
	
	ЗарплатаКадрыВнутренний.ПроверитьИсключенияПроверкиЗапретаИзменения(Объект, ПроверкаЗапретаИзменения, УзелПроверкиЗапретаЗагрузки, ВерсияОбъекта);
	
	Если ПроверкаЗапретаИзменения Тогда
		
		МетаданныеОбъекта = Объект.Метаданные();
		Если ОбщегоНазначения.ЭтоДокумент(МетаданныеОбъекта)
			И ЭтоОбъектЗарплатноКадровойБиблиотеки(МетаданныеОбъекта.ПолноеИмя()) Тогда
			
			// Отказ от проверки непроведенных документов.
			Если Объект.ЭтоНовый() Тогда
				ПроведенСтараяВерсия = Ложь;
			Иначе
				
				Если МетаданныеОбъекта.Проведение = Метаданные.СвойстваОбъектов.Проведение.Запретить Тогда
					Проведен = Не ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Объект.Ссылка, "ПометкаУдаления");
				Иначе
					Проведен = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Объект.Ссылка, "Проведен");
				КонецЕсли;
				
				ПроведенСтараяВерсия = ?(ТипЗнч(Проведен) <> Тип("Булево"), Ложь, Проведен);
				
			КонецЕсли;
			
			РежимЗаписи = Неопределено;
			Если Объект.ДополнительныеСвойства.Свойство("РежимЗаписи") Тогда
				РежимЗаписи = Объект.ДополнительныеСвойства.РежимЗаписи;
			КонецЕсли;
			
			Если РежимЗаписи = РежимЗаписиДокумента.Проведение Тогда
				ПроведенНоваяВерсия = Истина;
			ИначеЕсли РежимЗаписи = РежимЗаписиДокумента.ОтменаПроведения Тогда
				ПроведенНоваяВерсия = Ложь;
			Иначе
				
				Если МетаданныеОбъекта.Проведение = Метаданные.СвойстваОбъектов.Проведение.Запретить Тогда
					ПроведенНоваяВерсия = Не Объект.ПометкаУдаления;
				Иначе
					ПроведенНоваяВерсия = Объект.Проведен;
				КонецЕсли;
				
			КонецЕсли;
			
			Если Не ПроведенНоваяВерсия И Не ПроведенСтараяВерсия Тогда
				ПроверкаЗапретаИзменения = Ложь;
				УзелПроверкиЗапретаЗагрузки = Неопределено;
			ИначеЕсли Не ПроведенНоваяВерсия Тогда
				ВерсияОбъекта = "СтараяВерсия";
			ИначеЕсли Не ПроведенСтараяВерсия Тогда
				ВерсияОбъекта = "НоваяВерсия";
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.ДатыЗапретаИзменения

// СтандартныеПодсистемы.ЗапретРедактированияРеквизитовОбъектов

// См. ЗапретРедактированияРеквизитовОбъектовПереопределяемый.ПриОпределенииОбъектовСЗаблокированнымиРеквизитами
//
Процедура ПриОпределенииОбъектовСЗаблокированнымиРеквизитами(Объекты) Экспорт
	ЗарплатаКадрыВнутренний.ПриОпределенииОбъектовСЗаблокированнымиРеквизитами(Объекты);
КонецПроцедуры

// Конец СтандартныеПодсистемы.ЗапретРедактированияРеквизитовОбъектов

// СтандартныеПодсистемы.ГрупповоеИзменениеОбъектов

// См. ГрупповоеИзменениеОбъектовПереопределяемый.ПриОпределенииОбъектовСРедактируемымиРеквизитами
//
Процедура ПриОпределенииОбъектовСРедактируемымиРеквизитами(Объекты) Экспорт
	
	КадровыйУчет.ПриОпределенииОбъектовСРедактируемымиРеквизитами(Объекты);
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.ГрупповоеИзменениеОбъектов

// СтандартныеПодсистемы.ПодключаемыеКоманды

// См. ПодключаемыеКомандыПереопределяемый.ПриОпределенииВидовПодключаемыхКоманд.
Процедура ПриОпределенииВидовПодключаемыхКоманд(ВидыПодключаемыхКоманд) Экспорт
	ЗарплатаКадрыВнутренний.ПриОпределенииВидовПодключаемыхКоманд(ВидыПодключаемыхКоманд);
КонецПроцедуры

// См. ПодключаемыеКомандыПереопределяемый.ПриОпределенииСоставаНастроекПодключаемыхОбъектов.
Процедура ПриОпределенииСоставаНастроекПодключаемыхОбъектов(НастройкиПрограммногоИнтерфейса) Экспорт
	ЗарплатаКадрыВнутренний.ПриОпределенииСоставаНастроекПодключаемыхОбъектов(НастройкиПрограммногоИнтерфейса);
КонецПроцедуры

// См. ПодключаемыеКомандыПереопределяемый.ПриОпределенииКомандПодключенныхКОбъекту.
Процедура ПриОпределенииКомандПодключенныхКОбъекту(НастройкиФормы, Источники, ПодключенныеОтчетыИОбработки, Команды) Экспорт
	ЗарплатаКадрыВнутренний.ПриОпределенииКомандПодключенныхКОбъекту(НастройкиФормы, Источники, ПодключенныеОтчетыИОбработки, Команды);
КонецПроцедуры

// Конец СтандартныеПодсистемы.ПодключаемыеКоманды

// СтандартныеПодсистемы.ЗавершениеРаботыПользователей

// См. СоединенияИБПереопределяемый.ПриОпределенииПараметровБлокировкиСеансов.
Процедура ПриОпределенииПараметровБлокировкиСеансов(ПараметрыБлокировкиСеансов) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыРасширеннаяПодсистемы") Тогда
		МодульЗарплатаКадрыРасширенный = ОбщегоНазначения.ОбщийМодуль("ЗарплатаКадрыРасширенный");
		МодульЗарплатаКадрыРасширенный.ПриОпределенииПараметровБлокировкиСеансов(ПараметрыБлокировкиСеансов);
	КонецЕсли;
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.ЗавершениеРаботыПользователей

// СтандартныеПодсистемы.Свойства

// См. УправлениеСвойствамиПереопределяемый.ПриПолученииПредопределенныхНаборовСвойств.
Процедура ПриПолученииПредопределенныхНаборовСвойств(Наборы) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриПолученииПредопределенныхНаборовСвойств(Наборы);
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.Свойства

// СтандартныеПодсистемы.ЗащитаПерсональныхДанных

// См. ЗащитаПерсональныхДанныхПереопределяемый.ЗаполнитьСведенияОПерсональныхДанных.
Процедура ЗаполнитьСведенияОПерсональныхДанных(ТаблицаСведений) Экспорт
	
	ЗарплатаКадрыВнутренний.ЗаполнитьСведенияОПерсональныхДанных(ТаблицаСведений);
	
КонецПроцедуры

// См. ЗащитаПерсональныхДанныхПереопределяемый.ЗаполнитьОбластиПерсональныхДанных.
Процедура ЗаполнитьОбластиПерсональныхДанных(ОбластиПерсональныхДанных) Экспорт
	
	ЗарплатаКадрыВнутренний.ЗаполнитьОбластиПерсональныхДанных(ОбластиПерсональныхДанных);
	
КонецПроцедуры

// См. ЗащитаПерсональныхДанныхПереопределяемый.ДополнитьДанныеСубъектовПерсональныхДанных.
Процедура ДополнитьДанныеСубъектовПерсональныхДанных(СубъектыПерсональныхДанных, ДатаАктуальности) Экспорт 
	
	СписокФизическихЛиц = ОбщегоНазначения.ВыгрузитьКолонку(СубъектыПерсональныхДанных, "Субъект", Истина);	
	КадровыеДанные = "ФИОПолные, ДокументПредставление, АдресПоПропискеПредставление";
	
	КадровыеДанныеФизическихЛиц = КадровыйУчет.КадровыеДанныеФизическихЛиц(Истина, СписокФизическихЛиц, КадровыеДанные, ДатаАктуальности);
	
	Для Каждого ТекСтрока Из СубъектыПерсональныхДанных Цикл 
		КадровыеДанныеФизическогоЛица = КадровыеДанныеФизическихЛиц.Найти(ТекСтрока.Субъект, "ФизическоеЛицо");
		Если КадровыеДанныеФизическогоЛица <> Неопределено Тогда
			ТекСтрока.ФИО = КадровыеДанныеФизическогоЛица.ФИОПолные;
			ТекСтрока.Адрес = КадровыеДанныеФизическогоЛица.АдресПоПропискеПредставление;
			ТекСтрока.ПаспортныеДанные = Строка(КадровыеДанныеФизическогоЛица.ДокументПредставление);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// См. ЗащитаПерсональныхДанныхПереопределяемый.ДополнитьДанныеОрганизацииОператораПерсональныхДанных.
Процедура ДополнитьДанныеОрганизацииОператораПерсональныхДанных(Организация, ДанныеОрганизации, ДатаАктуальности) Экспорт 

	АдресаОрганизаций = УправлениеКонтактнойИнформациейЗарплатаКадры.АдресаОрганизаций(Организация, ДатаАктуальности);
	ДанныеОрганизации.АдресОрганизации = УправлениеКонтактнойИнформациейЗарплатаКадры.АдресОрганизации(АдресаОрганизаций, Организация, Справочники.ВидыКонтактнойИнформации.ЮрАдресОрганизации).Представление;
	
	ДанныеОрганизации.Вставить("НаименованиеОрганизации", ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Организация, "НаименованиеПолное"));
	
КонецПроцедуры

// См. ЗащитаПерсональныхДанныхПереопределяемый.ПередСкрытиемПерсональныхДанныхСубъектов.
Процедура ПередСкрытиемПерсональныхДанныхСубъектов(Субъекты, ТаблицаИсключений, Отказ) Экспорт
	
	ЗарплатаКадрыВнутренний.ПередСкрытиемПерсональныхДанныхСубъектов(Субъекты, ТаблицаИсключений, Отказ);
	
КонецПроцедуры

// См. ЗащитаПерсональныхДанныхПереопределяемый.ЗаполнитьФИОФизическогоЛица.
Процедура ПриЗаполненииФИОФизическогоЛица(ФизическоеЛицо, ФИО) Экспорт
	
	Если Не ЗначениеЗаполнено(ФизическоеЛицо) Тогда
		Возврат;
	КонецЕсли;
	
	КадровыеДанные = КадровыйУчет.КадровыеДанныеФизическихЛиц(Истина, ФизическоеЛицо, "ФИО");
	
	Если КадровыеДанные.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ФИО = КадровыеДанные[0]["ФИО"];
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.ЗащитаПерсональныхДанных

// СтандартныеПодсистемы.КонтрольВеденияУчета

// См. КонтрольВеденияУчетаПереопределяемый.ПриОпределенииПроверок.
Процедура ПриОпределенииПроверок(ГруппыПроверок, Проверки) Экспорт
	ЗарплатаКадрыВнутренний.ПриОпределенииПроверок(ГруппыПроверок, Проверки);
КонецПроцедуры

// Конец СтандартныеПодсистемы.КонтрольВеденияУчета

// СтандартныеПодсистемы.НастройкиПрограммы

// См. НастройкиПрограммыПереопределяемый.НастройкиПользователейИПравПриСозданииНаСервере.
Процедура НастройкиПользователейИПравПриСозданииНаСервере(Форма) Экспорт
	
	ЗарплатаКадрыВнутренний.НастройкиПользователейИПравПриСозданииНаСервере(Форма);
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.НастройкиПрограммы

// СтандартныеПодсистемы.Печать

// См. УправлениеПечатьюПереопределяемый.ПриОпределенииОбъектовСКомандамиПечати.
Процедура ПриОпределенииОбъектовСКомандамиПечати(СписокОбъектов) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриОпределенииОбъектовСКомандамиПечати(СписокОбъектов);
	
КонецПроцедуры

// См. УправлениеПечатьюПереопределяемый.ПриПолученииНастроекСпискаКомандПечати.
Процедура ПриПолученииНастроекСпискаКомандПечати(НастройкиСписка) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриПолученииНастроекСпискаКомандПечати(НастройкиСписка);
	
КонецПроцедуры

// См. УправлениеПечатьюПереопределяемый.ПриДобавленииКомандПечати.
Процедура ПриДобавленииКомандПечати(ИмяФормы, КомандыПечати) Экспорт
	ЗарплатаКадрыВнутренний.ПриДобавленииКомандПечати(ИмяФормы, КомандыПечати);
КонецПроцедуры

// См. УправлениеПечатьюПереопределяемый.ПечатьДокументовПриСозданииНаСервере.
Процедура ПечатьДокументовПриСозданииНаСервере(Форма, Отказ, СтандартнаяОбработка) Экспорт
	
	УправлениеПечатьюБЗК.ПечатьДокументовПриСозданииНаСервере(Форма, Отказ, СтандартнаяОбработка);
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.Печать

// СтандартныеПодсистемы.ПрофилиБезопасности

// См. РаботаВБезопасномРежимеПереопределяемый.ПриЗаполненииРазрешенийНаДоступКВнешнимРесурсам.
//
Процедура ПриЗаполненииРазрешенийНаДоступКВнешнимРесурсам(ЗапросыРазрешений) Экспорт
	ЗарплатаКадрыВнутренний.ПриЗаполненииРазрешенийНаДоступКВнешнимРесурсам(ЗапросыРазрешений);
КонецПроцедуры

// Конец СтандартныеПодсистемы.ПрофилиБезопасности

// СтандартныеПодсистемы.Пользователи

// См. ПользователиПереопределяемый.ПриОпределенииНазначенияРолей.
Процедура ПриОпределенииНазначенияРолей(НазначениеРолей) Экспорт
	ЗарплатаКадрыВнутренний.ПриОпределенииНазначенияРолей(НазначениеРолей)
КонецПроцедуры

// Конец СтандартныеПодсистемы.Пользователи

// СтандартныеПодсистемы.ПрефиксацияОбъектов

// См. ПрефиксацияОбъектовПереопределяемый.ПолучитьПрефиксообразующиеРеквизиты.
Процедура ПолучитьПрефиксообразующиеРеквизиты(Объекты) Экспорт
	
	// ЗарплатаКадрыПодсистемы.ПособияСоциальногоСтрахования
	УчетПособийСоциальногоСтрахования.ПолучитьПрефиксообразующиеРеквизиты(Объекты);
	// Конец ЗарплатаКадрыПодсистемы.ПособияСоциальногоСтрахования
	
	ЗарплатаКадрыВнутренний.ПолучитьПрефиксообразующиеРеквизиты(Объекты);
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.ПрефиксацияОбъектов

// СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий

// См. ОчередьЗаданийПереопределяемый.ПриПолученииСпискаШаблонов.
Процедура ПриПолученииСпискаШаблоновОчередиЗаданий(Шаблоны) Экспорт
	
	КабинетСотрудника.ПриПолученииСпискаШаблоновОчередиЗаданий(Шаблоны);
	ЗарплатаКадрыВнутренний.ПриПолученииСпискаШаблоновОчередиЗаданий(Шаблоны);
	
КонецПроцедуры

// См. ОчередьЗаданийПереопределяемый.ПриОпределенииПсевдонимовОбработчиков.
Процедура ПриОпределенииПсевдонимовОбработчиков(СоответствиеИменПсевдонимам) Экспорт
	
	КабинетСотрудника.ПриОпределенииПсевдонимовОбработчиков(СоответствиеИменПсевдонимам);
	ЗарплатаКадрыВнутренний.ПриОпределенииПсевдонимовОбработчиков(СоответствиеИменПсевдонимам);
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.РаботаВМоделиСервиса.ОчередьЗаданий

// СтандартныеПодсистемы.РассылкаОтчетов

// См. РассылкаОтчетовПереопределяемый.ПереопределитьТаблицуТиповПолучателей.
Процедура ПриПереопределенииТаблицыТиповПолучателей(ТаблицаТипов, ДоступныеТипы) Экспорт
	
	Если ОбщегоНазначения.ПодсистемаСуществует("СтандартныеПодсистемы.РассылкаОтчетов") Тогда
		// Параметры справочника "Физические лица".
		НастройкиТипа = Новый Структура;
		НастройкиТипа.Вставить("ГруппаКИ",			Справочники.ВидыКонтактнойИнформации.СправочникФизическиеЛица);
		НастройкиТипа.Вставить("ОсновнойВидКИ",		Справочники.ВидыКонтактнойИнформации.EMailФизическиеЛица);
		НастройкиТипа.Вставить("ОсновнойТип",		Тип("СправочникСсылка.ФизическиеЛица"));
		МодульРассылкаОтчетов = ОбщегоНазначения.ОбщийМодуль("РассылкаОтчетов");
		МодульРассылкаОтчетов.ДобавитьЭлементВТаблицуТиповПолучателей(ТаблицаТипов, ДоступныеТипы, НастройкиТипа);
	КонецЕсли;
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.РассылкаОтчетов

// СтандартныеПодсистемы.РегламентныеЗадания

// См. РегламентныеЗаданияПереопределяемый.ПриОпределенииНастроекРегламентныхЗаданий
Процедура ПриОпределенииНастроекРегламентныхЗаданий(Настройки) Экспорт
	
	КабинетСотрудника.ПриОпределенииНастроекРегламентныхЗаданий(Настройки);
	ЗарплатаКадрыВнутренний.ПриОпределенииНастроекРегламентныхЗаданий(Настройки);
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.РегламентныеЗадания

// СтандартныеПодсистемы.ТекущиеДела

// См. ТекущиеДелаПереопределяемый.ПриОпределенииОбработчиковТекущихДел.
Процедура ПриОпределенииОбработчиковТекущихДел(Обработчики) Экспорт
	
	// ЗарплатаКадрыПодсистемы.ПособияСоциальногоСтрахования
	УчетПособийСоциальногоСтрахования.ПриОпределенииОбработчиковТекущихДел(Обработчики);
	// Конец ЗарплатаКадрыПодсистемы.ПособияСоциальногоСтрахования
	
	ЗарплатаКадрыВнутренний.ПриОпределенииОбработчиковТекущихДел(Обработчики);
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.ТекущиеДела

// СтандартныеПодсистемы.УправлениеДоступом

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииСписковСОграничениемДоступа.
Процедура ПриЗаполненииСписковСОграничениемДоступа(Списки) Экспорт
	
	// ЗарплатаКадрыПодсистемы.ПособияСоциальногоСтрахования
	УчетПособийСоциальногоСтрахования.ПриЗаполненииСписковСОграничениемДоступа(Списки);
	// Конец ЗарплатаКадрыПодсистемы.ПособияСоциальногоСтрахования
	
	ЗарплатаКадрыВнутренний.ПриЗаполненииСписковСОграничениемДоступа(Списки);
	
КонецПроцедуры

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииОграниченияДоступа.
Процедура ПриЗаполненииОграниченияДоступа(Список, Ограничение) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриЗаполненииОграниченияДоступа(Список, Ограничение);
	
КонецПроцедуры

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииВидовОграниченийПравОбъектовМетаданных.
Процедура ПриЗаполненииВидовОграниченийПравОбъектовМетаданных(Описание) Экспорт
	
	УчетПособийСоциальногоСтрахования.ПриЗаполненииВидовОграниченийПравОбъектовМетаданных(Описание);
	
	ЗарплатаКадрыВнутренний.ПриЗаполненииВидовОграниченийПравОбъектовМетаданных(Описание);
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.УправлениеДоступом

// СтандартныеПодсистемы.ШаблоныСообщений

// См. ШаблоныСообщенийПереопределяемый.ПриОпределенииНастроек
Процедура ПриОпределенииНастроекШаблоновСообщений(Настройки) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриОпределенииНастроекШаблоновСообщений(Настройки);
	
КонецПроцедуры

// См. ШаблоныСообщенийПереопределяемый.ПриПодготовкеШаблонаСообщения
Процедура ПриПодготовкеШаблонаСообщения(Реквизиты, Вложения, НазначениеШаблона, ДополнительныеПараметры) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриПодготовкеШаблонаСообщения(Реквизиты, Вложения, НазначениеШаблона, ДополнительныеПараметры);
	
КонецПроцедуры

// См. ШаблоныСообщенийПереопределяемый.ПриФормированииСообщения
Процедура ПриФормированииСообщения(Сообщение, НазначениеШаблона, ПредметСообщения, ПараметрыШаблона) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриФормированииСообщения(Сообщение, НазначениеШаблона, ПредметСообщения, ПараметрыШаблона);
	
КонецПроцедуры

// См. ШаблоныСообщенийПереопределяемый.ПриЗаполненииПочтыПолучателейВСообщении
Процедура ПриЗаполненииПочтыПолучателейВСообщении(ПолучателиПисьма, НазначениеШаблона, ПредметСообщения) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриЗаполненииПочтыПолучателейВСообщении(ПолучателиПисьма, НазначениеШаблона, ПредметСообщения);
	
КонецПроцедуры

// См. ШаблоныСообщенийПереопределяемый.ПриЗаполненииТелефоновПолучателейВСообщении
Процедура ПриЗаполненииТелефоновПолучателейВСообщении(ПолучателиSMS, НазначениеШаблона, ПредметСообщения) Экспорт
	
	ЗарплатаКадрыВнутренний.ПриЗаполненииТелефоновПолучателейВСообщении(ПолучателиSMS, НазначениеШаблона, ПредметСообщения);
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.ШаблоныСообщений

// ТехнологияСервиса.ВыгрузкаЗагрузкаДанных

// См. ВыгрузкаЗагрузкаДанныхПереопределяемый.ПриЗаполненииТиповОбщихДанныхПоддерживающихСопоставлениеСсылокПриЗагрузке.
Процедура ПриЗаполненииТиповОбщихДанныхПоддерживающихСопоставлениеСсылокПриЗагрузке(Типы) Экспорт
	ЗарплатаКадрыВнутренний.ПриЗаполненииТиповОбщихДанныхПоддерживающихСопоставлениеСсылокПриЗагрузке(Типы);
КонецПроцедуры

// См. ВыгрузкаЗагрузкаДанныхПереопределяемый.ПриЗаполненииТиповОбщихДанныхНеТребующихСопоставлениеСсылокПриЗагрузке.
Процедура ПриЗаполненииТиповОбщихДанныхНеТребующихСопоставлениеСсылокПриЗагрузке(Типы) Экспорт
	ЗарплатаКадрыВнутренний.ПриЗаполненииТиповОбщихДанныхНеТребующихСопоставлениеСсылокПриЗагрузке(Типы);
КонецПроцедуры

// См. ВыгрузкаЗагрузкаДанныхПереопределяемый.ПослеЗагрузкиДанных.
Процедура ПослеЗагрузкиДанных(Контейнер) Экспорт

	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыПриложения.ПереносДанныхЗарплатаКадры") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ПереносДанныхЗарплатаКадры");
		УстановитьПривилегированныйРежим(Истина);
		Модуль.УстановитьДоступенПереносДанныхИзПрежнихПрограмм();
	КонецЕсли;

КонецПроцедуры

// См. ВыгрузкаЗагрузкаДанныхПереопределяемый.ПриЗаполненииТиповИсключаемыхИзВыгрузкиЗагрузки
Процедура ПриЗаполненииТиповИсключаемыхИзВыгрузкиЗагрузки(Типы) Экспорт
	
	КабинетСотрудника.ПриЗаполненииТиповИсключаемыхИзВыгрузкиЗагрузки(Типы);
	
КонецПроцедуры

// Конец ТехнологияСервиса.ВыгрузкаЗагрузкаДанных

// РегламентированнаяОтчетность

// См. ЭлектронныйДокументооборотСКонтролирующимиОрганамиВызовСервераПереопределяемый.ПриИзмененииСтатусаОтправкиДокумента.
Функция ПриИзмененииСтатусаОтправкиДокумента(Ссылка, СтатусОтправки) Экспорт
	
	УчетПособийСоциальногоСтрахования.ПриИзмененииСтатусаОтправкиДокумента(Ссылка, СтатусОтправки);
	
КонецФункции

// Конец ТехнологияСервиса.ВыгрузкаЗагрузкаДанных

// РегламентированнаяОтчетность

// См. ЭлектронныйДокументооборотСКонтролирующимиОрганамиВызовСервераПереопределяемый.ПолучитьДатыПериодаДокумента
Функция ПолучитьДатыПериодаДокумента(Ссылка) Экспорт
	
	ПериодОтчета = Новый Структура("ДатаНачала, ДатаОкончания");
	
	Если ТипЗнч(Ссылка) = Тип("ДокументСсылка.СправкиНДФЛДляПередачиВНалоговыйОрган") Тогда
		ГодОтчета = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, "НалоговыйПериод");
		ПериодОтчета.ДатаНачала = Дата(ГодОтчета, 1, 1);
		ПериодОтчета.ДатаОкончания = Дата(ГодОтчета, 12, 31);
		Возврат ПериодОтчета;
	ИначеЕсли ТипЗнч(Ссылка) = Тип("ДокументСсылка.ЗаявлениеОПодтвержденииПраваНаЗачетАвансовПоНДФЛ") Тогда
		ГодОтчета = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, "НалоговыйПериод");
		ПериодОтчета.ДатаНачала = Дата(ГодОтчета, 1, 1);
		ПериодОтчета.ДатаОкончания = Дата(ГодОтчета, 12, 31);
		Возврат ПериодОтчета;
	Иначе
		Возврат ПерсонифицированныйУчет.ПолучитьДатыПериодаДокумента(Ссылка);
	КонецЕсли;
	
КонецФункции

// См. ЭлектронныйДокументооборотСКонтролирующимиОрганамиВызовСервераПереопределяемый.ВыгрузитьДокумент.
Функция ВыгрузитьДокумент(Ссылка, УникальныйИдентификатор = Неопределено) Экспорт
	
	Возврат ЗарплатаКадрыВнутренний.ВыгрузитьДокумент(Ссылка, УникальныйИдентификатор);
	
КонецФункции

// См. ЭлектронныйДокументооборотСКонтролирующимиОрганамиВызовСервераПереопределяемый.ПолучитьДанныеИсполнителя
Функция ПолучитьДанныеИсполнителя(СсылкаФизЛицо, ОрганизацияСсылка) Экспорт
	
	ДанныеИсполнителя = Новый Структура;
	ФИО = Новый Структура("Фамилия, Имя, Отчество", "", "", "");
	
	ДанныеИсполнителя.Вставить("ФИО", ФИО);
	ДанныеИсполнителя.Вставить("ДатаРождения", '00010101');
	ДанныеИсполнителя.Вставить("МестоРождения", "");
	ДанныеИсполнителя.Вставить("Пол", Перечисления.ПолФизическогоЛица.ПустаяСсылка());
	ДанныеИсполнителя.Вставить("СНИЛС", "");
	ДанныеИсполнителя.Вставить("Серия", "");
	ДанныеИсполнителя.Вставить("Номер", "");
	ДанныеИсполнителя.Вставить("ДатаВыдачи", '00010101');
	ДанныеИсполнителя.Вставить("КемВыдан", "");
	ДанныеИсполнителя.Вставить("КодПодразделения", "");
	ДанныеИсполнителя.Вставить("Гражданство", Справочники.СтраныМира.ПустаяСсылка());
	ДанныеИсполнителя.Вставить("ВидДокумента", Справочники.ВидыДокументовФизическихЛиц.ПустаяСсылка());
	ДанныеИсполнителя.Вставить("Должность", "");
	ДанныеИсполнителя.Вставить("Подразделение", "");
	
	СписокФизическихЛиц = Новый Массив;
	СписокФизическихЛиц.Добавить(СсылкаФизЛицо);
	
	НеобходимыеДанные = "Фамилия, Имя, Отчество, ДатаРождения, МестоРождения, Пол, СтраховойНомерПФР, ДокументВид, ДокументСерия, ДокументНомер, ДокументДатаВыдачи, ДокументКемВыдан, ДокументКодПодразделения, Страна";
	
	ДанныеФизическихЛиц = КадровыйУчет.КадровыеДанныеФизическихЛиц(Истина, СписокФизическихЛиц, НеобходимыеДанные);
	
	Если ДанныеФизическихЛиц.Количество() > 0 Тогда
		
		ДанныеФизическогоЛица = ДанныеФизическихЛиц[0];
		
		ЗаполнитьЗначенияСвойств(ДанныеИсполнителя.ФИО, ДанныеФизическогоЛица);
		
		ДанныеИсполнителя.ДатаРождения	= ДанныеФизическогоЛица.ДатаРождения;
		ДанныеИсполнителя.МестоРождения	= ДанныеФизическогоЛица.МестоРождения;
		ДанныеИсполнителя.Пол			= Строка(ДанныеФизическогоЛица.Пол);
		
		ДанныеИсполнителя.Гражданство = ДанныеФизическогоЛица.Страна;
		
		ДанныеИсполнителя.СНИЛС = ДанныеФизическогоЛица.СтраховойНомерПФР;
		
		ДанныеИсполнителя.Серия = ДанныеФизическогоЛица.ДокументСерия;
		ДанныеИсполнителя.Номер = ДанныеФизическогоЛица.ДокументНомер;

		ДанныеИсполнителя.ДатаВыдачи		= ДанныеФизическогоЛица.ДокументДатаВыдачи;
		ДанныеИсполнителя.КемВыдан			= ДанныеФизическогоЛица.ДокументКемВыдан;
		ДанныеИсполнителя.КодПодразделения	= ДанныеФизическогоЛица.ДокументКодПодразделения;
		ДанныеИсполнителя.ВидДокумента		= ДанныеФизическогоЛица.ДокументВид;	
		
	КонецЕсли;
	
	ОсновныеСотрудники = КадровыйУчет.ОсновныеСотрудникиФизическихЛиц(СписокФизическихЛиц, Ложь, ОрганизацияСсылка, ТекущаяДатаСеанса());
	
	Если ОсновныеСотрудники.Количество() > 0
		И ЗначениеЗаполнено(ОсновныеСотрудники[0].Сотрудник) Тогда
		
		СписокСотрудников = Новый Массив;
		СписокСотрудников.Добавить(ОсновныеСотрудники[0].Сотрудник);
		
		НеобходимыеДанные = "Должность, Подразделение";
		
		КадровыеДанные = КадровыйУчет.КадровыеДанныеСотрудников(Истина, СписокСотрудников, НеобходимыеДанные);
		
		Если КадровыеДанные.Количество() > 0 Тогда
			КадровыеДанныеСотрудника = КадровыеДанные[0];
			
			Если ЗначениеЗаполнено(КадровыеДанныеСотрудника.Подразделение) Тогда
				ДанныеИсполнителя.Подразделение = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(КадровыеДанныеСотрудника.Подразделение, "Наименование");
			КонецЕсли;
			
			Если ЗначениеЗаполнено(КадровыеДанныеСотрудника.Должность) Тогда
				ДанныеИсполнителя.Должность = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(КадровыеДанныеСотрудника.Должность, "Наименование");
			КонецЕсли;
			
		КонецЕсли;
	КонецЕсли;
	
	Возврат ДанныеИсполнителя;
	
КонецФункции

// См. ЭлектронныйДокументооборотСКонтролирующимиОрганамиВызовСервераПереопределяемый.ПолучитьДанныеОтветственныхЛиц
Функция ПолучитьДанныеОтветственныхЛиц(ОрганизацияСсылка, ПолучитьСоответствие = Ложь) Экспорт
	
	ДанныеОтветственныхЛиц = ОтветственныеЛицаОрганизации(ОрганизацияСсылка, "Руководитель,ДолжностьРуководителя,ГлавныйБухгалтер", ТекущаяДатаСеанса());
	
	Если ПолучитьСоответствие Тогда
		Результат = Новый Соответствие;
	Иначе
		Результат = Новый Массив();
	КонецЕсли;
	
	СписокФизЛиц = Новый Массив;
	
	Если ЗначениеЗаполнено(ДанныеОтветственныхЛиц.Руководитель) Тогда
		СписокФизЛиц.Добавить(ДанныеОтветственныхЛиц.Руководитель);
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ДанныеОтветственныхЛиц.Руководитель) Тогда
		СписокФизЛиц.Добавить(ДанныеОтветственныхЛиц.ГлавныйБухгалтер);
	КонецЕсли;
	
	КадровыеДанные = КадровыйУчет.КадровыеДанныеФизическихЛиц(Ложь, СписокФизЛиц, "СтраховойНомерПФР");
	
	СтраховыеНомера = Новый Соответствие;
	Для Каждого КадровыеДанныеФизЛица Из КадровыеДанные Цикл
		СтраховыеНомера.Вставить(КадровыеДанныеФизЛица.ФизическоеЛицо, КадровыеДанныеФизЛица.СтраховойНомерПФР);
	КонецЦикла;
	
	Если ЗначениеЗаполнено(ДанныеОтветственныхЛиц.Руководитель) Тогда
		Если ПолучитьСоответствие Тогда
			ДолжностьРуководителя = "";                               
			Если ЗначениеЗаполнено(ДанныеОтветственныхЛиц.ДолжностьРуководителя) Тогда
				ДолжностьРуководителя = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(ДанныеОтветственныхЛиц.ДолжностьРуководителя, "Наименование"); 	
			КонецЕсли;
			
			СНИЛС = ?(СтраховыеНомера.Получить(ДанныеОтветственныхЛиц.Руководитель) = Неопределено, "", СтраховыеНомера[ДанныеОтветственныхЛиц.Руководитель]);
			
			СтруктураДанных = Новый Структура;
			СтруктураДанных.Вставить("Должность", ДолжностьРуководителя);
			СтруктураДанных.Вставить("СНИЛС",     СНИЛС);
			Результат.Вставить("Руководитель", СтруктураДанных);
		Иначе
			Результат.Добавить(ДанныеОтветственныхЛиц.Руководитель);
		КонецЕсли;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ДанныеОтветственныхЛиц.ГлавныйБухгалтер) Тогда
		Если ПолучитьСоответствие Тогда
			СНИЛС = ?(СтраховыеНомера.Получить(ДанныеОтветственныхЛиц.ГлавныйБухгалтер) = Неопределено, "", СтраховыеНомера[ДанныеОтветственныхЛиц.ГлавныйБухгалтер]);
			
			СтруктураДанных = Новый Структура;
			СтруктураДанных.Вставить("Должность", НСтр("ru = 'Главный бухгалтер'"));
			СтруктураДанных.Вставить("СНИЛС",     СНИЛС);
			Результат.Вставить("ГлавныйБухгалтер", СтруктураДанных);
		Иначе
			Результат.Добавить(ДанныеОтветственныхЛиц.ГлавныйБухгалтер);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// См. ЭлектронныйДокументооборотСКонтролирующимиОрганамиВызовСервераПереопределяемый.ПолучитьКодПодчиненностиРеестраСведенийНаВыплатуПособийФСС
Функция ПолучитьКодПодчиненностиРеестраСведенийНаВыплатуПособийФСС(Ссылка) Экспорт
	КодПодчиненности = "";
	Попытка
		КодПодчиненности = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, "КодПодчиненностиФСС");
	Исключение
	КонецПопытки;
	Возврат КодПодчиненности;		
КонецФункции

// См. ЭлектронныйДокументооборотСКонтролирующимиОрганамиВызовСервераПереопределяемый.ГлБухгалтер
Функция ГлБухгалтер(Организация) Экспорт
	
	Сведения = ОтветственныеЛицаОрганизации(Организация, "ГлавныйБухгалтер", ТекущаяДатаСеанса());

	Возврат Сведения.ГлавныйБухгалтер;
	
КонецФункции

// См. ЭлектронныйДокументооборотСКонтролирующимиОрганамиВызовСервераПереопределяемый.Руководитель
Функция Руководитель(Организация) Экспорт
	
	Сведения = ОтветственныеЛицаОрганизации(Организация, "Руководитель", ТекущаяДатаСеанса());
	
	Возврат Сведения.Руководитель;
	
КонецФункции

// См. ЭлектронныйДокументооборотСКонтролирующимиОрганамиВызовСервераПереопределяемый.ФизЛицоПоФИО
Функция ФизЛицоПоФИО(Фамилия, Имя, Отчество, СНИЛС, Организация) Экспорт
	
	Возврат КадровыйУчет.ФизическоеЛицоПоФИОСНИЛСИОрганизации(Фамилия, Имя, Отчество, СНИЛС, Организация);
	
КонецФункции

//////////////

// См. РегламентированнаяОтчетностьПереопределяемый.ПолучитьСведенияОбОрганизации.
Функция ПолучитьСведенияОбОрганизации(Знач Организация, Знач ДатаЗначения = Неопределено, Знач СписокПоказателей = Неопределено) Экспорт
	Возврат ЗарплатаКадрыВнутренний.ПолучитьСведенияОбОрганизации(Организация, ДатаЗначения, СписокПоказателей);
КонецФункции

// См. РегламентированнаяОтчетностьПереопределяемый.ПолучитьСписокРегламентированныхОтчетов.
Процедура ЗаполнитьСписокРегламентированныхОтчетов(СписокРегламентированныхОтчетов) Экспорт
	ЗарплатаКадрыВнутренний.ЗаполнитьСписокРегламентированныхОтчетов(СписокРегламентированныхОтчетов);
КонецПроцедуры

// См. РегламентированнаяОтчетностьПереопределяемый.ЭтоЮридическоеЛицо.
Функция ЭтоЮридическоеЛицо(Организация) Экспорт
	Возврат ЗарплатаКадрыПовтИсп.ЭтоЮридическоеЛицо(Организация);
КонецФункции

// См. РегламентированнаяОтчетностьПереопределяемый.ПолучитьСведенияОПоказателяхОтчета.
Процедура ЗаполнитьПоказателиРегламентированногоОтчета(ПоказателиОтчета, ИДОтчета, ИДРедакцииОтчета, ПараметрыОтчета = Неопределено) Экспорт
	ЗарплатаКадрыВнутренний.ЗаполнитьПоказателиРегламентированногоОтчета(ПоказателиОтчета, ИДОтчета, ИДРедакцииОтчета, ПараметрыОтчета);
КонецПроцедуры

// См. РегламентированнаяОтчетностьПереопределяемый.ЗаполнитьОтчет.
Процедура ЗаполнитьРегламентированныйОтчет(ИДОтчета, ИДРедакцииОтчета, ПараметрыОтчета, Контейнер) Экспорт
	ЗарплатаКадрыВнутренний.ЗаполнитьРегламентированныйОтчет(ИДОтчета, ИДРедакцииОтчета, ПараметрыОтчета, Контейнер);
КонецПроцедуры

// См. РегламентированнаяОтчетностьПереопределяемый.ИмяСправочникаОбособленныхПодразделений.
Функция ИмяСправочникаОбособленныхПодразделений() Экспорт
	Возврат ЗарплатаКадрыВнутренний.ИмяСправочникаОбособленныхПодразделений();
КонецФункции

// См. РегламентированнаяОтчетностьПереопределяемый.ИмяРеквизитаПризнакаОбособленногоПодразделения.
Функция ИмяРеквизитаПризнакаОбособленногоПодразделения() Экспорт
	Возврат ЗарплатаКадрыВнутренний.ИмяРеквизитаПризнакаОбособленногоПодразделения();
КонецФункции

// См. РегламентированнаяОтчетностьПереопределяемый.ПолучитьКодОКПОПодразделения.
Процедура ПолучитьКодОКПОПодразделения(Знач Подразделение, КодОКПО) Экспорт 
	ЗарплатаКадрыВнутренний.ПолучитьКодОКПОПодразделения(Подразделение, КодОКПО);
КонецПроцедуры

// См. РегламентированнаяОтчетностьПереопределяемый.ПолучитьКодОрганаФСГСПодразделения.
Процедура ПолучитьКодОрганаФСГСПодразделения(Подразделение, КодФСГС) Экспорт 
	ЗарплатаКадрыВнутренний.ПолучитьКодОрганаФСГСПодразделения(Подразделение, КодФСГС);
КонецПроцедуры

// См. РегламентированнаяОтчетностьПереопределяемый.ПолучитьНалоговыеОрганы.
Процедура ПолучитьНалоговыеОрганы(Организация, ДатаКонцаПериодаОтчета, НалоговыеОрганы) Экспорт
	НалоговыеОрганы = УчетНДФЛ.РегистрацииОрганизацииОтчетногоПериода(Организация, НачалоГода(ДатаКонцаПериодаОтчета), ДатаКонцаПериодаОтчета, Истина);
КонецПроцедуры

// См. РегламентированнаяОтчетностьПереопределяемый.ОпределитьСвойстваОбъектовДляОтображенииВФормеОтчетность.
Процедура ОпределитьСвойстваОбъектовДляОтображенииВФормеОтчетность(СвойстваОбъектов) Экспорт
	// Переопределяет свойства объекта, с которыми он будет отображен в форме Отчетность.
	ЗарплатаКадрыВнутренний.ОпределитьСвойстваОбъектовДляОтображенииВФормеОтчетность(СвойстваОбъектов);
КонецПроцедуры

// См. РегламентированнаяОтчетностьПереопределяемый.ОпределитьТаблицуОписанияОбъектовРегламентированнойОтчетности.
Процедура ОпределитьТаблицуОписанияОбъектовРегламентированнойОтчетности(ТаблицаОписания) Экспорт
	// Определяет свойства, касающиеся общих свойств объектов конфигураций-потребителей для отображения в форме Отчетность
	// и возможности создания новый объектов из формы Отчетность.
	ЗарплатаКадрыВнутренний.ОпределитьТаблицуОписанияОбъектовРегламентированнойОтчетности(ТаблицаОписания);
КонецПроцедуры

// См. РегламентированнаяОтчетностьПереопределяемый.ЗаписьОбъектовРегламентированнойОтчетности.
Процедура ЗаписьОбъектовРегламентированнойОтчетности(Ссылка, Отказ, СтандартнаяОбработка) Экспорт
	// Переопределяет обработчик подписки на событие "ЗаписьОбъектовРегламентированнойОтчетности*".
	ПерсонифицированныйУчет.ЗаписьОбъектовРегламентированнойОтчетности(Ссылка, Отказ, СтандартнаяОбработка);
	ЗарплатаКадрыВнутренний.ЗаписьОбъектовРегламентированнойОтчетности(Ссылка, Отказ, СтандартнаяОбработка);
КонецПроцедуры

// См. РегламентированнаяОтчетностьПереопределяемый.ПолучитьКодИлиРазмерТарифаПоКодуКатегории.
Процедура ПолучитьКодИлиРазмерТарифаПоКодуКатегории(КодКатегории, ОтчетныйГод, КодИлиРазмерТарифа, ВернутьРазмерТарифа) Экспорт
	Если ВернутьРазмерТарифа Тогда
		КодИлиРазмерТарифа = ТарифСтраховыхВзносовВПроцентахДляКатегорииЗЛ(КодКатегории, ОтчетныйГод);
	Иначе
		КодИлиРазмерТарифа = СоответствиеКодовТарифаКодамКатегорийЗастрахованных(ОтчетныйГод)[КодКатегории];
	КонецЕсли;
КонецПроцедуры

// Определяет тариф страховых взносов на ОПС по коду категории застрахованного лица.
//
// Параметры:
//  КодКатегории - Строка - Код категории застрахованного лица.
//                          Должен соответствовать одному из значения перечисления КатегорииЗастрахованныхЛицДляПФР.
//  Год - Число - Год, для которого следует определить тариф.
//
// Возвращаемое значение:
//  Число, Неопределено - Неопределено возвращается в том случае, когда переданы неподходящие значения параметров.
//
Функция ТарифСтраховыхВзносовВПроцентахДляКатегорииЗЛ(КодКатегории = "", Год = 2017) Экспорт
	
	Если Год < 2017 Тогда
		Возврат Неопределено
	КонецЕсли;
	
	Попытка
		Категория = Перечисления.КатегорииЗастрахованныхЛицДляПФР[КодКатегории];
	Исключение
		Возврат Неопределено
	КонецПопытки;
	
	Тарифы = ЗарплатаКадрыПовтИсп.ТарифыВзносовПоКатегориямЗЛ(Год).Получить(Категория);
	Если Тарифы = Неопределено Тогда
		Возврат Неопределено
	Иначе
		Возврат Тарифы.ПФРСтраховая;
	КонецЕсли;
	
КонецФункции

// Строит соответствие кодов тарифов страховых взносов на ОПС кодам категорий застрахованных лиц. 
//
// Параметры:
//  ОтчетныйГод - Число - год, для которого следует определить тариф;
//
// Возвращаемое значение:
//  Соответствие, ключом которого является код категории ЗЛ (строка), а значением - код тарифа (строка).
//
Функция СоответствиеКодовТарифаКодамКатегорийЗастрахованных(ОтчетныйГод = 2017) Экспорт
	Возврат ЗарплатаКадрыПовтИсп.СоответствиеКодовТарифаКодамКатегорийЗастрахованных(ОтчетныйГод)
КонецФункции

// См. ЭлектронныйДокументооборотСКонтролирующимиОрганамиПереопределяемый.ПереопределитьСтатусИСостояниеСдачиОтчетности.
Процедура ПереопределитьСтатусИСостояниеСдачиОтчетности(Ссылка, СтатусОтправки, СостояниеСдачиОтчетности) Экспорт
	
	УчетПособийСоциальногоСтрахования.ПереопределитьСтатусИСостояниеСдачиОтчетности(Ссылка, СтатусОтправки, СостояниеСдачиОтчетности);
	
КонецПроцедуры

// См. ЭлектронныйДокументооборотСКонтролирующимиОрганамиПереопределяемый.ОпределитьНаличиеДанныхДляЗаявленияНаСертификат.
Процедура ОпределитьНаличиеДанныхДляЗаявленияНаСертификат(Реквизиты, Организация = Неопределено) Экспорт
	
	//  РегламентированнаяОтчетностьПереопределяемый.ПолучитьСведенияОбОрганизации
	//    * ТелефонОсновной       - ТелОрганизации
	//    * ТелефонДополнительный - ТелРук.
	Реквизиты.Вставить(Перечисления.ПараметрыПодключенияК1СОтчетности.ТелефонОсновной, Истина);
	Реквизиты.Вставить(Перечисления.ПараметрыПодключенияК1СОтчетности.ТелефонДополнительный, Истина);
	
	//  Реквизиты справочника Организации
	//    * ДополнительныйКодФСС - ДополнительныйКодФСС, если есть в метаданных.
	Реквизиты.Вставить(Перечисления.ПараметрыПодключенияК1СОтчетности.ДополнительныйКодФСС, Истина);
	
	//  Контактная информация
	//    * ЭлектроннаяПочта - предопределенный элемент Справочники.ВидыКонтактнойИнформации.EmailОрганизации.
	Реквизиты.Вставить(Перечисления.ПараметрыПодключенияК1СОтчетности.ЭлектроннаяПочта, Истина);
	
	//  ЭлектронныйДокументооборотСКонтролирующимиОрганамиВызовСервераПереопределяемый.ПолучитьДанныеИсполнителя
	//    * ВладелецЭЦПДолжность        - Должность
	//    * ВладелецЭЦППодразделение    - Подразделение
	//    * ВладелецЭЦПСНИЛС            - СНИЛС
	//    * ВладелецЭЦПМестоРождения    - МестоРождения
	//    * ВладелецЭЦПДатаРождения     - ДатаРождения
	//    * ВладелецЭЦПКодПодразделения - КодПодразделения
	//    * ВладелецЭЦППол              - Пол
	//    * ВладелецЭЦПГражданство      - Гражданство.
	Реквизиты.Вставить(Перечисления.ПараметрыПодключенияК1СОтчетности.ВладелецЭЦПДолжность, Истина);
	Реквизиты.Вставить(Перечисления.ПараметрыПодключенияК1СОтчетности.ВладелецЭЦППодразделение, Истина);
	Реквизиты.Вставить(Перечисления.ПараметрыПодключенияК1СОтчетности.ВладелецЭЦПСНИЛС, Истина);
	Реквизиты.Вставить(Перечисления.ПараметрыПодключенияК1СОтчетности.ВладелецЭЦПМестоРождения, Истина);
	Реквизиты.Вставить(Перечисления.ПараметрыПодключенияК1СОтчетности.ВладелецЭЦПДатаРождения, Истина);
	Реквизиты.Вставить(Перечисления.ПараметрыПодключенияК1СОтчетности.ВладелецЭЦПКодПодразделения, Истина);
	Реквизиты.Вставить(Перечисления.ПараметрыПодключенияК1СОтчетности.ВладелецЭЦППол, Истина);
	Реквизиты.Вставить(Перечисления.ПараметрыПодключенияК1СОтчетности.ВладелецЭЦПГражданство, Истина);
	
КонецПроцедуры

// См. ЭлектронныйДокументооборотСКонтролирующимиОрганамиПереопределяемый.ПолучитьСведенияОСотруднике.
Функция ПолучитьСведенияОСотруднике(Знач Сотрудник, Знач МассивПоказателей = Неопределено, Знач ДатаЗначения = Неопределено) Экспорт
	
	Сведения = Новый Структура;
	
	Если ДатаЗначения = Неопределено Тогда
		ДатаЗначения = '00010101';
	КонецЕсли;
	
	Если МассивПоказателей = Неопределено Тогда
		МассивПоказателей = Новый Массив;
		МассивПоказателей.Добавить("СНИЛС");
		МассивПоказателей.Добавить("Фамилия");
		МассивПоказателей.Добавить("Имя");
		МассивПоказателей.Добавить("Отчество");
		МассивПоказателей.Добавить("АдресРегистрации");
		МассивПоказателей.Добавить("Телефон");
	КонецЕсли;
	
	СоответствиеИменамКадровыхДанных = Новый Соответствие;
	СоответствиеИменамКадровыхДанных.Вставить("СНИЛС", "СтраховойНомерПФР");
	СоответствиеИменамКадровыхДанных.Вставить("АдресРегистрации", "АдресПоПропискеПредставление");
	СоответствиеИменамКадровыхДанных.Вставить("Телефон", "ТелефонДомашнийПредставление");
	СоответствиеИменамКадровыхДанных.Вставить("ЭлектроннаяПочта", "EmailПредставление");
	
	СоответствиеИменамКадровыхДанных.Вставить("АдресМестаЖительства_XML", "АдресМестаПроживания");
	СоответствиеИменамКадровыхДанных.Вставить("АдресМестаПребывания_XML", "АдресПоПрописке");
	СоответствиеИменамКадровыхДанных.Вставить("АдресФактическогоПроживания_XML", "АдресМестаПроживания");
	СоответствиеИменамКадровыхДанных.Вставить("АдресЗаПределамиРФНаРусском_XML", "АдресЗаПределамиРФ");
	СоответствиеИменамКадровыхДанных.Вставить("АдресЗаПределамиРФНаИностранном_XML", "");
	
	СоответствиеИменамКадровыхДанных.Вставить("Гражданство", "Страна");
	
	ЗапрашиваемыеКадровыеДанные = Новый Массив;
	Для каждого Показатель Из МассивПоказателей Цикл
		
		Сведения.Вставить(Показатель);
		
		ИмяДанных = СоответствиеИменамКадровыхДанных.Получить(Показатель);
		Если ИмяДанных = Неопределено Тогда
			Если ВРег(Показатель) = ВРег("УдостоверениеЛичности") Тогда
				МассивПоказателей.Добавить("ДокументСерия");
				МассивПоказателей.Добавить("ДокументНомер");
				МассивПоказателей.Добавить("ДокументДатаВыдачи");
				МассивПоказателей.Добавить("ДокументКемВыдан");
				МассивПоказателей.Добавить("ДокументВид");
				МассивПоказателей.Добавить("ДокументКодПодразделения");
				МассивПоказателей.Добавить("ДокументСрокДействия");
			Иначе
				ЗапрашиваемыеКадровыеДанные.Добавить(Показатель);
			КонецЕсли;
		Иначе
			Если Не ПустаяСтрока(ИмяДанных) Тогда
				ЗапрашиваемыеКадровыеДанные.Добавить(ИмяДанных);
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	УдостоверениеЛичности = Новый Структура;
	КадровыеДанные = КадровыйУчет.КадровыеДанныеСотрудников(Истина, Сотрудник, ЗапрашиваемыеКадровыеДанные, ДатаЗначения);
	Если КадровыеДанные.Количество() > 0 Тогда
		
		ДанныеСотрудника = КадровыеДанные[0];
		Для каждого ОписаниеПоказателя Из Сведения Цикл
			
			Показатель = ОписаниеПоказателя.Ключ;
			
			ИмяДанных = СоответствиеИменамКадровыхДанных.Получить(Показатель);
			Если ИмяДанных = Неопределено Тогда
				ИмяДанных = Показатель;
			КонецЕсли;
			
			Если ИмяДанных = "УдостоверениеЛичности" Тогда
				Продолжить;
			ИначеЕсли ИмяДанных = "МестоРождения" Тогда
				Сведения.Вставить(ОписаниеПоказателя.Ключ, ПерсонифицированныйУчетКлиентСервер.ПредставлениеМестаРождения(ДанныеСотрудника[ИмяДанных]));
			ИначеЕсли ИмяДанных = "" Тогда
				Сведения.Вставить(ОписаниеПоказателя.Ключ, "");
			Иначе
				
				ЗначениеДанныхСотрудника = ДанныеСотрудника[ИмяДанных];
				Если ЗначениеДанныхСотрудника = Неопределено
					Или ЗначениеДанныхСотрудника = Null Тогда
					ЗначениеДанныхСотрудника = "";
				КонецЕсли;
				
				Если ВРег(ИмяДанных) = ВРег("ДокументСерия") Тогда
					УдостоверениеЛичности.Вставить("Серия", ЗначениеДанныхСотрудника);
				ИначеЕсли ВРег(ИмяДанных) = ВРег("ДокументНомер") Тогда
					УдостоверениеЛичности.Вставить("Номер", ЗначениеДанныхСотрудника);
				ИначеЕсли ВРег(ИмяДанных) = ВРег("ДокументДатаВыдачи") Тогда
					УдостоверениеЛичности.Вставить("ДатаВыдачи", ЗначениеДанныхСотрудника);
				ИначеЕсли ВРег(ИмяДанных) = ВРег("ДокументКемВыдан") Тогда
					УдостоверениеЛичности.Вставить("КемВыдан", ЗначениеДанныхСотрудника);
				ИначеЕсли ВРег(ИмяДанных) = ВРег("ДокументВид") Тогда
					УдостоверениеЛичности.Вставить("ВидДокумента", ЗначениеДанныхСотрудника);
				ИначеЕсли ВРег(ИмяДанных) = ВРег("ДокументКодПодразделения") Тогда
					УдостоверениеЛичности.Вставить("КодПодразделения", ЗначениеДанныхСотрудника);
				ИначеЕсли ВРег(ИмяДанных) = ВРег("ДокументСрокДействия") Тогда
					УдостоверениеЛичности.Вставить("СрокДействия", ЗначениеДанныхСотрудника);
				КонецЕсли;
				Сведения.Вставить(ОписаниеПоказателя.Ключ, ЗначениеДанныхСотрудника);
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	Если УдостоверениеЛичности.Количество() > 0 Тогда
		Сведения.Вставить("УдостоверениеЛичности", УдостоверениеЛичности);
	КонецЕсли;
	
	Возврат Сведения;
	
КонецФункции

// См. ЭлектронныйДокументооборотСФССПереопределяемый.ПослеЗагрузкиУведомленийОНовыхСообщенияхСЭДО.
Процедура ПослеЗагрузкиУведомленийОНовыхСообщенияхСЭДО(Страхователь, Уведомления, ОбработанныеУведомления) Экспорт
	
	УчетПособийСоциальногоСтрахования.ПослеЗагрузкиУведомленийОНовыхСообщенияхСЭДО(
		Страхователь,
		Уведомления,
		ОбработанныеУведомления);
	
	// АПК:278-выкл Базовые подсистемы могут условно вызывать расширенные.
	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыРасширеннаяПодсистемы") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ЗарплатаКадрыРасширенный");
		Модуль.ПослеЗагрузкиУведомленийОНовыхСообщенияхСЭДО(Страхователь, Уведомления, ОбработанныеУведомления);
	КонецЕсли;
	// АПК:278-вкл
	
КонецПроцедуры

// См. ЭлектронныйДокументооборотСФССПереопределяемый.ПослеРасшифровкиСообщенияСЭДО.
Процедура ПослеРасшифровкиСообщенияСЭДО(Страхователь, Сообщение, Результат) Экспорт
	
	УчетПособийСоциальногоСтрахования.ПослеРасшифровкиСообщенияСЭДО(Страхователь, Сообщение, Результат);
	
	// АПК:278-выкл Базовые подсистемы могут условно вызывать расширенные.
	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыРасширеннаяПодсистемы") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ЗарплатаКадрыРасширенный");
		Модуль.ПослеРасшифровкиСообщенияСЭДО(Страхователь, Сообщение, Результат);
	КонецЕсли;
	// АПК:278-вкл
	
КонецПроцедуры

// См. ЭлектронныйДокументооборотСФССПереопределяемый.ПослеПолученияОшибокЛогическогоКонтроляСЭДО.
Процедура ПослеПолученияОшибокЛогическогоКонтроляСЭДО(Страхователь, ИсходноеСообщение, ТекстОшибки, Результат) Экспорт
	
	// АПК:278-выкл Базовые подсистемы могут условно вызывать расширенные.
	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыРасширеннаяПодсистемы") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ЗарплатаКадрыРасширенный");
		Модуль.ПослеПолученияОшибокЛогическогоКонтроляСЭДО(Страхователь, ИсходноеСообщение, ТекстОшибки, Результат);
	КонецЕсли;
	// АПК:278-вкл
	
КонецПроцедуры

// См. ЭлектронныйДокументооборотСФССПереопределяемый.ПроверитьНеобходимостьЗапускаРегламентногоЗадания.
Процедура ПроверитьНеобходимостьЗапускаРегламентногоЗаданияСЭДО(Организации, ТребуетсяЗапуск) Экспорт
	
	ТребуетсяЗапуск = Истина;
	
КонецПроцедуры

// Конец РегламентированнаяОтчетность

// ИнтернетПоддержкаПользователей.РаботаСКлассификаторами

// См. РаботаСКлассификаторамиПереопределяемый.ПриДобавленииКлассификаторов.
Процедура ПриДобавленииКлассификаторов(Классификаторы) Экспорт
	МодульРаботаСКлассификаторами = ОбщегоНазначения.ОбщийМодуль("РаботаСКлассификаторами");
	
	ТаблицаКлассификаторов = АвтообновляемыеКлассификаторы();
	Для Каждого СтрокаТаблицы Из ТаблицаКлассификаторов Цикл
		Описание = МодульРаботаСКлассификаторами.ОписаниеКлассификатора();
		ЗаполнитьЗначенияСвойств(Описание, СтрокаТаблицы, "Наименование, Идентификатор");
		Описание.СохранятьФайлВКэш = Истина;
		Классификаторы.Добавить(Описание);
	КонецЦикла;
КонецПроцедуры

// См. РаботаСКлассификаторамиПереопределяемый.ПриЗагрузкеКлассификатора.
Процедура ПриЗагрузкеКлассификатора(Идентификатор, Версия, Адрес, Обработан, ДополнительныеПараметры = Неопределено) Экспорт
	Если Обработан Тогда
		Возврат;
	КонецЕсли;
	
	ТаблицаКлассификаторов = АвтообновляемыеКлассификаторы();
	СтрокаТаблицы = ТаблицаКлассификаторов.Найти(Идентификатор, "Идентификатор");
	Если СтрокаТаблицы = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Обработан = Истина;
	ДвоичныеДанные = ПолучитьИзВременногоХранилища(Адрес);
	ТекстXML = ДвоичныеДанныеВСтроку(ДвоичныеДанные, КодировкаТекста.UTF8);
	Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(СтрокаТаблицы.ПолноеИмя);
	Менеджер.Обновить(ТекстXML);
КонецПроцедуры

// Конец ИнтернетПоддержкаПользователей.РаботаСКлассификаторами

#Область УстаревшиеПроцедурыИФункции

// Устарела в версии БЭД 1.3.10. См. ЭлектронноеВзаимодействиеПереопределяемый.ЕстьПравоОбработкиЭД.
Функция ЭлектронноеВзаимодействиеПриОпределенииПраваОбработкиЭД() Экспорт
	
	Результат = Пользователи.РолиДоступны("ВыполнениеОбменаЭД, ПолныеПрава");
	Возврат Результат;
	
КонецФункции

// Устарела в версии БЭД 1.3.10. См. ЭлектронноеВзаимодействиеПереопределяемый.ЕстьПравоЧтенияЭД.
Функция ЭлектронноеВзаимодействиеПриОпределенииПраваЧтенияЭД() Экспорт
	
	Результат = Пользователи.РолиДоступны("ВыполнениеОбменаЭД, ЧтениеЭД, ПолныеПрава");
	Возврат Результат;
	
КонецФункции

// ЭлектронноеВзаимодействие

// Устарела. Следует использовать ЭлектронноеВзаимодействиеБЗК.ПолучитьСоответствиеСправочников
// См. ЭлектронноеВзаимодействиеПереопределяемый.ПолучитьСоответствиеСправочников.
Процедура ЭлектронноеВзаимодействиеПриОпределенииСоответствияСправочников(СоответствиеСправочников) Экспорт
	ЭлектронноеВзаимодействиеБЗК.ПолучитьСоответствиеСправочников(СоответствиеСправочников)
КонецПроцедуры

// Устарела. Следует использовать ЭлектронноеВзаимодействиеБЗК.ПолучитьСоответствиеФункциональныхОпций
// См. ЭлектронноеВзаимодействиеПереопределяемый.ПолучитьСоответствиеФункциональныхОпций.
Процедура ЭлектронноеВзаимодействиеПриОпределенииСоответствияФункциональныхОпций(СоответствиеФО) Экспорт
	ЭлектронноеВзаимодействиеБЗК.ПолучитьСоответствиеФункциональныхОпций(СоответствиеФО)
КонецПроцедуры

// Устарела. Следует использовать ЭлектронноеВзаимодействиеБЗК.ТекстСообщенияОНеобходимостиНастройкиСистемы
// См. ЭлектронноеВзаимодействиеПереопределяемый.ТекстСообщенияОНеобходимостиНастройкиСистемы.
Процедура ЭлектронноеВзаимодействиеПриОпределенииТекстаСообщенияОНеобходимостиНастройкиСистемы(ВидОперации, ТекстСообщения) Экспорт
	ЭлектронноеВзаимодействиеБЗК.ТекстСообщенияОНеобходимостиНастройкиСистемы(ВидОперации, ТекстСообщения)	
КонецПроцедуры

// Устарела. Следует использовать ЭлектронноеВзаимодействиеБЗК.ИзменитьСообщениеОбОшибке
// См. ЭлектронноеВзаимодействиеПереопределяемый.ИзменитьСообщениеОбОшибке.
Процедура ЭлектронноеВзаимодействиеПриОпределенииСообщенияОбОшибке(КодОшибки, ТекстОшибки) Экспорт
	ЭлектронноеВзаимодействиеБЗК.ИзменитьСообщениеОбОшибке(КодОшибки, ТекстОшибки)
КонецПроцедуры

// Устарела. Следует использовать ЭлектронноеВзаимодействиеБЗК.НайтиСсылкуНаОбъект
// См. ЭлектронноеВзаимодействиеПереопределяемый.НайтиСсылкуНаОбъект.
Процедура ЭлектронноеВзаимодействиеПриОпределенииСсылкиНаОбъект(ТипОбъекта, Результат, ИдОбъекта, ДополнительныеРеквизиты) Экспорт
	ЭлектронноеВзаимодействиеБЗК.НайтиСсылкуНаОбъект(ТипОбъекта, Результат, ИдОбъекта, ДополнительныеРеквизиты)
КонецПроцедуры

// Устарела. Следует использовать ЭлектронноеВзаимодействиеБЗК.ПолучитьПечатныйНомерДокумента
// См. ЭлектронноеВзаимодействиеПереопределяемый.ПолучитьПечатныйНомерДокумента.
Функция ЭлектронноеВзаимодействиеПриОпределенииПечатногоНомераДокумента(СсылкаНаОбъект) Экспорт
	ПечатныйНомерДокумента = "";
	ЭлектронноеВзаимодействиеБЗК.ПолучитьПечатныйНомерДокумента(СсылкаНаОбъект, ПечатныйНомерДокумента);
	Возврат ПечатныйНомерДокумента
КонецФункции

// Устарела. Следует использовать ЭлектронноеВзаимодействиеБЗК.ПроверитьГотовностьИсточников
// См. ЭлектронноеВзаимодействиеПереопределяемый.ПроверитьГотовностьИсточников.
Процедура ЭлектронноеВзаимодействиеПриОпределенииГотовностиИсточников(ДокументыМассив, ФормаИсточник = Неопределено) Экспорт
	ЭлектронноеВзаимодействиеБЗК.ПроверитьГотовностьИсточников(ДокументыМассив)
КонецПроцедуры

// Устарела. Следует использовать ЭлектронноеВзаимодействиеБЗК.ПолучитьДанныеЮрФизЛица
// См. ЭлектронноеВзаимодействиеПереопределяемый.ПолучитьДанныеЮрФизЛица.
Функция ЭлектронноеВзаимодействиеПриОпределенииДанныхЮрФизЛица(ЮрФизЛицо) Экспорт
	Сведения = Новый Структура;
	ЭлектронноеВзаимодействиеБЗК.ПолучитьДанныеЮрФизЛица(ЮрФизЛицо, Сведения);
	Возврат Сведения
КонецФункции

// Устарела. Следует использовать ЭлектронноеВзаимодействиеБЗК.ЕстьПравоОткрытияЖурналаРегистрации
// См. ЭлектронноеВзаимодействиеПереопределяемый.ЕстьПравоОткрытияЖурналаРегистрации.
Функция ЭлектронноеВзаимодействиеПриОпределенииПраваОткрытияЖурналаРегистрации() Экспорт
	Результат = Ложь;
	ЭлектронноеВзаимодействиеБЗК.ЕстьПравоОткрытияЖурналаРегистрации(Результат);
	Возврат Результат;
КонецФункции

// Устарела. Следует использовать ЭлектронноеВзаимодействиеБЗК.ОписаниеОрганизации
// См. ЭлектронноеВзаимодействиеПереопределяемый.ОписаниеОрганизации.
Функция ЭлектронноеВзаимодействиеПриОпределенииОписанияОрганизации(СведенияОКонтрагенте, Список = "", СПрефиксом = Истина) Экспорт
	Возврат "";
КонецФункции

// Конец ЭлектронноеВзаимодействие

// ЭлектронноеВзаимодействие.ОбменСБанками

// Устарела. Следует использовать ОбменСБанкамиБЗК.ПолучитьАктуальныеВидыЭД().
// См. ОбменСБанкамиПереопределяемый.ПолучитьАктуальныеВидыЭД.
Процедура ЗаполнитьАктуальныеВидыЭД(Массив) Экспорт
	ОбменСБанкамиБЗК.ПолучитьАктуальныеВидыЭД(Массив);
КонецПроцедуры

// Устарела. Следует использовать ОбменСБанкамиБЗК.ЗаполнитьПараметрыЭДПоИсточнику
// См. ОбменСБанкамиПереопределяемый.ЗаполнитьПараметрыЭДПоИсточнику.
Процедура ЗаполнитьПараметрыЭДПоИсточнику(Источник, ПараметрыЭД) Экспорт
	ОбменСБанкамиБЗК.ЗаполнитьПараметрыЭДПоИсточнику(Источник, ПараметрыЭД);
КонецПроцедуры

// Устарела в версии БЭД 1.6.1. Следует отказаться от использования.
// Устарела. Следует использовать ОбменСБанкамиБЗК.ПодготовитьСтруктуруОбъектовКомандЭДО
// См. ОбменСБанкамиПереопределяемый.ПодготовитьСтруктуруОбъектовКомандЭДО.
Процедура ПодготовитьСтруктуруОбъектовКомандЭДО(СоставКомандЭДО) Экспорт
	ОбменСБанкамиБЗК.ПодготовитьСтруктуруОбъектовКомандЭДО(СоставКомандЭДО);
КонецПроцедуры

// Устарела. Следует использовать ОбменСБанкамиБЗК.ПриФормированииXMLФайла
// См. ОбменСБанкамиПереопределяемый.ПриФормированииXMLФайла.
Процедура ПриФормированииXMLФайла(ОбъектДляВыгрузки, ИмяФайла, АдресФайла) Экспорт
	ОбменСБанкамиБЗК.ПриФормированииXMLФайла(ОбъектДляВыгрузки, ИмяФайла, АдресФайла);
КонецПроцедуры

// Устарела. Следует использовать ОбменСБанкамиБЗК.ЗаполнитьТабличныйДокумент
// См. ОбменСБанкамиПереопределяемый.ЗаполнитьТабличныйДокумент.
Процедура ЗаполнитьТабличныйДокументПоПрямомуОбменуСБанками(ИмяФайла, ТабличныйДокумент) Экспорт
	ОбменСБанкамиБЗК.ЗаполнитьТабличныйДокумент(ИмяФайла, ТабличныйДокумент);
КонецПроцедуры

// Устарела. Следует использовать ОбменСБанкамиБЗК.ПриПолученииXMLФайла
// См. ОбменСБанкамиПереопределяемый.ПриПолученииXMLФайла.
Процедура ПриПолученииXMLФайла(АдресДанныхФайла, ИмяФайла, ОбъектВладелец, ДанныеОповещения) Экспорт
	ОбменСБанкамиБЗК.ПриПолученииXMLФайла(АдресДанныхФайла, ИмяФайла, ОбъектВладелец, ДанныеОповещения);
КонецПроцедуры

// Конец ЭлектронноеВзаимодействие.ОбменСБанками

// СтандартныеПодсистемы.КонтрольВеденияУчета

// Возвращает идентификатор группы проверок ведения учета БЗК
//
// Возвращаемое значение:
//	Строка
//
Функция ИдентификаторГруппыПроверокВеденияУчетаБЗК() Экспорт
	
	Возврат "ИдентификаторГруппыПроверокВеденияУчетаБЗК";
	
КонецФункции

// Возвращает строку таблицы значений, соответствующую группе проверок БЗК
// 
// Параметры:
//	ГруппыПроверок	- ТаблицаЗначений - см. КонтрольВеденияУчетаПереопределяемый.ПриОпределенииПроверок
//
// ВозвращаемоеЗначение:
//	- СтрокаТаблицыЗначений	- см. ГруппыПроверок
//	- Неопределено          - если группа не найдена
//
Функция ГруппаПроверокБЗК(ГруппыПроверок) Экспорт
	
	Возврат ГруппыПроверок.Найти(ИдентификаторГруппыПроверокВеденияУчетаБЗК(), "Идентификатор");
	
КонецФункции

// Конец СтандартныеПодсистемы.КонтрольВеденияУчета

#КонецОбласти

// СтандартныеПодсистемы.БазоваяФункциональность

// См. ОбщегоНазначенияПереопределяемый.ПриДобавленииПереименованийОбъектовМетаданных.
//
// Заполняет переименования тех объектов метаданных, которые невозможно
// автоматически найти по типу, но ссылки на которые требуется сохранять
// в базе данных (например: подсистемы, роли).
//
// Подробнее: см. ОбщегоНазначения.ДобавитьПереименование().
//
Процедура ЗаполнитьТаблицуПереименованияОбъектовМетаданных(Итог) Экспорт
	
	ЗарплатаКадрыВнутренний.ЗаполнитьТаблицуПереименованияОбъектовМетаданных(Итог);
	
КонецПроцедуры

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииВидовДоступа.
Процедура УправлениеДоступомЗаполнитьСвойстваВидаДоступа(ВидыДоступа) Экспорт
	
	ЗарплатаКадрыВнутренний.УправлениеДоступомЗаполнитьСвойстваВидаДоступа(ВидыДоступа);
	
КонецПроцедуры

// См. УправлениеДоступомПереопределяемый.ПриЗаполненииИспользованияВидаДоступа.
Процедура УправлениеДоступомЗаполнитьИспользованиеВидаДоступа(ИмяВидаДоступа, Использование) Экспорт
	
	ЗарплатаКадрыВнутренний.УправлениеДоступомЗаполнитьИспользованиеВидаДоступа(ИмяВидаДоступа, Использование);
	
КонецПроцедуры

// Конец ИнтернетПоддержкаПользователей.РаботаСКлассификаторами

#КонецОбласти

#КонецОбласти


#Область СлужебныйПрограммныйИнтерфейс

// Проверяет заполнение реквизитов переданного объекта по заданным правилам.
// Формирует и выводит сообщение у поля управляемой формы, связанного с реквизитом объекта.
// 
// Параметры:
//	ПроверяемыйОбъект    - Произвольный - любой объект с доступом к полям по имени.
//	ПроверяемыеСвойства  - Структура    - свойства, заполнение которых нужно проверить:
//  	* Ключ     - Строка - имя проверяемого свойства, 
//		* Значение - Строка - сообщение об ошибке, если свойство не заполнено.
//	СообщитьПользователю - Булево       - сообщать пользователю о незаполненных свойствах.
//
// Возвращаемое значение:
//	Булево - Истина, если все свойства заполнены, Ложь - в противном случае. 
//			
Функция СвойстваЗаполнены(ПроверяемыйОбъект, ПроверяемыеСвойства, СообщитьПользователю = Истина) Экспорт
	Возврат 
		ЗарплатаКадрыКлиентСервер.СвойстваЗаполнены(
			ПроверяемыйОбъект, 
			ПроверяемыеСвойства, 
			?(СообщитьПользователю, ОбщегоНазначения, Неопределено));
КонецФункции

// Проверяет заполнение реквизитов формы по заданным правилам.
// 
// Параметры:
//	ПроверяемаяФорма     - ФормаКлиентскогоПриложения - форма, заполнение реквизитов которой проверяется.
//	ПроверяемыеСвойства	 - СписокЗначений   - свойства, заполнение которых нужно проверить:
//  	* Значение      - Строка - путь к данным формы, 
//		* Представление - Строка - сообщение об ошибке, если свойство не заполнено.
//	СообщитьПользователю - Булево           - сообщать пользователю о незаполненных свойствах.
//								
// Возвращаемое значение:
//	Булево - Истина, если все свойства заполнены, Ложь - в противном случае. 
//			
Функция СвойстваФормыЗаполнены(ПроверяемаяФорма, ПроверяемыеСвойства, СообщитьПользователю = Ложь) Экспорт
	Возврат 
		ЗарплатаКадрыКлиентСервер.СвойстваФормыЗаполнены(
			ПроверяемаяФорма, 
			ПроверяемыеСвойства, 
			?(СообщитьПользователю, ОбщегоНазначения, Неопределено));
КонецФункции

Функция ВыполнятьРасчетЗарплатыБезОптимизации() Экспорт
	УстановитьПривилегированныйРежим(Истина);
	Возврат Константы.ВыполнятьРасчетЗарплатыБезОптимизации.Получить();
КонецФункции	

// Создает команду перехода из исходных регистров в обработку редактирования законодательных значений.
//
// Параметры:
//	Форма - ФормаКлиентскогоПриложения - форма списка регистра сведений.
//	КоманднаяПанельФормы - КоманднаяПанель - командная панель, на которой будет отображаться создаваемая команда.
//
Процедура ДобавитьКомандуПереходаКОбработкеРедактированиюЗаконодательныхЗначений(Форма, КоманднаяПанельФормы) Экспорт 
	ЗарплатаКадрыВнутренний.ДобавитьКомандуПереходаКОбработкеРедактированиюЗаконодательныхЗначений(Форма, КоманднаяПанельФормы);
КонецПроцедуры

// Выполняет начальное заполнение классификаторов, и наборов записей регистров сведений.
// Если не указывать входной параметр, будет произведено начальное заполнение всех
// известных справочников - классификаторов и регистров сведений.
//
// Параметры:
//   ПараметрыВосстановления - Структура - Параметры установки начальных значений.
//       * ИменаОбъектовМетаданных - Строка - Полные имена объектов метаданных,
//           разделенных запятыми (см. процедуру ЗарплатаКадрыВнутренний.УстановитьНачальныеЗначения).
//   АдресРезультатаВХранилище - Строка - Адрес результата, необходимый для запуска фонового задания.
//
Процедура УстановитьНачальныеЗначения(ПараметрыВосстановления, АдресРезультатаВХранилище) Экспорт
	
	ИменаОбъектовМетаданных = "";
	Если ПараметрыВосстановления.Свойство("ИменаОбъектовМетаданных") И НЕ ПустаяСтрока(ПараметрыВосстановления.ИменаОбъектовМетаданных) Тогда
		ИменаОбъектовМетаданных = ПараметрыВосстановления.ИменаОбъектовМетаданных;
	КонецЕсли;
	
	УстановитьНачальныеЗначенияАвтообновляемыхКлассификаторов(ИменаОбъектовМетаданных);
	
	ЗарплатаКадрыВнутренний.УстановитьНачальныеЗначения(ИменаОбъектовМетаданных);
	
КонецПроцедуры

// Выполняет пропорциональное распределение суммы в соответствии
// с заданными базовыми значениями. 
//
// Параметры:
//  РаспределяемаяСумма - Число - сумма, которую надо распределить;
//  МассивБазовыхЗначений - базовые значения;
//  Точность - Число - точность округления при распределении. Необязателен.
//  КоэффициентЗависимостиОтБазы - коэффициент характерный для соотношения распределяемого и базового значения. 
//  Положительное число в диапазоне  0 < КоэффициентЗависимостиОтБазы <= 1.
//
// Предназначена для распределения сумм тем или иным образом "привязанных" к некоторым базовым значениям. 
// Примеры: распределение удержания по начислениям, распределение выплаты по остаткам. 
// Распределение выполняется с ограничением результата распределения величиной: 
// элемент из МассивБазовыхЗначений * КоэффициентЗависимостиОтБазы
// Нераспределенная часть суммы относится к максимальному значению из МассивБазовыхЗначений.
//
// Аналог: ЗарплатаКадрыКлиентСервер.РаспределитьПропорциональноКоэффициентам
// В отличие от аналога 
// - не допускает результатов распределения, "завышенных" относительно базовых 
//   значений (исключение - максимальное базовое значение)
// - не допускает отнесение положительных сумм к отрицательным базовым значениям и 
//   наоборот (исключение - максимальное базовое значение)
// - относит избыток распределяемой суммы к максимальному базовому значению, а 
//   не к максимальному по модулю значению.
//
// Возвращаемое значение:
//  Массив - массив размерностью равный массиву базовых значений, содержит
//           суммы в соответствии с весом базового значения в массиве всех базовых значений.
//           В случае если распределить не удалось (РаспределяемаяСумма = 0, кол-во базовых значений = 0,
//           или сумма базовых значений = 0), возвращается значение НеОпределено.
//
Функция РаспределитьСуммуПропорциональноБазе(Знач РаспределяемаяСумма, МассивБазовыхЗначений, Знач Точность = 2, КоэффициентЗависимостиОтБазы = 1, ВычетИзБазы = 0) Экспорт
	
	Если МассивБазовыхЗначений.Количество() = 0 Или Не ЗначениеЗаполнено(РаспределяемаяСумма) Тогда
		Возврат НеОпределено;
	КонецЕсли;
	
	ИндексМаксимальногоБазовогоЗначения = 0;
	МаксимальнаяБаза = 0;
	ИндексМаксимальногоКоэффициента = 0;
	МаксимальныйКоэффициент = 0;
	РаспределеннаяСумма = 0;
	СуммаБазы = 0;
	СуммаКоэффициентов  = 0;
	
	Для Индекс = 0 По МассивБазовыхЗначений.Количество() - 1 Цикл
		БазовоеЗначение = МассивБазовыхЗначений[Индекс];
		Если МаксимальнаяБаза < БазовоеЗначение Тогда
			МаксимальнаяБаза = БазовоеЗначение;
			ИндексМаксимальногоБазовогоЗначения = Индекс;
		КонецЕсли;
		АбсолютноеЗначениеКоэффициента = ?(БазовоеЗначение > 0, БазовоеЗначение, -БазовоеЗначение);
		Если МаксимальныйКоэффициент < АбсолютноеЗначениеКоэффициента Тогда
			МаксимальныйКоэффициент = АбсолютноеЗначениеКоэффициента;
			ИндексМаксимальногоКоэффициента = Индекс;
		КонецЕсли;
		// Сумма всех значений для распределения 
		СуммаБазы = СуммаБазы + ?(БазовоеЗначение > 0, БазовоеЗначение, -БазовоеЗначение);
		СуммаКоэффициентов = СуммаКоэффициентов + БазовоеЗначение;
	КонецЦикла;
	
	Если СуммаБазы = 0 Тогда
		Возврат НеОпределено;
	КонецЕсли;
	
	Результат = Новый Массив(МассивБазовыхЗначений.Количество());
	
	Если СуммаБазы = ?(СуммаКоэффициентов > 0, СуммаКоэффициентов, -СуммаКоэффициентов) Тогда
		// базовые значения одного знака
		
		Для Индекс = 0 По МассивБазовыхЗначений.Количество() - 1 Цикл
			Результат[Индекс] = Окр(РаспределяемаяСумма * МассивБазовыхЗначений[Индекс] / СуммаКоэффициентов, Точность, 1);
			РаспределеннаяСумма = РаспределеннаяСумма + Результат[Индекс];
		КонецЦикла;
		
		// Погрешности округления отнесем на коэффициент с максимальным весом.
		Если Не РаспределеннаяСумма = РаспределяемаяСумма Тогда
			Результат[ИндексМаксимальногоКоэффициента] = Результат[ИндексМаксимальногоКоэффициента] + РаспределяемаяСумма - РаспределеннаяСумма;
		КонецЕсли;
		
	Иначе
		// Базовые значения разного знака
		// ЭффективныйКоэффициентЗависимостиОтБазы распределяемой суммы к базовой сумме всегда должен быть положительным Если
		// распределяемая сумма и база разных знаков - нужно изменить знак результата, чтобы положительные суммы не относились
		// к отрицательным базам.
		Если РаспределяемаяСумма * СуммаБазы > 0 Тогда
			ЭффективныйКоэффициентЗависимостиОтБазы = РаспределяемаяСумма / СуммаБазы;
		Иначе
			ЭффективныйКоэффициентЗависимостиОтБазы = - РаспределяемаяСумма / СуммаБазы;
		КонецЕсли;
		ЭффективныйКоэффициентЗависимостиОтБазы = Мин(ЭффективныйКоэффициентЗависимостиОтБазы, КоэффициентЗависимостиОтБазы);
		
				
		Для Индекс = 0 По МассивБазовыхЗначений.Количество() - 1 Цикл
			Результат[Индекс] = Окр(ЭффективныйКоэффициентЗависимостиОтБазы * МассивБазовыхЗначений[Индекс], Точность, 1);
			РаспределеннаяСумма = РаспределеннаяСумма + Результат[Индекс];
		КонецЦикла;
		
		// Погрешности округления отнесем на максимальную базовую сумму
		Если Не РаспределеннаяСумма = РаспределяемаяСумма Тогда
			Результат[ИндексМаксимальногоБазовогоЗначения] = Результат[ИндексМаксимальногоБазовогоЗначения] + РаспределяемаяСумма - РаспределеннаяСумма;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Пропорционально распределяет сумму, изменяя значения в колонках базы
// так, чтобы итог совпадал с переданным значением.
//
// Параметры:
//	Сумма - Число - сумма, которую надо разнести.
//  База  - ТаблицаЗначений,
//          ДеревоЗначений,
//          СписокЗначений,
//          ТабличнаяЧасть,
//          Соответствие,
//          Структура - коллекция, по которой разносится сумма.
//          Допустимы другие типы, для которых доступен обход
//          посредством оператора Для каждого … Из … Цикл.
//  Колонка  - Строка - Имя колонки с суммой в базе. Необязательный, по умолчанию "Сумма".
//  Точность - Число  - Точность округления при расчетах. Необязательный, по умолчанию 2.
//
Процедура РазнестиСуммуПоБазе(Знач Сумма, Знач База, Колонка = "Сумма", Знач Точность = 2) Экспорт
	
	// С пустой коллекцией ничего делать не нужно
	Если База.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	// Определяем исходный итог по колонке и строку для отнесения погрешности.
	СтрокаДляПогрешности = Неопределено;
	МаксимальноеЗначение = 0;
	Количество = 0;
	Итог = 0;
	Для Каждого Строка Из База Цикл
		АбсолютноеЗначение = ?(Строка[Колонка] > 0, Строка[Колонка], -Строка[Колонка]);
		Если МаксимальноеЗначение < АбсолютноеЗначение Тогда
			МаксимальноеЗначение = АбсолютноеЗначение;
			СтрокаДляПогрешности = Строка;
		КонецЕсли;	
		Количество = Количество + 1;
		Итог = Итог + Строка[Колонка];
	КонецЦикла;	
	
	Если СтрокаДляПогрешности = Неопределено Тогда
		// Во всех строках коллекции нули, распределяем поровну
		НовоеЗначение = Окр(Сумма/Количество, Точность, 1);
		Для Каждого Строка Из База Цикл
			Строка[Колонка] = НовоеЗначение;
		КонецЦикла;	
		// Погрешность относим на первую строку
		СтрокаДляПогрешности = База[0];
	Иначе	
		// Разницу между суммой и исходным итогом распределяем пропорционально базе.
		// Распределенную разницу добавляем к исходной базе.		
		РаспределениеРазницы = 
			РаспределитьСуммуПропорциональноБазе(
				Сумма - Итог, 
				ОбщегоНазначения.ВыгрузитьКолонку(База, Колонка),
				Точность);
		Если РаспределениеРазницы = Неопределено Тогда
			// Кол-во базовых значений = 0 или сумма базовых значений = 0.
			// ничего не делаем
		Иначе			
			Для Индекс = 0 По База.Количество()-1 Цикл
				База[Индекс][Колонка] = База[Индекс][Колонка] + РаспределениеРазницы[Индекс];
			КонецЦикла			
		КонецЕсли;
	КонецЕсли;
	
	// Возможную погрешность относим на определенную ранее строку
	Итог = 0;
	Для Каждого Строка Из База Цикл
		Итог = Итог + Строка[Колонка]
	КонецЦикла;	
	Если Итог <> Сумма Тогда
		СтрокаДляПогрешности[Колонка] = СтрокаДляПогрешности[Колонка] + Сумма - Итог
	КонецЕсли
	
КонецПроцедуры

#Область ЗаполнениеЗначенийПоУмолчанию

// Выполняет заполнение первоначальных значений при создании новых 
// объектов или открытии иных форм.
// Параметры:
//		Форма - форма, реквизиты которой необходимо заполнить.
//		ЗапрашиваемыеЗначения - структура с запрашиваемыми значениями.
//			Имя элемента структуры идентифицирует значение, которое 
//				необходимо заполнить.
//			Значение элемента структуры - путь к реквизиту формы, значение
//				которого необходимо заполнить.
//			Список поддерживаемых значений см. в описании ПолучитьЗначенияПоУмолчанию.
//
Процедура ЗаполнитьПервоначальныеЗначенияВФорме(Форма, ЗапрашиваемыеЗначения) Экспорт
	
	ФиксированныеЗначения = Новый Массив;
	Для Каждого ЗапрашиваемоеЗначение Из ЗапрашиваемыеЗначения Цикл
		// Поддерживаемое значение по умолчанию "Ответственный" имеет особое поведение - заполняется безусловно.
		Если ЗапрашиваемоеЗначение.Ключ = "Ответственный" Тогда
			Продолжить;
		КонецЕсли;
		Если ЗначениеЗаполнено(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, ЗапрашиваемоеЗначение.Значение)) Тогда
			ФиксированныеЗначения.Добавить(ЗапрашиваемоеЗначение.Ключ)
		КонецЕсли	
	КонецЦикла;

	ЗаполнитьЗначенияВФорме(Форма, ЗапрашиваемыеЗначения, ФиксированныеЗначения);
	
КонецПроцедуры

// Выполняет заполнение значений в форме на основании значений по умолчанию.
// 
// Параметры:
//		Форма - форма, реквизиты которой необходимо заполнить.
//		ЗапрашиваемыеЗначения - структура с запрашиваемыми значениями.
//			Имя элемента структуры идентифицирует значение, которое 
//				необходимо заполнить.
//			Значение элемента структуры - путь к реквизиту формы, значение
//				которого необходимо заполнить.
//			Список поддерживаемых значений см. в описании ПолучитьЗначенияПоУмолчанию.
//
//		ФиксированныеЗначения - (необязательный) массив, 
//				Содержит идентификаторы значений, 
//				которое не должны быть изменены при заполнении.
//
Процедура ЗаполнитьЗначенияВФорме(Форма, ЗапрашиваемыеЗначения, ФиксированныеЗначения = Неопределено) Экспорт
	
	Если ФиксированныеЗначения = Неопределено Тогда
		ФиксированныеЗначения = Новый Массив
	КонецЕсли;
	
	ЗаполняемыеЗначения = Новый Структура;
	
	Для Каждого ЗапрашиваемоеЗначение Из ЗапрашиваемыеЗначения Цикл
		
		ЗначениеРеквизита = ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, ЗапрашиваемоеЗначение.Значение);
		Если ФиксированныеЗначения.Найти(ЗапрашиваемоеЗначение.Ключ) = Неопределено Тогда
			ЗначениеРеквизита = ПустоеЗначениеТипаПоЗначению(ЗначениеРеквизита);
		КонецЕсли;
		ЗаполняемыеЗначения.Вставить(ЗапрашиваемоеЗначение.Ключ, ЗначениеРеквизита);
		
	КонецЦикла;
	
	ПолучитьЗначенияПоУмолчанию(ЗаполняемыеЗначения);
	
	// Заполняем значения
	Для Каждого ЗапрашиваемоеЗначение Из ЗапрашиваемыеЗначения Цикл
		Если ФиксированныеЗначения.Найти(ЗапрашиваемоеЗначение.Ключ) = Неопределено Тогда
			ЗначениеРеквизита = НеОпределено;
			Если ЗаполняемыеЗначения.Свойство(ЗапрашиваемоеЗначение.Ключ, ЗначениеРеквизита) Тогда 
				ОбщегоНазначенияКлиентСервер.УстановитьРеквизитФормыПоПути(Форма, ЗапрашиваемоеЗначение.Значение, ЗначениеРеквизита);
			КонецЕсли;
		КонецЕсли
	КонецЦикла;
	
КонецПроцедуры

// Получает значения по умолчанию.
// Параметры:
//		ЗаполняемыеЗначения - структура, 
//				Ключи структуры - идентификаторы запрашиваемых значений, 
//				Значения полей структуры заполняются процедурой приведены ниже.
//
//				Процедура поддерживает получение значений по умолчанию, которые 
//				зависят от других значений.
//				Например, для получения значения ДолжностьРуководителя для 
//				конкретной организации можно передать структуру с полями Организация и 
//				ДолжностьРуководителя, причем поле Организация заполнить конкретным значением.
//				В результате выполнения процедуры поле ДолжностьРуководителя
//				будет заполнено значением по умолчанию.
//
//		ЗаполненныеЗначения - (необязательный) массив, 
//				Содержит идентификаторы уже заполненных значений, 
//				Значения - уже заполненные значения.
//				На основании уже заполненных значений, могут быть 
//				заполнены, например, данные организации (НаименованиеПРФ и т.п.).
//		
//		Допустимые идентификаторы запрашиваемых значений - см. СписокДоступныхЗначенийПоУмолчанию:
//
Процедура ПолучитьЗначенияПоУмолчанию(ЗаполняемыеЗначения, ДатаЗначений = НеОпределено) Экспорт
	
	ДатаЗначений = ДатаЗаполненияЗначений(ДатаЗначений);
	
	ЗначенияЗаполняемыеПоУмолчанию = ЗначенияЗаполняемыеПоУмолчанию(ЗаполняемыеЗначения);
	   
	// Значения по умолчанию получаем в цикле для того, чтобы заполнить как 
	// "первичные", так и зависимые значения.
	// Например, на первой итерации могли получить значение для поля Организация, 
	// а на следующей итерации - значение для поля НаименованиеПФР.
	Пока Истина Цикл
		
		НеОпределеноДо = КоличествоНеОпределенныхЗначений(ЗаполняемыеЗначения);
		
		ЗаполнитьЗначенияПоУмолчанию(ЗаполняемыеЗначения, ЗначенияЗаполняемыеПоУмолчанию, ДатаЗначений);
		
		ПолучитьЕдинственныеЗначенияТипов(ЗаполняемыеЗначения);
		
		НеОпределеноПосле = КоличествоНеОпределенныхЗначений(ЗаполняемыеЗначения);
		
		Если ЗаполнениеЗначенийЗакончено(НеОпределеноДо, НеОпределеноПосле) Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьЗначенияПоУмолчанию(ЗаполняемыеЗначения, ЗначенияЗаполняемыеПоУмолчанию, ДатаЗначений)
	
	ЗаполнитьЗначенияСвойств(ЗначенияЗаполняемыеПоУмолчанию, ЗаполняемыеЗначения);
	
	ЗарплатаКадрыВнутренний.ПолучитьЗначенияПоУмолчанию(ЗначенияЗаполняемыеПоУмолчанию, ДатаЗначений);
	ЗарплатаКадрыПереопределяемый.ПолучитьЗначенияПоУмолчанию(ЗначенияЗаполняемыеПоУмолчанию, ДатаЗначений);
	ЗаполнитьЗначениеОрганизацииПоУмолчанию(ЗначенияЗаполняемыеПоУмолчанию);
	
	ЗаполнитьЗначенияСвойств(ЗаполняемыеЗначения, ЗначенияЗаполняемыеПоУмолчанию);
	
КонецПроцедуры

Функция ЗначенияЗаполняемыеПоУмолчанию(ЗаполняемыеЗначения)
	
	ПоддерживаемыеИдентификаторы = ЗарплатаКадрыВнутренний.СписокДоступныхЗначенийПоУмолчанию();
	
	ЗначенияЗаполняемыеПоУмолчанию = Новый Структура;
	
	Для Каждого КлючЗначение Из ЗаполняемыеЗначения Цикл
		
		Если ПоддерживаемыеИдентификаторы.Найти(КлючЗначение.Ключ) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ЗначенияЗаполняемыеПоУмолчанию.Вставить(КлючЗначение.Ключ);
		
	КонецЦикла;
	
	Возврат ЗначенияЗаполняемыеПоУмолчанию;
	
КонецФункции

Функция ЗаполнениеЗначенийЗакончено(НеОпределеноДо, НеОпределеноПосле)
	// Ничего не заполнили или уже все заполнили.
	Возврат НеОпределеноДо = НеОпределеноПосле Или НеОпределеноПосле = 0
КонецФункции

Функция ДатаЗаполненияЗначений(ДатаЗначений)
	
	Если ДатаЗначений = НеОпределено Тогда
		ДатаЗначений = ОбщегоНазначения.ТекущаяДатаПользователя();
	КонецЕсли;

	Возврат ДатаЗначений;
	
КонецФункции

// Заполняет значение организации, если организация в коллекции запрашиваемых данных еще не заполнена.
// Значение организации получается из настроек пользователя по ключу объекта настроек "НастройкиПользователя"
// и ключу настроек "Организация". Если значения в настройках нет, заполняется первой доступной организацией.
//
Процедура ЗаполнитьЗначениеОрганизацииПоУмолчанию(ЗаполняемыеЗначения)
	
	Если ЗаполняемыеЗначения.Свойство("Организация") И НЕ ЗначениеЗаполнено(ЗаполняемыеЗначения.Организация) Тогда
		
		Организация = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("НастройкиПользователя", "Организация");
		Если ЗначениеЗаполнено(Организация) Тогда
			
			// Проверка доступности организации по РЛС.
			Запрос = Новый Запрос;
			Запрос.УстановитьПараметр("Организация", Организация);
			
			Запрос.Текст =
				"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
				|	Организации.Ссылка
				|ИЗ
				|	Справочник.Организации КАК Организации
				|ГДЕ
				|	Организации.Ссылка = &Организация";
				
			Выборка = Запрос.Выполнить().Выбрать();
			Если НЕ Выборка.Следующий() Тогда
				Организация = Справочники.Организации.ПустаяСсылка();
			КонецЕсли;
			
		КонецЕсли;
		
		Если ЗначениеЗаполнено(Организация) Тогда
			ЗаполняемыеЗначения.Организация = Организация;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура получает ссылочные значений, имеющиеся в базе в единственном экземпляре.
// Параметры:
//		ЗаполняемыеЗначения - структура, 
//				Ключи структуры - идентификаторы запрашиваемых значений, 
//				Значения полей должны быть заполнены, как минимум пустой ссылкой(для ссылочных полей).
//
// Допущения реализации:
//	1. Если в переданной структуре находятся 2 элемента одинакового типа
// 		и этот тип является типом владельца подбираемого значения, то в качестве владельца всегда будет использоваться
// 		первый заполненный элемент.
//  2. Не учитываются возможные связи параметров выбора.
//
Процедура ПолучитьЕдинственныеЗначенияТипов(ЗаполняемыеЗначения) Экспорт

	ТипыИзвестныхЗначений = Новый Соответствие;
	Для каждого ЗаполняемоеЗначение Из ЗаполняемыеЗначения Цикл
		
		ТипЗначения = ТипЗнч(ЗаполняемоеЗначение.Значение);
		Если НЕ ОбщегоНазначения.ЭтоСсылка(ТипЗначения) Тогда
			Продолжить;
		КонецЕсли; 
		
		Если ЗначениеЗаполнено(ЗаполняемоеЗначение.Значение) Тогда
			ТипыИзвестныхЗначений.Вставить(ЗаполняемоеЗначение.Значение , Метаданные.НайтиПоТипу(ТипЗначения));
		КонецЕсли; 
		
	КонецЦикла;
	
	Запрос = Новый Запрос;
	ТекстОсновногоЗапроса  = Новый Массив;;
	
	СтрокаЗаменыОбъединить  = "
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";
	
	ПервыйЗапрос = Истина;
	
	Для каждого ЗаполняемоеЗначение Из ЗаполняемыеЗначения Цикл
		Если ЗначениеЗаполнено(ЗаполняемоеЗначение.Значение) ИЛИ ЗаполняемоеЗначение.Значение = Неопределено Тогда
			Продолжить;	
		КонецЕсли;
		
		Тип = ТипЗнч(ЗаполняемоеЗначение.Значение);
		Если НЕ ОбщегоНазначения.ЭтоСсылка(Тип) Тогда
			Продолжить;
		КонецЕсли; 
		
		УсловиеПоВладельцу = Новый Массив;
		МетаданныеТипа = Метаданные.НайтиПоТипу(Тип);
		Если ОбщегоНазначения.ЭтоСправочник(МетаданныеТипа) И МетаданныеТипа.Владельцы.Количество() > 0 Тогда
			
			Для каждого ИзвестныеЗначения Из ТипыИзвестныхЗначений Цикл
				
				Если МетаданныеТипа.Владельцы.Содержит(ИзвестныеЗначения.Значение) Тогда
					УсловиеПоВладельцу.Добавить("ГДЕ ");
					УсловиеПоВладельцу.Добавить(МетаданныеТипа.Имя);
					УсловиеПоВладельцу.Добавить(".Владелец = &Владелец");
					УсловиеПоВладельцу.Добавить(МетаданныеТипа.Имя);
					Запрос.УстановитьПараметр("Владелец" + МетаданныеТипа.Имя, ИзвестныеЗначения.Ключ);
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
			Если УсловиеПоВладельцу.Количество() = 0 Тогда
				УсловиеПоВладельцу.Добавить("ГДЕ ");
				УсловиеПоВладельцу.Добавить(МетаданныеТипа.Имя);
				УсловиеПоВладельцу.Добавить(".Владелец = НЕОПРЕДЕЛЕНО");
			КонецЕсли; 
			
		КонецЕсли; 
		
		Если ПервыйЗапрос Тогда
			ПервыйЗапрос = Ложь;
			ТекстОсновногоЗапроса.Добавить("ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 2 """);
		Иначе
			ТекстОсновногоЗапроса.Добавить(СтрокаЗаменыОбъединить);
			ТекстОсновногоЗапроса.Добавить("ВЫБРАТЬ ПЕРВЫЕ 2 """);
		КонецЕсли;
		
		ТекстОсновногоЗапроса.Добавить(ЗаполняемоеЗначение.Ключ);
		ТекстОсновногоЗапроса.Добавить(""" КАК Поле,
			|	");
		ТекстОсновногоЗапроса.Добавить(МетаданныеТипа.Имя);
		ТекстОсновногоЗапроса.Добавить(".Ссылка КАК Ссылка
			| ИЗ ");
		ТекстОсновногоЗапроса.Добавить(МетаданныеТипа.ПолноеИмя());
		ТекстОсновногоЗапроса.Добавить(" КАК ");
		ТекстОсновногоЗапроса.Добавить(МетаданныеТипа.Имя);
		ТекстОсновногоЗапроса.Добавить(Символы.ПС);
		ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ТекстОсновногоЗапроса, УсловиеПоВладельцу);
		
	КонецЦикла;
	
	Если ТекстОсновногоЗапроса.Количество() > 0 Тогда
		ТекстОсновногоЗапроса.Добавить("
			|ИТОГИ ПО
			| Поле");
		Запрос.Текст = СтрСоединить(ТекстОсновногоЗапроса);
		Результат = Запрос.Выполнить();
		Если Не Результат.Пустой() Тогда
			Выборка = Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			Пока Выборка.Следующий() Цикл
				ВыборкаПоПолю = Выборка.Выбрать();
				Если ВыборкаПоПолю.Количество() = 1 Тогда
					ВыборкаПоПолю.Следующий();
					ЗаполняемыеЗначения[ВыборкаПоПолю.Поле] = ВыборкаПоПолю.Ссылка;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область ДатыИзмененийЗаконодательства

Функция ДатаОтменыЕНВД() Экспорт

	Возврат '20210101'

КонецФункции

#КонецОбласти

// Возвращает ссылку на первую из упорядоченных по алфавиту, доступную организацию.
//
// Возвращаемое значение:
//		СправочникСсылка.Организации
//
Функция ПерваяДоступнаяОрганизация() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
		|	Организации.Ссылка
		|ИЗ
		|	Справочник.Организации КАК Организации
		|
		|УПОРЯДОЧИТЬ ПО
		|	Организации.Наименование";
		
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Организация = Выборка.Ссылка;
	Иначе
		Организация = Справочники.Организации.ПустаяСсылка();
	КонецЕсли;
	
	Возврат Организация;
			
КонецФункции

// Процедура заполняет значение реквизитов "РегистрацияВНалоговомОргане" и т.п.
// Перед записью организации для подразделений, владельцем которых она является
// или перед записью подразделения для подчиненных элементов.
//
//	Параметры:
//		ИсточникДанных - источник данных для записи реквизитов.
//			Неопределено - устанавливаются реквизиты для всех подчиненных подразделений
//			Объект, содержащий свойства.
//				Ссылка (СправочникСсылка.Организации или СправочникСсылка.ПодразделенияОрганизаций).
//				Наименование
//				РегистрацияВНалоговомОргане
//				РайонныйКоэффициент.
//				РайонныйКоэффициентРФ - не обязательно.
//				ПрименяемыйЛьготныйТерриториальныйТариф - не обязательно.
//
Процедура УстановитьРеквизитыВПодчиненныхПодразделениях(ИсточникДанных) Экспорт
	
	Если ИсточникДанных <> Неопределено Тогда
		ВыполняетсяЗаписьОрганизации = (ТипЗнч(ИсточникДанных.Ссылка) = Тип("СправочникСсылка.Организации"));
	КонецЕсли;
	
	Если ИсточникДанных <> Неопределено И Не ВыполняетсяЗаписьОрганизации 
		И ИсточникДанных.ДополнительныеСвойства.ОбособленноеПодразделение = ИсточникДанных.ОбособленноеПодразделение
		И Не ИсточникДанных.ОбособленноеПодразделение Тогда
		// Не обновляем подчиненные структурные единицы, т.к. ничего не изменилось.
		ПодчиненныеСтруктурныеЕдиницы = Новый Соответствие;
		ПодчиненныеСтруктурныеЕдиницы.Вставить(ИсточникДанных.Ссылка, Новый Массив);
	Иначе
		ПодчиненныеСтруктурныеЕдиницы = Справочники.ПодразделенияОрганизаций.ПодчиненныеСтруктурныеЕдиницы(
			?(ИсточникДанных = Неопределено, Неопределено, ИсточникДанных.Ссылка));
		РегистрыСведений.ТерриториальныеУсловияПФР.ОбновитьПодчиненныеСтруктурныеЕдиницы(ПодчиненныеСтруктурныеЕдиницы, ИсточникДанных = Неопределено);
		РегистрыСведений.ИсторияРегистрацийВНалоговомОргане.ОбновитьПодчиненныеСтруктурныеЕдиницы(ПодчиненныеСтруктурныеЕдиницы, ИсточникДанных = Неопределено);
		РегистрыСведений.ИсторияСамостоятельныхКлассификационныхЕдиниц.ОбновитьПодчиненныеСтруктурныеЕдиницы(ПодчиненныеСтруктурныеЕдиницы, ИсточникДанных = Неопределено);
	КонецЕсли;
	
	Запрос = Новый Запрос;
	
	Для Каждого СтрокаСтруктурныеЕдиницы Из ПодчиненныеСтруктурныеЕдиницы Цикл
		Запрос.УстановитьПараметр("ПодчиненныеСтруктурныеЕдиницы", СтрокаСтруктурныеЕдиницы.Значение);
		
		Запрос.Текст = 
		"ВЫБРАТЬ
		|	ПодразделенияОрганизаций.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ПодразделенияОрганизаций КАК ПодразделенияОрганизаций
		|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.Организации КАК Организации
		|		ПО ПодразделенияОрганизаций.Владелец = Организации.Ссылка
		|ГДЕ
		|	(&УсловияПроверкиНеобходимостиОбновления
		|			ИЛИ НЕ Организации.ЕстьОбособленныеПодразделения
		|				И ПодразделенияОрганизаций.ОбособленноеПодразделение)
		|	И ПодразделенияОрганизаций.Ссылка В(&ПодчиненныеСтруктурныеЕдиницы)
		|	И &ПодчиненВладельцу";
		
		Если ИсточникДанных = Неопределено Тогда
			УсловиеЗапроса = "(ИСТИНА)";
		ИначеЕсли ВыполняетсяЗаписьОрганизации Тогда
			УсловиеЗапроса = "ПодразделенияОрганизаций.Владелец = &Владелец";
			Запрос.УстановитьПараметр("Владелец", ИсточникДанных.Ссылка);
		Иначе
			Если ТипЗнч(СтрокаСтруктурныеЕдиницы.Ключ) = Тип("СправочникСсылка.Организации") Тогда
				УсловиеЗапроса = "(ИСТИНА)";
			Иначе
				УсловиеЗапроса = "ПодразделенияОрганизаций.Родитель В ИЕРАРХИИ (&Владелец)";
				Запрос.УстановитьПараметр("Владелец", ИсточникДанных.Ссылка);
			КонецЕсли;
		КонецЕсли;
		
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ПодчиненВладельцу", УсловиеЗапроса);
		
		// Условия проверки необходимости обновления.
		УсловияПроверкиНеобходимостиОбновления = "";
		УсловияЗапроса = УсловияЗапросаПроверкиНеобходимостиЗаполненияПодчиненныхПодразделений(Запрос, СтрокаСтруктурныеЕдиницы.Ключ);
		Для каждого УсловиеЗапроса Из УсловияЗапроса Цикл
			УсловияПроверкиНеобходимостиОбновления = ?(ПустаяСтрока(УсловияПроверкиНеобходимостиОбновления), "", УсловияПроверкиНеобходимостиОбновления + Символы.ПС + "ИЛИ ")
				+ УсловиеЗапроса;
		КонецЦикла;
		
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловияПроверкиНеобходимостиОбновления", УсловияПроверкиНеобходимостиОбновления);
		
		ВыборкаПодразделений = Запрос.Выполнить().Выбрать();
		
		Пока ВыборкаПодразделений.Следующий() Цикл
			ПодразделениеОбъект = ВыборкаПодразделений.Ссылка.ПолучитьОбъект();
			Попытка
				ПодразделениеОбъект.Заблокировать();
			Исключение
				ТекстИсключенияЗаписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Не удалось изменить подчиненное подразделение %1 при записи %2.
				|Возможно, подразделение редактируется другим пользователем'"),
				ПодразделениеОбъект.Наименование,
				?(ИсточникДанных = Неопределено, НСтр("ru = 'всех подразделений'"), ИсточникДанных.Наименование));
				ВызватьИсключение ТекстИсключенияЗаписи;
			КонецПопытки;
			
			ЗаполнитьПодчиненноеПодразделение(ПодразделениеОбъект, СтрокаСтруктурныеЕдиницы.Ключ);
			Если ИсточникДанных <> Неопределено И ВыполняетсяЗаписьОрганизации Тогда
				Если Не ИсточникДанных.ЕстьОбособленныеПодразделения И ПодразделениеОбъект.ОбособленноеПодразделение Тогда
					ПодразделениеОбъект.ОбособленноеПодразделение = Ложь;
				КонецЕсли;
			КонецЕсли;
			
			ПодразделениеОбъект.ДополнительныеСвойства.Вставить("ОбработкаЗаписиРодителя", Истина);
			ПодразделениеОбъект.ОбменДанными.Загрузка = Истина;
			ПодразделениеОбъект.Записать();
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

// Выполняет формирование таблицы с набором значений доступа объекта (документа), 
// содержащего ссылки на организацию.
// Вызывается из процедуры ЗаполнитьНаборыЗначенийДоступа, реализованной в модуле таких 
// документов, доступ к которым выполняется через наборы значений доступа.
// Параметры:
//		Объект
//		Таблица - переданная таблица значений.
//		ПутьОрганизация - строка с именем реквизита, содержащего организацию.
//
Процедура ЗаполнитьНаборыПоОрганизации(Объект, Таблица, ПутьОрганизация, НомерНабора = 0) Экспорт
	
	// Логика ограничения:
	// объект доступен, если доступна организация.
	
	СтрокаТаб = Таблица.Добавить();
	СтрокаТаб.ЗначениеДоступа = Объект[ПутьОрганизация];
	СтрокаТаб.НомерНабора = НомерНабора;
	
КонецПроцедуры

// Выполняет формирование таблицы с набором значений доступа объекта (документа), 
// содержащего ссылки на организацию и сотрудника (сотрудников).
// Вызывается из процедуры ЗаполнитьНаборыЗначенийДоступа, реализованной в модуле таких 
// документов, доступ к которым выполняется через наборы значений доступа.
// Параметры:
//		Объект
//		Таблица - переданная таблица значений.
//		ПутьОрганизация - строка с именем реквизита, содержащего организацию.
//		ПутьФизическоеЛицо - строка с именем реквизита, содержащего физическое лицо.
//			Может быть идентификатором реквизита объекта (например, "ФизическоеЛицо") или
//			путем к реквизиту табличной части в 
//			формате <ИмяТабличнойЧасти>.<ИмяРеквизита> 
//			(например, "ФизическиеЛица.ФизическоеЛицо").
//
Процедура ЗаполнитьНаборыПоОрганизацииИФизическимЛицам(Объект, Таблица, ПутьОрганизация, ПутьФизическоеЛицо, НомерНабора = 0) Экспорт
	
	// Логика ограничения:
	// объект доступен, если доступна организация и все физические лица.
	
	ЗаполнитьНаборыПоОрганизации(Объект, Таблица, ПутьОрганизация, НомерНабора);
	
	СтрокиПутиФизическогоЛица = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьФизическоеЛицо, ".");
	Если СтрокиПутиФизическогоЛица.Количество() = 1 Тогда
		СтрокаТаб = Таблица.Добавить();
		СтрокаТаб.ЗначениеДоступа = Объект[ПутьФизическоеЛицо];
		СтрокаТаб.НомерНабора = НомерНабора;
		
	Иначе
		Для Каждого СтрокаТаблицы Из Объект[СтрокиПутиФизическогоЛица[0]] Цикл
			СтрокаТаб = Таблица.Добавить();
			СтрокаТаб.ЗначениеДоступа = СтрокаТаблицы[СтрокиПутиФизическогоЛица[1]];
			СтрокаТаб.НомерНабора = НомерНабора;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Помещает в переданный массив имена реквизитов формы.
// Параметры:
//		Форма - ФормаКлиентскогоПриложения.
//		МассивИменРеквизитовФормы - Массив - заполняемый массив имен реквизитов формы.
//      ПутьКДанным - Строка - путь к родительскому реквизиту. 
//		                       Если параметр опущен или указана пустая строка, 
//		                       возвращаются реквизиты верхнего уровня.
//
Процедура ЗаполнитьМассивИменРеквизитовФормы(Форма, МассивИменРеквизитовФормы,  ПутьКДанным = "") Экспорт
	
	Если ЗначениеЗаполнено(ПутьКДанным) Тогда
		МассивРеквизитовФормы = Форма.ПолучитьРеквизиты(ПутьКДанным);
	Иначе
		МассивРеквизитовФормы = Форма.ПолучитьРеквизиты();
	КонецЕсли;
	
	Для Каждого Реквизит Из МассивРеквизитовФормы Цикл
		МассивИменРеквизитовФормы.Добавить(?(ЗначениеЗаполнено(ПутьКДанным), ПутьКДанным + ".", "") + Реквизит.Имя);	
	КонецЦикла;
	
КонецПроцедуры

// Помещает в переданный массив имена реквизитов формы,
// "отложенные" для добавления в пакете и хранящиеся в реквизите "РеквизитыКДобавлению".
// Параметры:
//		Форма - ФормаКлиентскогоПриложения.
//		МассивИменРеквизитовФормы - Массив - заполняемый массив имен реквизитов формы.
//      ПутьКДанным - Строка - путь к родительскому реквизиту. 
//		                       Если параметр опущен или указана пустая строка, 
//		                       возвращаются реквизиты верхнего уровня.
//
Процедура ДополнитьМассивИменРеквизитовФормыИзРеквизитовКДобавлению(Форма, МассивИменРеквизитовФормы, ПутьКДанным = "") Экспорт

	Если МассивИменРеквизитовФормы.Найти("РеквизитыКДобавлению") <> Неопределено Тогда
		Для каждого ДобавляемыйРеквизит Из Форма.РеквизитыКДобавлению.ВыгрузитьЗначения() Цикл
			Если ДобавляемыйРеквизит.Путь = ПутьКДанным Тогда
				МассивИменРеквизитовФормы.Добавить(?(ЗначениеЗаполнено(ПутьКДанным), ПутьКДанным + ".", "") + ДобавляемыйРеквизит.Имя);	
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

// Изменяет реквизиты формы
// Параметры:
// 		Форма, 
//		ДобавляемыеРеквизиты - массив добавляемых реквизитов.
//		СуществующиеРеквизиты - массив текущих реквизитов формы. Можно получить при помощи
//		                        ЗарплатаКадры.ЗаполнитьМассивИменРеквизитовФормы.
//		УдаляемыеРеквизиты - не обязательный. Массив удаляемых реквизитов.
//		ОтложенноеИзменение - по умолчанию Ложь. В случае если параметр равен Истина - добавления/удаления реквизитов не происходит, а происходит запись
//								данных реквизитов в реквизит формы с типом "СписокЗначений".
//
// В том случае, если реквизит уже существует, он не создается.
//
Процедура ИзменитьРеквизитыФормы(Форма, ДобавляемыеРеквизиты, СуществующиеРеквизиты, УдаляемыеРеквизиты = Неопределено, ОтложенноеИзменение = Ложь) Экспорт
	
	Если УдаляемыеРеквизиты = Неопределено Тогда 
		УдаляемыеРеквизиты = Новый Массив;
	КонецЕсли;
	
	// Удаляем уже существующие реквизиты из ДобавляемыеРеквизиты.
	УжеСуществующиеРеквизиты = Новый Массив;
	ИменаУдаляемыхРеквизитов = Новый Массив;
	
	Для Каждого Реквизит Из ДобавляемыеРеквизиты Цикл
		ПолноеИмяРеквизита = ?(ЗначениеЗаполнено(Реквизит.Путь), Реквизит.Путь + ".", "") + Реквизит.Имя;
		Если СуществующиеРеквизиты.Найти(ПолноеИмяРеквизита) <> Неопределено Тогда
			УжеСуществующиеРеквизиты.Добавить(Реквизит);
			ИменаУдаляемыхРеквизитов.Добавить(ПолноеИмяРеквизита);
		КонецЕсли;					
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ИменаУдаляемыхРеквизитов, УдаляемыеРеквизиты);
	
	// Из дополняемых реквизитов также удаляем те, которые содержатся внутри удаляемых реквизитов и дублей-реквизитов.
	Для Каждого Реквизит Из ДобавляемыеРеквизиты Цикл
		Если УжеСуществующиеРеквизиты.Найти(Реквизит) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Если НЕ ЗначениеЗаполнено(Реквизит.Путь) Тогда
		    Продолжить;
		КонецЕсли;
		Если ИменаУдаляемыхРеквизитов.Найти(Реквизит.Путь) <> Неопределено Тогда
			УжеСуществующиеРеквизиты.Добавить(Реквизит);
		КонецЕсли;					
	КонецЦикла;
	
	Для Каждого Реквизит Из УжеСуществующиеРеквизиты Цикл
		ОбщегоНазначенияКлиентСервер.УдалитьЗначениеИзМассива(ДобавляемыеРеквизиты, Реквизит);
	КонецЦикла;
	
	Если ДобавляемыеРеквизиты.Количество() = 0 И УдаляемыеРеквизиты.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	Если ОтложенноеИзменение Тогда
		Для Каждого Реквизит Из УдаляемыеРеквизиты Цикл
			Форма.РеквизитыКУдалению.Добавить(Реквизит);
		КонецЦикла;
		Для Каждого Реквизит Из ДобавляемыеРеквизиты Цикл
			Форма.РеквизитыКДобавлению.Добавить(Реквизит);
		КонецЦикла;
	Иначе
		Форма.ИзменитьРеквизиты(ДобавляемыеРеквизиты, УдаляемыеРеквизиты);
	КонецЕсли;
	
КонецПроцедуры

// Удаляет все элементы, подчиненные группе элементов формы.
Процедура УдалитьПодчиненныеЭлементыГруппы(Форма, ГруппаФормы) Экспорт 
	
	ЭлементыДляУдаления = Новый Массив;
	Для Каждого Элемент Из ГруппаФормы.ПодчиненныеЭлементы Цикл
		ЭлементыДляУдаления.Добавить(Элемент);
	КонецЦикла;
	
	Для Каждого Элемент Из ЭлементыДляУдаления Цикл
		Форма.Элементы.Удалить(Элемент);
	КонецЦикла;
	
КонецПроцедуры

// Возвращает ссылку на валюту в которой происходит расчет заработной платы (рубль РФ).
// Номинирование тарифов, надбавок, выплата зарплаты допускается в любой валюте, 
// но расчеты выполняются в валюте учета зарплаты.
Функция ВалютаУчетаЗаработнойПлаты() Экспорт
	
	Возврат ЗарплатаКадрыПовтИсп.ВалютаУчетаЗаработнойПлаты();
	
КонецФункции

// Возвращает соответствие Физлицо - ФИО на дату
// относящихся к персональным.
//
// Параметры:
//		ДатаАктуальности - дата, на которую определяется ФИО:
//		МассивФизЛиц - массив ссылок типа СправочникСсылка.ФизическиеЛица.
//
// Возвращаемое значение:
//		соответствие	
//			ключ - СправочникСсылка.ФизическиеЛица
//			значение - строка ФИО.
//
//
Функция СоответствиеФИОФизЛицСсылкам(ДатаАктуальности, МассивФизЛиц) Экспорт 
	
	МассивНеобходимыхПолей = Новый Массив;
	МассивНеобходимыхПолей.Добавить("ФамилияИО");
	МассивНеобходимыхПолей.Добавить("Фамилия");
	МассивНеобходимыхПолей.Добавить("Имя");
	МассивНеобходимыхПолей.Добавить("Отчество");
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	КадровыйУчет.СоздатьНаДатуВТКадровыеДанныеФизическихЛиц(Запрос.МенеджерВременныхТаблиц, Истина, МассивФизЛиц, МассивНеобходимыхПолей, ДатаАктуальности);
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	КадровыеДанныеФизЛиц.ФизическоеЛицо,
	|	КадровыеДанныеФизЛиц.ФамилияИО,
	|	КадровыеДанныеФизЛиц.Фамилия,
	|	КадровыеДанныеФизЛиц.Имя,
	|	КадровыеДанныеФизЛиц.Отчество
	|ИЗ
	|	ВТКадровыеДанныеФизическихЛиц КАК КадровыеДанныеФизЛиц";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	СоответствиеФИОФизЛицСсылкам = Новый Соответствие;
	
	Пока Выборка.Следующий() Цикл
		ФИО = Новый Структура("ФамилияИО, Фамилия, Имя, Отчество");
		ЗаполнитьЗначенияСвойств(ФИО, Выборка);
		СоответствиеФИОФизЛицСсылкам.Вставить(Выборка.ФизическоеЛицо, ФИО);		
	КонецЦикла;	
	
	Возврат СоответствиеФИОФизЛицСсылкам;
	
КонецФункции	

// Преобразовывает переданные массивы сотрудников и физических лиц в строку 
// вида <Фамилия И.О., Фамилия И.О...>.
// Используется для заполнения краткого состава документов.
//
// Параметры:
//	- Сотрудники - массив элементов типа СправочникСсылка.Сотрудники,
//	- ДатаАктуальности - дата для получения фамилии, имени и отчества.
//	- Физлица - необязательный, массив элементов типа СправочникСсылка.ФизическиеЛица.
//	- ФизлицаСотрудников - соответствие Сотрудник - Физическое лицо.
//
Функция КраткийСоставСотрудников(Сотрудники, ДатаАктуальности, Физлица = Неопределено, ФизлицаСотрудников = Неопределено) Экспорт
	
	Если ФизлицаСотрудников = Неопределено Тогда
		ФизлицаСотрудников = ОбщегоНазначения.ЗначениеРеквизитаОбъектов(Сотрудники, "ФизическоеЛицо");
	КонецЕсли;
	
	СписокФизическихЛиц = ОбщегоНазначения.ВыгрузитьКолонку(ФизлицаСотрудников, "Значение", Истина);
	
	Если Физлица <> Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.ДополнитьМассив(СписокФизическихЛиц, Физлица, Истина);
	КонецЕсли;
	
	Возврат КраткийСоставСотрудниковПоСпискуФизическихЛиц(СписокФизическихЛиц, ДатаАктуальности);
	
КонецФункции

Функция КраткийСоставСотрудниковПоСпискуФизическихЛиц(ФизическиеЛица, ДатаАктуальности) Экспорт
	
	// Первые N человек и M символов.
	МаксимальноеКоличествоФизическихЛиц = 10;
	МаксимальнаяДлинаСтроки = 100;

	Счетчик = 0;
	ПервыеФизлица = Новый Массив;
	УникальныеФизлица = Новый Соответствие;
	
	Для Каждого Физлицо Из ФизическиеЛица Цикл
		
		Если Счетчик = МаксимальноеКоличествоФизическихЛиц Тогда
			Прервать;
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(Физлицо) 
			Или УникальныеФизлица[Физлицо] <> Неопределено Тогда
			
			Продолжить;
			
		КонецЕсли;
		
		ПервыеФизлица.Добавить(Физлицо);
		УникальныеФизлица.Вставить(Физлицо, Истина);
		
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
	ИменаФизлиц = СоответствиеФИОФизЛицСсылкам(ДатаАктуальности, ПервыеФизлица);
	
	КраткийСостав = "";
	
	Для Каждого Физлицо Из ПервыеФизлица Цикл
		
		Если Не ПустаяСтрока(КраткийСостав) Тогда
			КраткийСостав = КраткийСостав + ", ";
		КонецЕсли;
		
		ФИО = ИменаФизлиц[Физлицо];
		КраткийСостав = КраткийСостав + ФИО.ФамилияИО;
		
	КонецЦикла;
	
	Если СтрДлина(КраткийСостав) > МаксимальнаяДлинаСтроки Тогда
		КраткийСостав = Лев(КраткийСостав, МаксимальнаяДлинаСтроки - 3) + "...";
	КонецЕсли;
	
	Возврат КраткийСостав;
	
КонецФункции

// Преобразовывает переданный массив физических лиц в строку 
// вида <Фамилия И.О., Фамилия И.О...>.
// Используется для представления краткого состава документов.
//
// Параметры:
//	- Физлица - массив элементов типа СправочникСсылка.ФизическиеЛица,
//	- ДатаАктуальности - дата для получения фамилии, имени и отчества.
//	- МаксимальнаяДлинаСтроки - необязательный, максимальная длина результирующей строки.
//
Функция КраткийСоставФизЛиц(ФизЛица, ДатаАктуальности, МаксимальнаяДлинаСтроки = 100) Экспорт
	
	ФИОФизЛиц = СоответствиеФИОФизЛицСсылкам(ДатаАктуальности, ФизЛица);
	
	КраткийСостав = "";
	Для Каждого ФизЛицо Из ФизЛица Цикл
		Если Не ПустаяСтрока(КраткийСостав) Тогда
			КраткийСостав = КраткийСостав + ", ";
		КонецЕсли;
		ФИО = ФИОФизЛиц[ФизЛицо];
		КраткийСостав = КраткийСостав + ФИО.ФамилияИО;
	КонецЦикла;
	Если СтрДлина(КраткийСостав) > МаксимальнаяДлинаСтроки Тогда
		КраткийСостав = Лев(КраткийСостав, МаксимальнаяДлинаСтроки - 3) + "...";
	КонецЕсли;
	
	Возврат КраткийСостав;

КонецФункции

// Возвращает Истина, если объект метаданных входит в состав подсистем зарплатно кадровой библиотеки.
//
// Параметры:
//		ПолноеИмяОбъектаМетаданных
//
// Возвращаемое значение:
//		Булево
//
Функция ЭтоОбъектЗарплатноКадровойБиблиотеки(ПолноеИмяОбъектаМетаданных) Экспорт
	
	Возврат ЗарплатаКадрыВнутренний.ЭтоОбъектЗарплатноКадровойБиблиотеки(ПолноеИмяОбъектаМетаданных);;
	
КонецФункции

// Возвращает перечень имен подсистем БЗК верхнего уровня. 
// Предполагаем, что список поставляемых/"чужих" подсистем более стабилен, 
// чем набор подсистем разрабатываемой/сопровождаемой функциональности БЗК.
// Получаем список имен "вычитанием чужих" подсистем.
//
// Параметры:
//		ВключатьПодсистемыКомандногоИнтерфейса - Булево - подсистемы командного интерфейса входят в БЗК.
//		                                                  Подсистемы "Демо и разработка" не включаются
//		ВключатьПодсистемыДемоИРазработка      - Булево - подсистемы демо и разработка входят в состав БЗК.
//		                                                  Подсистемы "Демо и разработка" это все, что начинается с "_".
// Возвращаемое значение:
//		Массив - имена подсистем.
//
Функция ИменаПодсистемБЗКВерхнегоУровня(ВключатьПодсистемыКомандногоИнтерфейса = Ложь, 
			ВключатьПодсистемыДемоИРазработка = Ложь) Экспорт

	ИменаЧужихПодсистемВерхнегоУровня = Новый Массив;
	ИменаЧужихПодсистемВерхнегоУровня.Добавить("ИнтеграцияС1СДокументооборотом");
	ИменаЧужихПодсистемВерхнегоУровня.Добавить("ИнтернетПоддержкаПользователей");
	ИменаЧужихПодсистемВерхнегоУровня.Добавить("РегламентированнаяОтчетность");
	ИменаЧужихПодсистемВерхнегоУровня.Добавить("СтандартныеПодсистемы");
	ИменаЧужихПодсистемВерхнегоУровня.Добавить("ТехнологияСервиса");
	ИменаЧужихПодсистемВерхнегоУровня.Добавить("ЭлектронноеВзаимодействие");
	
	ИменаПодсистемИсключений = Новый Массив;
	
	// 1 из 3. Формируем список подсистем "Демо и разработка"
	ИменаПодсистемДемоИРазработка = Новый Массив;
	
	Для каждого ПодсистемаВерхнегоУровня Из Метаданные.Подсистемы Цикл
	
		Если Лев(ПодсистемаВерхнегоУровня.Имя, 1) = "_" Тогда
			
			ИменаПодсистемДемоИРазработка.Добавить(ПодсистемаВерхнегоУровня.Имя);	
			
		КонецЕсли;	
	
	КонецЦикла;
	
	// 2 из 3. Формируем список подсистем "Командный интерфейс"
	ИменаПодсистемКомандногоИнтерфейса = Новый Массив;
	
	Для каждого ПодсистемаВерхнегоУровня Из Метаданные.Подсистемы Цикл
	
		Если ПодсистемаВерхнегоУровня.ВключатьВКомандныйИнтерфейс Тогда
			
			ИменаПодсистемКомандногоИнтерфейса.Добавить(ПодсистемаВерхнегоУровня.Имя);	
			
		КонецЕсли;	
	
	КонецЦикла;
	
	ИменаПодсистемКомандногоИнтерфейса = ОбщегоНазначенияКлиентСервер.РазностьМассивов(
		ИменаПодсистемКомандногоИнтерфейса, ИменаПодсистемДемоИРазработка);
	
	// 3 из 3. Формируем список подсистем "БЗК"
	ИменаПодсистемБЗКВерхнегоУровня = Новый Массив;
	
	Для каждого ПодсистемаВерхнегоУровня Из Метаданные.Подсистемы Цикл
	
		ИменаПодсистемБЗКВерхнегоУровня.Добавить(ПодсистемаВерхнегоУровня.Имя);	
		
	КонецЦикла;
	
	Если НЕ ВключатьПодсистемыКомандногоИнтерфейса Тогда
	
		ИменаПодсистемБЗКВерхнегоУровня = ОбщегоНазначенияКлиентСервер.РазностьМассивов(
			ИменаПодсистемБЗКВерхнегоУровня, ИменаПодсистемКомандногоИнтерфейса);	
	
	КонецЕсли;
	
	Если НЕ ВключатьПодсистемыДемоИРазработка Тогда
	
		ИменаПодсистемБЗКВерхнегоУровня = ОбщегоНазначенияКлиентСервер.РазностьМассивов(
			ИменаПодсистемБЗКВерхнегоУровня, ИменаПодсистемДемоИРазработка);	
	
	КонецЕсли;
	
	ИменаПодсистемБЗКВерхнегоУровня = ОбщегоНазначенияКлиентСервер.РазностьМассивов(
		ИменаПодсистемБЗКВерхнегоУровня, ИменаЧужихПодсистемВерхнегоУровня);
		
	ИменаПодсистемБЗКВерхнегоУровня = ОбщегоНазначенияКлиентСервер.РазностьМассивов(
		ИменаПодсистемБЗКВерхнегоУровня, ИменаПодсистемИсключений);
		
	Возврат ИменаПодсистемБЗКВерхнегоУровня;
	
КонецФункции 

Функция ЭтоБазоваяВерсияКонфигурации() Экспорт
	Возврат ЗарплатаКадрыВнутренний.ЭтоБазоваяВерсияКонфигурации();
КонецФункции

// Возвращает Истина, если оплата ведомостей регистрируется специальными документами.
Функция ИспользуютсяДокументыОплатыВедомостей() Экспорт
	Возврат ЗарплатаКадрыВнутренний.ИспользуютсяДокументыОплатыВедомостей();
КонецФункции

// Заполняет ответственных лиц организации, 
// сохраняет запрашиваемые значения в реквизите формы СведенияОбОтветственныхРаботниках.
//
// Параметры:
//	Форма					- ФормаКлиентскогоПриложения
//	ЗапрашиваемыеЗначения	- Структура
//	ФиксированныеЗначения	- Массив
//
Процедура ЗаполнитьОтветственныхРаботниковОрганизацииВФорме(Форма, ЗапрашиваемыеЗначения, ФиксированныеЗначения) Экспорт
	
	ЗаполнитьЗначенияВФорме(Форма, ЗапрашиваемыеЗначения, ФиксированныеЗначения);
	ЗапомнитьОтветственныхРаботниковОрганизацииВФорме(Форма, ЗапрашиваемыеЗначения);
	
КонецПроцедуры

// Сохраняет в настройках значения ответственных работников организации.
//
// Параметры:
//		Организация										- СправочникСсылка.Организации
//		СохраняемыеЗначения								- Структура, ключи идентификаторы данных (см. функцию СписокДоступныхЗначенийПоУмолчанию).
//		СведенияОбОтветственныхРаботникахОрганизации	- Структура
//
Процедура СохранитьЗначенияЗаполненияОтветственныхРаботников(Организация, СохраняемыеЗначения, СведенияОбОтветственныхРаботникахОрганизации = Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(Организация) И СохраняемыеЗначения.Количество() > 0 Тогда
		
		Если СведенияОбОтветственныхРаботникахОрганизации = Неопределено Тогда
			ОбновитьСведения = Истина;
		Иначе
			
			ОбновитьСведения = Ложь;
			Для каждого ОписаниеЗначения Из СохраняемыеЗначения Цикл
				
				Если Не СведенияОбОтветственныхРаботникахОрганизации.Свойство(ОписаниеЗначения.Ключ)
					Или СведенияОбОтветственныхРаботникахОрганизации[ОписаниеЗначения.Ключ] <> ОписаниеЗначения.Значение Тогда
					
					ОбновитьСведения = Истина;
					Прервать;
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
		Если ОбновитьСведения Тогда
			
			СведенияОбОтветственныхРаботниках = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("НастройкиПользователя", "СведенияОбОтветственныхРаботниках");
			Если СведенияОбОтветственныхРаботниках = Неопределено Тогда
				СведенияОбОтветственныхРаботниках = Новый Соответствие;
			КонецЕсли;
			
			СведенияПоОрганизации = СведенияОбОтветственныхРаботниках.Получить(Организация);
			Если СведенияПоОрганизации = Неопределено Тогда
				СведенияПоОрганизации = Новый Структура;
			КонецЕсли;
			
			СохранитьНастройки = Ложь;
			Для каждого ОписаниеЗначения Из СохраняемыеЗначения Цикл
				
				Если Не СведенияПоОрганизации.Свойство(ОписаниеЗначения.Ключ)
					Или СведенияПоОрганизации[ОписаниеЗначения.Ключ] <> ОписаниеЗначения.Значение Тогда
					
					СохранитьНастройки = Истина;
					СведенияПоОрганизации.Вставить(ОписаниеЗначения.Ключ, ОписаниеЗначения.Значение);
					
				КонецЕсли;
				
			КонецЦикла;
			
			Если СохранитьНастройки Тогда
				
				СведенияОбОтветственныхРаботниках.Вставить(Организация, СведенияПоОрганизации);
				ОбщегоНазначения.ХранилищеОбщихНастроекСохранить("НастройкиПользователя", "СведенияОбОтветственныхРаботниках", СведенияОбОтветственныхРаботниках);
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

Процедура СохранитьЗначенияЗаполненияОтветственныхРаботниковФормы(Форма, Организация, СохраняемыеЗначения) Экспорт
	
	СведенияОбОтветственныхРаботниках = ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, "СведенияОбОтветственныхРаботниках");
	
	СохранитьЗначенияЗаполненияОтветственныхРаботников(Организация, СохраняемыеЗначения, СведенияОбОтветственныхРаботниках);
	ОбщегоНазначенияКлиентСервер.УстановитьРеквизитФормыПоПути(Форма, "СведенияОбОтветственныхРаботниках", СохраняемыеЗначения);
	
КонецПроцедуры

Процедура ЗапомнитьОтветственныхРаботниковОрганизацииВФорме(Форма, ЗапрашиваемыеЗначения) Экспорт
	
	ДанныеФормыПоОрганизации = Новый Структура;
	Для Каждого ЗапрашиваемоеЗначение Из ЗапрашиваемыеЗначения Цикл
		
		ДанныеФормыПоОрганизации.Вставить(ЗапрашиваемоеЗначение.Ключ,
			ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, ЗапрашиваемоеЗначение.Значение));
		
	КонецЦикла;
	
	ОбщегоНазначенияКлиентСервер.УстановитьРеквизитФормыПоПути(Форма, "СведенияОбОтветственныхРаботниках", ДанныеФормыПоОрганизации);
	
КонецПроцедуры

Процедура ДобавитьИдентификаторКомандыДляПечатиВПакетномРежиме(ИдентификаторыПФ, КомандаПечати) Экспорт
	
	Если Не ПустаяСтрока(КомандаПечати.ФункциональныеОпции) Тогда
		
		ДобавитьКоманду = Ложь;
		Для Каждого ИмяФункциональнойОпции Из СтрРазделить(КомандаПечати.ФункциональныеОпции, ",") Цикл
			
			Если ПолучитьФункциональнуюОпцию(ИмяФункциональнойОпции) = Истина Тогда
				ДобавитьКоманду = Истина;
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе
		ДобавитьКоманду = Истина;
	КонецЕсли;
	
	Если ДобавитьКоманду Тогда
		ИдентификаторыПФ.Добавить(КомандаПечати.Идентификатор);
	КонецЕсли;
	
КонецПроцедуры

#Область РегламентированнаяОтчетность

// Добавляет описание показателя регламентированной отчетности.
Процедура ДобавитьПоказательРегламентированнойОтчетности(СтруктураПоказателей, ИмяПоказателя, ПризнакАвтозаполнения, ПризнакРасшифровки) Экспорт
	РегламентированнаяОтчетность.ВставитьПоказательВСтруктуру(СтруктураПоказателей, ИмяПоказателя, ПризнакАвтозаполнения, ПризнакРасшифровки);
КонецПроцедуры

// Выводит в отчет-расшифровку сообщение о расхождении значения показателя в рег.отчете с расшифровкой по данным учета.
Процедура ВывестиПредупреждениеОРасхожденииПоказателяСРасшифровкой(ТекстТекущегоПоказателя, ИтогРасшифровки, ДокументРезультат) Экспорт

	Попытка
		ЗначениеТекущегоПоказателя = Число(ТекстТекущегоПоказателя);
	Исключение                             
	    ЗначениеТекущегоПоказателя = Неопределено
	КонецПопытки;
	Если ЗначениеТекущегоПоказателя <> Неопределено И ЗначениеТекущегоПоказателя <> ИтогРасшифровки Тогда
		Макет = ПолучитьОбщийМакет("ЗаголовокРасшифровкиРегламентированногоОтчетаЗарплата");
		Макет.Параметры.ЗначениеТекущегоПоказателя = Формат(ЗначениеТекущегоПоказателя, "ЧДЦ=2; ЧГ=0");
		Макет.Параметры.ИтогРасшифровки = Формат(ИтогРасшифровки, "ЧДЦ=2; ЧГ=0");
		ДокументРезультат.Вывести(Макет);
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область ЗаголовкиСвертываемыхГрупп

// Устанавливает текст заголовка, отображаемого, когда группа свернута.
// Параметры:
//		Группа - группа формы, заголовок свернутого отображения которой необходимо заполнить.
//		ОтображаемыеРеквизиты - массив путей к реквизитам формы, 
//				значения которых необходимо вывести в заголовке.
//		Заголовок - строка заголовка, если не указана, используется заголовок группы.
//		ПредставлениеНезаполненного - строка - текст, выводимый после заголовка, 
//			если ни один из отображаемых реквизитов не заполнен.
//			Значение по умолчанию: <не указано>.
//		ПредставлениеЧастичноЗаполненного - строка - текст, выводимый в конце, 
//			если хотя бы один из отображаемых реквизитов не заполнен.
//			Значение по умолчанию: (не все поля заполнены).
//
// Пример использования:
// 	ОтображаемыеРеквизиты = Новый Массив;
// 	ОтображаемыеРеквизиты.Добавить("Объект.Кассир");
// 	ОтображаемыеРеквизиты.Добавить("Объект.ГлавныйБухгалтер");
// 	ОтображаемыеРеквизиты.Добавить("Объект.Бухгалтер");
//	ЗарплатаКадры.УстановитьЗаголовокСвернутогоОтображенияГруппы(Элементы.ПодписиГруппа, ОтображаемыеРеквизиты);
//
Процедура УстановитьЗаголовокСвернутогоОтображенияГруппы(Группа, ОтображаемыеРеквизиты, Знач ЗаголовокГруппы = Неопределено, Знач ПредставлениеНезаполненного = Неопределено, Знач ПредставлениеЧастичноЗаполненного = Неопределено) Экспорт
	
	Форма = ФормаЭлемента(Группа);

	ОтображаемыеЗначения = Новый Массив;
	Для Каждого ОтображаемыйРеквизит Из ОтображаемыеРеквизиты Цикл
		ОтображаемыеЗначения.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, ОтображаемыйРеквизит));
	КонецЦикла;
	
	Если ЗаголовокГруппы = Неопределено Тогда
		ЗаголовокГруппы = Группа.Заголовок
	КонецЕсли;
	
	Группа.ЗаголовокСвернутогоОтображения = ЗаголовокСвернутогоОтображенияГруппы(ЗаголовокГруппы, ОтображаемыеЗначения, ПредставлениеНезаполненного, ПредставлениеЧастичноЗаполненного);
	
КонецПроцедуры

// Настраивает отображение группы с подписями ответственных лиц документа.
// Параметры:
//		Группа - группа формы с ответственными лицами.
//		Физлицо1...Физлицо9 - путь к реквизиту формы с ответственным лицом.
//
// Пример использования:
//	ЗарплатаКадры.НастроитьОтображениеГруппыПодписей(Элементы.ПодписиГруппа, "Объект.Кассир", "Объект.ГлавныйБухгалтер", "Объект.Бухгалтер");
//
Процедура НастроитьОтображениеГруппыПодписей(Группа, 
		Знач Физлицо1 = Неопределено, Знач Физлицо2 = Неопределено, Знач Физлицо3 = Неопределено,
		Знач Физлицо4 = Неопределено, Знач Физлицо5 = Неопределено, Знач Физлицо6 = Неопределено,
		Знач Физлицо7 = Неопределено, Знач Физлицо8 = Неопределено, Знач Физлицо9 = Неопределено) Экспорт
	
	Форма = ФормаЭлемента(Группа);

	СписокФизлиц = Новый Массив;
	Если ЗначениеЗаполнено(Физлицо1) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо1));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо2) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо2));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо3) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо3));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо4) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо4));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо5) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо5));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо6) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо6));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо7) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо7));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо8) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо8));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо9) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо9));
	КонецЕсли;
	
	КадровыеДанныеФизическихЛиц = КадровыйУчет.КадровыеДанныеФизическихЛиц(Истина, СписокФизлиц, "ИОФамилия");
	
	ИОФамилии = Новый Массив;
	Для Каждого Физлицо Из СписокФизлиц Цикл
		СтрокаФизлица = КадровыеДанныеФизическихЛиц.Найти(Физлицо, "ФизическоеЛицо");
		Если СтрокаФизлица <> Неопределено Тогда
			ИОФамилии.Добавить(СтрокаФизлица.ИОФамилия);
		КонецЕсли	
	КонецЦикла;		
	
	Если ИОФамилии.Количество() > 0 Тогда
		Группа.ЗаголовокСвернутогоОтображения = ЗаголовокСвернутогоОтображенияГруппы(НСтр("ru = 'Подписи'"), ИОФамилии);
	Иначе	
		Группа.ЗаголовокСвернутогоОтображения = НСтр("ru = 'Подписи не указаны'");
	КонецЕсли	
	
КонецПроцедуры

Функция ЗаголовокСвернутогоОтображенияГруппы(Знач ЗаголовокГруппы, ОтображаемыеЗначения, Знач ПредставлениеНезаполненного = Неопределено, Знач ПредставлениеЧастичноЗаполненного = Неопределено)
	
	Если ПредставлениеНезаполненного = Неопределено Тогда
		ПредставлениеНезаполненного = НСтр("ru = '<не указано>'")
	КонецЕсли;	
	Если ПредставлениеЧастичноЗаполненного = Неопределено Тогда
		ПредставлениеЧастичноЗаполненного = НСтр("ru = '(не все поля заполнены)'")	
	КонецЕсли;	
	
	ПредставляемыеЗначения = Новый Массив;
	Для Каждого ОтображаемоеЗначение Из ОтображаемыеЗначения Цикл
		Если ЗначениеЗаполнено(ОтображаемоеЗначение) Тогда
			ПредставляемыеЗначения.Добавить(ОтображаемоеЗначение);
		КонецЕсли	
	КонецЦикла;
	
	Если ПредставляемыеЗначения.Количество() = 0 Тогда
		ПредставлениеЗначений = ПредставлениеНезаполненного;
	Иначе
		ПредставлениеЗначений = СтрСоединить(ПредставляемыеЗначения, ", ");
		Если ПредставляемыеЗначения.Количество() < ОтображаемыеЗначения.Количество() Тогда
			ПредставлениеЗначений = ПредставлениеЗначений + " " + ПредставлениеЧастичноЗаполненного
		КонецЕсли	
	КонецЕсли;	
	
	Возврат ЗаголовокГруппы + ?(ЗначениеЗаполнено(ЗаголовокГруппы) И ЗначениеЗаполнено(ПредставлениеЗначений), ": ", "") + ПредставлениеЗначений;
	
КонецФункции

Функция ФормаЭлемента(Элемент)
	Родитель = Элемент.Родитель;
	Пока ТипЗнч(Родитель) <> Тип("ФормаКлиентскогоПриложения") Цикл
		Родитель = Родитель.Родитель
	КонецЦикла;	
	Возврат Родитель
КонецФункции

#КонецОбласти

#Область УпорядочиваниеСписковСотрудниковДокументов

// Дополняет состав запрашиваемых кадровых данных именами, которые необходимы
// для организации упорядочивания.
//
// Параметры:
//		КадровыеДанные	- Строка, имена кадровых данных сотрудника, перечисленные через запятую
//						- Массив, строк имен кадровых данных сотрудника.
//
// Возвращаемое значение:
//		Булево - Истина, если кадровые данные были дополнены полями порядка.
//
Функция ДополнитьКадровымиДаннымиНастройкиПорядкаСписка(КадровыеДанные) Экспорт
	ПоляУпорядочивания = РегистрыСведений.ДополнительныеНастройкиЗарплатаКадры.ПоляУпорядочиванияСпискаСотрудников();
	Если ПоляУпорядочивания.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ПоляДобавлены = Ложь;
	
	Если ТипЗнч(КадровыеДанные) = Тип("Строка") Тогда
		ЗапрашиваемыеКадровыеДанные = СтрРазделить(КадровыеДанные, ", ", Ложь);
	Иначе
		ЗапрашиваемыеКадровыеДанные = КадровыеДанные;
	КонецЕсли;
	
	Для каждого ОписаниеПоляУпорядочивания Из ПоляУпорядочивания Цикл
		
		Если ОписаниеПоляУпорядочивания.КлючПорядка = "Справочник.ПодразделенияОрганизаций" Тогда
			ИмяКадровыхДанных = "Подразделение";
		ИначеЕсли ОписаниеПоляУпорядочивания.КлючПорядка = "Справочник.Должности" Тогда
			ИмяКадровыхДанных = "Должность";
		ИначеЕсли ОписаниеПоляУпорядочивания.КлючПорядка = "Справочник.Сотрудники" Тогда
			ИмяКадровыхДанных = СокрЛП(ОписаниеПоляУпорядочивания.ПолеПорядка);
		Иначе
			Продолжить;
		КонецЕсли;
		
		Если Не ПустаяСтрока(ИмяКадровыхДанных) И ЗапрашиваемыеКадровыеДанные.Найти(ИмяКадровыхДанных) = Неопределено Тогда
			ПоляДобавлены = Истина;
			ЗапрашиваемыеКадровыеДанные.Добавить(ИмяКадровыхДанных);
		КонецЕсли;
		
	КонецЦикла;
	
	Если ПоляДобавлены Тогда
		Если ТипЗнч(КадровыеДанные) = Тип("Строка") Тогда
			КадровыеДанные = СтрСоединить(ЗапрашиваемыеКадровыеДанные, ",");
		Иначе
			КадровыеДанные = ЗапрашиваемыеКадровыеДанные;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПоляДобавлены;
КонецФункции

// Модифицирует текст последнего запроса в тексте, преданного запроса, изменяет или добавляет
// поля упорядочивания выборки запроса.
//
// Параметры:
//		Запрос						- Запрос
//		ПсевдонимВТСДаннымиПорядка	- Строка, псевдоним временной таблицы, которая содержит поля упорядочивания:
//										Подразделение, Должность, Код (справочника Сотрудники) и
//										Наименование (справочника Сотрудники)
//		ОсобаяОбработкаСотрудников	- признак того, что поля сортировки сотрудников обрабатываются иным способом.
//
//	Примеры псевдонимов для имен популярных временных таблиц:
//		ВТКадровыеДанныеСотрудников - "КадровыеДанныеСотрудников"
//		ВТСотрудникиОрганизации		- "СотрудникиОрганизации"
//
Процедура ДополнитьТекстЗапросаУпорядочиваниемСотрудниковПоВТСДаннымиПорядка(Запрос, ПсевдонимВТСДаннымиПорядка, ОсобаяОбработкаСотрудников = Истина) Экспорт
	
	ПсевдонимыТаблиц = Новый Соответствие;
	ПсевдонимыТаблиц.Вставить("Справочник.ПодразделенияОрганизаций", ПсевдонимВТСДаннымиПорядка);
	ПсевдонимыТаблиц.Вставить("Справочник.Должности", ПсевдонимВТСДаннымиПорядка);
	ПсевдонимыТаблиц.Вставить("Справочник.Сотрудники", ПсевдонимВТСДаннымиПорядка);
	
	ДополнитьТекстЗапросаУпорядочиваниемСотрудников(Запрос, ПсевдонимыТаблиц, ОсобаяОбработкаСотрудников);
	
КонецПроцедуры

// Модифицирует текст последнего запроса в тексте, преданного запроса, изменяет или добавляет
// поля упорядочивания выборки запроса.
//
// Параметры:
//		Запрос							- Запрос
//		ПсевдонимыТаблицСДаннымиПорядка	- Соответствие, в качестве ключа выступает полное имя объекта метаданных
//											по которому осуществляется упорядочивание списка, в качестве значения
//											строка - псевдоним временной таблицы, которая содержит поля упорядочивания
//											Ключи соответствия:
//												"Справочник.ПодразделенияОрганизаций"
//												"Справочник.Должности"
//												"Справочник.Сотрудники"
//		ОсобаяОбработкаСотрудников		- признак того, что поля сортировки сотрудников обрабатываются иным способом.
//
Процедура ДополнитьТекстЗапросаУпорядочиваниемСотрудников(Запрос, ПсевдонимыТаблицСДаннымиПорядка, ОсобаяОбработкаСотрудников = Истина) Экспорт
	
	ПоляУпорядочивания = РегистрыСведений.ДополнительныеНастройкиЗарплатаКадры.ПоляУпорядочиванияСпискаСотрудников();
	Если ПоляУпорядочивания.Количество() > 0  Тогда
		
		ТекстыЗапросов = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Запрос.Текст, ";");
		НомерЗапроса = ТекстыЗапросов.Количество();
		ПакетЗапросов = Неопределено;
		
		Пока НЕ ТипЗнч(ПакетЗапросов) = Тип("ЗапросВыбораСхемыЗапроса")
			И НомерЗапроса > 0 Цикл
		
			ТекстПоследнегоЗапроса = ТекстыЗапросов[НомерЗапроса - 1];
			
			СхемаЗапроса = Новый СхемаЗапроса;
			СхемаЗапроса.УстановитьТекстЗапроса(ТекстПоследнегоЗапроса);
			ПакетЗапросов = СхемаЗапроса.ПакетЗапросов[0];
			
			НомерЗапроса = НомерЗапроса - 1;
			
		КонецЦикла;
		
		ИндексПоляПорядка = 0;
		ПсевдонимыДобавленныхПолей = Новый Соответствие;
		ПоляПорядка = Новый Массив;
		
		Для каждого ОписаниеПоляУпорядочивания Из ПоляУпорядочивания Цикл
			
			Если ОписаниеПоляУпорядочивания.КлючПорядка = "Справочник.ПодразделенияОрганизаций" Тогда
				ПутьКДанным = "ВЫРАЗИТЬ(КадровыеДанныеСотрудников.Подразделение КАК Справочник.ПодразделенияОрганизаций)." + ОписаниеПоляУпорядочивания.ПолеПорядка;
				ИмяПоляПорядка = "Подразделение";
				ПсевдонимВТКадровыеДанныеСотрудников = ПсевдонимыТаблицСДаннымиПорядка.Получить("Справочник.ПодразделенияОрганизаций");
			ИначеЕсли ОписаниеПоляУпорядочивания.КлючПорядка = "Справочник.Должности" Тогда
				ПутьКДанным = "ВЫРАЗИТЬ(КадровыеДанныеСотрудников.Должность КАК Справочник.Должности)." + ОписаниеПоляУпорядочивания.ПолеПорядка;
				ИмяПоляПорядка = "Должность";
				ПсевдонимВТКадровыеДанныеСотрудников = ПсевдонимыТаблицСДаннымиПорядка.Получить("Справочник.Должности");
			ИначеЕсли ОписаниеПоляУпорядочивания.КлючПорядка = "Справочник.Сотрудники" Тогда
				Если ОсобаяОбработкаСотрудников Тогда
					ПутьКДанным = "КадровыеДанныеСотрудников." + ОписаниеПоляУпорядочивания.ПолеПорядка;
					ИмяПоляПорядка = ОписаниеПоляУпорядочивания.ПолеПорядка;
				Иначе
					ПутьКДанным = "ВЫРАЗИТЬ(КадровыеДанныеСотрудников.Сотрудник КАК Справочник.Сотрудники)." + ОписаниеПоляУпорядочивания.ПолеПорядка;
					ИмяПоляПорядка = "Сотрудник";
				КонецЕсли;
				ПсевдонимВТКадровыеДанныеСотрудников = ПсевдонимыТаблицСДаннымиПорядка.Получить("Справочник.Сотрудники");
			Иначе
				ПутьКДанным = "";
			КонецЕсли; 
			
			Если Не ПустаяСтрока(ПутьКДанным) Тогда
				
				Если ЗначениеЗаполнено(ПсевдонимВТКадровыеДанныеСотрудников) Тогда
					ПутьКДанным = СтрЗаменить(ПутьКДанным, "КадровыеДанныеСотрудников.", ПсевдонимВТКадровыеДанныеСотрудников + ".");
				КонецЕсли; 
				
				Для каждого ОператорСхемы Из ПакетЗапросов.Операторы Цикл
					
					Для каждого ИсточникСхемы Из ОператорСхемы.Источники Цикл
						
						Если ИсточникСхемы.Источник.Псевдоним = ПсевдонимВТКадровыеДанныеСотрудников Тогда
							
							ДобавлятьДоступноеПоле = Истина;
							Для каждого ДоступноеПоле Из ИсточникСхемы.Источник.ДоступныеПоля Цикл
								Если ДоступноеПоле.Имя = ИмяПоляПорядка Тогда
									ДобавлятьДоступноеПоле = Ложь;
									Прервать;
								КонецЕсли; 
							КонецЦикла; 
							
							Если ДобавлятьДоступноеПоле Тогда
								ИсточникСхемы.Источник.ДоступныеПоля.Добавить(ИмяПоляПорядка);
							КонецЕсли; 
							
							Прервать;
							
						КонецЕсли; 
						
					КонецЦикла; 
					
					ОператорСхемы.ВыбираемыеПоля.Добавить(ПутьКДанным);
					
					КолонкаПорядка = ПакетЗапросов.Колонки.Получить(ПакетЗапросов.Колонки.Количество() - 1);
					КолонкаПорядка.Псевдоним = "ПолеПорядка" + ИндексПоляПорядка;
						
					Если ПсевдонимыДобавленныхПолей.Получить(КолонкаПорядка.Псевдоним) = Неопределено Тогда
						ПсевдонимыДобавленныхПолей.Вставить(КолонкаПорядка.Псевдоним, Истина);
						ПоляПорядка.Вставить(0, КолонкаПорядка);
					КонецЕсли; 
					
				КонецЦикла;
				
			КонецЕсли; 
			
			ИндексПоляПорядка = ИндексПоляПорядка + 1;
			
		КонецЦикла;		
		
		Если ПоляПорядка.Количество() > 0 Тогда
			
			Для каждого КолонкаПорядка Из ПоляПорядка Цикл
				// Вставляем поле порядка в начало упорядочивания
				ВыражениеПорядка = ПакетЗапросов.Порядок.Добавить(КолонкаПорядка);
				ПакетЗапросов.Порядок.Сдвинуть(ВыражениеПорядка, 1 - ПакетЗапросов.Порядок.Количество());
			КонецЦикла;
			
			Запрос.Текст = СтрЗаменить(Запрос.Текст, ТекстПоследнегоЗапроса, СхемаЗапроса.ПолучитьТекстЗапроса());
			
		КонецЕсли; 
		
	КонецЕсли; 
	
КонецПроцедуры

#КонецОбласти

#Область УниверсальныеПроцедуры

// Заполняет данные выбора справочника при вводе по строке и автоподборе в справочнике.
// Предназначена для вызова из обработчика ОбработкаПолученияДанныхВыбора в том случае, когда 
// обработка получения данных выбора выполняется "особым образом" (с выполнением особенного запроса).
//
// Параметры:
//		ДанныеВыбора
//		МетаданныеОбъекта - метаданные справочника для которого переопределяется обработка получения данных выбора.
//		Отбор - параметры отбора, переданные в ОбработкаПолученияДанныхВыбора.
//		Запрос - Запрос с предустановленными параметрами текст запроса, который необходимо выполнять
//			ВНИМАНИЕ. Запрос обязательно должен быть построен по схеме:
//				ВЫБРАТЬ * 
//				ИЗ 
//					... КАК <Псевдоним>
//				...
//			Текст запроса дополняется необходимыми функциями.
//		ПсевдонимТаблицы - псевдоним основной таблицы в тексте переданного запроса.
//
Процедура ЗаполнитьДанныеВыбораСправочника(ДанныеВыбора, МетаданныеОбъекта, Параметры, Запрос, ПсевдонимТаблицы, ИспользоватьДанныеВыбора = Ложь) Экспорт
	
	ЗапросТекст = Запрос.Текст;
	
	ЗапросТекст = СтрЗаменить(ЗапросТекст, " *", 
	" ПЕРВЫЕ 51
	|	" + ПсевдонимТаблицы + ".Ссылка,
	|	" + ПсевдонимТаблицы + ".ПометкаУдаления,
	|	" + ПсевдонимТаблицы + ".Код,
	|	ПРЕДСТАВЛЕНИЕ(" + ПсевдонимТаблицы + ".Ссылка) КАК Наименование");
	
	Если МетаданныеОбъекта.ДлинаКода = 0 Тогда
		ЗапросТекст = СтрЗаменить(ЗапросТекст, ",
		|	" + ПсевдонимТаблицы + ".Код", "");
	КонецЕсли;
	
	Если МетаданныеОбъекта.ДлинаНаименования = 0 Тогда
		ЗапросТекст = СтрЗаменить(ЗапросТекст, ",
		|	ПРЕДСТАВЛЕНИЕ(" + ПсевдонимТаблицы + ".Ссылка) КАК Наименование", "");
	Иначе 
		ЗапросТекст = ЗапросТекст + "
		|
		|УПОРЯДОЧИТЬ ПО
		|	" + ПсевдонимТаблицы + ".Наименование";
	КонецЕсли;
	
	КоличествоЭлементов = 51;
	ДанныеВыбораСправочника = Новый СписокЗначений;
	
	ДополнительноеУсловие = "";
	
	Если Параметры.Свойство("Отбор") Тогда
		
		Для Каждого ЭлементОтбора Из Параметры.Отбор Цикл
			
			Реквизит = МетаданныеОбъекта.Реквизиты.Найти(ЭлементОтбора.Ключ);
			Если Реквизит <> НеОпределено Тогда
				
				Если ТипЗнч(ЭлементОтбора.Значение) = Тип("Массив")
					Или ТипЗнч(ЭлементОтбора.Значение) = Тип("ФиксированныйМассив")
					Или ТипЗнч(ЭлементОтбора.Значение) = Тип("СписокЗначений") Тогда
					
					ДополнительноеУсловие = ДополнительноеУсловие + "
						|	И " + ПсевдонимТаблицы + "." + ЭлементОтбора.Ключ + " В (&" + ЭлементОтбора.Ключ + ")";
						
				Иначе
						
					ДополнительноеУсловие = ДополнительноеУсловие + "
						|	И " + ПсевдонимТаблицы + "." + ЭлементОтбора.Ключ + " = &" + ЭлементОтбора.Ключ;
						
				КонецЕсли;	
					
				Запрос.УстановитьПараметр(ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЕсли;
	
	ПоляПредставления = ПоляПредставления(МетаданныеОбъекта);
	
	Если Параметры.Свойство("СтрокаПоиска") 
		И НЕ ПустаяСтрока(Параметры.СтрокаПоиска) Тогда
		
		Для Каждого Поле Из МетаданныеОбъекта.ВводПоСтроке Цикл
			
			ТекстЗапроса = ЗапросТекст;
			
			ИмяПоля = Поле.Имя;
			
			Если Не ИспользоватьДанныеВыбора Или ДанныеВыбора = Неопределено Или ИмяПоля <> "Наименование" Тогда
				
				// Установим в запросе условие.
				ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "И &ДополнительноеУсловие", ДополнительноеУсловие + "
					|	И " + ПсевдонимТаблицы + "." + ИмяПоля + " ПОДОБНО &СтрокаПоиска");
					
				Если ИмяПоля = "Наименование" Тогда
					Запрос.УстановитьПараметр("СтрокаПоиска", Параметры.СтрокаПоиска + "%");
				Иначе
					Запрос.УстановитьПараметр("СтрокаПоиска", "%" + Параметры.СтрокаПоиска + "%");
				КонецЕсли;
				
			Иначе
				
				ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "И &ДополнительноеУсловие", ДополнительноеУсловие + "
					|	И " + ПсевдонимТаблицы + ".Ссылка В(&ДанныеВыбора)");
					
				Запрос.УстановитьПараметр("ДанныеВыбора", ДанныеВыбора);
				
			КонецЕсли; 

			// Допишем в поля выборки поле поиска.
			Если ИмяПоля <> ПоляПредставления.ПолеОсновногоПредставления 
				И ИмяПоля <> ПоляПредставления.ПолеДопПредставления Тогда
				
				ТекстЗапроса = СтрЗаменить(ТекстЗапроса, " ПЕРВЫЕ 51", " ПЕРВЫЕ 51
					|	" + ПсевдонимТаблицы + "." + ИмяПоля + " КАК ПолеПоиска,");
					
			КонецЕсли;
			
			// Установим число выбираемых элементов.
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, " ПЕРВЫЕ 51", " ПЕРВЫЕ " + Строка(КоличествоЭлементов));
			
			Запрос.Текст = ТекстЗапроса;
			Выборка = Запрос.Выполнить().Выбрать();
			
			Пока Выборка.Следующий() Цикл
				
				Если ИспользоватьДанныеВыбора И ДанныеВыбора <> Неопределено И ИмяПоля = "Наименование" Тогда
					
					ЭлементДанныхДанныеВыбора = ДанныеВыбора.НайтиПоЗначению(Выборка.Ссылка);
					Если ЭлементДанныхДанныеВыбора <> Неопределено Тогда
						ДанныеВыбораСправочника.Добавить(ЗначениеДанныхВыбора(ЭлементДанныхДанныеВыбора.Значение, ЭлементДанныхДанныеВыбора.Пометка), ЭлементДанныхДанныеВыбора.Представление);
					КонецЕсли; 
					
				Иначе
					
					Представление = ПредставлениеВыбираемогоЭлемента(Выборка, ПоляПредставления, ИмяПоля);
					
					МассивСтрок = Новый Массив();
					ВыделеннаяСтрока 		= Новый ФорматированнаяСтрока(Лев(Представление, СтрДлина(Параметры.СтрокаПоиска)), Новый Шрифт( , , Истина), WebЦвета.Зеленый);
					ОкончаниеПредставления 	= Прав(Представление, СтрДлина(Представление) - СтрДлина(Параметры.СтрокаПоиска));
					СтрокаПредставление = Новый ФорматированнаяСтрока(ВыделеннаяСтрока, ОкончаниеПредставления);
					
					ДанныеВыбораСправочника.Добавить(ЗначениеДанныхВыбора(Выборка.Ссылка, Выборка.ПометкаУдаления), СтрокаПредставление);
					
				КонецЕсли; 
			
			КонецЦикла;
			
			КоличествоЭлементов = КоличествоЭлементов - Выборка.Количество();
			
			Если КоличествоЭлементов <= 0 Тогда
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
	Иначе
		
		// Установим в запросе условие.
		ЗапросТекст = СтрЗаменить(ЗапросТекст, "И &ДополнительноеУсловие", ДополнительноеУсловие);
		
		Запрос.Текст = ЗапросТекст;
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			Представление = ПредставлениеВыбираемогоЭлемента(Выборка, ПоляПредставления);
			ДанныеВыбораСправочника.Добавить(ЗначениеДанныхВыбора(Выборка.Ссылка, Выборка.ПометкаУдаления), Представление);
		КонецЦикла;
		
	КонецЕсли;
	
	ДанныеВыбораСправочника.СортироватьПоПредставлению();
	ДанныеВыбора = ДанныеВыбораСправочника;

КонецПроцедуры

Функция ЗначениеДанныхВыбора(Значение, ПометкаУдаления)
	
	Возврат Новый Структура("Значение,ПометкаУдаления", Значение, ПометкаУдаления);
	
КонецФункции

// Создает структуру наборов записей, имитирующую коллекцию движений регистратора.
// Может применяться для временного использования методов, формирующих движения, 
// когда регистратор пока не записан.
//
// Параметры:
//	МетаданныеРегистратора
//
// Возвращаемое значение - структура, где ключ имя набора, 
//		значение - набор записей с отбором по временной ссылке.
//
Функция НаборыЗаписейРегистратора(МетаданныеРегистратора, ВременнаяСсылка = Неопределено, ПропуститьПроверкуЗапретаИзменения = Истина, ЭтоВременныйНаборЗаписей = Истина) Экспорт
	
	НаборыЗаписей = Новый Структура;
	
	Если ВременнаяСсылка = Неопределено Тогда
		ВременнаяСсылка = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МетаданныеРегистратора.ПолноеИмя()).ПолучитьСсылку();
	КонецЕсли;
	
	Для Каждого МетаданныеНабора Из МетаданныеРегистратора.Движения Цикл
		Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МетаданныеНабора.ПолноеИмя());
		НаборЗаписей = Менеджер.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.Регистратор.Установить(ВременнаяСсылка);
		НаборЗаписей.Записывать = Истина;
		Если ПропуститьПроверкуЗапретаИзменения Тогда
			НаборЗаписей.ДополнительныеСвойства.Вставить("ПропуститьПроверкуЗапретаИзменения");
		КонецЕсли;
		Если ЭтоВременныйНаборЗаписей Тогда
			НаборЗаписей.ДополнительныеСвойства.Вставить("ЭтоВременныйНаборЗаписей");
			НаборЗаписей.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
			НаборЗаписей.ОбменДанными.Получатели.АвтоЗаполнение = Ложь;
		КонецЕсли;
		НаборыЗаписей.Вставить(МетаданныеНабора.Имя, НаборЗаписей);
	КонецЦикла;
	
	Возврат НаборыЗаписей;
	
КонецФункции

/////////////////////////////////////////////////////////////////////////////////////////
// Особенные математические функции подгонки сумм.

// По "округленной" сумме многих слагаемых округляет сами слагаемые,
// внося при этом наименьшую ошибку округления
// Примечание. "Округленная" сумма не обязательно должна быть равна 
// 				выражению Окр(сумма слагаемых), может быть получена  
//              из других соображений.
//
// Параметры:
//		Данные - Таблица значений
//		ИмяКолонки - строка - имя колонки, содержащей слагаемые.
//		Сумма - Число
//		Точность - Число - необязательный, по умолчанию - рубли.
//      ИмяКлюча - строка - перечень колонок, однозначно определяющих строку из т.з. Данные.
//
Процедура ОкруглитьСлагаемыеПоСумме(Данные, ИмяКолонки, Сумма, Точность = 0, ИмяКлюча = "ФизическоеЛицо") Экспорт 
	
	ВременнаяТаблица = Данные.Скопировать(, ИмяКлюча + "," + ИмяКолонки);
	ВременнаяТаблица.Колонки.Добавить(ИмяКолонки + "Окр");
	Для каждого СтрокаТЗ Из ВременнаяТаблица Цикл
		СтрокаТЗ[ИмяКолонки + "Окр"] = Окр(СтрокаТЗ[ИмяКолонки],Точность)
	КонецЦикла;
	Данные.ЗагрузитьКолонку(ВременнаяТаблица.ВыгрузитьКолонку(ИмяКолонки + "Окр"),ИмяКолонки);
	
	СуммаСлагаемых = ВременнаяТаблица.Итог(ИмяКолонки + "Окр");
	Если СуммаСлагаемых <> Сумма Тогда
		Шаг = Pow(10, -Точность);
		РасхождениеСуммы = Сумма - СуммаСлагаемых;
		Приращение = ?(РасхождениеСуммы > 0, Шаг, -Шаг);
		ВсегоПриращений = Мин(РасхождениеСуммы / Приращение, ВременнаяТаблица.Количество());
		ВременнаяТаблица.Колонки.Добавить(ИмяКолонки + "Расхождение");
		ВременнаяТаблица.Колонки.Добавить(ИмяКолонки + "Изменение");
		Для каждого СтрокаТЗ Из ВременнаяТаблица Цикл
			СтрокаТЗ[ИмяКолонки + "Расхождение"] = ?(СтрокаТЗ[ИмяКолонки + "Окр"] < СтрокаТЗ[ИмяКолонки], СтрокаТЗ[ИмяКолонки] - СтрокаТЗ[ИмяКолонки + "Окр"], СтрокаТЗ[ИмяКолонки + "Окр"] - СтрокаТЗ[ИмяКолонки]);
			СтрокаТЗ[ИмяКолонки + "Изменение"] = ?(СтрокаТЗ[ИмяКолонки + "Окр"] < СтрокаТЗ[ИмяКолонки], - Шаг, Шаг);
		КонецЦикла;
		ВременнаяТаблица.Сортировать(ИмяКолонки + "Изменение" + ?(Приращение > 0,""," Убыв") + ", " + ИмяКолонки + "Расхождение Убыв");
		СтруктураПоиска = Новый Структура(ИмяКлюча); 
		Для Сч = 1 По ВсегоПриращений Цикл
			Если ВременнаяТаблица[Сч-1][ИмяКолонки + "Изменение"] <> Приращение Тогда
				ЗаполнитьЗначенияСвойств(СтруктураПоиска, ВременнаяТаблица[Сч-1]);
				Данные.НайтиСтроки(СтруктураПоиска)[0][ИмяКолонки] = ВременнаяТаблица[Сч-1][ИмяКолонки + "Окр"] + Приращение;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

// По округленной сумме двух слагаемых округляет сами слагаемые, внося при этом наименьшую ошибку округления.
//
// Параметры:
//		ПервоеСлагаемое - Число
//		ВтороеСлагаемое - Число
//		Сумма - Число - необязательный, если не указана определяется по переданным слагаемым.
//		Точность - Число - необязательный, по умолчанию - рубли.
//
Процедура ОкруглитьДваСлагаемыхПоСумме(ПервоеСлагаемое, ВтороеСлагаемое, Сумма = Неопределено, Точность = 0) Экспорт
	
	Если Сумма = Неопределено Тогда
		Сумма = Окр(ПервоеСлагаемое + ВтороеСлагаемое, Точность)
	КонецЕсли;
	
	Если Окр(ПервоеСлагаемое, Точность) + Окр(ВтороеСлагаемое, Точность) = Сумма Тогда
		ПервоеСлагаемое = Окр(ПервоеСлагаемое, Точность);
		ВтороеСлагаемое = Окр(ВтороеСлагаемое, Точность);
	Иначе
		РасхождениеСуммы = Сумма - Окр(ПервоеСлагаемое, Точность) - Окр(ВтороеСлагаемое, Точность);
		ПервоеРасхождение = ?(Окр(ПервоеСлагаемое, Точность) < ПервоеСлагаемое, ПервоеСлагаемое - Окр(ПервоеСлагаемое, Точность), Окр(ПервоеСлагаемое, Точность) - ПервоеСлагаемое);
		ВтороеРасхождение = ?(Окр(ВтороеСлагаемое, Точность) < ВтороеСлагаемое, ВтороеСлагаемое - Окр(ВтороеСлагаемое, Точность), Окр(ВтороеСлагаемое, Точность) - ВтороеСлагаемое);
		ПервоеСлагаемое = Окр(ПервоеСлагаемое, Точность);
		ВтороеСлагаемое = Окр(ВтороеСлагаемое, Точность);
		Если ПервоеРасхождение <= ВтороеРасхождение Тогда
			ВтороеСлагаемое = ВтороеСлагаемое + РасхождениеСуммы; 
		Иначе
			ПервоеСлагаемое = ПервоеСлагаемое + РасхождениеСуммы; 
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

// Возвращает признак того, что объект метаданных может изменяться в режиме АРМ.
//
// Параметры:
//   ОбъектМетаданных - метаданные объекта.
//
// Возвращаемое значение:
//   Булево.
//
Функция АвтономнаяРаботаРазрешеноИзменениеДанных(ОбъектМетаданных) Экспорт
	
	ТолькоПросмотр = Ложь;
	АвтономнаяРаботаСлужебный.ОпределитьВозможностьИзмененияДанных(ОбъектМетаданных, ТолькоПросмотр);
	
	Возврат НЕ ТолькоПросмотр
	
КонецФункции	

#Область ПостроительМеню

// Возвращает описание раздела меню.
//
// Параметры:
//			ВидЭлемента - значения системных перечислений:
//						ВидГруппыФормы.Подменю
//						ВидГруппыФормы.ГруппаКнопок.
//			Заголовок
//
// ВозвращаемоеЗначение:
//			Структура - дополняет структуру, полученную с помощью метода ЭлементМеню
//					ключем Пункты - Массив.
//
Функция РазделМеню(Заголовок = "") Экспорт
	
	ОписаниеРазделаМеню = ЭлементМеню(ВидГруппыФормы.Подменю, Заголовок);
	ОписаниеРазделаМеню.Вставить("Пункты", Новый Массив);
	
	Возврат ОписаниеРазделаМеню;
	
КонецФункции

// Возвращает описание разделителя кнопок меню.
//
Функция РазделительМеню() Экспорт
	
	Возврат ЭлементМеню();
	
КонецФункции

// Возвращает описание раздела пункта меню.
//
// Параметры:
//			Заголовок
//			ИмяКоманды
//			Действие
//
// ВозвращаемоеЗначение:
//			Структура - дополняет структуру, полученную с помощью метода ЭлементМеню
//					ключами ИмяКоманды и Действие.
//
Функция ПунктМеню(Заголовок = "", ИмяКоманды = "", Действие = "") Экспорт
	
	ОписаниеПунктаМеню = ЭлементМеню(ВидКнопкиФормы.КнопкаКоманднойПанели, Заголовок);
	ОписаниеПунктаМеню.Вставить("ИмяКоманды", ИмяКоманды);
	ОписаниеПунктаМеню.Вставить("Действие", Действие); 
	
	Возврат ОписаниеПунктаМеню;
	
КонецФункции

// Осуществляет установку меню командных панелей формы, по приведенному описанию. Добавляет команды
// элементы меню в командные панели формы.
//
// Параметры:
//			Форма
//			ОписаниеМеню - структура описания меню, полученная с помощью методов
//							РазделМеню и ПунктМеню.
//			ИменаКонтейнеров - имена элементов (групп командной панели), в которых
//							необходимо разместить меню, перечисленные через запятую.
//
Процедура УстановитьМенюВФорме(Форма, ОписаниеМеню, ИменаКонтейнеров) Экспорт
	
	Если ОписаниеМеню = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	ИменаГруппПодменю = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаКонтейнеров);
	
	Для каждого ИмяГруппыПодменю Из ИменаГруппПодменю Цикл
		
		ГруппаПодменю = Форма.Элементы.Найти(ИмяГруппыПодменю);
		Если ГруппаПодменю = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		// Предварительная очистка меню, при повторном заполнении.
		Если ГруппаПодменю <> Неопределено Тогда
			Пока ГруппаПодменю.ПодчиненныеЭлементы.Количество() > 0 Цикл
				Форма.Элементы.Удалить(ГруппаПодменю.ПодчиненныеЭлементы[0]);
			КонецЦикла; 
		КонецЕсли; 
		
		Если ОписаниеМеню.Вид = ВидГруппыФормы.Подменю Тогда
			
			ДобавитьПодменю(Форма, ОписаниеМеню, ГруппаПодменю);
			
		ИначеЕсли ОписаниеМеню.Вид = ВидКнопкиФормы.КнопкаКоманднойПанели Тогда
			
			ДобавитьПунктМеню(Форма, ОписаниеМеню, ГруппаПодменю);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Проверяет доступность объектов метаданных по полным именам. Проверка производится по критериям:
//	- наличие объекта в конфигурации
//  - доступность в зависимости от значений функциональных опций в состав которых входит объект
//  - и наличие права на объект у текущего пользователя.
//
// Параметры:
//		ПолныеИменаОбъектовМетаданных - Массив строк (например: "Документы.ПриемНаРаботу").
//		ПравоДоступа - Строка, описание параметра соответствует описанию параметра "Право" метода
//				платформы "ПравоДоступа".
//		ПолныеИменаИсключаемыхИзПроверкиОбъектовМетаданных - Массив строк имен объектов метаданных,
//				право доступа к которым не предоставляется из логических соображений.
//
// ВозвращаемоеЗначение:
//		Соответствие - Ключ - полное имя объекта метаданных, Значение - Синоним объекта, заданный в конфигураторе.
//
Функция ПредставленияДоступныхОбъектовМетаданных(ПолныеИменаОбъектовМетаданных, ПравоДоступа, ПолныеИменаИсключаемыхИзПроверкиОбъектовМетаданных = Неопределено, СобственныеПредставленияОбъектов = Неопределено) Экспорт
	
	ПредставленияДоступныхОбъектов = Новый Соответствие;
	
	Для каждого ПолноеИмяОбъектаМетаданных Из ПолныеИменаОбъектовМетаданных Цикл
		
		Если ПустаяСтрока(ПолноеИмяОбъектаМетаданных) Тогда
			Продолжить;
		КонецЕсли;
		
		Если ПолныеИменаИсключаемыхИзПроверкиОбъектовМетаданных <> Неопределено
			И ПолныеИменаИсключаемыхИзПроверкиОбъектовМетаданных.Найти(ПолноеИмяОбъектаМетаданных) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ЧастиИменОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмяОбъектаМетаданных, ".");
		ОбъектМетаданных = Метаданные[ЧастиИменОбъекта[0]].Найти(ЧастиИменОбъекта[1]);
		
		Если ОбъектМетаданных = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если НЕ ОбщегоНазначения.ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Тогда
			Продолжить;
		КонецЕсли;
		
		Если НЕ ПравоДоступа(ПравоДоступа, ОбъектМетаданных) Тогда
			Продолжить;
		КонецЕсли;
		
		СобственноеПредставлениеОбъекта = "";
		Если СобственныеПредставленияОбъектов <> Неопределено Тогда
			СобственноеПредставлениеОбъекта = СобственныеПредставленияОбъектов.Получить(ПолноеИмяОбъектаМетаданных);
		КонецЕсли;
		
		Если ЗначениеЗаполнено(СобственноеПредставлениеОбъекта) Тогда
			ПредставленияДоступныхОбъектов.Вставить(ПолноеИмяОбъектаМетаданных, СобственноеПредставлениеОбъекта);
		Иначе
			ПредставленияДоступныхОбъектов.Вставить(ПолноеИмяОбъектаМетаданных, ОбъектМетаданных.Синоним);
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ПредставленияДоступныхОбъектов;
	
КонецФункции

#КонецОбласти

// Проверяет принадлежность объекта метаданных к подсистемам. Проверка производится на вхождение
// в состав указанных подсистем и на вхождение в состав подсистем подчиненных указанным.
//
// Параметры:
//			ПолноеИмяОбъектаМетаданных 	- Строка, полное имя объекта метаданных (см. функцию НайтиПоПолномуИмени).
//			ИменаПодсистем				- Строка, имена подсистем, перечисленные через запятую.
//
// Возвращаемое значение:
//		Булево
//
Функция ОбъектМетаданныхВключенВПодсистемы(ПолноеИмяОбъектаМетаданных, ИменаПодсистем) Экспорт
	Возврат ЗарплатаКадрыПовтИсп.ОбъектМетаданныхВключенВПодсистемы(ПолноеИмяОбъектаМетаданных, ИменаПодсистем);
КонецФункции

// Возвращает значение по умолчанию для типа соответствующего типу переданного параметра.
//
// Параметры:
//		Значение			- Любое значение.
//
// Возвращаемое значение:
//		Пустое значение такого же типа как и значение переданное в качестве параметра.
//
Функция ПустоеЗначениеТипаПоЗначению(Значение)
	Тип = ТипЗнч(Значение);
	ОписаниеТипа = Новый ОписаниеТипов(ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Тип));
	Возврат ОписаниеТипа.ПривестиЗначение();
КонецФункции

// Возвращает сериализованный объект в виде двоичных данных.
//
// Параметры:
//  Объект - Любой сериализуемый в XML объект.
//
// Возвращаемое значение:
//  ДвоичныеДанные - сериализованный объект.
//
Функция СериализоватьОбъектВДвоичныеДанные(Объект) Экспорт
	ЗаписьXML = Новый ЗаписьFastInfoset;
	ЗаписьXML.УстановитьДвоичныеДанные();
	ЗаписьXML.ЗаписатьОбъявлениеXML();
	ЗаписатьXML(ЗаписьXML, Объект, НазначениеТипаXML.Явное);
	Возврат ЗаписьXML.Закрыть();

КонецФункции

// Десериализует объект из двоичных данных
// 
// Параметры:
//   ДанныеОбъекта - двоичные данные, представляющие собой объект, сериализованный, 
//   например, при помощи СериализоватьОбъектВДвоичныеДанные.
//
Функция ДесериализоватьОбъектИзДвоичныхДанных(ДанныеОбъекта) Экспорт
	ЧтениеXML = Новый ЧтениеFastInfoset;
	ЧтениеXML.УстановитьДвоичныеДанные(ДанныеОбъекта);
	Объект = ПрочитатьXML(ЧтениеXML);
	ЧтениеXML.Закрыть();
	Возврат Объект;
	
КонецФункции

// Выгрузка результата запроса в таблицу значений
// Применяется в методах, которые должны возвращать таблицу значений заданной структуры
// Исключает влияние текста запроса на значение, возвращаемое такими методами
Процедура ВыгрузитьРезультатВТаблицуЗначений(РезультатЗапроса, ЦелеваяТаблица) Экспорт
	Выборка = РезультатЗапроса.Выбрать();
	Пока Выборка.Следующий() Цикл
		ЗаполнитьЗначенияСвойств(ЦелеваяТаблица.Добавить(), Выборка);
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область КлючевыеРеквизитыЗаполненияФормы

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для предупреждения об очистке таблиц формы при редактировании "ключевых" реквизитов.
//
// Для работы механизма в форме должны быть определены экспортные процедуры: 
// 		КлючевыеРеквизитыЗаполненияФормыТаблицыОчищаемыеПриИзменении()
// 		КлючевыеРеквизитыЗаполненияФормыОписаниеКлючевыхРеквизитов().
// Пример можно посмотреть в форме документа НачислениеЗарплаты.
//

// Процедура заполняет текст предупреждения при редактировании для ключевых реквизитов.
Процедура КлючевыеРеквизитыЗаполненияФормыЗаполнитьПредупреждения(Форма, МассивОписанийРеквизитов = Неопределено, ДействиеПриИзмененииОчистка = Истина) Экспорт
	
	Если МассивОписанийРеквизитов = Неопределено Тогда 
		МассивОписанийРеквизитов = Форма.КлючевыеРеквизитыЗаполненияФормыОписаниеКлючевыхРеквизитов();
	КонецЕсли;	
	
	Для Каждого Описание Из МассивОписанийРеквизитов Цикл
		Если Описание.Свойство("ПредупреждениеПриРедактировании") Тогда
			ПредупреждениеПриРедактировании = Описание.ПредупреждениеПриРедактировании;
		Иначе
			ПредупреждениеПриРедактировании = КлючевыеРеквизитыПредставлениеПредупреждения(Описание.Представление, ДействиеПриИзмененииОчистка)
		КонецЕсли;
		ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы,
		Описание.ЭлементФормы,
		"ПредупреждениеПриРедактировании",
		ПредупреждениеПриРедактировании);
	КонецЦикла;
	
КонецПроцедуры

Функция КлючевыеРеквизитыЗаполненияФормыТекстПредупрежденияДокументовСАвтоматическимРасчетом() Экспорт
	Возврат НСтр("ru = 'Ручные исправления таблиц документа будут потеряны'");
КонецФункции

// Функция возвращает текст предупреждения для конкретного реквизита.
Функция КлючевыеРеквизитыПредставлениеПредупреждения(ПредставлениеРеквизита, ДействиеПриИзмененииОчистка)
	
	ПредставлениеПредупреждения = НСтр("ru = 'Редактирование %1 приведет к %2 табличных частей документа'");
	
	Если ДействиеПриИзмененииОчистка Тогда
		ПредставлениеДействияПриИзменении = НСтр("ru = 'очистке'");
	Иначе 
		ПредставлениеДействияПриИзменении = НСтр("ru = 'перезаполнению'");
	КонецЕсли;
	
	ПредставлениеПредупреждения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ПредставлениеПредупреждения, ПредставлениеРеквизита, ПредставлениеДействияПриИзменении);
	
	Возврат	ПредставлениеПредупреждения;
	
КонецФункции 

#КонецОбласти

#Область РасчетПериодовСостоянийСотрудников

// Возвращает пустую структуру для описания регистра первичных данных.
//
// Возвращаемое значение:
//	Структура - структура с полями:
//		ИмяРегистра - имя регистра сведений содержащего первичные данные.
//		ИмяПоляНачало - Дата - имя поля, содержащего дату начала интервала.
//		ИмяПоляОкончание - Дата - имя поля, содержащего дату окончания интервала.
//		ИмяПоляПриоритет - ПеречислениеСсылка.СостоянияСотрудника - имя поля, содержащего состояние сотрудника.
//							Исходя из значения этого поля определяется приоритет интервала.
//		Измерения - Массив - сюда надо добавить поля - измерения, в разрезе которых ведется учет.
//		Ресурсы - Массив - сюда надо добавить поля - ресурсы.
//
Функция ОписаниеРегистраИсходныхПериодовСостояний() Экспорт 
	Описание = Новый Структура;
	Описание.Вставить("ИмяРегистра");
	Описание.Вставить("ИмяПоляДатаНачалаСобытия");
	Описание.Вставить("ИмяПоляДатаНачалаПериода");
	Описание.Вставить("ИмяПоляДатаОкончанияПериода");
	Описание.Вставить("ИмяПоляПриоритет");          
	Описание.Вставить("Измерения", Новый Массив);
	Описание.Вставить("Ресурсы", Новый Массив);
	Описание.Вставить("ДополнятьИсточникПолученияДанных", Ложь);
	
	Возврат Описание;
КонецФункции	

// Возвращает пустую структуру для описания регистра вторичных данных.
//
// Возвращаемое значение:
//	Структура - структура с полями:
//		ИмяРегистра - имя регистра сведений содержащего вторичные данные.
//		ИмяПоляНачало - Дата - имя поля, содержащего дату начала интервала.
//		ИмяПоляОкончание - Дата - имя поля, содержащего дату окончания интервала.
//		Измерения - Массив - сюда надо добавить поля - измерения, в разрезе которых ведется учет.
//		Ресурсы - Массив - сюда надо добавить поля - ресурсы.
//
Функция ОписаниеРегистраРассчитанныхПериодовСостояний() Экспорт 
	Описание = Новый Структура;
	Описание.Вставить("ИмяРегистра");
	Описание.Вставить("ИмяПоляДатаНачалаПериода");
	Описание.Вставить("ИмяПоляДатаОкончанияПериода");
	Описание.Вставить("Измерения", Новый Массив);
	Описание.Вставить("Ресурсы", Новый Массив);
	Описание.Вставить("ОтборПоГоду", Ложь);
	Описание.Вставить("ОтборРассчитанныхДанныхРавно");
	Описание.Вставить("ОтборРассчитанныхДанныхНеРавно");
	
	Возврат Описание;
КонецФункции	


// Добавляет отбор для записей вторичного регистра состояний
// Отбор применяется после, расчета данных на основе первичного регистра, в момент формирования набора вторичного регистра.
// Отбор возможен только по условию равенства, 
// если задано несколько элементов отбора, то считаем что запись соответствует отбору при выполнении хотя бы одного условия.
//
// 	Параметры: 
//		ОписаниеРегистраРассчитанныхПериодовСостояний - структура см. ОписаниеРегистраРассчитанныхПериодовСостояний - содержит описание
//		                                  регистра первичных данных.
//		ЛевоеЗначение - любой ресурс первичного регистра
//      ПравоеЗначение - значение отбора.
//
Процедура ДобавитьОтборЗаписейРегистраРассчитанныхПериодовСостоянийРавно(ОписаниеРегистраРассчитанныхПериодовСостояний, ЛевоеЗначение, ПравоеЗначение, ПроверятьЗарегистрированноеЗначение = Ложь) Экспорт 
	Если ОписаниеРегистраРассчитанныхПериодовСостояний.ОтборРассчитанныхДанныхРавно = Неопределено Тогда
		ОписаниеРегистраРассчитанныхПериодовСостояний.ОтборРассчитанныхДанныхРавно = Новый Структура;	
	КонецЕсли;		
	
	ЗначениеОтбора = Новый Структура("Значение, ПроверятьЗарегистрированноеЗначение");
	ЗначениеОтбора.Значение = ПравоеЗначение;
	ЗначениеОтбора.ПроверятьЗарегистрированноеЗначение = ПроверятьЗарегистрированноеЗначение;
	ОписаниеРегистраРассчитанныхПериодовСостояний.ОтборРассчитанныхДанныхРавно.Вставить(ЛевоеЗначение, ЗначениеОтбора);
КонецПроцедуры	

// Добавляет отбор для записей вторичного регистра состояний
// Отбор применяется после, расчета данных на основе первичного регистра, в момент формирования набора вторичного регистра.
// Отбор возможен только по условию "не равно", 
// если задано несколько элементов отбора, то считаем что запись соответствует отбору при выполнении хотя бы одного условия.
//
// 	Параметры: 
//		ОписаниеРегистраРассчитанныхПериодовСостояний - структура см. ОписаниеРегистраРассчитанныхПериодовСостояний - содержит описание
//		                                  регистра первичных данных.
//		ЛевоеЗначение - любой ресурс первичного регистра
//      ПравоеЗначение - значение отбора.
//
Процедура ДобавитьОтборЗаписейРегистраРассчитанныхПериодовСостоянийНеРавно(ОписаниеРегистраРассчитанныхПериодовСостояний, ЛевоеЗначение, ПравоеЗначение, ПроверятьЗарегистрированноеЗначение = Ложь) Экспорт 
	Если ОписаниеРегистраРассчитанныхПериодовСостояний.ОтборРассчитанныхДанныхНеРавно = Неопределено Тогда
		ОписаниеРегистраРассчитанныхПериодовСостояний.ОтборРассчитанныхДанныхНеРавно = Новый Структура;	
	КонецЕсли;		
	
	ЗначениеОтбора = Новый Структура("Значение, ПроверятьЗарегистрированноеЗначение");
	ЗначениеОтбора.Значение = ПравоеЗначение;
	ЗначениеОтбора.ПроверятьЗарегистрированноеЗначение = ПроверятьЗарегистрированноеЗначение;
	ОписаниеРегистраРассчитанныхПериодовСостояний.ОтборРассчитанныхДанныхНеРавно.Вставить(ЛевоеЗначение, ЗначениеОтбора);
КонецПроцедуры	

// Обновляет данные вторичного регистра учета событий на оси времени
// с учетом приоритетов.
//
// 	Параметры: 
//		ОписаниеРегистраПервичныхДанных - структура см. СтруктураОписанияРегистраПервичныхДанных - содержит описание
//		                                  регистра первичных данных.
//		ОписаниеРегистраВторичныхДанных	структура см. СтруктураОписанияРегистраВторичныхДанных - содержит описание регистра
//		вторичных данных.
//      КлючиОбновляемыхДанных - таблица значений - содержит данные для отбора. Имена колонок совпадают с имена измерений
//                               регистра первичных данных.
//		РежимЗагрузки - булево - устанавливает свойство ОбменДанными.Загрузка набору записей регистра вторичных данных.
//
Процедура ОбновитьРегистрРассчитанныхПериодовСостояний(ОписаниеРегистраПервичныхДанных, ОписаниеРегистраВторичныхДанных, КлючиОбновляемыхДанных, РежимЗагрузки = Ложь, НаборЗаписей = Неопределено) Экспорт
	
	Если КлючиОбновляемыхДанных <> Неопределено 
		И КлючиОбновляемыхДанных.Количество() = 0 Тогда
		
		Возврат;
	КонецЕсли;
	
	// расчет периодов ведем в разрезе значений измерений первичного регистра
	ИзмеренияРасчета = ОписаниеРегистраПервичныхДанных.Измерения;
	ИзмеренияВторичногоРегистра = ОписаниеРегистраВторичныхДанных.Измерения;
	
	КлючиОбновленныхНаборов = НовыйКлючиОбновленныхНаборовВторичногоРегистраСостояний(ОписаниеРегистраВторичныхДанных);
	ВыборкаРассчитанныхПериодов = ВыборкаРассчитанныеПериодыСостояний(КлючиОбновляемыхДанных, ОписаниеРегистраПервичныхДанных);
	РассчитанныеДанныеВторичногоРегистра = НовыйРассчитанныеДанныеВторичногоРегистраСостояний(ОписаниеРегистраПервичныхДанных);
	ДанныеПредыдущегоСостояния = Неопределено;
	
	ЗначенияИзмеренийПредыдущейЗаписи = Неопределено;
	Пока ВыборкаРассчитанныхПериодов.Следующий() Цикл
		Если ЗначенияИзмеренийЗаписейСостоянийОтличны(ДанныеПредыдущегоСостояния, ВыборкаРассчитанныхПериодов, ИзмеренияВторичногоРегистра)
			И РассчитанныеДанныеВторичногоРегистра.Количество() > 0 Тогда
			
			ЗаписатьНаборыВторичногоРегистраСостояний(ОписаниеРегистраВторичныхДанных, РассчитанныеДанныеВторичногоРегистра, КлючиОбновленныхНаборов, РежимЗагрузки, НаборЗаписей);
			
			ДанныеПредыдущегоСостояния = Неопределено;
			РассчитанныеДанныеВторичногоРегистра.Очистить();
		КонецЕсли;		
		
		Если НЕ ПродолжатьДействиеТекущегоСостояния(ДанныеПредыдущегоСостояния, ВыборкаРассчитанныхПериодов, ИзмеренияРасчета, ОписаниеРегистраВторичныхДанных.Ресурсы) Тогда
			ЗакрытьПериодПредыдущегоСостояния(ДанныеПредыдущегоСостояния, ВыборкаРассчитанныхПериодов, ИзмеренияРасчета);	
			ДанныеПредыдущегоСостояния = ДобавитьЗаписьВРассчитанныеПериодыСостояний(РассчитанныеДанныеВторичногоРегистра, ВыборкаРассчитанныхПериодов);
		КонецЕсли;			
	КонецЦикла;		
	
	Если РассчитанныеДанныеВторичногоРегистра.Количество() > 0 Тогда
		ЗаписатьНаборыВторичногоРегистраСостояний(ОписаниеРегистраВторичныхДанных, РассчитанныеДанныеВторичногоРегистра, КлючиОбновленныхНаборов, РежимЗагрузки, НаборЗаписей);
	КонецЕсли;	
		
	// По тем значениям измерений, по которым не было записей в регистре первичных данных 
	// запишем пустые наборы.
	Если НаборЗаписей = Неопределено Тогда
		ЗаписатьПустыеНаборыВторичногоРегистраСостояний(ОписаниеРегистраВторичныхДанных, КлючиОбновляемыхДанных, КлючиОбновленныхНаборов, РежимЗагрузки);
	КонецЕсли;
КонецПроцедуры

Функция ЗначенияИзмеренийЗаписейСостоянийОтличны(ДанныеПредыдущегоСостояния, ДанныеТекущегоСостояния, Измерения)
	Если ДанныеПредыдущегоСостояния = Неопределено
		Или ДанныеТекущегоСостояния = Неопределено Тогда
		
		Возврат Истина;
	КонецЕсли;	
	
	Для Каждого ТекущееИзмерение Из Измерения Цикл
		Если ДанныеПредыдущегоСостояния[ТекущееИзмерение] <> ДанныеТекущегоСостояния[ТекущееИзмерение] Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;	
	
	Возврат Ложь;
КонецФункции

Процедура ЗаписатьНаборыВторичногоРегистраСостояний(ОписаниеРегистраВторичныхДанных, РассчитанныеДанные, КлючиОбновленныхНаборов, РежимЗагрузки, НаборЗаписей = Неопределено)
	Если РассчитанныеДанные.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;	
	
	ИзмеренияВторичныхДанных = ОписаниеРегистраВторичныхДанных.Измерения;
	
	Если НаборЗаписей = Неопределено Тогда
		Записывать = Истина;
		Набор = РегистрыСведений[ОписаниеРегистраВторичныхДанных.ИмяРегистра].СоздатьНаборЗаписей();	
		Если РежимЗагрузки Тогда
			Набор.ОбменДанными.Загрузка = Истина;
		КонецЕсли;	
		
		Для Каждого Измерение Из ИзмеренияВторичныхДанных Цикл
			Набор.Отбор[Измерение].Установить(РассчитанныеДанные[0][Измерение]);
		КонецЦикла;
	Иначе
		Записывать = Ложь;
		Набор = НаборЗаписей;
	КонецЕсли;
	
	ОтборПоГоду = ОписаниеРегистраВторичныхДанных.ОтборПоГоду;
	РассчитанныеДанные.Сортировать("ДатаНачала");
	
	ПредыдущаяЗапись = Неопределено;
	Для Каждого ДанныеПериода Из РассчитанныеДанные Цикл
		Если ДанныеПериода.СостояниеДействует 
			И ЗаписьВторичныхДанныхСостоянийСоответствуетОтбору(ДанныеПериода, ОписаниеРегистраВторичныхДанных) Тогда
			
			Если Не ЗначенияИзмеренийЗаписейСостоянийОтличны(ПредыдущаяЗапись, ДанныеПериода, ИзмеренияВторичныхДанных) Тогда
				Если ПредыдущаяЗапись.ДатаНачала = ДанныеПериода.ДатаНачала Тогда
					Продолжить;
				КонецЕсли;
				Если ДанныеПериода.ДатаНачала <= ПредыдущаяЗапись.ДатаОкончания
					Или Не ЗначениеЗаполнено(ПредыдущаяЗапись.ДатаОкончания) Тогда
					
					ПредыдущаяЗапись.ДатаОкончания = ДанныеПериода.ДатаНачала - 86400;
				КонецЕсли;
			КонецЕсли;
			ПредыдущаяЗапись = ДанныеПериода;
		КонецЕсли;
	КонецЦикла;
	
	ГодТекущейЗаписи = Неопределено;
	ПредыдущаяЗапись = Неопределено;
	Для Каждого ДанныеПериода Из РассчитанныеДанные Цикл
		Если Записывать
			И ОтборПоГоду  
			И ГодТекущейЗаписи <> НачалоГода(ДанныеПериода.ДатаНачала) 
			И Набор.Количество() > 0 Тогда
			
			КлючНабора = КлючиОбновленныхНаборов.Добавить();
			ЗаполнитьЗначенияСвойств(КлючНабора, Набор[0]); 

			Набор.Отбор.Год.Установить(Набор[0].Год);
			Набор.Записать();
			Набор.Очистить();
		КонецЕсли;	
		
		Если ДанныеПериода.СостояниеДействует 
			И ЗаписьВторичныхДанныхСостоянийСоответствуетОтбору(ДанныеПериода, ОписаниеРегистраВторичныхДанных) Тогда
			
			Если Не ЗначенияИзмеренийЗаписейСостоянийОтличны(ПредыдущаяЗапись, ДанныеПериода, ИзмеренияВторичныхДанных)
				И ПредыдущаяЗапись.ДатаНачала = ДанныеПериода.ДатаНачала Тогда
				
				Продолжить;
			КонецЕсли;
			
			СтрокаНабора = Набор.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаНабора, ДанныеПериода);
			СтрокаНабора[ОписаниеРегистраВторичныхДанных.ИмяПоляДатаНачалаПериода] = ДанныеПериода.ДатаНачала;
			СтрокаНабора[ОписаниеРегистраВторичныхДанных.ИмяПоляДатаОкончанияПериода] = ДанныеПериода.ДатаОкончания;
			СтрокаНабора.Год = НачалоГода(ДанныеПериода.ДатаНачала);
			ПредыдущаяЗапись = ДанныеПериода;
		КонецЕсли;	
		
		ГодТекущейЗаписи = НачалоГода(ДанныеПериода.ДатаНачала);	
	КонецЦикла;	
	
	Если Записывать И Набор.Количество() > 0 Тогда
		КлючНабора = КлючиОбновленныхНаборов.Добавить();
		ЗаполнитьЗначенияСвойств(КлючНабора, Набор[0]);
		
		Если ОтборПоГоду Тогда
			Набор.Отбор.Год.Установить(Набор[0].Год);
		КонецЕсли;	
		Набор.Записать();
	КонецЕсли;	
КонецПроцедуры

Функция НовыйРассчитанныеДанныеВторичногоРегистраСостояний(ОписаниеРегистраПервичныхДанных)
	РассчитанныеДанные = Новый ТаблицаЗначений;
	РассчитанныеДанные.Колонки.Добавить("ДатаНачала", Новый ОписаниеТипов("Дата"));
	РассчитанныеДанные.Колонки.Добавить("ДатаОкончания", Новый ОписаниеТипов("Дата"));
	РассчитанныеДанные.Колонки.Добавить("СостояниеДействует", Новый ОписаниеТипов("Булево"));
	
	Для Каждого ИзмерениеРасчета Из ОписаниеРегистраПервичныхДанных.Измерения Цикл
		РассчитанныеДанные.Колонки.Добавить(ИзмерениеРасчета);
	КонецЦикла;	
	
	Для Каждого Ресурс Из ОписаниеРегистраПервичныхДанных.Ресурсы Цикл
		РассчитанныеДанные.Колонки.Добавить(Ресурс);
		РассчитанныеДанные.Колонки.Добавить("ИспользованиеРесурса" + Ресурс);
		РассчитанныеДанные.Колонки.Добавить("ЗарегистрированоЗначение" + Ресурс);
	КонецЦикла;	
	
	Возврат РассчитанныеДанные;
КонецФункции	

Функция ДобавитьЗаписьВРассчитанныеПериодыСостояний(РассчитанныеДанныеВторичногоРегистра, ДанныеТекущегоСостояния)	
	НоваяСтрока = РассчитанныеДанныеВторичногоРегистра.Добавить();
	ЗаполнитьЗначенияСвойств(НоваяСтрока, ДанныеТекущегоСостояния);
	НоваяСтрока.ДатаНачала = ДанныеТекущегоСостояния.Дата;
	
	Возврат НоваяСтрока;
КонецФункции

Процедура ЗакрытьПериодПредыдущегоСостояния(ДанныеПредыдущегоСостояния, ДатаСледующегоСостояния, ИзмеренияРасчета)
	Если ДанныеПредыдущегоСостояния <> Неопределено
		И Не ЗначенияИзмеренийЗаписейСостоянийОтличны(ДанныеПредыдущегоСостояния, ДатаСледующегоСостояния, ИзмеренияРасчета) Тогда
		
		ДанныеПредыдущегоСостояния.ДатаОкончания = ДатаСледующегоСостояния.Дата - 86400;	
	КонецЕсли;	
КонецПроцедуры	

Процедура ЗарегистрироватьСторноИсходныхДанныхСостояний(Движения, ИмяРегистраПервичныхДанных, ДокументСсылка, СторнируемыйДокумент) Экспорт
	СторнируемыйНабор = РегистрыСведений[ИмяРегистраПервичныхДанных].СоздатьНаборЗаписей();
	СторнируемыйНабор.Отбор.Регистратор.Установить(СторнируемыйДокумент);
	СторнируемыйНабор.Прочитать();
	
	НаборСторноЗаписей = Движения[ИмяРегистраПервичныхДанных];
	
	Для Каждого СторнируемаяЗапись Из СторнируемыйНабор Цикл
		Если Не СторнируемаяЗапись.Сторно Тогда
			СторноЗапись = НаборСторноЗаписей.Добавить();
			ЗаполнитьЗначенияСвойств(СторноЗапись, СторнируемаяЗапись);
			СторноЗапись.ДокументОснование = ДокументСсылка;
			СторноЗапись.Сторно = Истина;
			СторноЗапись.Регистратор = ДокументСсылка;
		КонецЕсли;	
	КонецЦикла;	
		
	Движения[ИмяРегистраПервичныхДанных].Записывать = Истина;
	
КонецПроцедуры	

Функция НовыйКлючиОбновленныхНаборовВторичногоРегистраСостояний(ОписаниеРегистраВторичныхДанных)
	КлючиОбновленныхНаборов = Новый ТаблицаЗначений;
	Для Каждого Измерение Из ОписаниеРегистраВторичныхДанных.Измерения Цикл
		КлючиОбновленныхНаборов.Колонки.Добавить(Измерение);
	КонецЦикла;
	
	Если ОписаниеРегистраВторичныхДанных.ОтборПоГоду Тогда
		КлючиОбновленныхНаборов.Колонки.Добавить("Год");
	КонецЕсли;

	Возврат КлючиОбновленныхНаборов;
КонецФункции	

Функция ЗаписатьПустыеНаборыВторичногоРегистраСостояний(ОписаниеРегистраВторичныхДанных, КлючиОбновляемыхДанных, КлючиОбновленныхНаборов, РежимЗагрузки)
	ОтборПоГоду = ОписаниеРегистраВторичныхДанных.ОтборПоГоду;
	СтруктураПоиска = Новый Структура;
	ПоляИндекса = Новый Массив;
	Для Каждого Колонка Из КлючиОбновляемыхДанных.Колонки Цикл	
		Если Колонка.Имя = "Год" 
			И Не ОтборПоГоду Тогда
			
			Продолжить;
		КонецЕсли; 
		СтруктураПоиска.Вставить(Колонка.Имя);
		ПоляИндекса.Добавить(Колонка.Имя);
	КонецЦикла;	
	КлючиОбновленныхНаборов.Индексы.Добавить(СтрСоединить(ПоляИндекса, ","));	
	
	Набор = РегистрыСведений[ОписаниеРегистраВторичныхДанных.ИмяРегистра].СоздатьНаборЗаписей();	
	Если РежимЗагрузки Тогда
		Набор.ОбменДанными.Загрузка = Истина;
	КонецЕсли;	
	
	Для Каждого КлючНабора Из КлючиОбновляемыхДанных Цикл
		ЗаполнитьЗначенияСвойств(СтруктураПоиска, КлючНабора);
		Если КлючиОбновленныхНаборов.НайтиСтроки(СтруктураПоиска).Количество() > 0 Тогда
			Продолжить;
		КонецЕсли;	
		
		Для Каждого Измерение Из КлючиОбновляемыхДанных.Колонки Цикл
			Набор.Отбор[Измерение.Имя].Установить(КлючНабора[Измерение.Имя]);
		КонецЦикла;
		
		Набор.Записать();
	КонецЦикла;	
КонецФункции	

#КонецОбласти

#Область АдресаСтруктуройПоКЛАДР

Функция СтруктураАдресаИзXML(Адрес, ВидАдреса = Неопределено) Экспорт
	
	Если УправлениеКонтактнойИнформациейКлиентСервер.ЭтоКонтактнаяИнформацияВJSON(Адрес) Тогда
		АдресXML = УправлениеКонтактнойИнформацией.КонтактнаяИнформацияВXML(Адрес, , ВидАдреса);
	Иначе
		АдресXML = Адрес;
	КонецЕсли;
	СтруктураАдреса = РаботаСАдресами.ПредыдущаяСтруктураКонтактнойИнформацииXML(АдресXML, ВидАдреса);
	
	Если ЗначениеЗаполнено(Адрес) И СтруктураАдреса.Свойство("Улица") И Не ЗначениеЗаполнено(СтруктураАдреса.Улица) Тогда
		
		ДопСведенияОбАдресе = РаботаСАдресами.СведенияОбАдресе(Адрес);
		Если ДопСведенияОбАдресе.Свойство("ДополнительнаяТерритория") И ЗначениеЗаполнено(ДопСведенияОбАдресе.ДополнительнаяТерритория) Тогда
			СтруктураАдреса.Улица = ДопСведенияОбАдресе.ДополнительнаяТерритория;
			СтруктураАдреса.УлицаСокращение = ДопСведенияОбАдресе.ДополнительнаяТерриторияСокращение;
		КонецЕсли;
		
	КонецЕсли; 
	
	Возврат СтруктураАдреса;
	
КонецФункции

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ФАЙЛАМИ ОТЧЕТНОСТИ

// Процедура создает и записывает файл, содержащий сведения для отправки в ПФР.
// 
// Параметры:
// 		ИмяФайла - строка
//  	ТекстФайла - строка
//		РасширениеЗаглавнымиБуквами - булево, необязательный.
//		Кодировка - необязательный, кодировка записываемого файла по умолчанию "windows-1251".
//		
Функция ЗаписатьФайлОтчетностиНаДиск(ИмяФайла, ТекстФайла, РасширениеЗаглавнымиБуквами = Истина, Кодировка = Неопределено, ЗаписатьBOM = Истина) Экспорт
	
	Если РасширениеЗаглавнымиБуквами Тогда
		ПолноеИмяФайла = ПолучитьИмяВременногоФайла("XML");
	Иначе 
		ПолноеИмяФайла = ПолучитьИмяВременногоФайла("xml");
	КонецЕсли;	
	
	Поток = Новый ФайловыйПоток(ПолноеИмяФайла, РежимОткрытияФайла.СоздатьНовый);
	
	Если Кодировка = Неопределено Тогда
		ЗаписьТекста = Новый ЗаписьТекста(Поток, "windows-1251", , , ЗаписатьBOM);
	Иначе
		ЗаписьТекста = Новый ЗаписьТекста(Поток, Кодировка, , , ЗаписатьBOM);
	КонецЕсли;	
	
	ЗаписьТекста.Записать(ТекстФайла);
	ЗаписьТекста.Закрыть();
	
	Поток.Закрыть();
	
	Возврат ПолноеИмяФайла;
	
КонецФункции	

// Процедура записывает файл отчетности в базу.
// 
// Параметры:
// 		ВладелецФайла - ссылка на объект - владелец файла.
// 		ИмяФайла - строка.
//  	ТекстФайла - строка
//		РасширениеЗаглавнымиБуквами - булево, необязательный.
//		Кодировка - необязательный, кодировка записываемого файла по умолчанию "windows-1251".
//
Процедура ЗаписатьФайлВАрхив(ВладелецФайла, Знач ИмяФайла, ТекстФайла, РасширениеЗаглавнымиБуквами = Истина, Кодировка = Неопределено, РасширениеВместеСИменемФайла = Истина, ЗаписатьBOM = Истина) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ИмяОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ВладелецФайла.Метаданные().ПолноеИмя(), ".")[1];
	
	ПолноеИмяФайла = ЗаписатьФайлОтчетностиНаДиск(ИмяФайла, ТекстФайла, РасширениеЗаглавнымиБуквами, Кодировка, ЗаписатьBOM);
	
	Файл = Новый Файл(ПолноеИмяФайла);
	
	ДвоичныеДанныеФайла = Новый ДвоичныеДанные(ПолноеИмяФайла);
	
	АдресВременногоХранилищаФайла = ПоместитьВоВременноеХранилище(ДвоичныеДанныеФайла);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ВладелецФайла", ВладелецФайла);
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ПрисоединенныеФайлы.Ссылка
	|ИЗ
	|	ИсточникДанных КАК ПрисоединенныеФайлы
	|ГДЕ
	|	ПрисоединенныеФайлы.ВладелецФайла = &ВладелецФайла";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИсточникДанных", "Справочник." + ИмяОбъекта + "ПрисоединенныеФайлы"); 
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда 
		Если РасширениеЗаглавнымиБуквами Тогда
			Расширение = ВРег(Прав(Файл.Расширение, СтрДлина(Файл.Расширение)-1));
		Иначе
			Расширение = Прав(Файл.Расширение, СтрДлина(Файл.Расширение)-1);
		КонецЕсли;
		
		Если РасширениеВместеСИменемФайла Тогда
			ИмяБезРасширения = Лев(ИмяФайла, СтрДлина(ИмяФайла) - 4);
		Иначе 	
			ИмяБезРасширения = ИмяФайла;
		КонецЕсли;

		ИнформацияОФайле = Новый Структура;
		ИнформацияОФайле.Вставить("ДатаМодификацииУниверсальная", Файл.ПолучитьУниверсальноеВремяИзменения());
		ИнформацияОФайле.Вставить("АдресФайлаВоВременномХранилище", АдресВременногоХранилищаФайла);
		ИнформацияОФайле.Вставить("АдресВременногоХранилищаТекста", "");
		ИнформацияОФайле.Вставить("Расширение", Прав(Файл.Расширение, СтрДлина(Файл.Расширение)-1));
		ИнформацияОФайле.Вставить("ИмяБезРасширения", ИмяБезРасширения);
		
		РаботаСФайлами.ОбновитьФайл(Выборка.Ссылка, ИнформацияОФайле);
		
		СсылкаФайла = Выборка.Ссылка;
	Иначе
		
		Если РасширениеЗаглавнымиБуквами Тогда
			Расширение = ВРег(ОбщегоНазначенияКлиентСервер.РасширениеБезТочки(Файл.Расширение));
		Иначе
			Расширение = ОбщегоНазначенияКлиентСервер.РасширениеБезТочки(Файл.Расширение);
		КонецЕсли;
		
		ПараметрыФайла = Новый Структура(
			"Автор,
			|ВладелецФайлов,
			|ИмяБезРасширения,
			|РасширениеБезТочки,
			|ВремяИзменения,
			|ВремяИзмененияУниверсальное");
			
		ПараметрыФайла.ВладелецФайлов = ВладелецФайла;
		
		Если РасширениеВместеСИменемФайла Тогда
			ПараметрыФайла.ИмяБезРасширения = Лев(ИмяФайла, СтрДлина(ИмяФайла) - 4);
		Иначе 	
			ПараметрыФайла.ИмяБезРасширения = ИмяФайла;
		КонецЕсли;

		ПараметрыФайла.РасширениеБезТочки = Расширение;
		ПараметрыФайла.ВремяИзменения = ТекущаяДатаСеанса();
		ПараметрыФайла.ВремяИзмененияУниверсальное = Файл.ПолучитьУниверсальноеВремяИзменения();
		
		СсылкаФайла = РаботаСФайлами.ДобавитьФайл(ПараметрыФайла, АдресВременногоХранилищаФайла, "");
	КонецЕсли;
	
	Если Кодировка <> Неопределено И ЗаписатьBOM = Ложь Тогда
		РаботаСФайламиСлужебныйВызовСервера.ЗаписатьКодировкуВерсииФайла(СсылкаФайла, Кодировка);
	КонецЕсли;
	
	УдалитьФайлы(ПолноеИмяФайла);
	
КонецПроцедуры

// Возвращает данные присоединенного к объекту файла.
//
// Параметры:	
//  ВладелецФайла      - ОпределяемыйТип.ВладелецПрисоединенныхФайлов - Ссылка на объект-владелец файлов.
//  ИдентификаторФормы - УникальныйИдентификатор - см. РаботаСФайлами.ПолучитьДанныеФайла
//                                                 По умолчанию не задан.
//  ПолучатьСсылкуНаДвоичныеДанные - Булево      - см. РаботаСФайлами.ПолучитьДанныеФайла 
//                                                 По умолчанию - Истина.
//	ПривилегированныйРежим - Булево - признак получения данных в привилегированном режиме.
//                                    По умолчанию - Истина.
//
// Возвращаемое значение:
//  Структура - см. РаботаСФайлами.ПолучитьДанныеФайла.
//		
Функция ПолучитьДанныеФайла(Знач ВладелецФайла, 
                            Знач ИдентификаторФормы = Неопределено,
                            Знач ПолучатьСсылкуНаДвоичныеДанные = Истина,
                            Знач ПривилегированныйРежим = Истина) Экспорт
	
	ФайлыВладельца = Новый Массив;
	РаботаСФайлами.ЗаполнитьПрисоединенныеФайлыКОбъекту(ВладелецФайла, ФайлыВладельца);
	
	Если ФайлыВладельца.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ПривилегированныйРежим Тогда
		УстановитьПривилегированныйРежим(Истина);
	КонецЕсли;
	
	ПараметрыДанныхФайла = РаботаСФайламиКлиентСервер.ПараметрыДанныхФайла();
	ПараметрыДанныхФайла.ИдентификаторФормы = ИдентификаторФормы;
	ПараметрыДанныхФайла.ПолучатьСсылкуНаДвоичныеДанные = ПолучатьСсылкуНаДвоичныеДанные;
	
	Возврат РаботаСФайлами.ДанныеФайла(ФайлыВладельца[0], ПараметрыДанныхФайла);
	
КонецФункции

// Записывает текст в двоичные данные.
//
// Параметры:
//   Текст - Строка - Записываемый текст.
//   Кодировка - КодировкаТекста, Строка - Кодировка записываемого текста.
//   ЗаписатьBOM - Булево - Признак записи маркера последовательности байтов (BOM) в начало двоичных данных.
//
// Возвращаемое значение:
//   ДвоичныеДанные - Двоичные данные текста.
//
Функция СтрокаВДвоичныеДанные(Текст, Кодировка, ЗаписатьBOM) Экспорт
	Поток = Новый ПотокВПамяти();
	ЗаписьТекста = Новый ЗаписьТекста(Поток, Кодировка, , , ЗаписатьBOM);
	ЗаписьТекста.Записать(Текст);
	ЗаписьТекста.Закрыть();
	Возврат Поток.ЗакрытьИПолучитьДвоичныеДанные();
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы с данными физических лиц.

// Создает временную таблицу, содержащую ФИО физических лиц, содержащую колонки:
//		* ФизическоеЛицо
//		* Дата
//		* Ссылка
//		* Фамилия
//		* Имя
//		* Отчество
//		* ФИОПолные
//		* РасшифровкаПодписи
//
// Параметры:
//		МенеджерВременныхТаблиц
//		ТолькоРазрешенные
//		ИменаПолейОтветственныхЛиц	- Строка, содержит имена полей временной таблицы, разделенные запятыми, в которых
//		                             содержатся ответственные лица.
//									- Массив, строк имен полей временной таблицы, в которой содержатся ответственные лица
//											поле должно содержать ссылку на справочник ФизическиеЛица.
//		ИмяВременнойТаблицыДанныхДокумента - Строка, имя временной таблицы, содержащей данные документа,
//						таблица, должна содержать колонки:
//							* Дата -  дата на которую получаются ФИО.
//							* Ссылка - нечто, которое можно использовать для отбора полученных данных.
//
Процедура СоздатьВТФИООтветственныхЛиц(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИменаПолейОтветственныхЛиц, ИмяВременнойТаблицыДанныхДокумента) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	
	Если ТипЗнч(ИменаПолейОтветственныхЛиц) = Тип("Строка") Тогда
		МассивИменПолей = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаПолейОтветственныхЛиц, , ,Истина);
	Иначе
		МассивИменПолей = ИменаПолейОтветственныхЛиц;
	КонецЕсли;
	
	ЭтоПервоеПолеОтветственного = Истина;
	Для Каждого ИмяПоляОтветственногоЛица Из МассивИменПолей Цикл
		
		Если Не ЭтоПервоеПолеОтветственного Тогда
			
			Запрос.Текст = Запрос.Текст + "
				|ОБЪЕДИНИТЬ ВСЕ
				|ВЫБРАТЬ РАЗЛИЧНЫЕ";
			
		Иначе
			Запрос.Текст = Запрос.Текст + "ВЫБРАТЬ " + ?(ТолькоРазрешенные, "РАЗРЕШЕННЫЕ", "") + " РАЗЛИЧНЫЕ";
		КонецЕсли;
		
		Запрос.Текст = Запрос.Текст + "
			|	ДанныеДокумента.ИмяПоляОтветственногоЛица КАК ФизическоеЛицо,
			|	ДанныеДокумента.Дата КАК Период,
			|	ДанныеДокумента.Ссылка" + ?(ЭтоПервоеПолеОтветственного, "
			|ПОМЕСТИТЬ ВТСотрудники", "") + "
			|ИЗ
			|	ДанныеДокумента КАК ДанныеДокумента";
		
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяПоляОтветственногоЛица", ИмяПоляОтветственногоЛица);
		
		ЭтоПервоеПолеОтветственного = Ложь;
		
	КонецЦикла;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ДанныеДокумента", ИмяВременнойТаблицыДанныхДокумента);
	Запрос.Выполнить();
	
	ОписательВременныхТаблиц = КадровыйУчет.ОписательВременныхТаблицДляСоздатьВТКадровыеДанныеФизическихЛиц(
		МенеджерВременныхТаблиц, "ВТСотрудники");
	
	КадровыйУчет.СоздатьВТКадровыеДанныеФизическихЛиц(ОписательВременныхТаблиц, ТолькоРазрешенные, "Фамилия,Имя,Отчество,ФИОПолные,ИОФамилия,ФамилияИО,Пол");
	
	Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
		|	ДанныеДокументов.ФизическоеЛицо,
		|	ДанныеДокументов.Период КАК Дата,
		|	ДанныеДокументов.Ссылка,
		|	КадровыеДанныеФизЛиц.Пол,
		|	КадровыеДанныеФизЛиц.Фамилия,
		|	КадровыеДанныеФизЛиц.Имя,
		|	КадровыеДанныеФизЛиц.Отчество,
		|	КадровыеДанныеФизЛиц.ФИОПолные,
		|	КадровыеДанныеФизЛиц.ФамилияИО,
		|	КадровыеДанныеФизЛиц.ИОФамилия КАК РасшифровкаПодписи
		|ПОМЕСТИТЬ ВТФИООтветственныхЛиц
		|ИЗ
		|	ВТСотрудники КАК ДанныеДокументов
		|		ЛЕВОЕ СОЕДИНЕНИЕ ВТКадровыеДанныеФизическихЛиц КАК КадровыеДанныеФизЛиц
		|		ПО ДанныеДокументов.ФизическоеЛицо = КадровыеДанныеФизЛиц.ФизическоеЛицо
		|			И ДанныеДокументов.Период = КадровыеДанныеФизЛиц.Период";
		
	ЗарплатаКадрыОбщиеНаборыДанных.УстановитьВыборкуТолькоРазрешенныхДанных(
		Запрос.Текст, ТолькоРазрешенные);
	
	Запрос.Выполнить();
	
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции ЗАРПЛАТА И КАДРЫ.

// Получает размер минимальной оплаты труда.
//
// Параметры:
//	ДатаАктуальности - дата, на которую нужно получить МРОТ.
//
// Возвращаемое значение:
//	число, размер МРОТ на дату, или Неопределено, если МРОТ на дату не определен.
//
Функция МинимальныйРазмерОплатыТрудаРФ(ДатаАктуальности) Экспорт
	
	Возврат ЗарплатаКадрыПовтИсп.МинимальныйРазмерОплатыТрудаРФ(ДатаАктуальности);
	
КонецФункции	

// Заполняет документ по основанию сотрудник, осуществляет проверку корректности ввода документа.
// В случае , когда проверка не проходит вызывает исключение.
//
// Параметры:
//		ДокументОбъект - ДокументОбъект
//		ДанныеЗаполнения - СправочникСсылка.Сотрудники
//		ПроверкаОформленностиНаРаботу 	- Булево, когда Истина вызывает исключение, если сотрудник уже принят на работу,
//											Ложь - если сотрудник еще не принят.
//		ОтключитьПроверкуЗанятости 		- Булево, отключает проверку принятости сотрудника.
//		ТолькоГоловнаяОрганизация		- Булево, указывает, что организация может быть только головной.
//
// Возвращаемое значение - Булево, Истина - ДанныеЗаполнения заполнен имеют тип СправочникСсылка.Сотрудники, Ложь -
//   если  ДанныеЗаполнения содержат значение другого типа.
//
Процедура ЗаполнитьПоОснованиюСотрудником(ДокументОбъект, ДанныеЗаполнения, ПроверкаОформленностиНаРаботу = Ложь, ОтключитьПроверкуЗанятости = Ложь, ТолькоГоловнаяОрганизация = Ложь) Экспорт
	
	КадровыеДанные = КадровыйУчет.КадровыеДанныеСотрудников(
		Истина, 
		ДанныеЗаполнения, 
		"ГоловнаяОрганизация,Организация,ФизическоеЛицо,ДатаПриема,ОформленПоТрудовомуДоговору,ДатаЗавершенияРаботы");
		
	Если КадровыеДанные.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
		
	СтрокаДанных = КадровыеДанные[0];
	
	Если НЕ ОтключитьПроверкуЗанятости Тогда
		
		Если ПроверкаОформленностиНаРаботу Тогда
			
			Если СтрокаДанных.ОформленПоТрудовомуДоговору Тогда
				
				Если ЗначениеЗаполнено(СтрокаДанных.ДатаЗавершенияРаботы) Тогда
					
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Сотрудник ""%1"" был оформлен на работу с %2, уволен %3'"),
						ДанныеЗаполнения,
						Формат(СтрокаДанных.ДатаПриема, "ДЛФ=DD"),
						Формат(СтрокаДанных.ДатаЗавершенияРаботы, "ДЛФ=DD"));
					
				Иначе
					
					Если ЗначениеЗаполнено(СтрокаДанных.ДатаПриема) Тогда
						
						ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							НСтр("ru = 'Сотрудник ""%1"" уже оформлен на работу с %2'"),
							ДанныеЗаполнения,
							Формат(СтрокаДанных.ДатаПриема, "ДЛФ=DD"));
						
					Иначе
							
						ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							НСтр("ru = 'Сотрудник ""%1"" уже оформлен на работу'"),
							ДанныеЗаполнения);
						
					КонецЕсли;
					
				КонецЕсли;
				
			КонецЕсли; 
				
		Иначе
			
			Если НЕ ЗначениеЗаполнено(СтрокаДанных.Организация) Тогда
				
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Сотрудник ""%1"" не оформлен на работу'"),
					ДанныеЗаполнения);
				
			ИначеЕсли ЗначениеЗаполнено(СтрокаДанных.ДатаЗавершенияРаботы) Тогда
					
				ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Сотрудник ""%1"" уволен %2'"),
					ДанныеЗаполнения,
					Формат(СтрокаДанных.ДатаЗавершенияРаботы, "ДЛФ=DD"));
				
			КонецЕсли;
				
		КонецЕсли;
		
	КонецЕсли; 
	
	Если ЗначениеЗаполнено(СтрокаДанных.Организация) И НЕ ТолькоГоловнаяОрганизация Тогда
		ДокументОбъект.Организация = СтрокаДанных.Организация;
	Иначе
		ДокументОбъект.Организация = СтрокаДанных.ГоловнаяОрганизация;
	КонецЕсли;
	
	МетаданныеДокумента = ДокументОбъект.Метаданные();
	
	РеквизитСотрудник = МетаданныеДокумента.Реквизиты.Найти("Сотрудник");
	Если РеквизитСотрудник <> Неопределено Тогда
		
		Если РеквизитСотрудник.Тип.СодержитТип(Тип("СправочникСсылка.ФизическиеЛица")) Тогда
			ДокументОбъект.Сотрудник 		= СтрокаДанных.ФизическоеЛицо;
		Иначе
			ДокументОбъект.Сотрудник 		= СтрокаДанных.Сотрудник;
		КонецЕсли;
		
	КонецЕсли; 
	
	Если МетаданныеДокумента.Реквизиты.Найти("ФизическоеЛицо") <> Неопределено Тогда
		
		ДокументОбъект.ФизическоеЛицо 	= СтрокаДанных.ФизическоеЛицо;
		
	КонецЕсли; 
	
КонецПроцедуры

// Возвращает признак необходимости отключения бизнес логики при записи объекта.
//
// Параметры:
//  Объект - прикладной объект, например СправочникОбъект - объект для которого
//   требуется проверить необходимость отключения бизнес логики при записи.
//
// Возвращаемое значение:
//  Булево - признак необходимости отключения бизнес логики при записи объекта.
//
Функция ОтключитьБизнесЛогикуПриЗаписи(Знач Объект) Экспорт
	
	Возврат Объект.ОбменДанными.Загрузка И (НЕ Объект.ДополнительныеСвойства.Свойство("ПроверятьБизнесЛогикуПриЗаписи")); 
		
КонецФункции

#Область УправлениеОтборамиВФормахСДинамическимСписком

// Добавляет и дополняет описание параметра отбора в структуру параметров отбора.
//
// Параметры:
//  СтруктураПараметровОтбора - Структура    - Описание параметров, указанных в тексте запроса
//                                             динамического списка, или добавляемых при модификации запроса.
//  ИмяПараметра              - Строка       - Имя параметра.
//  ОписаниеТипа              - ОписаниеТипа - Описание типа параметра.
//  Представление             - Строка       - Представление для вывода на форму.
//  ИмяМодификации            - Строка       - Имя модификации запроса после которой возможно использование
//                                             этого параметра отбора.
//
Процедура ДобавитьПараметрОтбора(СтруктураПараметровОтбора, ИмяПараметра, ОписаниеТипа,	Представление = Неопределено,
	ИмяМодификации = "") Экспорт
	
	ОписаниеПараметра = Новый Структура;
	ОписаниеПараметра.Вставить("ТипПараметра", ОписаниеТипа);
	ОписаниеПараметра.Вставить("ПредставлениеПараметра", ?(Представление = Неопределено, ИмяПараметра, Представление));
	
	ЗарплатаКадрыВнутренний.ДополнитьОписаниеМодифицирующегоПараметраОтбора(
		ИмяПараметра, ОписаниеПараметра, ИмяМодификации);
	
	СтруктураПараметровОтбора.Вставить(ИмяПараметра, ОписаниеПараметра);
	
КонецПроцедуры

// Создает элементы формы для группы настроек отбора.
//		СписокНастройкиОтбораНадпись
//		НаименованиеРеквизитаФормыДинамическийСписок
//		ПараметрыКритерияОтбора
//
// Параметры:
//		Форма - Форма, где располагается динамический список
//		НаименованиеРеквизитаСписок - Наименование реквизита формы "Динамический список"
//		ГруппаНастроек - Наименование группы, где будут отображаться недоступные пользователю настройки отбора в динамическом списке
//		ПараметрыКритерияОтбора - структура имен параметров, указанных в тексте запроса динамического списка,
//									элементы для заполнения параметров будут выведены на форму
//									Ключ - имя параметра, Значение - описание типов параметра
//		ГруппаПараметровКритерияОтбора - Наименование группы, где будут выведены параметры критериев отбора
//		ИсключаемыеИменаОтборов - Строка - Имена отборов, исключаемых из надписи, разделенные запятой
//		ЗаполнятьПользовательскийОтборПоОрганизации - Булево - Если Истина, то пользовательский отбор по организации будет заполнен организацией по умолчанию.
//
Процедура ПриСозданииНаСервереФормыСДинамическимСписком(Форма, НаименованиеРеквизитаСписок, ГруппаНастроек = "СписокНастройкиОтбора",
	ПараметрыКритерияОтбора = Неопределено, ГруппаПараметровКритерияОтбора = Неопределено, ИсключаемыеИменаОтборов = "", ЗаполнятьПользовательскийОтборПоОрганизации = Истина) Экспорт
	
	Элементы = Форма.Элементы;
	ГруппаНастроек = Элементы[ГруппаНастроек];
	Список = Форма[НаименованиеРеквизитаСписок];
	
	ДобавляемыеРеквизиты = Новый Массив;
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("СписокНастройкиОтбораНадпись", Новый ОписаниеТипов("Строка")));
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("НаименованиеРеквизитаФормыДинамическийСписок", Новый ОписаниеТипов("Строка")));
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("СинонимыЭлементовОтбора", Новый ОписаниеТипов("СписокЗначений")));
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИспользоватьНесколькоОрганизацийЗарплатаКадрыБазовая", Новый ОписаниеТипов("Булево")));
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИсключаемыеИменаОтборов", Новый ОписаниеТипов("Строка")));
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ЗаполнятьПользовательскийОтборПоОрганизации", Новый ОписаниеТипов("Булево")));
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИмяПоляОрганизация", Новый ОписаниеТипов("Строка")));
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИспользоватьКритерийОтбора", Новый ОписаниеТипов("Булево")));
	
	ТипОбъекта = ТипЗнч(ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(Форма.ИмяФормы));
	МетаданныеОбъекта = Метаданные.НайтиПоТипу(ТипОбъекта);
	ЭтоЖурналДокументов = ОбщегоНазначения.ЭтоЖурналДокументов(МетаданныеОбъекта);
	
	Если ЭтоЖурналДокументов Тогда
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ТипыОбъектовОповещения", Новый ОписаниеТипов("СписокЗначений")));
	КонецЕсли;
	
	Если ПараметрыКритерияОтбора <> Неопределено Тогда
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ПараметрыКритерияОтбора", Новый ОписаниеТипов("ТаблицаЗначений")));
		
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИмяПараметра", Новый ОписаниеТипов("Строка"), "ПараметрыКритерияОтбора"));
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ПредставлениеПараметра", Новый ОписаниеТипов("Строка"), "ПараметрыКритерияОтбора"));
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ТипПараметра", Новый ОписаниеТипов("ОписаниеТипов"), "ПараметрыКритерияОтбора"));
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИмяРеквизитаФормыПараметра", Новый ОписаниеТипов("Строка"), "ПараметрыКритерияОтбора"));
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИмяРеквизитаФормыПараметраИспользование", Новый ОписаниеТипов("Строка"), "ПараметрыКритерияОтбора"));
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИмяЭлементаФормыПараметра", Новый ОписаниеТипов("Строка"), "ПараметрыКритерияОтбора"));
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИмяЭлементаФормыПараметраИспользование", Новый ОписаниеТипов("Строка"), "ПараметрыКритерияОтбора"));
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИмяМодификации", Новый ОписаниеТипов("Строка"), "ПараметрыКритерияОтбора"));
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ПараметрыМодификации", Новый ОписаниеТипов(), "ПараметрыКритерияОтбора"));
		
		ТаблицаПараметрыКритериевОтбора = Новый ТаблицаЗначений;
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ИмяПараметра", Новый ОписаниеТипов("Строка"));
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ПредставлениеПараметра", Новый ОписаниеТипов("Строка"));
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ТипПараметра", Новый ОписаниеТипов("ОписаниеТипов"));
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ИмяРеквизитаФормыПараметра", Новый ОписаниеТипов("Строка"));
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ИмяРеквизитаФормыПараметраИспользование", Новый ОписаниеТипов("Строка"));
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ИмяЭлементаФормыПараметра", Новый ОписаниеТипов("Строка"));
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ИмяЭлементаФормыПараметраИспользование", Новый ОписаниеТипов("Строка"));
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ИмяМодификации", Новый ОписаниеТипов("Строка"));
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ПараметрыМодификации", Новый ОписаниеТипов());
		
		Для каждого ПараметрКритерияОтбора Из ПараметрыКритерияОтбора Цикл
			
			ИдПараметра = СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "x");
			
			ОписаниеПараметра = ПараметрКритерияОтбора.Значение;
			ИмяРеквизитаФормы = ПараметрКритерияОтбора.Ключ + "_" + ИдПараметра;
			ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(ИмяРеквизитаФормы, ОписаниеПараметра.ТипПараметра));
			
			НоваяСтрокаПараметра = ТаблицаПараметрыКритериевОтбора.Добавить();
			НоваяСтрокаПараметра.ПредставлениеПараметра = ОписаниеПараметра.ПредставлениеПараметра;
			НоваяСтрокаПараметра.ИмяПараметра = ПараметрКритерияОтбора.Ключ;
			НоваяСтрокаПараметра.ТипПараметра = ОписаниеПараметра.ТипПараметра;
			НоваяСтрокаПараметра.ИмяРеквизитаФормыПараметра = ИмяРеквизитаФормы;
			
			ОписаниеПараметра.Свойство("ИмяМодификации", НоваяСтрокаПараметра.ИмяМодификации);
			
			ИмяРеквизитаФормы = ПараметрКритерияОтбора.Ключ + "_Использование_" + ИдПараметра;
			ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(ИмяРеквизитаФормы, Новый ОписаниеТипов("Булево")));
			
			НоваяСтрокаПараметра.ИмяРеквизитаФормыПараметраИспользование = ИмяРеквизитаФормы;
		КонецЦикла;
	КонецЕсли;
	
	МассивИменРеквизитовФормы = Новый Массив;
	ЗаполнитьМассивИменРеквизитовФормы(Форма, МассивИменРеквизитовФормы);
	ИзменитьРеквизитыФормы(Форма, ДобавляемыеРеквизиты, МассивИменРеквизитовФормы);
	
	// Надпись отборов, не доступных пользователю
	Если Элементы.Найти("СписокНастройкиОтбораНадпись") = Неопределено Тогда
		Элемент = Элементы.Добавить("СписокНастройкиОтбораНадпись", Тип("ПолеФормы"), ГруппаНастроек);
		Элемент.ПутьКДанным = "СписокНастройкиОтбораНадпись";
		Элемент.Вид = ВидПоляФормы.ПолеНадписи;
		Элемент.ПоложениеЗаголовка = ПоложениеЗаголовкаЭлементаФормы.Нет;
		Элемент.ЦветТекста = ЦветаСтиля.ПоясняющийТекст;
		Элемент.ЦветФона = ЦветаСтиля.ЦветФонаПодсказки;
		Элемент.АвтоМаксимальнаяШирина = Ложь;
	КонецЕсли;
	
	Если ЭтоЖурналДокументов Тогда
		Для Каждого РегистрируемыйДокумент Из МетаданныеОбъекта.РегистрируемыеДокументы Цикл
			Форма.ТипыОбъектовОповещения.Добавить(
				ТипЗнч(ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(РегистрируемыйДокумент.ПолноеИмя()).ПустаяСсылка()));
		КонецЦикла;
	КонецЕсли;
	
	Если ПараметрыКритерияОтбора <> Неопределено И ГруппаПараметровКритерияОтбора <> Неопределено Тогда
		
		ГруппаПараметровКритерияОтбора = Элементы[ГруппаПараметровКритерияОтбора];
		ГруппаПараметровКритерияОтбора.Группировка = ГруппировкаПодчиненныхЭлементовФормы.Горизонтальная;
		ЛеваяГруппаПараметров = Неопределено;
		ПраваяГруппаПараметров = Неопределено;
		НомерПараметра = 0;
		Для каждого ПараметрКритерияОтбора Из ПараметрыКритерияОтбора Цикл
			НомерПараметра = НомерПараметра + 1;
			Если НомерПараметра/2 = Цел(НомерПараметра/2) Тогда
				Если ПраваяГруппаПараметров = Неопределено Тогда
					ИмяГруппы = "ПраваяГруппаПараметров" + "_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "x");
					ПраваяГруппаПараметров = Элементы.Добавить(ИмяГруппы, Тип("ГруппаФормы"), ГруппаПараметровКритерияОтбора);
					ПраваяГруппаПараметров.Вид = ВидГруппыФормы.ОбычнаяГруппа;
					ПраваяГруппаПараметров.Отображение = ОтображениеОбычнойГруппы.Нет;
					ПраваяГруппаПараметров.Заголовок = НСтр("ru = 'Правая группа'");
					ПраваяГруппаПараметров.ОтображатьЗаголовок = Ложь;
					ПраваяГруппаПараметров.Группировка = ГруппировкаПодчиненныхЭлементовФормы.Вертикальная;
				КонецЕсли;
				ГруппаТекущегоПараметра = ПраваяГруппаПараметров;
			Иначе
				Если ЛеваяГруппаПараметров = Неопределено Тогда
					ИмяГруппы = "ЛеваяГруппаПараметров" + "_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "x");
					ЛеваяГруппаПараметров = Элементы.Добавить(ИмяГруппы, Тип("ГруппаФормы"), ГруппаПараметровКритерияОтбора);
					ЛеваяГруппаПараметров.Вид = ВидГруппыФормы.ОбычнаяГруппа;
					ЛеваяГруппаПараметров.Отображение = ОтображениеОбычнойГруппы.Нет;
					ЛеваяГруппаПараметров.Заголовок = НСтр("ru = 'Левая группа'");
					ЛеваяГруппаПараметров.ОтображатьЗаголовок = Ложь;
					ЛеваяГруппаПараметров.Группировка = ГруппировкаПодчиненныхЭлементовФормы.Вертикальная;
				КонецЕсли;
				ГруппаТекущегоПараметра = ЛеваяГруппаПараметров;
			КонецЕсли;
			
			ИдПараметра = СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "x");
			ОписаниеПараметра = ПараметрКритерияОтбора.Значение;
			
			ИмяГруппы = "ГруппаПараметра" + "_" + ИдПараметра;
			ГруппаТекущегоПараметра = Элементы.Добавить(ИмяГруппы, Тип("ГруппаФормы"), ГруппаТекущегоПараметра);
			ГруппаТекущегоПараметра.Вид = ВидГруппыФормы.ОбычнаяГруппа;
			ГруппаТекущегоПараметра.Отображение = ОтображениеОбычнойГруппы.Нет;
			ГруппаТекущегоПараметра.Заголовок = ОписаниеПараметра.ПредставлениеПараметра;
			ГруппаТекущегоПараметра.ОтображатьЗаголовок = Ложь;
			ГруппаТекущегоПараметра.Группировка = ГруппировкаПодчиненныхЭлементовФормы.Горизонтальная;
			
			ИмяЭлементаФормы = ПараметрКритерияОтбора.Ключ + "_Использование_" + ИдПараметра;
			СтрокаПараметра = ТаблицаПараметрыКритериевОтбора.Найти(ПараметрКритерияОтбора.Ключ, "ИмяПараметра");
			СтрокаПараметра.ИмяЭлементаФормыПараметраИспользование = ИмяЭлементаФормы;
			Элемент = Элементы.Добавить(ИмяЭлементаФормы, Тип("ПолеФормы"), ГруппаТекущегоПараметра);
			Элемент.ПутьКДанным = СтрокаПараметра.ИмяРеквизитаФормыПараметраИспользование;
			Элемент.Вид = ВидПоляФормы.ПолеФлажка;
			Элемент.Заголовок = ОписаниеПараметра.ПредставлениеПараметра;
			Элемент.УстановитьДействие("ПриИзменении", "Подключаемый_ПараметрОтбораПриИзменении");
			
			ИмяЭлементаФормы = ПараметрКритерияОтбора.Ключ + "_" + ИдПараметра;
			СтрокаПараметра.ИмяЭлементаФормыПараметра = ИмяЭлементаФормы;
			Элемент = Элементы.Добавить(ИмяЭлементаФормы, Тип("ПолеФормы"), ГруппаТекущегоПараметра);
			Элемент.ПутьКДанным = СтрокаПараметра.ИмяРеквизитаФормыПараметра;
			Элемент.Вид = ВидПоляФормы.ПолеВвода;
			Элемент.РастягиватьПоГоризонтали = Истина;
			Элемент.Заголовок = НСтр("ru = 'Значение'");
			Элемент.ПоложениеЗаголовка = ПоложениеЗаголовкаЭлементаФормы.Нет;
			Элемент.УстановитьДействие("ПриИзменении", "Подключаемый_ПараметрОтбораПриИзменении");
			
			ЗарплатаКадрыВнутренний.НастроитьМодифицирующийПараметрОтбора(СтрокаПараметра, Список, МетаданныеОбъекта, Элементы);

		КонецЦикла;
	КонецЕсли;
	
	Форма.НаименованиеРеквизитаФормыДинамическийСписок = НаименованиеРеквизитаСписок;
	Если ПараметрыКритерияОтбора <> Неопределено Тогда
		Форма.ИспользоватьКритерийОтбора = Истина;
		ОбщегоНазначенияКлиентСервер.ДополнитьТаблицу(ТаблицаПараметрыКритериевОтбора, Форма.ПараметрыКритерияОтбора);
	КонецЕсли;
	
	// Заполним синонимы элементов отбора по пути к данным элементов формы
	Для каждого ЭлементФормы Из Элементы Цикл
		Если ТипЗнч(ЭлементФормы) <> Тип("ПолеФормы") Тогда
			Продолжить;
		КонецЕсли;
		Форма.СинонимыЭлементовОтбора.Добавить(ЭлементФормы.ПутьКДанным, ЭлементФормы.Заголовок);
	КонецЦикла;
	
	// Заполним синонимы элементов отбора по реквизитам объекта
	Коллекция = ?(ЭтоЖурналДокументов, МетаданныеОбъекта.Графы, МетаданныеОбъекта.Реквизиты);
	
	Для каждого ЭлементКоллекции Из Коллекция Цикл
		Форма.СинонимыЭлементовОтбора.Добавить(ЭлементКоллекции.Имя, ЭлементКоллекции.Синоним);
	КонецЦикла;
	
	// Заполним синонимы элементов отбора по стандартным реквизитам объекта
	Для каждого ЭлементКоллекции Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		Форма.СинонимыЭлементовОтбора.Добавить(ЭлементКоллекции.Имя, ЭлементКоллекции.Синоним);
	КонецЦикла;
	
	Форма.ИспользоватьНесколькоОрганизацийЗарплатаКадрыБазовая = ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоОрганизацийЗарплатаКадрыБазовая");
	Форма.ИсключаемыеИменаОтборов = ИсключаемыеИменаОтборов;
	Форма.ЗаполнятьПользовательскийОтборПоОрганизации = ЗаполнятьПользовательскийОтборПоОрганизации;
	
	// По умолчанию добавим в пользовательские настройки отбор по организации
	КоллекцияОтборов = ЗарплатаКадрыКлиентСервер.ФиксированныйОтборДинамическогоСписка(Форма, Список);
	ДобавитьПользовательскийОтборПоОрганизацииВДинамическийСписок(Форма, Список.КомпоновщикНастроек.ПользовательскиеНастройки, КоллекцияОтборов);
	
	// Обновим надпись фиксированных настроек отбора
	ЗарплатаКадрыКлиентСервер.ОбновитьНадписьФиксированногоОтбора(Форма);
	
КонецПроцедуры

// Проверяет настройку пользовательских отборов, если она не удовлетворяет фиксированному отбору динамического списка,
// то неправильные элементы пользовательского отбора удаляются.
//
// Параметры:
//		Форма - форма с динамическим списком
//		Настройки - Пользовательские настройки динамического списка
//		ПользовательскиеНастройкиПередЗагрузкой - Пользовательские настройки динамического списка, если вызов метода производится
//								из обработчика ПередЗагрузкойПользовательскихНастроекНаСервере элемента динамического списка.
//
Процедура ПроверитьПользовательскиеНастройкиДинамическогоСписка(Форма, ПользовательскиеНастройкиПередЗагрузкой = Неопределено, СтандартнаяОбработка = Истина) Экспорт
	
	Список = Форма[Форма.НаименованиеРеквизитаФормыДинамическийСписок];
	Настройки = Список.КомпоновщикНастроек.ПользовательскиеНастройки;
	
	КоллекцияОтборов = ЗарплатаКадрыКлиентСервер.ФиксированныйОтборДинамическогоСписка(Форма, Список);
	
	Для каждого НастройкаКомпоновщика Из Настройки.Элементы Цикл
		
		Если ТипЗнч(НастройкаКомпоновщика) = Тип("ОтборКомпоновкиДанных") Тогда
			
			ДобавитьПользовательскийОтборПоОрганизацииВДинамическийСписок(Форма, Настройки, КоллекцияОтборов);
			
			УдаляемыеЭлементы = Новый Массив;
			Для каждого ЭлементОтбора Из НастройкаКомпоновщика.Элементы Цикл
				
				Если ПользовательскиеНастройкиПередЗагрузкой <> Неопределено
					И Форма.ЗаполнятьПользовательскийОтборПоОрганизации
					И ТипЗнч(ЭлементОтбора) <> Тип("ГруппаЭлементовОтбораКомпоновкиДанных")
					И ТипЗнч(ЭлементОтбора.ПравоеЗначение) = Тип("СправочникСсылка.Организации") Тогда
					СтруктураЗначений = Новый Структура("Организация");
					ПолучитьЗначенияПоУмолчанию(СтруктураЗначений);
					ОрганизацияПоУмолчанию = Неопределено;
					СтруктураЗначений.Свойство("Организация", ОрганизацияПоУмолчанию);
					Если ЗначениеЗаполнено(ОрганизацияПоУмолчанию) Тогда
						// Подменим на организацию по умолчанию, т.к. это открытие формы
						ЭлементОтбора.ПравоеЗначение = ОрганизацияПоУмолчанию;
					КонецЕсли;
					Для каждого НастройкаКомпоновщикаПользовательскихНастроекПередЗагрузкой Из ПользовательскиеНастройкиПередЗагрузкой.Элементы Цикл
						Если ТипЗнч(НастройкаКомпоновщикаПользовательскихНастроекПередЗагрузкой) = Тип("ОтборКомпоновкиДанных") Тогда
							Для каждого ЭлементОтбораПользовательскихНастроекПередЗагрузкой Из НастройкаКомпоновщикаПользовательскихНастроекПередЗагрузкой.Элементы Цикл
								Если ТипЗнч(ЭлементОтбораПользовательскихНастроекПередЗагрузкой) <> Тип("ГруппаЭлементовОтбораКомпоновкиДанных")
									И ТипЗнч(ЭлементОтбораПользовательскихНастроекПередЗагрузкой.ПравоеЗначение) = Тип("СправочникСсылка.Организации") Тогда
									Если ЗначениеЗаполнено(ОрганизацияПоУмолчанию) Тогда
										// Подменим на организацию по умолчанию, т.к. это открытие формы
										ЭлементОтбораПользовательскихНастроекПередЗагрузкой.ПравоеЗначение = ОрганизацияПоУмолчанию;
									КонецЕсли;
								КонецЕсли;
							КонецЦикла;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
					ОтборПоиска = ЭлементОтбора.Представление;
				Иначе
					ОтборПоиска = ЭлементОтбора.ЛевоеЗначение;
				КонецЕсли;
				ЭлементФиксированногоОтбора = КоллекцияОтборов.Получить(ОтборПоиска);
				Если ЭлементФиксированногоОтбора <> Неопределено Тогда
					Если ЭлементФиксированногоОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
						УдаляемыеЭлементы.Добавить(ЭлементОтбора);
					ИначеЕсли ТипЗнч(ЭлементОтбора) <> Тип("ГруппаЭлементовОтбораКомпоновкиДанных")
						И ЭлементОтбора.ПравоеЗначение <> ЭлементФиксированногоОтбора.ПравоеЗначение Тогда
						ЭлементОтбора.ПравоеЗначение = ЭлементФиксированногоОтбора.ПравоеЗначение;
					КонецЕсли;
				КонецЕсли;
				
			КонецЦикла;
			
			Для каждого ЭлементОтбора Из УдаляемыеЭлементы Цикл
				НастройкаКомпоновщика.Элементы.Удалить(ЭлементОтбора);
			КонецЦикла;
			
		ИначеЕсли ТипЗнч(НастройкаКомпоновщика) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			ОтборПоиска = Новый ПолеКомпоновкиДанных(НастройкаКомпоновщика.ИдентификаторПользовательскойНастройки);
			ЭлементФиксированногоОтбора = КоллекцияОтборов.Получить(ОтборПоиска);
			Если ЭлементФиксированногоОтбора <> Неопределено Тогда
				Если ЭлементФиксированногоОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
					Настройки.Элементы.Удалить(НастройкаКомпоновщика)
				ИначеЕсли НастройкаКомпоновщика.ПравоеЗначение <> ЭлементФиксированногоОтбора.ПравоеЗначение Тогда
					НастройкаКомпоновщика.ПравоеЗначение = ЭлементФиксированногоОтбора.ПравоеЗначение;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ПользовательскиеНастройкиПередЗагрузкой = Неопределено Тогда
		// Если это не загрузка пользовательских настроек, то создадим элементы формы пользовательских настроек и доработаем их.
		СтандартнаяОбработка = Ложь;
		
		ГруппаПользовательскихНастроек = Форма.Элементы.СписокКомпоновщикНастроекПользовательскиеНастройки;
		Форма.Элементы[Форма.НаименованиеРеквизитаФормыДинамическийСписок].СоздатьЭлементыФормыПользовательскихНастроек(ГруппаПользовательскихНастроек);
		УстановитьШиринуЭлементовОтбораДинамическогоСписка(ГруппаПользовательскихНастроек);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура УстановитьШиринуЭлементовОтбораДинамическогоСписка(ГруппаНастроек)
	
	Для Каждого ЭлементФормы Из ГруппаНастроек.ПодчиненныеЭлементы Цикл
		Если ТипЗнч(ЭлементФормы) = Тип("ГруппаФормы") Тогда
			УстановитьШиринуЭлементовОтбораДинамическогоСписка(ЭлементФормы);
		ИначеЕсли ТипЗнч(ЭлементФормы) = Тип("ПолеФормы") И ЭлементФормы.Вид = ВидПоляФормы.ПолеВвода Тогда
			ЭлементФормы.АвтоМаксимальнаяШирина = Истина;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьПользовательскийОтборПоОрганизацииВДинамическийСписок(Форма, ПользовательскиеНастройки, ФиксированныеОтборы)
	
	ИспользоватьНесколькоОрганизаций = ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоОрганизацийЗарплатаКадрыБазовая");
	
	ИменаИсключаемыхОтборов = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрЗаменить(Форма.ИсключаемыеИменаОтборов, " ",""), ",");
	Для каждого НастройкаКомпоновщика Из ПользовательскиеНастройки.Элементы Цикл
		Если ТипЗнч(НастройкаКомпоновщика) = Тип("ОтборКомпоновкиДанных") Тогда
			Если НастройкаКомпоновщика.ДоступныеПоляОтбора = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ДоступноеПолеВыбораОрганизация = НастройкаКомпоновщика.ДоступныеПоляОтбора.Элементы.Найти("Организация");
			Если ДоступноеПолеВыбораОрганизация = Неопределено Тогда
				ДоступноеПолеВыбораОрганизация = НастройкаКомпоновщика.ДоступныеПоляОтбора.Элементы.Найти("Владелец");
				Если ДоступноеПолеВыбораОрганизация = Неопределено
					Или ДоступноеПолеВыбораОрганизация.Тип <> Новый ОписаниеТипов("СправочникСсылка.Организации") Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			Если ИменаИсключаемыхОтборов.Найти(Строка(ДоступноеПолеВыбораОрганизация.Поле)) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			НайденОтборПоОрганизации = Ложь;
			Для каждого ЭлементОтбора Из НастройкаКомпоновщика.Элементы Цикл
				Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
					Продолжить;
				КонецЕсли;
				Если ЭлементОтбора.ЛевоеЗначение = ДоступноеПолеВыбораОрганизация.Поле Тогда
					НайденОтборПоОрганизации = Истина;
					Если ЭлементОтбора.ПравоеЗначение = Неопределено Тогда
						ЭлементОтбора.ПравоеЗначение = Справочники.Организации.ПустаяСсылка();
					КонецЕсли;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не НайденОтборПоОрганизации Тогда
				Если ФиксированныеОтборы.Получить(ДоступноеПолеВыбораОрганизация.Поле) <> Неопределено Тогда
					НайденОтборПоОрганизации = Истина;
				КонецЕсли;
			КонецЕсли;
			Если Не НайденОтборПоОрганизации Тогда
				ОрганизацияПоУмолчанию = Справочники.Организации.ПустаяСсылка();
				Если Форма.ЗаполнятьПользовательскийОтборПоОрганизации Тогда
					СтруктураЗначений = Новый Структура("Организация");
					ПолучитьЗначенияПоУмолчанию(СтруктураЗначений);
					СтруктураЗначений.Свойство("Организация", ОрганизацияПоУмолчанию);
				КонецЕсли;
				Форма.ИмяПоляОрганизация = Строка(ДоступноеПолеВыбораОрганизация.Поле);
				Если ИспользоватьНесколькоОрганизаций Тогда
					ОбщегоНазначенияКлиентСервер.УстановитьЭлементОтбора(
						НастройкаКомпоновщика,
						Форма.ИмяПоляОрганизация,
						ОрганизацияПоУмолчанию,
						ВидСравненияКомпоновкиДанных.Равно,
						,
						ЗначениеЗаполнено(ОрганизацияПоУмолчанию),
						РежимОтображенияЭлементаНастройкиКомпоновкиДанных.БыстрыйДоступ,
						Новый УникальныйИдентификатор);
				Иначе
					ОбщегоНазначенияКлиентСервер.УстановитьЭлементОтбораДинамическогоСписка(
						Форма[Форма.НаименованиеРеквизитаФормыДинамическийСписок],
						Форма.ИмяПоляОрганизация,
						ОрганизацияПоУмолчанию,
						ВидСравненияКомпоновкиДанных.Равно,
						,
						ЗначениеЗаполнено(ОрганизацияПоУмолчанию),
						РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный);
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Заполняет значения заполнения, передаваемые при создании нового документа из формы списка журнала
// В ЗначенияЗаполнения добавляется только единственный сотрудник, который соответствует отбору по физическому лицу и организации
// Перед вызовом метода для формы списка журнала должен быть вызван метод
// "ПриСозданииНаСервереФормыСДинамическимСписком", в который должны быть переданы параметры "ПараметрыКритерияОтбора" и
// "ГруппаПараметровКритерияОтбора".
//
// Параметры:
//		ПараметрыОткрытия - Структура - структура, в которую будут добавлены значения заполнения
//						ЗначенияЗаполнения - Структура
//							Организация - ссылка на организацию
//							Сотрудник - ссылка на сотрудника
//						ОписаниеФормы - Строка - полный путь к форме документа
//		ФизическоеЛицо - ссылка на физическое лицо для получения единственного сотрудника
//		ОрганизацияОтбора - ссылка на организацию для получения единственного сотрудника
//		ТипДокумента - тип создаваемого документа.
//
// Возвращаемое значение:
//		ЗначенияЗаполнения - Структура - содержит значения:
//			Сотрудник - Ссылка - Сотрудник, полученный по физическому лицу и организации, установленные в отборах на форме списка журнала.
//
Процедура ДинамическийСписокПередНачаломДобавления(ПараметрыОткрытия, ФизическоеЛицо, ОрганизацияОтбора, ТипДокумента, ИмяПоляСотрудник = "Сотрудник", ИмяПоляФизическоеЛицо = "ФизическоеЛицо") Экспорт
	
	Если ТипЗнч(ТипДокумента) = Тип("Строка") Тогда
		ПараметрыОткрытия.Вставить("ОписаниеФормы", ТипДокумента + ".ФормаОбъекта");
	Иначе
		МетаданныеДокумента = Метаданные.НайтиПоТипу(ТипДокумента);
		ПараметрыОткрытия.Вставить("ОписаниеФормы", МетаданныеДокумента.ПолноеИмя() + ".ФормаОбъекта");
	КонецЕсли;
	
	ЗначенияЗаполнения = Новый Структура;
	Если ЗначениеЗаполнено(ОрганизацияОтбора) Тогда
		ЗначенияЗаполнения.Вставить("Организация", ОрганизацияОтбора);
	КонецЕсли;
	Если ЗначениеЗаполнено(ФизическоеЛицо) Тогда
		Если Не ПустаяСтрока(ИмяПоляФизическоеЛицо) Тогда
			ЗначенияЗаполнения.Вставить(ИмяПоляФизическоеЛицо, ФизическоеЛицо);
		КонецЕсли;
		Если Не ЗначениеЗаполнено(ИмяПоляСотрудник) Тогда
			ПараметрыОткрытия.Вставить("ЗначенияЗаполнения", ЗначенияЗаполнения);
			Возврат;
		КонецЕсли;
		ПараметрыПолученияСотрудников = КадровыйУчет.ПараметрыПолученияСотрудниковОрганизацийПоСпискуФизическихЛиц();
		ПараметрыПолученияСотрудников.КадровыеДанные = "ОсновноеРабочееМестоВОрганизации,Организация";
		ПараметрыПолученияСотрудников.ОтбиратьПоГоловнойОрганизации = Истина;
		Если ЗначениеЗаполнено(ОрганизацияОтбора) Тогда
			ПараметрыПолученияСотрудников.Организация = ОрганизацияОтбора;
		КонецЕсли;
		ПараметрыПолученияСотрудников.ОкончаниеПериода = ТекущаяДатаСеанса();
		ПараметрыПолученияСотрудников.СписокФизическихЛиц = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ФизическоеЛицо);
		СотрудникиФизическихЛиц = КадровыйУчет.СотрудникиОрганизации(Истина, ПараметрыПолученияСотрудников);
		Для Каждого СтрокаСотрудникиФизическихЛиц Из СотрудникиФизическихЛиц Цикл
			Если СтрокаСотрудникиФизическихЛиц.ОсновноеРабочееМестоВОрганизации И Не ПустаяСтрока(ИмяПоляСотрудник)Тогда
				ЗначенияЗаполнения.Вставить(ИмяПоляСотрудник, СтрокаСотрудникиФизическихЛиц.Сотрудник);
				Если Не ЗначениеЗаполнено(ОрганизацияОтбора) Тогда
					ЗначенияЗаполнения.Вставить("Организация", СтрокаСотрудникиФизическихЛиц.Организация);
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	ПараметрыОткрытия.Вставить("ЗначенияЗаполнения", ЗначенияЗаполнения);
	
КонецПроцедуры

#КонецОбласти

#Область ФормированиеПечатныхФорм

// Возвращает настройки формирования печатных форм
// Возвращаемые значения кэшируется на время сеанса.
//
// Возвращаемое значение:
// 	ФиксированнаяСтруктура - см. РегистрыСведений.ДополнительныеНастройкиЗарплатаКадры.НастройкиПечатныхФорм()
//
Функция НастройкиПечатныхФорм() Экспорт
    Возврат ЗарплатаКадрыПовтИсп.НастройкиПечатныхФорм();
КонецФункции

// Выводит строки по данным заполнения в результирующий табличный документ, в количестве не превышающем
// "ОграничениеСтрок".
// Остальные строки выводятся в дополнительные страницы, которые помещаются в массив "ОбластиДополнительныхСтрок".
//
// Параметры:
//		ТабличныйДокумент - результирующий табличный документ.
//		ДанныеЗаполнения - коллекция с данными для заполнения строк, коллекция доступна для обхода циклом Для Каждого … Из
//		                   … Цикл.
//		ОграничениеСтрок - число, количество строк, размещаемых в основной области.
//		ОбластиДополнительныхСтрок - массив областей с дополнительными строками.
//		ОбластьШапка - область табличного документа для шапки.
//		ОбластьСтрока - область табличного документа для строки.
//		МассивОбластейЗаголовок - массив областей табличного документа для заголовка, выводятся по порядку.
//		МассивОбластейПодвал - массив областей табличного документа для подвала, выводятся по порядку.
//		ВыводитьСтрокиНаВсюСтраницу - Если Истина, то до конца дополнительной страницы будут выведены пустые строки.
//
Процедура СформироватьОбластьТабличногоДокументаСОграниченнымНаборомСтрок(ТабличныйДокумент, ДанныеЗаполнения, ОграничениеСтрок,
	ОбластиДополнительныхСтрок, ОбластьШапка, ОбластьСтрока, МассивОбластейЗаголовок = Неопределено, МассивОбластейПодвал = Неопределено,
	ВыводитьСтрокиНаВсюСтраницу = Ложь) Экспорт
	
	КоличествоВыведенныхСтрок = 0;
	ДополнительнаяСтраница = Новый ТабличныйДокумент;
	
	Для каждого СтрокаДанныхЗаполнения Из ДанныеЗаполнения Цикл
		
		КоличествоВыведенныхСтрок = КоличествоВыведенныхСтрок + 1;
		
		// Если выводимая строка помещается в основной табличный документ.
		Если КоличествоВыведенныхСтрок <= ОграничениеСтрок Тогда
			ОбластьСтрока.Параметры.Заполнить(СтрокаДанныхЗаполнения);
			ТабличныйДокумент.Вывести(ОбластьСтрока);
		КонецЕсли;
		
		// Если выводимая строка не помещается в основной табличный документ, то нужно вывести
		// заголовок и шапку для дополнительной страницы.
		Если КоличествоВыведенныхСтрок = ОграничениеСтрок + 1 Тогда
			
			// Если задан заголовок для дополнительной страницы - выведем его.
			Если МассивОбластейЗаголовок <> Неопределено Тогда
				СтруктураПараметров = Новый Структура("НомерПриложения", ОбластиДополнительныхСтрок.Количество() + 1);
				Для каждого ОбластьЗаголовок Из МассивОбластейЗаголовок Цикл
					ОбластьЗаголовок.Параметры.Заполнить(СтруктураПараметров);
					ДополнительнаяСтраница.Вывести(ОбластьЗаголовок);
				КонецЦикла;
			КонецЕсли;
			
			// Выводим шапку дополнительной страницы.
			ДополнительнаяСтраница.Вывести(ОбластьШапка);
			
			// Повторяем шапку на каждой странице при печати.
			ДополнительнаяСтраница.ПовторятьПриПечатиСтроки = ОбластьШапка;
			
		КонецЕсли;
		
		// Все строки, которые не поместились в основной табличный документ выводим в дополнительную страницу.
		Если КоличествоВыведенныхСтрок > ОграничениеСтрок Тогда
			ОбластьСтрока.Параметры.Заполнить(СтрокаДанныхЗаполнения);
			ДополнительнаяСтраница.Вывести(ОбластьСтрока);
		КонецЕсли;
		
	КонецЦикла;
	
	// Если создавали дополнительную страницу нужно вывести подвал и надпись о продолжении таблицы.
	Если КоличествоВыведенныхСтрок > ОграничениеСтрок Тогда
		
		// Выводим пустые строки до конца дополнительной страницы.
		Если ВыводитьСтрокиНаВсюСтраницу Тогда
			
			Для ПараметрОбласти = 0 По ОбластьСтрока.Параметры.Количество() -1 Цикл
				ОбластьСтрока.Параметры[ПараметрОбласти] = Неопределено;
			КонецЦикла;
			
			ВыводимыеОбласти = Новый Массив();
			ВыводимыеОбласти.Добавить(ОбластьСтрока);
			Если МассивОбластейПодвал <> Неопределено Тогда
				Для каждого ОбластьПодвал Из МассивОбластейПодвал Цикл
					ВыводимыеОбласти.Добавить(ОбластьПодвал);
				КонецЦикла;
			КонецЕсли;
			
			Пока ДополнительнаяСтраница.ПроверитьВывод(ВыводимыеОбласти) Цикл
				ДополнительнаяСтраница.Вывести(ОбластьСтрока);
			КонецЦикла;
			
		КонецЕсли;
		
		// Если задан подвал для дополнительной страницы - выведем его.
		Если МассивОбластейПодвал <> Неопределено Тогда
			Для каждого ОбластьПодвал Из МассивОбластейПодвал Цикл
				ДополнительнаяСтраница.Вывести(ОбластьПодвал);
			КонецЦикла;
		КонецЕсли;
		
		// Поместим созданную страницу в массив.
		ОбластиДополнительныхСтрок.Добавить(ДополнительнаяСтраница);
		
		// В основном табличном документе напишем, что есть дополнительная страница.
		ОбластьНадписи = ОбластьСтрока.Область(1,1, ОбластьСтрока.ВысотаТаблицы, ОбластьСтрока.ШиринаТаблицы);
		ОбластьНадписи.Объединить();
		ОбластьНадписи.Очистить(Истина, Истина, Истина);
		ТекстНадписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Продолжение таблицы см. в дополнении к документу №%1.'"),
				ОбластиДополнительныхСтрок.Количество());
		ОбластьНадписи.Текст = ТекстНадписи;
		ОбластьНадписи.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
		ОбластьНадписи.АвтовысотаСтроки = Истина;
		ТабличныйДокумент.Вывести(ОбластьСтрока);
		
	// В основном табличном документе выведем пустые строки до заданного количества "ОграничениеСтрок".
	ИначеЕсли КоличествоВыведенныхСтрок < ОграничениеСтрок Тогда
		
		Для ПараметрОбласти = 0 По ОбластьСтрока.Параметры.Количество() -1 Цикл
			ОбластьСтрока.Параметры[ПараметрОбласти] = Неопределено;
		КонецЦикла;
		
		Для Шаг = КоличествоВыведенныхСтрок + 1 По ОграничениеСтрок Цикл
			ТабличныйДокумент.Вывести(ОбластьСтрока);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Выводит дополнительные страницы в результирующий табличный документ.
//
// Параметры:
//		ТабличныйДокумент - результирующий табличный документ.
//		ОбластиДополнительныхСтрок - массив областей с дополнительными строками.
//
Процедура ВывестиОбластиТабличногоДокументаСОграниченнымНаборомСтрок(ТабличныйДокумент, ОбластиДополнительныхСтрок) Экспорт
	
	Для каждого ДополнительнаяСтраница Из ОбластиДополнительныхСтрок Цикл
		ТабличныйДокумент.ВывестиГоризонтальныйРазделительСтраниц();
		ТабличныйДокумент.Вывести(ДополнительнаяСтраница);
	КонецЦикла;
	
КонецПроцедуры

// Выводит данные побуквенно
// Параметры:
//			Данные - Строка, которую нужно вывести.
//			Раздел - Макет (область) табличного документа в которую нужно вывести.
//			ИмяПоказателя - Строка, имя ячейки в области к которой прибавляется номер позиции в имени показателя.
//			КоличествоЯчеек - Число, количество ячеек в которые нужно вывести данные.
//			НачальнаяЯчейка - Число, ячейка с которой нужно начать побуквенный вывод.
Процедура ВывестиДанныеПоБуквенно(Данные, Раздел, ИмяПоказателя, КоличествоЯчеек, НачальнаяЯчейка = 1) Экспорт

	Для НомерЯчейки = НачальнаяЯчейка По НачальнаяЯчейка + КоличествоЯчеек - 1 Цикл
		Раздел.Области[ИмяПоказателя + Формат(НомерЯчейки,"ЧГ=0")].Текст = Сред(Данные, НомерЯчейки - НачальнаяЯчейка + 1, 1);
	КонецЦикла;

КонецПроцедуры

// Разбивает строку (не разрывая слов) на подстроки указанной длинны, 
//							строки дополняются пробелами, переводы строк удаляются.
// Параметры:
//  ТекстСтроки  - Строка, которую необходимо разбить на подстроки.
//                 
//  МассивДлинСтрок  - Массив длин строк, если в результирующей строке оказалось подстрок больше.
//                     Чем количество указанных длин, то все "лишние" строки выравниваются по последнему
//                     значению длинны строки.
// Возвращаемое значение:
//   Строка   - разбитая на подстроки указанной длинны.
//
Функция РазбитьСтрокуНаПодСтроки(Знач ТекстСтроки, МассивДлинСтрок) Экспорт

	ВозвращаемаяСтрока = "";
	
	РазделителиСлов = " .,:;?!%\<>+-*/=_" + Символы.ПС;
	
	ТекстСтроки = СокрЛП(ТекстСтроки);
	
	// Обыграем случай, когда у нас многострочная строка.
	Если СтрЧислоСтрок(ТекстСтроки) > 1 Тогда
	
		Для НомерПодстроки = 1 По СтрЧислоСтрок(ТекстСтроки) Цикл
			
			НовыйМассивДлинСтроки = Новый Массив;
			
			Если НомерПодстроки = 1 Тогда
			
				НачальнаяГраница = 0;
			
			Иначе
				
				Если СтрЧислоСтрок(ВозвращаемаяСтрока) > МассивДлинСтрок.ВГраница() Тогда
				
					НачальнаяГраница = МассивДлинСтрок.ВГраница();
					
				Иначе
					
					НачальнаяГраница = СтрЧислоСтрок(ВозвращаемаяСтрока);
				
				КонецЕсли; 
			
			КонецЕсли; 
			
			Для ИндексСтроки = НачальнаяГраница По МассивДлинСтрок.ВГраница() Цикл
			
				НовыйМассивДлинСтроки.Добавить(МассивДлинСтрок[ИндексСтроки]);
			
			КонецЦикла; 
		
			ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + РазбитьСтрокуНаПодСтроки(СтрПолучитьСтроку(ТекстСтроки, НомерПодстроки), НовыйМассивДлинСтроки);
		
		КонецЦикла; 
		
	Иначе
		
		ДлинаСтроки = МассивДлинСтрок[0];
		
		// Если длина строки меньше или равна нужной длине - просто вернем ее.
		Если СтрДлина(ТекстСтроки) <= ДлинаСтроки Тогда
		
			ВозвращаемаяСтрока = ТекстСтроки; 
			
		Иначе
			
			// Заменим все разделители символом _, для удобства анализа.
			ТестируемаяСтрока = ТекстСтроки;
			
			Для НомерРазделителя = 1 По СтрДлина(РазделителиСлов)  Цикл
				
				РазделительСлов = Сред(РазделителиСлов, НомерРазделителя, 1);
				
				ТестируемаяСтрока = СтрЗаменить(ТестируемаяСтрока, РазделительСлов, "_");
			
			КонецЦикла; 
			
			// Найдем первый разделитель
			Разрыв = СтрНайти(ТестируемаяСтрока, "_");
			
			ИндексМассиваДлинСтрок = 0;
			
			// Обрабатываем строку пока она не закончится.
			Пока СтрДлина(ТекстСтроки) > 0 Цикл
				
				Если ИндексМассиваДлинСтрок <= МассивДлинСтрок.ВГраница() Тогда
				
					ДлинаСтроки = МассивДлинСтрок[ИндексМассиваДлинСтрок];
				
				Иначе
				
					ДлинаСтроки = МассивДлинСтрок[МассивДлинСтрок.ВГраница()];
				
				КонецЕсли; 
				
				// Если разрыв больше чем нужная длина
				// если разрывов больше нет
				// и частный случай, когда есть разрыв - пробел в самом конце строки нужной длины
				// или длина оставшейся строки меньше или равна нужной длине.
				Если Разрыв >= ДлинаСтроки ИЛИ Разрыв = 0 ИЛИ Сред(ТекстСтроки, ДлинаСтроки + 1, 1) = " " ИЛИ СтрДлина(ТекстСтроки) <= ДлинаСтроки Тогда
				
					ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + СокрЛП(Лев(ТекстСтроки, ДлинаСтроки));
					
					ТекстСтроки = СокрЛП(Сред(ТекстСтроки, ДлинаСтроки + 1));
					
					ТестируемаяСтрока = Сред(ТестируемаяСтрока, ДлинаСтроки + 1);
					
					Если Лев(ТестируемаяСтрока,1) = "_" Тогда
					
						ТестируемаяСтрока = Сред(ТестируемаяСтрока, 2);
					
					КонецЕсли; 
					
					ИндексМассиваДлинСтрок = ИндексМассиваДлинСтрок + 1;
					
					Разрыв = СтрНайти(ТестируемаяСтрока, "_");
				
				Иначе 
					
					НовыйРазрыв = СтрНайти(Сред(ТестируемаяСтрока, Разрыв + 1), "_");
					
					// Есть еще один разрыв и он вместе с предыдущим меньше или равен длине строки.
					Если НовыйРазрыв > 0 И Разрыв + НовыйРазрыв <= ДлинаСтроки Тогда
						
						Разрыв = Разрыв + НовыйРазрыв;
						
					Иначе
						
						// Больше разрывов нет
						// или он вместе с предыдущим больше нужной длины.
						ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + СокрЛП(Лев(ТекстСтроки, Разрыв));
						
						ТекстСтроки = СокрЛП(Сред(ТекстСтроки, Разрыв + 1));
						
						ТестируемаяСтрока = Сред(ТестируемаяСтрока, Разрыв + 1);
						
						Если Лев(ТестируемаяСтрока,1) = "_" Тогда
					
							ТестируемаяСтрока = Сред(ТестируемаяСтрока, 2);
					
						КонецЕсли; 
					
						ИндексМассиваДлинСтрок = ИндексМассиваДлинСтрок + 1;
					
						Разрыв = СтрНайти(ТестируемаяСтрока, "_");
						
					КонецЕсли;
				
				КонецЕсли;
				
			КонецЦикла; 
				
		КонецЕсли; 
	
	КонецЕсли;
	
	Если СтрЧислоСтрок(ВозвращаемаяСтрока) > 1 Тогда
		
		ВыровненнаяСтрока = "";
		
		Для НомерПодстроки = 1 По СтрЧислоСтрок(ВозвращаемаяСтрока) - 1 Цикл
			
			ВыравниваемаяСтрока = СтрПолучитьСтроку(ВозвращаемаяСтрока, НомерПодстроки);
			
			Если НомерПодстроки - 1 <= МассивДлинСтрок.ВГраница() Тогда
				
				ДлинаСтроки = МассивДлинСтрок[НомерПодстроки - 1];
				
			Иначе
				
				ДлинаСтроки = МассивДлинСтрок[МассивДлинСтрок.ВГраница()];
				
			КонецЕсли; 
				
			Для НомерПозицииВСтроке = СтрДлина(ВыравниваемаяСтрока) + 1 По ДлинаСтроки Цикл
			
				ВыравниваемаяСтрока = ВыравниваемаяСтрока + " ";
			
			КонецЦикла; 
			
			ВыровненнаяСтрока = ВыровненнаяСтрока + ?(ПустаяСтрока(ВыровненнаяСтрока), "", Символы.ПС) + ВыравниваемаяСтрока;
		
		КонецЦикла;
		
		ВозвращаемаяСтрока = ВыровненнаяСтрока + Символы.ПС + СтрПолучитьСтроку(ВозвращаемаяСтрока, СтрЧислоСтрок(ВозвращаемаяСтрока));
		
	КонецЕсли; 
	
	ВозвращаемаяСтрока = СтрЗаменить(ВозвращаемаяСтрока, Символы.ПС, "");
	
	Возврат ВозвращаемаяСтрока;

КонецФункции // РазбитьСтрокуПоСтрочно()

// Выводит сумму в рублях и копейках в ячейки посимвольно.
// Параметры:
//			Данные - Строка, которую нужно вывести.
//			ТабличныйДокумент - Макет (область) табличного документа в которую нужно вывести.
//			ПрефиксЯчеек - Строка, имя ячейки в области к которой прибавляется номер позиции в имени показателя.
//			КоличествоЯчеек - Число, количество ячеек в которые нужно вывести данные.
Процедура ВывестиСуммуВРубляхКопейкахВЯчейки(Данные, ТабличныйДокумент, ПрефиксЯчеек, КоличествоЯчеек) Экспорт
	ВывестиДанныеПоБуквенно(Прав("                  " + Формат(Данные, "ЧЦ=" + (КоличествоЯчеек + 1) + "; ЧДЦ=0; ЧС=-2; ЧГ="), КоличествоЯчеек), ТабличныйДокумент, ПрефиксЯчеек, КоличествоЯчеек);
КонецПроцедуры

// Возвращает ответственных лиц организации.
//
// Параметры:
//		Организация - ссылка на организацию.
//		Сведения - строка с идентификаторами, разделенными запятыми.
//		ДатаСведений - дата получения сведений.
//
// Возвращаемое значение:
//		СтруктураДанных - структура со свойствами, совпадающими с параметром «Сведения».
//			Допустимые идентификаторы запрашиваемых значений:
//				Руководитель - руководитель организации.
//				ДолжностьРуководителя - должность руководителя.
//				ГлавныйБухгалтер - главбух организации.
//				Кассир - кассир организации.
//				ДолжностьКассира - должность кассира.
//
Функция ОтветственныеЛицаОрганизации(Организация, Сведения, ДатаСведений) Экспорт
	
	Возврат ЗарплатаКадрыВнутренний.ОтветственныеЛицаОрганизации(Организация, Сведения, ДатаСведений)
	
КонецФункции

// Предназначена для формирования типового текста сообщения о неприменимости
// печатной формы при выполнении требуемых условий.
//
// Параметры:
//  ДатаДокумента  - Дата - месяц формирования печатной формы.
//
//  ДатаВступленияВСилуНормативногоДокумента  - Дата - дата вступления в силу документа нормативного основания.
//
//  ВидНормативногоДокументаВРодительном  - Строка - вид документа нормативного основания - например
//								в связи с вступлением в силу "Приказа Минфина РФ" от 30.03.2015 № 52н.
//  ДатаНормативногоДокумента  - Дата - дата документа нормативного основания.
//
//  НомерНормативногоДокумента  - Строка - номер документа нормативного основания.
//
// Возвращаемое значение:
//   Строка   - Текст сообщения о неприменимости или пустая строка.
//
Функция СообщениеОНеприменимостиПечатнойФормы(ДатаДокумента,
			ДатаВступленияВСилуНормативногоДокумента,
			ВидНормативногоДокументаВРодительном,
			ДатаНормативногоДокумента,
			НомерНормативногоДокумента) Экспорт

	СообщениеОНеприменимости = "";
	
	ВыводитьСообщение = Ложь;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыПриложения.УчетБюджетныхУчреждений") Тогда
		
		Модуль = ОбщегоНазначения.ОбщийМодуль("УчетБюджетныхУчреждений");
		Модуль.УстановитьПараметрВыводитьСообщениеВУнифицированныхФормах(ВыводитьСообщение);
		
	КонецЕсли;
	
	Если ВыводитьСообщение И (ДатаДокумента > ДатаВступленияВСилуНормативногоДокумента) Тогда
	
		СообщениеОНеприменимости = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Не применяется с %1
			|в связи с вступлением в силу
			|%2 от %3 № %4'"),
			Формат(ДатаВступленияВСилуНормативногоДокумента, "ДЛФ=D"),
			ВидНормативногоДокументаВРодительном,
			Формат(ДатаНормативногоДокумента, "ДЛФ=D"),
			НомерНормативногоДокумента);
	
	КонецЕсли;
	
	Возврат СообщениеОНеприменимости;
	
КонецФункции

#КонецОбласти

#Область РаботаСВременнымиТаблицами

// Уничтожает указанные временные таблицы
// Параметры:
//	МенеджерВременныхТаблиц - МенеджерВременныхТаблиц
//	ИменаВТ                 - Массив, Строка - список уничтожаемых таблиц или имя одной таблицы
//	ПроверятьНаличие        - Булево - признак игнорирования отсутствия таблицы с указанным именем
//	                                   Истина - ничего не произойдет
//	                                   Ложь   - возникнет ошибка.
//
Процедура УничтожитьВТ(МенеджерВременныхТаблиц, Знач ИменаВТ, ПроверятьНаличие = Ложь) Экспорт
	
	// АПК:1297-выкл Не локализуется, все строки - части запросов или их параметры
	
	Если ТипЗнч(ИменаВТ) = Тип("Массив") Тогда
		УничтожаемыеВТ = ОбщегоНазначенияКлиентСервер.СвернутьМассив(ИменаВТ)
	Иначе	
		УничтожаемыеВТ = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(ИменаВТ);
	КонецЕсли;
	
	ЗапросыУничтожения = Новый Массив;
	Для Каждого ИмяВТ Из УничтожаемыеВТ Цикл
		Если ПроверятьНаличие И Не ВТСуществует(МенеджерВременныхТаблиц, ИмяВТ) Тогда
			Продолжить;
		КонецЕсли;
		ЗапросыУничтожения.Добавить(СтрШаблон("УНИЧТОЖИТЬ %1", ИмяВТ));
	КонецЦикла;
	
	Если ЗапросыУничтожения.Количество() = 0 Тогда
		Возврат
	КонецЕсли;	
	
	Запрос = Новый Запрос;
	Запрос.Текст = СтрСоединить(ЗапросыУничтожения, ЗарплатаКадрыОбщиеНаборыДанных.РазделительЗапросов());
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.Выполнить();
	
	// АПК:1297-вкл
	
КонецПроцедуры

// Возвращает умолчательное имя временной таблицы, соответствующей указанной таблице ИБ
// Параметры:
//	ПолноеИмяТаблицы - Строка
// Возвращаемое значение:
//	Строка
//
Функция ИмяВТПоУмолчанию(ПолноеИмяТаблицы) Экспорт
	Возврат "ВТ" + СтрЗаменить(ПолноеИмяТаблицы, ".", "_");
КонецФункции

// Создает пустую временную таблицу, совпадающую по структуре с указанной таблицей ИБ 
// Параметры:
//	МенеджерВременныхТаблиц - МенеджерВременныхТаблиц
//	ПолноеИмяТаблицы        - Строка
//	ИменаВТ                 - Строка - имя создаваемой временной таблицы
//                            Необязательное.
//                            Если не указано, ВТ будет иметь имя по умолчанию (см. ИмяВТПоУмолчанию).
//
Процедура СоздатьПустуюВТ(МенеджерВременныхТаблиц, ПолноеИмяТаблицы, ИмяВТ = Неопределено) Экспорт
	
	Если ИмяВТ = Неопределено Тогда
		ИмяВТ = ИмяВТПоУмолчанию(ПолноеИмяТаблицы);
	КонецЕсли;
	Если ВТСуществует(МенеджерВременныхТаблиц, ИмяВТ) Тогда
		Возврат;
	КонецЕсли;
	
	ТекстЗапроса = 
		"ВЫБРАТЬ ПЕРВЫЕ 0
		|	ИмяТаблицы.*
		|ПОМЕСТИТЬ ИмяВТ
		|ИЗ
		|	#ПолноеИмяТаблицы КАК ИмяТаблицы
		|ГДЕ
		|	ЛОЖЬ";
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ИмяВТ", ИмяВТ);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#ПолноеИмяТаблицы", ПолноеИмяТаблицы);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	
	УстановитьПривилегированныйРежим(Истина);
	Запрос.Выполнить();
	УстановитьПривилегированныйРежим(Ложь);
	
КонецПроцедуры

// Создает временную таблицу по переданному запросу (или структуре с текстом и параметрами).
//
// Параметры
//	МенеджерВременныхТаблиц - МенеджерВременныхТаблиц - Менеджер временных таблиц, в котором будет создана ВТ.
// 	                                                    Если в запросе указан менеджер временных таблиц, то они должны совпадать.
//	Запрос - Запрос, Структура - описание запроса к базе данных с полями:
//		* Текст     - Строка    - исходный текст выполняемого запроса.
//		* Параметры - Структура - значения параметров запроса.
//	ИмяВТ    - Строка - Имя временной таблицы, которая будет создана.
//	ИндексВТ - Строка - Поля, по которым будет индексироваться временная таблица.
//                      Соответствует выражению ИНДЕКСИРОВАТЬ ПО языка запросов.
//
Процедура СоздатьВТПоЗапросу(МенеджерВременныхТаблиц, Запрос, ИмяВТ, ИндексВТ = Неопределено) Экспорт
	
	Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Запрос, "МенеджерВременныхТаблиц") Тогда
		ОбщегоНазначенияКлиентСервер.Проверить(
			Запрос.МенеджерВременныхТаблиц = Неопределено 
				Или Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц, 
			НСтр("ru = 'Менеджер временных таблиц отличается от установленного в запросе'"),
			"ЗарплатаКадры.СоздатьВТПоЗапросу");
	КонецЕсли;
	
	Схема = Новый СхемаЗапроса;
	Схема.УстановитьТекстЗапроса(Запрос.Текст);
	
	// ищем последний запрос выбора
	ЗапросВыбора = Неопределено;
	Индекс = Схема.ПакетЗапросов.Количество()-1;
	Пока Индекс >= 0 Цикл
		Если ТипЗнч(Схема.ПакетЗапросов[Индекс]) = Тип("ЗапросВыбораСхемыЗапроса") Тогда
			ЗапросВыбора = Схема.ПакетЗапросов[Индекс];
			Прервать
		КонецЕсли;
		Индекс = Индекс - 1;
	КонецЦикла;	
	ОбщегоНазначенияКлиентСервер.Проверить(
		ЗапросВыбора <> Неопределено, 
		НСтр("ru = 'В запросе нет оператора ВЫБРАТЬ'"),
		"ЗарплатаКадры.СоздатьВТПоЗапросу");
		
	ЗапросВыбора.ТаблицаДляПомещения = ИмяВТ;
	Если ЗапросВыбора.Операторы[0].КоличествоПолучаемыхЗаписей <> Неопределено Тогда
		ЗапросВыбора.Порядок.Очистить();
	КонецЕсли;	
	Если ИндексВТ <> Неопределено Тогда
		ЗапросВыбора.Индекс.Добавить(ИндексВТ);
	КонецЕсли;	
	
	ЗапросСозданияВТ = Новый Запрос;
	ЗапросСозданияВТ.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	ЗапросСозданияВТ.Текст = Схема.ПолучитьТекстЗапроса();
	ОбщегоНазначенияКлиентСервер.ДополнитьСтруктуру(ЗапросСозданияВТ.Параметры, Запрос.Параметры);
	ЗапросСозданияВТ.Выполнить();
	
КонецПроцедуры

// Создает временную таблицу по таблице значений
//
// Параметры
//	МенеджерВременныхТаблиц
//	НаборЗаписей
//	Замещать - если Истина, то таблица будет создана вместо обнаруженной в менеджере ВТ с таким же именем, если Ложь, то будет объединена с ней.
//	ИмяВТ
//
Процедура СоздатьВТПоТаблицеЗначений(МенеджерВременныхТаблиц, ТаблицаЗначений, ИмяВТ, Замещать = Ложь) Экспорт
	
	ИменаКолонок = ОбщегоНазначения.ВыгрузитьКолонку(ТаблицаЗначений.Колонки, "Имя");
	СоздатьВТПоТаблицеИменамПолей(МенеджерВременныхТаблиц, ИмяВТ, ТаблицаЗначений, ИменаКолонок, Замещать);
	
КонецПроцедуры

// Создает временную таблицу по набору записей
//
// Параметры
//	МенеджерВременныхТаблиц - МенеджерВременныхТаблиц
//	НаборЗаписей            - РегистрСведенийНаборЗаписей, РегистрНакопленияНаборЗаписей
//	Замещать                - Булево - если Истина, то таблица будет создана вместо обнаруженной в менеджере ВТ с таким же именем, 
//                                     если Ложь, то будет объединена с ней.
//	ИмяВТ                   - Строка
//
Процедура СоздатьВТПоНаборуЗаписей(МенеджерВременныхТаблиц, НаборЗаписей, Замещать = Ложь, ИмяВТ = Неопределено) Экспорт
	
	МетаданныеНабора = НаборЗаписей.Метаданные();
	
	Если ИмяВТ = Неопределено Тогда
		ИмяВТ = ИмяВТПоУмолчанию(МетаданныеНабора.ПолноеИмя());
	КонецЕсли;
	
	Если НаборЗаписей.Количество() = 0 Тогда
		Если Замещать Тогда
			УничтожитьВТ(МенеджерВременныхТаблиц, ИмяВТ, Истина);
		КонецЕсли;
		СоздатьПустуюВТ(МенеджерВременныхТаблиц, МетаданныеНабора.ПолноеИмя(), ИмяВТ);
		Возврат;
	КонецЕсли;
	
	ИменаПолей = Новый Массив;
	Для Каждого Измерение Из МетаданныеНабора.Измерения Цикл
		ИменаПолей.Добавить(Измерение.Имя);
	КонецЦикла;
	Для Каждого Ресурс Из МетаданныеНабора.Ресурсы Цикл
		ИменаПолей.Добавить(Ресурс.Имя);
	КонецЦикла;
	Для Каждого Реквизит Из МетаданныеНабора.Реквизиты Цикл
		ИменаПолей.Добавить(Реквизит.Имя);
	КонецЦикла;
	Для Каждого ОписаниеРеквизита Из МетаданныеНабора.СтандартныеРеквизиты Цикл
		ИменаПолей.Добавить(ОписаниеРеквизита.Имя);
	КонецЦикла;
	
	РегистраторПараметр = Истина;
	Если Метаданные.РегистрыСведений.Содержит(МетаданныеНабора) Тогда
		Если МетаданныеНабора.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.Независимый Тогда
			РегистраторПараметр = Ложь;
		КонецЕсли;
	КонецЕсли;
	Если РегистраторПараметр Тогда
		ПоляПараметры = Новый Структура("Регистратор");
		ПоляПараметры.Регистратор = НаборЗаписей.Отбор.Регистратор.Значение;
	КонецЕсли;
	
	СоздатьВТПоТаблицеИменамПолей(МенеджерВременныхТаблиц, ИмяВТ, НаборЗаписей, ИменаПолей, Замещать, ПоляПараметры);
	
КонецПроцедуры

Процедура СоздатьВТПоТаблицеИменамПолей(МенеджерВременныхТаблиц, ИмяВТ, Таблица, ИменаПолейМассив, Замещать = Ложь, ПоляПараметры = Неопределено)
	
	Если ПоляПараметры = Неопределено Тогда
		ПоляПараметры = Новый Структура;
	КонецЕсли;
	
	ИменаПолейСтрока = "";
	Для Каждого ИмяПоля Из ИменаПолейМассив Цикл
		Если Не ПустаяСтрока(ИменаПолейСтрока) Тогда
			ИменаПолейСтрока = ИменаПолейСтрока + ", ";
		КонецЕсли;
		ИменаПолейСтрока = ИменаПолейСтрока + "ИмяТаблицы." + ИмяПоля;
	КонецЦикла;
	
	Объединять = Ложь;
	Если ВТСуществует(МенеджерВременныхТаблиц, ИмяВТ) Тогда
		// Если такая таблица уже есть, то нужно пересоздать ее дополнением.
		Объединять = Не Замещать;
		Если Замещать Тогда
			// Если установлено требование замещать, то удаляем таблицу прежде
			УничтожитьВТ(МенеджерВременныхТаблиц, ИмяВТ);
		КонецЕсли;
	КонецЕсли;
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.УстановитьПараметр("ИмяТаблицы", Таблица);
	
	Если Не Объединять Тогда
		Запрос.Текст = 
			"ВЫБРАТЬ
			|	&ИменаПолейСтрока
			|ПОМЕСТИТЬ ВТИмяВТ
			|ИЗ
			|	&ИмяТаблицы КАК ИмяТаблицы";
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИменаПолейСтрока", ИменаПолейСтрока);
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ВТИмяВТ", ИмяВТ);
		Для Каждого КлючИЗначение Из ПоляПараметры Цикл
			ИмяПараметра = КлючИЗначение.Ключ;
			ЗначениеПараметра = КлючИЗначение.Значение;
			Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяТаблицы." + ИмяПараметра, "&" + ИмяПараметра + " КАК " + ИмяПараметра);
			Запрос.УстановитьПараметр(ИмяПараметра, ЗначениеПараметра);
		КонецЦикла;
		Запрос.Выполнить();
		Возврат;
	КонецЕсли;
	
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	&ИменаПолейСтрока
		|ПОМЕСТИТЬ ВТПрежняя
		|ИЗ
		|	ВТИмяВТ КАК ИмяТаблицы";
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИменаПолейСтрока", ИменаПолейСтрока);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ВТИмяВТ", ИмяВТ);
	Запрос.Выполнить();
	
	УничтожитьВТ(МенеджерВременныхТаблиц, ИмяВТ);
		
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	&ИменаПолейСтрока
		|ПОМЕСТИТЬ ВТТаблицаЗначений
		|ИЗ
		|	&ИмяТаблицы КАК ИмяТаблицы";
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИменаПолейСтрока", ИменаПолейСтрока);
	Запрос.Выполнить();
	
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	&ИменаПолейСтрока
		|ПОМЕСТИТЬ ВТИмяВТ
		|ИЗ
		|	ВТТаблицаЗначений КАК ИмяТаблицы";
		
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИменаПолейСтрока", ИменаПолейСтрока);
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ВТИмяВТ", ИмяВТ);
	Для Каждого КлючИЗначение Из ПоляПараметры Цикл
		ИмяПараметра = КлючИЗначение.Ключ;
		ЗначениеПараметра = КлючИЗначение.Значение;
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяТаблицы." + ИмяПараметра, "&" + ИмяПараметра + " КАК " + ИмяПараметра);
		Запрос.УстановитьПараметр(ИмяПараметра, ЗначениеПараметра);
	КонецЦикла;
	
	Запрос.Текст = Запрос.Текст + "
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|ВЫБРАТЬ
		|	&ИменаПолейСтрока
		|ИЗ
		|	ВТПрежняя КАК ИмяТаблицы";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ИменаПолейСтрока", ИменаПолейСтрока);
	Запрос.Выполнить();
	
	УничтожитьВТ(МенеджерВременныхТаблиц, "ВТТаблицаЗначений");
	УничтожитьВТ(МенеджерВременныхТаблиц, "ВТПрежняя");
	
КонецПроцедуры

Процедура ОсвободитьМенеджерВременныхТаблиц(МенеджерВременныхТаблиц, Знач ИсключаяВТ = Неопределено) Экспорт
	
	УдалитьВТ = ИменаВТ(МенеджерВременныхТаблиц);
	Если ИсключаяВТ <> Неопределено Тогда
		УдалитьВТ = ОбщегоНазначенияКлиентСервер.РазностьМассивов(УдалитьВТ, ИсключаяВТ);
	КонецЕсли;
	УничтожитьВТ(МенеджерВременныхТаблиц, УдалитьВТ);
	
КонецПроцедуры

// Возвращает имена временных таблиц, находящихся в менеджере 
// Параметры:
//	МенеджерВременныхТаблиц - МенеджерВременныхТаблиц
//
// Возвращаемое значение:
//	Массив - массив строк с именами временных таблиц.
//
Функция ИменаВТ(МенеджерВременныхТаблиц) Экспорт
	
	ИменаВТ = Новый Массив;
	
	Для Каждого ОписаниеВТ Из МенеджерВременныхТаблиц.Таблицы Цикл
		ИменаВТ.Добавить(ОписаниеВТ.ПолноеИмя);
	КонецЦикла;
	
	Возврат ИменаВТ;
	
КонецФункции

// Ищет по имени временную таблицу в менеджере
// Параметры:
//	МенеджерВременныхТаблиц - МенеджерВременныхТаблиц
//	ИменаВТ                 - Строка - имя таблицы для поиска.
//
// Возвращаемое значение:
//	Булево
//
Функция ВТСуществует(МенеджерВременныхТаблиц, ИмяВТ) Экспорт
	
	Если МенеджерВременныхТаблиц.Таблицы.Найти(ИмяВТ) = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если МенеджерВременныхТаблиц.Таблицы.Индекс(МенеджерВременныхТаблиц.Таблицы.Найти(ИмяВТ)) = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;

КонецФункции

// Определяет, есть ли во временной таблице записи 
// Параметры:
//	МенеджерВременныхТаблиц - МенеджерВременныхТаблиц
//	ИменаВТ                 - Строка - имя таблицы для поиска.
//
// Возвращаемое значение:
//	Булево
//
Функция ВТСодержитСтроки(МенеджерВременныхТаблиц, ИмяВТ) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	Запрос.Текст = 
		"ВЫБРАТЬ ПЕРВЫЕ 1
		|	ИСТИНА
		|ИЗ
		|	ИмяВТ КАК ИмяВТ";
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяВТ", ИмяВТ);
	
	Возврат Не Запрос.Выполнить().Пустой();
	
КонецФункции

// В тексте запроса заменяет &ИменаПолей на список полей по именам из указанной ВТ, исключая ПоляИсключения.
// Используется для сохранения полей ВТ при пересоздании.
//
// Параметры:
//	ТекстЗапроса - Строка - текст запроса с параметром &ИменаПолей, вместо которого будут включены имена полей вида
//	                        ПсевдонимТаблицы.ИмяПоля1,
//	                        ПсевдонимТаблицы.ИмяПоля2,
//	                        ...
//	МенеджерВТ       - МенеджерВременныхТаблиц - менеджер временных таблиц,
//	ИмяВТ            - Строка - имя исходной временной таблицы, поля которой нужно воссоздать.
//	ПсевдонимТаблицы - Строка - псевдоним таблицы запроса.
//	ПоляИсключения   - Массив - имена полей, которые уже включены в текст запроса, такие поля не будут включены вместо &ИменаПолей.
//
Процедура ЗаполнитьИменаПолейВТ(ТекстЗапроса, МенеджерВТ, ИмяВТ, ПсевдонимТаблицы, ПоляИсключения) Экспорт
	
	ИменаПолейВТ = ОбщегоНазначения.ВыгрузитьКолонку(МенеджерВТ.Таблицы[ИмяВТ].Колонки, "Имя");
	ИменаПолейВТ = ОбщегоНазначенияКлиентСервер.РазностьМассивов(ИменаПолейВТ, ПоляИсключения);

	Если ИменаПолейВТ.Количество() = 0 Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИменаПолей,", "");
		Возврат;
	КонецЕсли;
	
	ИменаПолей = "";
	Для Каждого ИмяПоля Из ИменаПолейВТ Цикл
		ИменаПолей = ИменаПолей + ПсевдонимТаблицы + "." + ИмяПоля + ", ";
	КонецЦикла;
	СтроковыеФункцииКлиентСервер.УдалитьПоследнийСимволВСтроке(ИменаПолей, 2);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&ИменаПолей", ИменаПолей);
	
КонецПроцедуры

#КонецОбласти

// Заполняет реквизит ДатаЗапрета максимальным значением реквизитов документа Дата и реквизита
// с именем равным значению параметра ИмяРеквизитаДатаСобытия.
//
// Параметры:
//		ОбъектДокумента			- ДокументОбъект
//		ИмяРеквизитаДатаСобытия	- Строка, имя реквизита документа
//
Процедура ЗаполнитьДатуЗапретаРедактирования(ОбъектДокумента, ИмяРеквизитаДатаСобытия) Экспорт
	
	ОбъектДокумента.ДатаЗапрета = Макс(ОбъектДокумента.Дата, ОбъектДокумента[ИмяРеквизитаДатаСобытия]);
	
КонецПроцедуры

// Заполняет реквизит ДатаЗапрета максимальным значением реквизитов документа Дата и реквизитов
// с именем равным значению параметра ИмяРеквизитаДатаСобытия, табличной части документа с именем
// равным значению параметра ИмяТабличнойЧасти.
//
// Параметры:
//		ОбъектДокумента			- ДокументОбъект
//		ИмяТабличнойЧасти		- Строка, имя табличной части
//		ИмяРеквизитаДатаСобытия	- Строка, имя реквизита табличной части
//
Процедура ЗаполнитьДатуЗапретаРедактированияСписочногоДокумента(ОбъектДокумента, ИмяТабличнойЧасти, ИмяРеквизитаДатаСобытия) Экспорт
	
	ДатаСобытия = '00010101';
	
	Для Каждого СтрокаДокумента Из ОбъектДокумента[ИмяТабличнойЧасти] Цикл
		
		Если ДатаСобытия < СтрокаДокумента[ИмяРеквизитаДатаСобытия] Тогда
			ДатаСобытия = СтрокаДокумента[ИмяРеквизитаДатаСобытия];
		КонецЕсли;
		
	КонецЦикла;
	
	ОбъектДокумента.ДатаЗапрета = Макс(ОбъектДокумента.Дата, ДатаСобытия);
	
КонецПроцедуры

// ЗарплатаКадрыПодсистемы.ПодписиДокументов

// См. ПодписиДокументовПереопределяемый.ПриОпределенииРолейПодписантов.
Процедура ПриОпределенииРолейПодписантов(РолиПодписантов) Экспорт
	ЗарплатаКадрыВнутренний.ПриОпределенииРолейПодписантов(РолиПодписантов);
КонецПроцедуры

// См. ПодписиДокументовПереопределяемый.ЗаполнитьСведенияОПодписяхДокументов.
Процедура ЗаполнитьСведенияОПодписяхДокументов(ОписаниеПодписей, Организация, ЗначенияПодписей, СтандартнаяОбработка) Экспорт
	
	ОписаниеПодписиУполномоченныйПоПрямымВыплатамФСС = ОписаниеПодписей.Получить("УполномоченныйПоПрямымВыплатамФСС");
	Если ОписаниеПодписиУполномоченныйПоПрямымВыплатамФСС <> Неопределено Тогда
		ОтветственныеЛица = ОтветственныеЛицаОрганизации(Организация, "Руководитель, ГлавныйБухгалтер", ТекущаяДатаСеанса());
		Если ЗначениеЗаполнено(ОтветственныеЛица.ГлавныйБухгалтер) Тогда
			ЗначенияПодписей.Вставить(ОписаниеПодписиУполномоченныйПоПрямымВыплатамФСС.ФизическоеЛицо, ОтветственныеЛица.ГлавныйБухгалтер);
		Иначе
			ЗначенияПодписей.Вставить(ОписаниеПодписиУполномоченныйПоПрямымВыплатамФСС.ФизическоеЛицо, ОтветственныеЛица.Руководитель);
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// Конец ЗарплатаКадрыПодсистемы.ПодписиДокументов

// Заполняет имя клиентского приложения (User-Agent), используемое при формировании веб-запросов.
//
Функция ИмяКлиентскогоПриложения() Экспорт
	Возврат ЗарплатаКадрыПовтИсп.ИмяКлиентскогоПриложения();
КонецФункции

// Возвращает ГоловнуюОрганизацию, организации переданной в параметре
//
// Параметры:
//		Организация - СправочникСсылка.Организации
//
// Возвращаемое значение:
//		СправочникСсылка.Организации
//
Функция ГоловнаяОрганизация(Организация) Экспорт
	
	Возврат ЗарплатаКадрыПовтИсп.ГоловнаяОрганизация(Организация);
	
КонецФункции

// Конец ЗарплатаКадрыПодсистемы.ПодписиДокументов

// Формирует соответствие статей расходов способам расчетов с физическими лицами.
//
//	Возвращаемое значение: Соответствие
//		Ключ 		- ПеречислениеСсылка.СпособыРасчетовСФизическимиЛицами
//		Значение 	- СправочникаСсылка.СтатьиРасходовЗарплата
//
Функция СтатьиРасходовПоСпособамРасчетовСФизическимиЛицами() Экспорт

	Возврат ЗарплатаКадрыПовтИсп.СтатьиРасходовПоСпособамРасчетовСФизическимиЛицами();

КонецФункции

Процедура СтатьиРасходовЗарплатаНачальноеЗаполнениеПоСпособамРасчетов(ПараметрыОбновления = Неопределено) Экспорт

	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	СтатьиРасходов.Ссылка КАК Ссылка,
	|	СтатьиРасходов.СпособРасчетовСФизическимиЛицами КАК СпособРасчетовСФизическимиЛицами
	|ИЗ
	|	Справочник.СтатьиРасходовЗарплата КАК СтатьиРасходов
	|ГДЕ
	|	СтатьиРасходов.СпособРасчетовСФизическимиЛицами <> ЗНАЧЕНИЕ(Перечисление.СпособыРасчетовСФизическимиЛицами.ПустаяСсылка)";
	Результат = Запрос.Выполнить();
	
	СуществующиеСтатьи = Новый Соответствие;
	Выборка = Результат.Выбрать();
	Пока Выборка.Следующий() Цикл
		СуществующиеСтатьи.Вставить(Выборка.СпособРасчетовСФизическимиЛицами, Выборка.Ссылка);
	КонецЦикла;
	
	Для каждого ЗначениеПеречисления Из Перечисления.СпособыРасчетовСФизическимиЛицами Цикл
	
		Если СуществующиеСтатьи[ЗначениеПеречисления] = Неопределено Тогда
			
			Если ЗначениеПеречисления = Перечисления.СпособыРасчетовСФизическимиЛицами.ОплатаТруда Тогда
				НовыйКод = "ОТ";
			ИначеЕсли ЗначениеПеречисления = Перечисления.СпособыРасчетовСФизическимиЛицами.ПрочиеРасчетыСПерсоналом Тогда
				НовыйКод = "ПР";
			ИначеЕсли ЗначениеПеречисления = Перечисления.СпособыРасчетовСФизическимиЛицами.РасчетыСКонтрагентами Тогда
				НовыйКод = "КА";
			ИначеЕсли ЗначениеПеречисления = Перечисления.СпособыРасчетовСФизическимиЛицами.Дивиденды Тогда
				НовыйКод = "ДВ";
			Иначе
				Продолжить;
			КонецЕсли;
			
			СправочникОбъект = Справочники.СтатьиРасходовЗарплата.СоздатьЭлемент();
			СправочникОбъект.СпособРасчетовСФизическимиЛицами = ЗначениеПеречисления;
			СправочникОбъект.Наименование = Строка(ЗначениеПеречисления);
			СправочникОбъект.Код = НовыйКод;
			ОбновлениеИнформационнойБазы.ЗаписатьОбъект(СправочникОбъект);
			
		КонецЕсли;
	
	КонецЦикла;
	
	ОбновлениеИнформационнойБазыЗарплатаКадрыБазовый.УстановитьПараметрОбновления(ПараметрыОбновления, "ОбработкаЗавершена", Истина);

КонецПроцедуры

Процедура ОбработкаПолученияФормыСтатьиРасходовЗарплата(ВидФормы, Параметры, ВыбраннаяФорма, ДополнительнаяИнформация, СтандартнаяОбработка) Экспорт
	
	ЗарплатаКадрыВнутренний.ОбработкаПолученияФормыСтатьиРасходовЗарплата(ВидФормы, Параметры, ВыбраннаяФорма, ДополнительнаяИнформация, СтандартнаяОбработка);
	
КонецПроцедуры

#Область РегистрыКлассификаторы

// Возвращает таблицу с описанием классификаторов, обновляемых автоматически.
//
// Возвращаемое значение:
//   ТаблицаЗначений - Таблица сведений о классификаторах с колонками:
//       * Идентификатор - Строка - Идентификатор классификатора на английском языке.
//       * ПолноеИмя - Строка - Полное имя объекта метаданных, отвечающего за обновление классификатора.
//           В менеджере объекта должна быть размещена экспортная процедура Обновить с параметром ТекстXML.
//
Функция АвтообновляемыеКлассификаторы() Экспорт
	ТаблицаКлассификаторов = Новый ТаблицаЗначений;
	ТаблицаКлассификаторов.Колонки.Добавить("Наименование",  Новый ОписаниеТипов("Строка"));
	ТаблицаКлассификаторов.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Строка"));
	ТаблицаКлассификаторов.Колонки.Добавить("ПолноеИмя",     Новый ОписаниеТипов("Строка"));
	
	ЗарплатаКадрыБазовый.ПриРегистрацииАвтоообновляемыхКлассификаторов(ТаблицаКлассификаторов);
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыРасширеннаяПодсистемы") Тогда
		МодульЗарплатаКадрыРасширенный = ОбщегоНазначения.ОбщийМодуль("ЗарплатаКадрыРасширенный");
		МодульЗарплатаКадрыРасширенный.ПриРегистрацииАвтоообновляемыхКлассификаторов(ТаблицаКлассификаторов);
	КонецЕсли;
	
	Для Каждого СтрокаТаблицы Из ТаблицаКлассификаторов Цикл
		Если Не ЗначениеЗаполнено(СтрокаТаблицы.Наименование) Тогда
			СтрокаТаблицы.Наименование = Метаданные.НайтиПоПолномуИмени(СтрокаТаблицы.ПолноеИмя).Представление();
		КонецЕсли;
	КонецЦикла;
	
	Возврат ТаблицаКлассификаторов;
КонецФункции

// Записывает данные классификатора на основе текста XML.
//
// Параметры:
//   ТекстXML - Строка - Сведения о классификаторе (загружаемая версия).
//   ПолучатьДанныеИзСервиса - Булево - Если Истина и загружаемая версия меньше текущей (которая загружена в базу),
//       то перед обновлением будет произведена попытка получить более новую (актуальную) версию классификатора.
//       Особенности см. в комментарии функции РаботаСКлассификаторами.ПолучитьФайлыКлассификаторов():
//       - в коробке последняя доступная версия будет получена из веб-сервиса,
//       - в модели сервиса текущая версия будет получена из кэша.
//
// Возвращаемое значение:
//   Булево - Истина, если данные удалось записать в классификатор.
//
Функция ОбновитьКлассификатор(ТекстXML, ПолучатьДанныеИзСервиса = Истина) Экспорт
	ЗагружаемыеСведения = ОбщегоНазначения.ЗначениеИзСтрокиXML(ТекстXML);
	
	Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ЗагружаемыеСведения.ПолноеИмя);
	ОбъектМетаданных = Метаданные.НайтиПоТипу(ТипЗнч(Менеджер));
	
	МодульРаботаСКлассификаторами = Неопределено;
	Если ОбщегоНазначения.ПодсистемаСуществует("ИнтернетПоддержкаПользователей.РаботаСКлассификаторами") Тогда
		МодульРаботаСКлассификаторами = ОбщегоНазначения.ОбщийМодуль("РаботаСКлассификаторами");
		ТекущаяВерсия = МодульРаботаСКлассификаторами.ВерсияКлассификатора(ЗагружаемыеСведения.Идентификатор, Истина);
		Если ЗагружаемыеСведения.Версия < ТекущаяВерсия Тогда
			Если Не ПолучатьДанныеИзСервиса Тогда
				ЗаписьЖурналаРегистрации(
					НСтр("ru = 'Нормативно-правовая информация БЗК'", ОбщегоНазначения.КодОсновногоЯзыка()),
					УровеньЖурналаРегистрации.Предупреждение,
					ОбъектМетаданных,
					,
					СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Версия %1 классификатора ""%2"" не загружена, т.к. уже загружена более новая версия %3.
							|Рекомендуется проверить наличие обновлений конфигурации.'"),
						ЗагружаемыеСведения.Версия,
						ОбъектМетаданных.Представление(),
						ТекущаяВерсия));
				Возврат Ложь; // В ИБ уже загружена более новая версия классификатора.
			КонецЕсли;
			// В данную ветку процесс попадает когда пользователь хочет сбросить данные регистра до умолчательных значений,
			// но версия загруженных данных классификатора выше версии из макета в метаданных.
			// Проверка возможности загрузки обновления из веб-сервиса.
			СведенияИзВебСервиса = ПолучитьДанныеКлассификатораИзСервиса(ЗагружаемыеСведения.Идентификатор);
			Если СведенияИзВебСервиса = Неопределено
				Или СведенияИзВебСервиса.Версия < ТекущаяВерсия
				Или ВРег(СведенияИзВебСервиса.ПолноеИмя) <> ВРег(ЗагружаемыеСведения.ПолноеИмя) Тогда
				Возврат Ложь; // Пользователь загружал обновление из файла.
			КонецЕсли;
			// Загрузка обновления из веб-сервиса.
			ЗагружаемыеСведения = СведенияИзВебСервиса;
		КонецЕсли;
	КонецЕсли;
	
	// Поиск ссылок.
	ТаблицаБезСсылок = ЗагружаемыеСведения.Данные;
	ТаблицаОшибок = ТаблицаБезСсылок.СкопироватьКолонки();
	ТаблицаОшибок.Колонки.Добавить("ТекстОшибки");
	
	Если ОбщегоНазначения.ЭтоСправочник(ОбъектМетаданных) Тогда
		ШаблонТаблицыСоСсылками = ШаблонТаблицыСоСсылкамиСправочника(ОбъектМетаданных);
	Иначе
		НаборЗаписей = Менеджер.СоздатьНаборЗаписей();
		ШаблонТаблицыСоСсылками = НаборЗаписей.ВыгрузитьКолонки();
	КонецЕсли;
	
	ТаблицаСоСсылками = ПолныеИменаВСсылки(ТаблицаБезСсылок, ШаблонТаблицыСоСсылками, ТаблицаОшибок);
	
	// Анализ ошибок поиска ссылок, подготовка текста для записи в журнал регистрации.
	КоличествоБылоПередано = ТаблицаБезСсылок.Количество();
	КоличествоБудетЗагружено = ТаблицаСоСсылками.Количество();
	Если КоличествоБылоПередано > КоличествоБудетЗагружено Тогда
		ТаблицаОшибок.Свернуть("ТекстОшибки");
		Разделитель = "  - ";
		ПредставлениеСпискаОшибок = Разделитель + СтрСоединить(ТаблицаОшибок.ВыгрузитьКолонку("ТекстОшибки"), ";" + Символы.ПС + Разделитель);
		Если КоличествоБудетЗагружено = 0 Тогда
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Классификатор ""%1"" не обновлен по причине:
					|%2.
					|
					|Рекомендуется проверить наличие обновлений конфигурации.'"),
				ОбъектМетаданных.Представление(),
				ПредставлениеСпискаОшибок);
		Иначе
			УровеньЖурнала = УровеньЖурналаРегистрации.Предупреждение;
			ТекстЖурнала = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Классификатор ""%1"" обновлен частично: Загружено %2 из %3 записей; %4 записей не загружено по причине:
					|%5.
					|
					|Рекомендуется проверить наличие обновлений конфигурации.'"),
				ОбъектМетаданных.Представление(),
				КоличествоБудетЗагружено,
				КоличествоБылоПередано,
				КоличествоБылоПередано - КоличествоБудетЗагружено,
				ПредставлениеСпискаОшибок);
		КонецЕсли;
	Иначе
		УровеньЖурнала = УровеньЖурналаРегистрации.Информация;
		ТекстЖурнала = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Обновлен классификатор ""%1"" (загружено %2 записей).'"),
			ОбъектМетаданных.Представление(),
			КоличествоБудетЗагружено);
	КонецЕсли;
	
	// Загрузка сведений.
	Если ОбщегоНазначения.ЭтоСправочник(ОбъектМетаданных) Тогда
		Менеджер.ЗагрузитьКлассификатор(ТаблицаСоСсылками);
	Иначе
		НаборЗаписей.Загрузить(ТаблицаСоСсылками);
		НаборЗаписей.ДополнительныеСвойства.Вставить("ЗаписьОбщихДанных");
		ОбновлениеИнформационнойБазы.ЗаписатьНаборЗаписей(НаборЗаписей);
	КонецЕсли;
	
	// Запись результатов в журнал регистрации.
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Нормативно-правовая информация БЗК'", ОбщегоНазначения.КодОсновногоЯзыка()),
		УровеньЖурнала,
		ОбъектМетаданных,
		,
		ТекстЖурнала);
	
	Если МодульРаботаСКлассификаторами <> Неопределено Тогда
		МодульРаботаСКлассификаторами.УстановитьВерсиюКлассификатора(ЗагружаемыеСведения.Идентификатор, ЗагружаемыеСведения.Версия);
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

// В переданной таблице значений преобразует строковые идентификаторы предопределенных элементов в ссылки базы данных.
//
// Параметры:
//   ТаблицаБезСсылок - ТаблицаЗначений - Исходная таблица, в которой могут содержаться строковые идентификаторы.
//   ТаблицаСоСсылками - ТаблицаЗначений - Пустой шаблон результирующей таблицы.
//       Типы колонок этой таблицы используются для определения списка колонок, для которых требуется конвертация.
//   ТаблицаОшибок - ТаблицаЗначений - Таблица со списком ошибок.
//       В колонку ТекстОшибки помещаются с тексты ошибок, возникших при поиске ссылок.
//       Значения остальных колонок заполняются из элемента таблицы ТаблицаБезСсылок.
//
// Возвращаемое значение:
//   ТаблицаЗначений - Результат преобразования.
//
Функция ПолныеИменаВСсылки(ТаблицаБезСсылок, ТаблицаСоСсылками, ТаблицаОшибок = Неопределено) Экспорт
	// Для оптимизации составляется список колонок, для которых потребуется конвертация ссылок.
	ИменаКолонокДляПреобразованияСсылок = Новый Массив;
	
	ВсеСсылкиСправочников = Справочники.ТипВсеСсылки();
	ВсеСсылкиПеречислений = Перечисления.ТипВсеСсылки();
	Для Каждого Колонка Из ТаблицаСоСсылками.Колонки Цикл
		Типы = Колонка.ТипЗначения.Типы();
		Для Каждого Тип Из Типы Цикл
			Если ВсеСсылкиСправочников.СодержитТип(Тип)
				Или ВсеСсылкиПеречислений.СодержитТип(Тип) Тогда
				ИменаКолонокДляПреобразованияСсылок.Добавить(Колонка.Имя);
				Прервать;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	// Если конвертация ссылок не требуется, то возвращается исходная таблица.
	Если ИменаКолонокДляПреобразованияСсылок.Количество() = 0 Тогда
		Возврат ТаблицаБезСсылок;
	КонецЕсли;
	
	// Механизмы конвертации поддерживают типовые методы ПредопределенноеЗначение и НайтиПоКоду.
	Для Каждого СтрокаТаблицыБезСсылок Из ТаблицаБезСсылок Цикл
		СтрокаТаблицыССсылками = ТаблицаСоСсылками.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыССсылками, СтрокаТаблицыБезСсылок);
		
		// Правило "по умолчанию" - выгрузка имени предопределенных данных.
		Для Каждого ИмяКолонки Из ИменаКолонокДляПреобразованияСсылок Цикл
			ЗначениеБезСсылок = СтрокаТаблицыБезСсылок[ИмяКолонки];
			ЗначениеССсылками = Неопределено;
			// Чтение ссылки.
			Если СтрНачинаетсяС(ЗначениеБезСсылок, "ПредопределенноеЗначение:") Тогда
				ПолноеИмяПредопределенного = Сред(ЗначениеБезСсылок, СтрДлина("ПредопределенноеЗначение:") + 1);
				Если ПредопределенныйЭлементОтсутствуетВМетаданных(ПолноеИмяПредопределенного) Тогда
					ЗначениеССсылками = Неопределено; // Элемент не будет добавлен.
				Иначе
					ЗначениеССсылками = ОбщегоНазначения.ПредопределенныйЭлемент(ПолноеИмяПредопределенного);
				КонецЕсли;
			ИначеЕсли СтрНачинаетсяС(ЗначениеБезСсылок, "НайтиПоКоду:") Тогда
				Остаток = Сред(ЗначениеБезСсылок, СтрДлина("НайтиПоКоду:") + 1);
				Позиция = СтрНайти(Остаток, ".", , , 2);
				Если Позиция > 0 Тогда
					ПолноеИмяОбъектаМетаданных = Лев(Остаток, Позиция - 1);
					Код = Сред(Остаток, Позиция + 1);
					Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
					ЗначениеССсылками = Менеджер.НайтиПоКоду(Код);
				КонецЕсли;
			КонецЕсли;
			// Если элемента нет в метаданных или ссылка еще не создана в данных, то строка не добавляется.
			Если ЗначениеССсылками = Неопределено Тогда
				Если ТаблицаОшибок <> Неопределено Тогда
					СтрокаОшибки = ТаблицаОшибок.Добавить();
					ЗаполнитьЗначенияСвойств(СтрокаОшибки, СтрокаТаблицыБезСсылок);
					СтрокаОшибки.ТекстОшибки = СтрШаблон(НСтр("ru = '""%1"" отсутствует в данных'"), ЗначениеБезСсылок);
				КонецЕсли;
				ТаблицаСоСсылками.Удалить(СтрокаТаблицыССсылками);
				Прервать;
			КонецЕсли;
			// Установка ссылки.
			СтрокаТаблицыССсылками[ИмяКолонки] = ЗначениеССсылками;
		КонецЦикла;
	КонецЦикла;
	
	Возврат ТаблицаСоСсылками;
КонецФункции

Функция ШаблонТаблицыСоСсылкамиСправочника(ОбъектМетаданных) Экспорт
	
	ТаблицыСоСсылками = Новый ТаблицаЗначений;
	
	Если ОбъектМетаданных.ДлинаКода > 0 Тогда
		Если ОбъектМетаданных.ТипКода = Метаданные.СвойстваОбъектов.ТипКодаСправочника.Число Тогда
			ТаблицыСоСсылками.Колонки.Добавить("Код", Новый ОписаниеТипов("Число"));
		Иначе
			ТаблицыСоСсылками.Колонки.Добавить("Код", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(1024)));
		КонецЕсли;
	КонецЕсли;
	
	Если ОбъектМетаданных.ДлинаНаименования > 0 Тогда
		ТаблицыСоСсылками.Колонки.Добавить("Наименование", Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(1024)));
	КонецЕсли;
	
	Для Каждого Реквизит Из ОбъектМетаданных.Реквизиты Цикл
		ТаблицыСоСсылками.Колонки.Добавить(Реквизит.Имя, Реквизит.Тип);
	КонецЦикла;
	
	Возврат ТаблицыСоСсылками;
	
КонецФункции

// В переданной таблице значений преобразует ссылки справочников в строковые идентификаторы предопределенных элементов.
//
// Параметры:
//   ТаблицаСоСсылками - ТаблицаЗначений - Таблица, в которой могут содержаться ссылки справочников.
//       Типы колонок этой таблицы используются для определения списка колонок, для которых требуется конвертация.
//
// Возвращаемое значение:
//   ТаблицаЗначений - Результат преобразования - Таблица, в которой ссылки справочников преобразованы в строковые идентификаторы.
//
Функция СсылкиВПолныеИмена(ТаблицаСоСсылками) Экспорт
	ТаблицаБезСсылок = ТаблицаСоСсылками.СкопироватьКолонки();
	
	// Для оптимизации составляется список колонок, для которых потребуется конвертация ссылок.
	ИменаКолонокДляПреобразованияСсылок = Новый Массив;
	БыстрыйПоискПолногоИмениПоТипу = Новый Соответствие;
	
	ВсеСсылкиСправочников = Справочники.ТипВсеСсылки();
	ВычитаемыеТипы = Новый Массив;
	Для Каждого Колонка Из ТаблицаСоСсылками.Колонки Цикл
		Типы = Колонка.ТипЗначения.Типы();
		Для Каждого Тип Из Типы Цикл
			Если ВсеСсылкиСправочников.СодержитТип(Тип) Тогда
				ВычитаемыеТипы.Добавить(Тип);
				БыстрыйПоискПолногоИмениПоТипу.Вставить(Тип, Метаданные.НайтиПоТипу(Тип).ПолноеИмя());
			КонецЕсли;
		КонецЦикла;
		
		Если ВычитаемыеТипы.Количество() > 0 Тогда
			ИменаКолонокДляПреобразованияСсылок.Добавить(Колонка.Имя);
			
			Если Колонка.ТипЗначения.СодержитТип(Тип("Строка")) Тогда
				ОписаниеТиповВНовойТаблице = Новый ОписаниеТипов(Колонка.ТипЗначения, , ВычитаемыеТипы, , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная));
			Иначе
				ДобавляемыеТипы = Новый Массив;
				ДобавляемыеТипы.Добавить(Тип("Строка"));
				ОписаниеТиповВНовойТаблице = Новый ОписаниеТипов(Колонка.ТипЗначения, ДобавляемыеТипы, ВычитаемыеТипы, , Новый КвалификаторыСтроки(0, ДопустимаяДлина.Переменная));
			КонецЕсли;
			ТаблицаБезСсылок.Колонки.Удалить(Колонка.Имя);
			ТаблицаБезСсылок.Колонки.Вставить(ТаблицаСоСсылками.Колонки.Индекс(Колонка), Колонка.Имя, ОписаниеТиповВНовойТаблице, Колонка.Заголовок, Колонка.Ширина);
			
			ВычитаемыеТипы.Очистить();
		КонецЕсли;
	КонецЦикла;
	
	// Если конвертация ссылок не требуется, то возвращается исходная таблица.
	Если ИменаКолонокДляПреобразованияСсылок.Количество() = 0 Тогда
		Возврат ТаблицаСоСсылками;
	КонецЕсли;
	
	// Механизмы конвертации рассчитывают на поддержку типовых методов ПредопределенноеЗначение (правило по умолчанию)
	// и НайтиПоКоду (например, для валют).
	Для Каждого СтрокаТаблицыССсылками Из ТаблицаСоСсылками Цикл
		СтрокаТаблицыБезСсылок = ТаблицаБезСсылок.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыБезСсылок, СтрокаТаблицыССсылками);
		
		Для Каждого ИмяКолонки Из ИменаКолонокДляПреобразованияСсылок Цикл
			Ссылка = СтрокаТаблицыССсылками[ИмяКолонки];
			ПолноеИмя = БыстрыйПоискПолногоИмениПоТипу[ТипЗнч(Ссылка)];
			Если ПолноеИмя <> Неопределено Тогда
				ИмяПредопределенныхДанных = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, "ИмяПредопределенныхДанных");
				Если ЗначениеЗаполнено(ИмяПредопределенныхДанных) Тогда
					СтрокаТаблицыБезСсылок[ИмяКолонки] = "ПредопределенноеЗначение:" + ПолноеИмя + "." + ИмяПредопределенныхДанных;
				Иначе
					Код = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Ссылка, "Код");
					СтрокаТаблицыБезСсылок[ИмяКолонки] = "НайтиПоКоду:" + ПолноеИмя + "." + Код;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Возврат ТаблицаБезСсылок;
КонецФункции

// Возвращает Истина когда предопределенный элемент отсутствует в метаданных.
//
// Параметры:
//   ПолноеИмяПредопределенного - Строка - Полный путь к предопределенному элементу, включая его имя.
//     Формат аналогичен функции глобального контекста ПредопределенноеЗначение(), например:
//       - "Справочник.ВидыКонтактнойИнформации.EmailПользователя",
//       - "ПланСчетов.Хозрасчетный.Материалы",
//       - "ПланВидовРасчета.Начисления.ОплатаПоОкладу".
//
// Возвращаемое значение:
//   Булево - Результат проверки наличия предопределенного в метаданных.
//       Истина - Предопределенного нет в метаданных.
//       Ложь - Во всех остальных ситуациях.
//
Функция ПредопределенныйЭлементОтсутствуетВМетаданных(ПолноеИмяПредопределенного) Экспорт
	ЧастиПолногоИмениВРег = СтрРазделить(ВРег(ПолноеИмяПредопределенного), ".");
	Если ЧастиПолногоИмениВРег.Количество() <> 3 Тогда
		Возврат Ложь; // Некорректный формат параметра.
	КонецЕсли;
	
	ВидОМВРег               = ЧастиПолногоИмениВРег[0];
	ИмяОМВРег               = ЧастиПолногоИмениВРег[1];
	ИмяПредопределенногоРег = ЧастиПолногоИмениВРег[2];
	
	МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(ВидОМВРег + "." + ИмяОМВРег);
	Если МетаданныеОбъекта = Неопределено Тогда
		Возврат Ложь; // Объект метаданных не найден.
	КонецЕсли;
	
	Если ВидОМВРег = ВРег("Справочник")
		Или ВидОМВРег = ВРег("ПланВидовХарактеристик")
		Или ВидОМВРег = ВРег("ПланСчетов")
		Или ВидОМВРег = ВРег("ПланВидовРасчета") Тогда
		
		Если ИмяПредопределенногоРег = "ПУСТАЯССЫЛКА" Тогда
			Возврат Ложь; // Предопределенный найден в метаданных.
		КонецЕсли;
		
		ИменаПредопределенных = МетаданныеОбъекта.ПолучитьИменаПредопределенных();
		
		Для Каждого Имя Из ИменаПредопределенных Цикл
			Если ВРег(Имя) = ИмяПредопределенногоРег Тогда
				Возврат Ложь; // Предопределенный найден в метаданных.
			КонецЕсли;
		КонецЦикла;
		
		Возврат Истина; // Предопределенный не найден в метаданных.
		
	ИначеЕсли ВидОМВРег = ВРег("Перечисление") Тогда
		
		Если ИмяПредопределенногоРег = "ПУСТАЯССЫЛКА" Тогда
			Возврат Ложь; // Предопределенный найден в метаданных.
		КонецЕсли;
		
		Если ТипЗнч(МетаданныеОбъекта.ЗначенияПеречисления.Найти(ИмяПредопределенногоРег)) = Тип("ОбъектМетаданных") Тогда
			Возврат Ложь; // Предопределенный найден в метаданных.
		КонецЕсли;
		
		Возврат Истина; // Предопределенный не найден в метаданных.
		
	КонецЕсли;
	
	Возврат Ложь; // Проверка вида объекта метаданных не поддерживается.
КонецФункции

#КонецОбласти

#Область РаботаСПотокамиXML

// Создает и возвращает объект ЗаписьXML, для создания XML документа.
Функция СоздатьПотокXML(ИмяФайла = Неопределено, Кодировка  = "windows-1251") Экспорт	
	ПотокXML = Новый ЗаписьXML();
	
	ПотокXML.УстановитьСтроку(Кодировка);
	ПотокXML.Отступ = Истина;
	Если ИмяФайла <> Неопределено Тогда
		ПотокXML.ОткрытьФайл(ИмяФайла, Кодировка);
	КонецЕсли;
	
	ПотокXML.ЗаписатьОбъявлениеXML();
	
	Возврат ПотокXML;
	
КонецФункции

// Сохраняет документ XML  на диск и закрывает запись XML.
Функция ЗаписатьПотокXML(ПотокXML) Экспорт
	Возврат ПотокXML.Закрыть();	
КонецФункции

/////////////////////////////////////
// Работа с деревом XML

// КОМПОЗИЦИЯ ДЕРЕВА

// Создает объект дерево значений, представляющее XML файл.
Функция СоздатьДеревоXML() Экспорт	
	НовоеДеревоXML = Новый ДеревоЗначений;
	НовоеДеревоXML.Колонки.Добавить("Имя",      Новый ОписаниеТипов("Строка"));
	НовоеДеревоXML.Колонки.Добавить("Значение", Новый ОписаниеТипов("Строка"));
	
	Возврат НовоеДеревоXML;
	
КонецФункции

Функция ДобавитьУзелВДеревоXML(Ветка, Имя, Значение, СписокАтрибутов = Неопределено, ТипДанных = "", ЗначениеЗаписи = Неопределено) Экспорт
	ПустаяДата = Дата(1,1,1);
	
	НовыйУзел = Ветка.Строки.Добавить();
	НовыйУзел.Имя = Имя;
	НовыйУзел.Значение = Значение;
	
	Если СписокАтрибутов <> Неопределено Тогда
		ВеткаАтрибутов = НовыйУзел.Строки.Добавить();
		ВеткаАтрибутов.Имя = "АтрибутыXMLУзла";
		ВеткаАтрибутов.Значение = Неопределено;
		
		Для Каждого ЭлементСпискаАтрибутов Из СписокАтрибутов Цикл
			ЛистАтрибутов = ВеткаАтрибутов.Строки.Добавить();
			ЛистАтрибутов.Имя = ЭлементСпискаАтрибутов.Ключ;
			// Доделать до правильного преобразования.
			ЛистАтрибутов.Значение = Строка(ЭлементСпискаАтрибутов.Значение);
		КонецЦикла;
		
	КонецЕсли;
	
	Если ТипДанных = "СТРОКА" И ЗначениеЗаписи <> Неопределено Тогда
		ЗначениеЗаписи = "";
	ИначеЕсли ТипДанных = "ЧИСЛО" И ЗначениеЗаписи <> Неопределено Тогда
		Если ТипЗнч(ЗначениеЗаписи) = Тип("Число") Тогда
			ЗначениеЗаписи = 0;	
		Иначе
			ЗначениеЗаписи = "";
		КонецЕсли;	
	ИначеЕсли ТипДанных = "ДАТА" И ЗначениеЗаписи <> Неопределено Тогда
		ЗначениеЗаписи = ПустаяДата;	
	КонецЕсли;	
	
	Возврат НовыйУзел;
	
КонецФункции

// Записывает значения из дерева значение в поток связанный с файлом XML.
Процедура ЗаписатьУзелДереваXMLВXML(СтрокаДерева, ПотокXML, ПрефиксПространстваИмен = Неопределено, URIПространстваИмен = Неопределено, ЗаменятьПодчеркивания = Истина) Экспорт	
	Если ТипЗнч(СтрокаДерева) = Тип("СтрокаДереваЗначений") Тогда
		
		Если НЕ ПустаяСтрока(СтрокаДерева.Имя) Тогда
			Если ЗаменятьПодчеркивания Тогда
				ПотокXML.ЗаписатьНачалоЭлемента(СтрЗаменить(СтрокаДерева.Имя,"__","-"));
			Иначе
				ПотокXML.ЗаписатьНачалоЭлемента(СтрокаДерева.Имя);	
			КонецЕсли;	
			Если ПрефиксПространстваИмен <> Неопределено И URIПространстваИмен <> Неопределено Тогда
				ПотокXML.ЗаписатьСоответствиеПространстваИмен(ПрефиксПространстваИмен, URIПространстваИмен);
			КонецЕсли;
			СписокАтрибутов = СтрокаДерева.Строки.Найти("АтрибутыXMLУзла", "Имя", Ложь);
			
			Если СписокАтрибутов <> Неопределено Тогда
				Для каждого СтрокаСАтрибутом Из СписокАтрибутов.Строки Цикл
					ПотокXML.ЗаписатьАтрибут(СтрокаСАтрибутом.Имя, СтрокаСАтрибутом.Значение);
				КонецЦикла;
			КонецЕсли;
			
			ПотокXML.ЗаписатьТекст(?(СтрокаДерева.Значение = "00.00.0000", "", СтрокаДерева.Значение));
			
		КонецЕсли;
		
	КонецЕсли;
	
	Для каждого Лист Из СтрокаДерева.Строки Цикл
		Если Лист.Имя = "АтрибутыXMLУзла" Тогда
			Продолжить;
		КонецЕсли;
		ЗаписатьУзелДереваXMLВXML(Лист, ПотокXML, ПрефиксПространстваИмен, URIПространстваИмен, ЗаменятьПодчеркивания);
	КонецЦикла;
	
	Если ТипЗнч(СтрокаДерева) = Тип("СтрокаДереваЗначений") Тогда
		Если НЕ ПустаяСтрока(СтрокаДерева.Имя) Тогда
			ПотокXML.ЗаписатьКонецЭлемента();
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// ИМПОРТ / ЭКСПОРТ ДЕРЕВА

Функция ЗагрузитьXMLВДокументDOM(ТекстXML) Экспорт
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ТекстXML);
	
	ПостроительDOM = Новый ПостроительDOM;
	
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	
	Возврат ДокументDOM;
КонецФункции	

Функция ЗагрузитьФорматНабораЗаписей(Знач ДеревоФормата, Знач ИмяНабораЗаписей, НомерВыбираемогоЭлемента = 1) Экспорт
	ФорматНабора = Новый Структура();
	
	УзлыФормата = ДеревоФормата.ДочерниеУзлы[0].ПолучитьЭлементыПоИмени(ИмяНабораЗаписей)[0].ДочерниеУзлы;
	
	Для Каждого УзелФормата Из УзлыФормата Цикл
		
		Если ТипЗнч(УзелФормата) <> Тип("ЭлементDOM") Тогда
			Продолжить;
		КонецЕсли;
		
		ФорматЗаписи = Новый Структура("ТипДанных, Размер, РазрядностьДробнойЧасти, Поля, Значение, ЭлементНеОбязателен, ТипЭлемента, НеВыводитьВФайл");
		
		// Имя записи хранится в 4 колонке.
		ИмяЗаписи =  УзелФормата.ДочерниеУзлы[3].ТекстовоеСодержимое;
		
		// Тип данных хранится во 2 колонке.
		ТипДанных = ВРег(УзелФормата.ДочерниеУзлы[1].ТекстовоеСодержимое);
		
		// Признак обязательности элемента хранится в 5-й колонке.
		ЭлементНеОбязателен = (ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "НЕ ОБЯЗАТЕЛЬНО" Или ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "Н");
		
		Если УзелФормата.ДочерниеУзлы.Количество() = 7 И УзелФормата.ДочерниеУзлы[6].ИмяУзла = "ТипЭлемента" Тогда
			ТипЭлемента = ВРег(УзелФормата.ДочерниеУзлы[6].ТекстовоеСодержимое);
		Иначе
			ТипЭлемента = "С";
		КонецЕсли;	
		
		Если ТипДанных = "" Тогда// Если тип данных не задан, то встретили строку - группировку.
			Продолжить;
		КонецЕсли; 
		
		ПозицияРазделителя = СтрНайти(ТипДанных,"/");
		Если ПозицияРазделителя <> 0 Тогда
			ТипДанных = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ТипДанных, "/")[НомерВыбираемогоЭлемента-1];
		КонецЕсли;
		
		ПозицияРазделителя = СтрНайти(ИмяЗаписи,"/");
		Если ПозицияРазделителя <> 0 Тогда
			ИмяЗаписи = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЗаписи, "/")[НомерВыбираемогоЭлемента-1];
		КонецЕсли;
		
		ФорматЗаписи.ТипДанных =  ТипДанных;
		ФорматЗаписи.ЭлементНеОбязателен = ЭлементНеОбязателен;
		ФорматЗаписи.ТипЭлемента = ТипЭлемента;
		ФорматЗаписи.НеВыводитьВФайл = Ложь;
		// Размер хранится в 3 колонке.
		СтрРазмерПоля =  УзелФормата.ДочерниеУзлы[2].ТекстовоеСодержимое;
		
		Если ФорматЗаписи.ТипДанных = "КОНСТАНТА" Тогда
			
			// В колонке "размер" должно указываться значение константы.
			ФорматЗаписи.Значение = СтрРазмерПоля;
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "ЧИСЛО" Тогда
			
			ПозицияТочки = СтрНайти(СтрРазмерПоля,".");
			Если ПозицияТочки<>0 Тогда
				ФорматЗаписи.Размер = Число(Лев(СтрРазмерПоля,ПозицияТочки-1));
				ФорматЗаписи.РазрядностьДробнойЧасти = Число(Сред(СтрРазмерПоля,ПозицияТочки+1));
			Иначе	
				ФорматЗаписи.Размер = Число(СтрРазмерПоля);
				ФорматЗаписи.РазрядностьДробнойЧасти = 0;
			КонецЕсли;	 
			
			ФорматЗаписи.Значение = 0;
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "СТРОКА" Тогда
			
			ФорматЗаписи.Размер = Число(СтрРазмерПоля);
			
			ФорматЗаписи.Значение = "";
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "ДАТА" Тогда
			
			ФорматЗаписи.Значение = Дата('00010101');
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "ТАБЛИЦА" Тогда	
			
			// Имя области-описания формата полей таблицы или структуры хранится в колонке размер.
			ФорматЗаписи.Поля = ПолучитьФорматЗаписиИзДереваФормата(ДеревоФормата, СтрРазмерПоля);
			ФорматЗаписи.Значение = Новый ТаблицаЗначений;
			
			Для каждого Поле Из ФорматЗаписи.Поля Цикл
				
				Если Поле.ТипДанных = "ТАБЛИЦА" Тогда
					ФорматЗаписи.Значение.Колонки.Добавить(Поле.ИмяПоля);
				Иначе	
					Если Поле.ТипДанных = "ЧИСЛО" Тогда
						ОписаниеТиповПоля = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(Поле.Размер, Поле.РазрядностьДробнойЧасти));
					ИначеЕсли Поле.ТипДанных = "СТРОКА" Тогда
						ОписаниеТиповПоля = Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(Поле.Размер));
					ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
						ОписаниеТиповПоля = Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты.Дата));
					КонецЕсли; 
					ФорматЗаписи.Значение.Колонки.Добавить(Поле.ИмяПоля, ОписаниеТиповПоля);
				КонецЕсли;	
				
			КонецЦикла; 
				
		ИначеЕсли ФорматЗаписи.ТипДанных = "СТРУКТУРА" Тогда	
			
			ПозицияРазделителя = СтрНайти(ИмяЗаписи,"/");
			Если ПозицияРазделителя <> 0 Тогда
				ИмяЗаписи = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЗаписи, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			ПозицияРазделителя = СтрНайти(СтрРазмерПоля,"/");
			Если ПозицияРазделителя <> 0 Тогда
				СтрРазмерПоля = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрРазмерПоля, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			
			// Имя области-описания формата полей таблицы или структуры хранится в колонке размер.
			ФорматЗаписи.Поля = ПолучитьФорматЗаписиИзДереваФормата(ДеревоФормата, СтрРазмерПоля);
			ФорматЗаписи.Значение = Новый Структура;
			Для каждого Поле Из ФорматЗаписи.Поля Цикл
				
				ПустоеЗначениеПоля = Неопределено;
				Если Поле.ТипДанных = "ЧИСЛО" Тогда
					ПустоеЗначениеПоля = 0;
				ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
					ПустоеЗначениеПоля = Дата('00010101');
				Иначе
					ПустоеЗначениеПоля = "";
				КонецЕсли; 
				
				ФорматЗаписи.Значение.Вставить(Поле.ИмяПоля, ПустоеЗначениеПоля);
				
			КонецЦикла; 
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "НАБОРЗАПИСЕЙ" Тогда
			
			// Имя набора записей хранится в третьей колонке.
			ИмяНабора = УзелФормата.ДочерниеУзлы[2].ТекстовоеСодержимое;
			ПозицияРазделителя = СтрНайти(ИмяНабора,"/");
			Если ПозицияРазделителя <> 0 Тогда
				ИмяНабора = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяНабора, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			ПозицияРазделителя = СтрНайти(ИмяЗаписи,"/");
			Если ПозицияРазделителя <> 0 Тогда
				ИмяЗаписи = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЗаписи, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			ФорматЗаписи.Значение = ЗагрузитьФорматНабораЗаписей(ДеревоФормата, ИмяНабора, НомерВыбираемогоЭлемента);
			
		КонецЕсли;	
		
		ФорматНабора.Вставить(ИмяЗаписи, ФорматЗаписи);
		
	КонецЦикла;	
	
	Возврат ФорматНабора;
		
КонецФункции

// Добавляет реквизит в дерево значений, представляющее XML файл.
Процедура ДобавитьИнформациюВДерево(ДеревоВыгрузки, НаборЗаписей) Экспорт
	
	ПустаяДата = Дата(1,1,1);
	
	Для каждого ЭлементНабора Из НаборЗаписей Цикл
		ИмяЗаписи = ЭлементНабора.Ключ;
		
		Запись = ЭлементНабора.Значение;
		
		Если Запись.НеВыводитьВФайл Тогда 
			Запись.НеВыводитьВФайл = Ложь;
			Продолжить;
		КонецЕсли;
		
		ТипДанных = Запись.ТипДанных;
		Если ТипДанных = "КОНСТАНТА" Тогда
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Запись.Значение, , ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ЧИСЛО" Тогда
			
			// Для проверок
			// Запись.Размер 
			// Запись.РазрядностьДробнойЧасти
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Формат(Запись.Значение,"ЧЦ=" + Запись.Размер + "; ЧДЦ=" + Запись.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0"), , ТипДанных, Запись.Значение);
			Запись.НеВыводитьВФайл = Ложь;
		ИначеЕсли ТипДанных = "СТРОКА" Тогда
			
			// Для проверок
			// Запись.Размер 
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Запись.Значение, ,ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ДАТА" Тогда
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, ?(Запись.Значение = ПустаяДата,"00.00.0000", Формат(Запись.Значение,"ДФ=dd.MM.yyyy")), ,ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ТАБЛИЦА" Тогда	
			
			ПроверятьНеобязательныеПоля = Ложь;
			Для каждого Поле Из Запись.Поля Цикл
				ПроверятьНеобязательныеПоля = Поле.ЭлементНеОбязателен;
				Если ПроверятьНеобязательныеПоля Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла; 
			
			Для каждого СтрокаТЗ Из Запись.Значение Цикл
				
				ВыводитьНеобязательныеПоля = Ложь;
				Если ПроверятьНеобязательныеПоля Тогда
					Для каждого Поле Из Запись.Поля Цикл
						Если Поле.ЭлементНеОбязателен Тогда
							ВыводитьНеобязательныеПоля = ЗначениеЗаполнено(СтрокаТЗ[Поле.ИмяПоля]);
							Если ВыводитьНеобязательныеПоля Тогда
								Прервать;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				Атрибуты = Новый Структура;
				Для каждого Поле Из Запись.Поля Цикл
					
					Если Поле.ЭлементНеОбязателен И Не ВыводитьНеобязательныеПоля Тогда
						Продолжить;
					КонецЕсли;
					
					Данные = СтрокаТЗ[Поле.ИмяПоля];
					
					Если Поле.ТипДанных = "ЧИСЛО" Тогда
						Данные = Формат(Данные,"ЧЦ=" + Поле.Размер + "; ЧДЦ=" + Поле.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0")
					ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
						Если Не ЗначениеЗаполнено(Данные) Тогда
							Данные = ""
						Иначе
							Данные = Формат(Данные,"ДФ=dd.MM.yyyy");
						КонецЕсли;
					КонецЕсли;
					
					Если Поле.ТипЭлемента = "А" И НЕ Поле.НеВыводитьВФайл Тогда
						Атрибуты.Вставить(Поле.ИмяПоля, Данные);
					КонецЕсли;
					
				КонецЦикла;
				
				ВеткаСтрокиТЗ = ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты);
				
				Для каждого Поле Из Запись.Поля Цикл
					
					Если Поле.ТипЭлемента = "А" Тогда
						Поле.НеВыводитьВФайл = Ложь;
						Продолжить;
					КонецЕсли;
					
					Если Поле.НеВыводитьВФайл Тогда
						Поле.НеВыводитьВФайл = Ложь;
						Продолжить;
					КонецЕсли;
					
					Если Поле.ЭлементНеОбязателен И Не ВыводитьНеобязательныеПоля Тогда
						Продолжить;
					КонецЕсли;
					
					ДобавитьИнформациюВДерево(ВеткаСтрокиТЗ, СтрокаТЗ[Поле.ИмяПоля])
					
				КонецЦикла;
				
			КонецЦикла;
			
		ИначеЕсли ТипДанных = "СТРУКТУРА" Тогда	
			МассивДанных = Новый Массив;
			Атрибуты = Новый Структура;
			Для каждого Поле Из Запись.Поля Цикл
				
				Данные = Запись.Значение[Поле.ИмяПоля];
				
				Если Поле.ЭлементНеОбязателен И Не ЗначениеЗаполнено(Данные) Тогда
					Продолжить;
				КонецЕсли;
				
				ПустоеЗначение = "";
				Если Поле.ТипДанных = "ЧИСЛО" Тогда
					Если ТипЗнч(Данные) = Тип("Число") Тогда
						ПустоеЗначение = 0;	
					КонецЕсли;	
					Данные = Формат(Данные,"ЧЦ=" + Поле.Размер + "; ЧДЦ=" + Поле.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0");
				ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
					Если Не ЗначениеЗаполнено(Данные) Тогда
						Данные = ""
					Иначе
						Данные = Формат(Данные,"ДФ=dd.MM.yyyy");
						ПустоеЗначение = '00010101';
					КонецЕсли;
				КонецЕсли;
				
				Если Поле.ТипЭлемента = "А" И НЕ Поле.НеВыводитьВФайл  Тогда
					Атрибуты.Вставить(Поле.ИмяПоля, Данные);
				ИначеЕсли НЕ Поле.НеВыводитьВФайл Тогда 
					СтруктураДанных = Новый Структура;
					СтруктураДанных.Вставить("ИмяПоля", Поле.ИмяПоля);
					СтруктураДанных.Вставить("Значение", Запись.Значение[Поле.ИмяПоля]);
					СтруктураДанных.Вставить("Данные", Данные);
					СтруктураДанных.Вставить("ТипДанных", Поле.ТипДанных);
					МассивДанных.Добавить(СтруктураДанных);
				КонецЕсли;
				Поле.НеВыводитьВФайл = Ложь;
				Запись.Значение[Поле.ИмяПоля] = ПустоеЗначение;
			КонецЦикла; 
				
			ВеткаСтруктуры = ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты);
			
			Для Каждого Поле Из МассивДанных Цикл
				ДобавитьУзелВДеревоXML(ВеткаСтруктуры, Поле.ИмяПоля, Поле.Данные, ,Поле.ТипДанных, Поле.Данные);
			КонецЦикла;
			
		ИначеЕсли ТипДанных = "НАБОРЗАПИСЕЙ" Тогда
			
			Значение = Запись.Значение;
			
			Атрибуты = Новый Структура;
			Для каждого Поле Из Значение Цикл
				Если Поле.Значение.ТипЭлемента = "А" И НЕ Поле.Значение.НеВыводитьВФайл  Тогда
					Данные = Поле.Значение.Значение;
					Если Поле.Значение.ТипДанных = "ЧИСЛО" Тогда
						Данные = Формат(Данные,"ЧЦ=" + Поле.Значение.Размер + "; ЧДЦ=" + Поле.Значение.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0")
					ИначеЕсли Поле.Значение.ТипДанных = "ДАТА" Тогда
						Если Не ЗначениеЗаполнено(Данные) Тогда
							Данные = ""
						Иначе
							Данные = Формат(Данные,"ДФ=dd.MM.yyyy");
						КонецЕсли;
					КонецЕсли;
					Атрибуты.Вставить(Поле.Ключ, Данные);
					Значение.Удалить(Поле.Ключ);
				КонецЕсли;
			КонецЦикла;
			
			ДобавитьИнформациюВДерево(ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты), Значение);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Добавляет реквизит в дерево значений, представляющее XML файл.
Процедура ДобавитьИнформациюВДеревоБезУдаленияАтрибутов(ДеревоВыгрузки, НаборЗаписей) Экспорт
	
	ПустаяДата = Дата(1,1,1);
	
	Для каждого ЭлементНабора Из НаборЗаписей Цикл
		ИмяЗаписи = ЭлементНабора.Ключ;
		
		Запись = ЭлементНабора.Значение;
		
		Если Запись.НеВыводитьВФайл Тогда 
			Запись.НеВыводитьВФайл = Ложь;
			Продолжить;
		КонецЕсли;
		
		ТипДанных = Запись.ТипДанных;
		Если ТипДанных = "КОНСТАНТА" Тогда
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Запись.Значение, , ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ЧИСЛО" Тогда
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Формат(Запись.Значение,"ЧЦ=" + Запись.Размер + "; ЧДЦ=" + Запись.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0"), , ТипДанных, Запись.Значение);
			Запись.НеВыводитьВФайл = Ложь;
		ИначеЕсли ТипДанных = "СТРОКА" Тогда
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Запись.Значение, ,ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ДАТА" Тогда
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, ?(Запись.Значение = ПустаяДата,"00.00.0000", Формат(Запись.Значение,"ДФ=dd.MM.yyyy")), ,ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ТАБЛИЦА" Тогда	
			
			ПроверятьНеобязательныеПоля = Ложь;
			Для каждого Поле Из Запись.Поля Цикл
				ПроверятьНеобязательныеПоля = Поле.ЭлементНеОбязателен;
				Если ПроверятьНеобязательныеПоля Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла; 
			
			Для каждого СтрокаТЗ Из Запись.Значение Цикл
				
				ВыводитьНеобязательныеПоля = Ложь;
				Если ПроверятьНеобязательныеПоля Тогда
					Для каждого Поле Из Запись.Поля Цикл
						Если Поле.ЭлементНеОбязателен Тогда
							ВыводитьНеобязательныеПоля = ЗначениеЗаполнено(СтрокаТЗ[Поле.ИмяПоля]);
							Если ВыводитьНеобязательныеПоля Тогда
								Прервать;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
				
				Атрибуты = Новый Структура;
				Для каждого Поле Из Запись.Поля Цикл
					
					Если Поле.ЭлементНеОбязателен И Не ВыводитьНеобязательныеПоля Тогда
						Продолжить;
					КонецЕсли;
					
					Данные = СтрокаТЗ[Поле.ИмяПоля];
					
					Если Поле.ТипДанных = "ЧИСЛО" Тогда
						Данные = Формат(Данные,"ЧЦ=" + Поле.Размер + "; ЧДЦ=" + Поле.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0")
					ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
						Если Не ЗначениеЗаполнено(Данные) Тогда
							Данные = ""
						Иначе
							Данные = Формат(Данные,"ДФ=dd.MM.yyyy");
						КонецЕсли;
					КонецЕсли;
					
					Если Поле.ТипЭлемента = "А" И НЕ Поле.НеВыводитьВФайл Тогда
						Атрибуты.Вставить(Поле.ИмяПоля, Данные);
					КонецЕсли;
					
				КонецЦикла;
				
				ВеткаСтрокиТЗ = ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты);
				
				Для каждого Поле Из Запись.Поля Цикл
					
					Если Поле.ТипЭлемента = "А" Тогда
						Поле.НеВыводитьВФайл = Ложь;
						Продолжить;
					КонецЕсли;
					
					Если Поле.НеВыводитьВФайл Тогда
						Поле.НеВыводитьВФайл = Ложь;
						Продолжить;
					КонецЕсли;
					
					Если Поле.ЭлементНеОбязателен И Не ВыводитьНеобязательныеПоля Тогда
						Продолжить;
					КонецЕсли;
					
					ДобавитьИнформациюВДерево(ВеткаСтрокиТЗ, СтрокаТЗ[Поле.ИмяПоля])
					
				КонецЦикла;
				
			КонецЦикла;
			
		ИначеЕсли ТипДанных = "СТРУКТУРА" Тогда	
			МассивДанных = Новый Массив;
			Атрибуты = Новый Структура;
			Для каждого Поле Из Запись.Поля Цикл
				
				Данные = Запись.Значение[Поле.ИмяПоля];
				
				Если Поле.ЭлементНеОбязателен И Не ЗначениеЗаполнено(Данные) Тогда
					Продолжить;
				КонецЕсли;
				
				ПустоеЗначение = "";
				Если Поле.ТипДанных = "ЧИСЛО" Тогда
					Если ТипЗнч(Данные) = Тип("Число") Тогда
						ПустоеЗначение = 0;	
					КонецЕсли;	
					Данные = Формат(Данные,"ЧЦ=" + Поле.Размер + "; ЧДЦ=" + Поле.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0");
				ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
					Если Не ЗначениеЗаполнено(Данные) Тогда
						Данные = ""
					Иначе
						Данные = Формат(Данные,"ДФ=dd.MM.yyyy");
						ПустоеЗначение = '00010101';
					КонецЕсли;
				КонецЕсли;
				
				Если Поле.ТипЭлемента = "А" И НЕ Поле.НеВыводитьВФайл  Тогда
					Атрибуты.Вставить(Поле.ИмяПоля, Данные);
				ИначеЕсли НЕ Поле.НеВыводитьВФайл Тогда 
					СтруктураДанных = Новый Структура;
					СтруктураДанных.Вставить("ИмяПоля", Поле.ИмяПоля);
					СтруктураДанных.Вставить("Значение", Запись.Значение[Поле.ИмяПоля]);
					СтруктураДанных.Вставить("Данные", Данные);
					СтруктураДанных.Вставить("ТипДанных", Поле.ТипДанных);
					МассивДанных.Добавить(СтруктураДанных);
				КонецЕсли;
				Поле.НеВыводитьВФайл = Ложь;
				Запись.Значение[Поле.ИмяПоля] = ПустоеЗначение;
			КонецЦикла; 
				
			ВеткаСтруктуры = ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты);
			
			Для Каждого Поле Из МассивДанных Цикл
				ДобавитьУзелВДеревоXML(ВеткаСтруктуры, Поле.ИмяПоля, Поле.Данные, ,Поле.ТипДанных, Поле.Данные);
			КонецЦикла;
			
		ИначеЕсли ТипДанных = "НАБОРЗАПИСЕЙ" Тогда
			
			Значение = Запись.Значение;
			
			Атрибуты = Новый Структура;
			Для каждого Поле Из Значение Цикл
				Если Поле.Значение.ТипЭлемента = "А" И НЕ Поле.Значение.НеВыводитьВФайл  Тогда
					Данные = Поле.Значение.Значение;
					Если Поле.Значение.ТипДанных = "ЧИСЛО" Тогда
						Данные = Формат(Данные,"ЧЦ=" + Поле.Значение.Размер + "; ЧДЦ=" + Поле.Значение.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0")
					ИначеЕсли Поле.Значение.ТипДанных = "ДАТА" Тогда
						Если Не ЗначениеЗаполнено(Данные) Тогда
							Данные = ""
						Иначе
							Данные = Формат(Данные,"ДФ=dd.MM.yyyy");
						КонецЕсли;
					КонецЕсли;
					Атрибуты.Вставить(Поле.Ключ, Данные);
					Поле.Значение.НеВыводитьВФайл = Истина;
				КонецЕсли;
			КонецЦикла;
			
			ДобавитьИнформациюВДерево(ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты), Значение);
			
			Для каждого Поле Из Значение Цикл
				Если Поле.Значение.ТипЭлемента = "А" Тогда
					Поле.Значение.НеВыводитьВФайл = Ложь;
				КонецЕсли;
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

// Проверяет корректность вводимых дат, не проверяет заполненность дат.
//  При нахождении ошибки формирует сообщение пользователю, взводит флаг Отказ.
//
// Параметры:
//  Ссылка						 - 	 - ДокументСсылка, СправочникСсылка
//  ПроверяемаяДата				 - 	 - Дата
//  ПутьКПроверяемойДате		 - 	 - Строка
//  Отказ						 - 	 - Булево
//  ПредставлениеПроверяемойДаты - 	 - Строка
//  МинимальноеЗначение			 - 	 - Дата
//  ПредставлениеМинимальнойДаты - 	 - Строка
//  ПроверятьПустыеДаты			 - 	 - Булево, если Ложь то будет проверяться только заполненная дата.
//
Процедура ПроверитьКорректностьДаты(Ссылка, ПроверяемаяДата, ПутьКПроверяемойДате, Отказ, ПредставлениеПроверяемойДаты = "", МинимальноеЗначение = '19000101', ПредставлениеМинимальнойДаты = "", ПроверятьПустыеДаты = Истина) Экспорт
	
	Если (ПроверятьПустыеДаты Или ЗначениеЗаполнено(ПроверяемаяДата))
		И ПроверяемаяДата < НачалоДня(МинимальноеЗначение) Тогда
		
		Если ПустаяСтрока(ПредставлениеПроверяемойДаты) Тогда
			ТекстСообщения = НСтр("ru = 'Дата'") + " " + Формат(ПроверяемаяДата, "ДЛФ=DD");
		Иначе
			ТекстСообщения = ПредставлениеПроверяемойДаты + " (" + Формат(ПроверяемаяДата, "ДЛФ=DD") + ")";
		КонецЕсли;
		
		ТекстСообщения = ТекстСообщения + " " + НСтр("ru = 'не может быть меньше'") + " ";
		
		Если ПустаяСтрока(ПредставлениеМинимальнойДаты) Тогда
			ТекстСообщения = ТекстСообщения + Формат(МинимальноеЗначение, "ДЛФ=DD");
		Иначе
			ТекстСообщения = ТекстСообщения + ПредставлениеМинимальнойДаты + " (" + Формат(МинимальноеЗначение, "ДЛФ=DD") + ")"
		КонецЕсли;
		
		ОбщегоНазначения.СообщитьПользователю(
			ТекстСообщения,
			Ссылка,
			ПутьКПроверяемойДате,
			,
			Отказ);
		
	КонецЕсли;
	
КонецПроцедуры

Процедура ЗаполнитьДанныеПодписанта(Объект, ПолеПодписанта, ПолеДолжностиПодписанта) Экспорт
	ЗарплатаКадрыВнутренний.ЗаполнитьДанныеПодписанта(Объект, ПолеПодписанта, ПолеДолжностиПодписанта);	
КонецПроцедуры

// Проверяет наличие колонке в строке коллекции, используемой при расчете.
//
// Параметры:
//	СтрокаКоллекции - строка таблицы расчетного документа.
//	ИмяПоля - имя поля, наличие которого необходимо выяснить.
//
// Возвращаемое значение - Истина, если поле есть, Ложь - в противном случае.
//
Функция ЕстьПолеВСтрокеКоллекции(СтрокаКоллекции, ИмяПоля) Экспорт
	
	Если ТипЗнч(СтрокаКоллекции) = Тип("СтрокаТаблицыЗначений") Тогда
		Возврат СтрокаКоллекции.Владелец().Колонки.Найти(ИмяПоля) <> Неопределено;
	Иначе
		Возврат СтрокаКоллекции.Свойство(ИмяПоля);
	КонецЕсли;
	
КонецФункции

// Формирует таблицу значений с параметрами отпусков сотрудника для расчета оценочных обязательств
//	Параметры
//		МассивСотрудников
//		Период - месяц, для которого рассчитываются обязательства
//	Возвращаемое значение Таблица значений
//			* Сотрудник
//			* ОстатокОтпусков
//			* ОтпускАвансом
//			* СреднийЗаработок
//
Функция СведенияОбОтпускахСотрудниковДляРасчетаОценочныхОбязательств(МассивСотрудников, Период) Экспорт

	Возврат ЗарплатаКадрыВнутренний.СведенияОбОтпускахСотрудниковДляРасчетаОценочныхОбязательств(МассивСотрудников, Период);

КонецФункции

#КонецОбласти


#Область СлужебныеПроцедурыИФункции

// Проверяет корректность вводимых дат, не проверяет заполненность дат.
// При нахождении ошибки формирует сообщение пользователю, взводит флаг Отказ.
//
// Параметры:
//	Ссылка									- ДокументСсылка
//											- СправочникСсылка
//	ПроверяемыйМесяц						- Дата
//	ПутьКПроверяемомуМесяцу					- Строка
//	Отказ									- Булево
//	ПредставлениеПроверяемогоМесяца			- Строка
//	МинимальноеЗначение						- Дата
//	ПредставлениеМинимальногоЗначенияМесяца	- Строка
//	ПроверятьПустыеМесяцы					- Булево, если Ложь то будет проверяться только заполненная дата.
//
Процедура ПроверитьКорректностьМесяца(Ссылка, ПроверяемыйМесяц, ПутьКПроверяемомуМесяцу, Отказ, ПредставлениеПроверяемогоМесяца = "", МинимальноеЗначение = '19000101', ПредставлениеМинимальногоЗначенияМесяца = "", ПроверятьПустыеМесяцы = Истина) Экспорт
	
	Если (ПроверятьПустыеМесяцы Или ЗначениеЗаполнено(ПроверяемыйМесяц))
		И ПроверяемыйМесяц < НачалоМесяца(МинимальноеЗначение) Тогда
		
		Если ПустаяСтрока(ПредставлениеПроверяемогоМесяца) Тогда
			ТекстСообщения = НСтр("ru='Месяц'") + " " + Формат(ПроверяемыйМесяц, "ДФ='ММММ гггг'");
		Иначе
			ТекстСообщения = ПредставлениеПроверяемогоМесяца + " (" + Формат(ПроверяемыйМесяц, "ДФ='ММММ гггг'") + ")";
		КонецЕсли;
		
		ТекстСообщения = ТекстСообщения + " " + НСтр("ru='не может быть меньше'") + " ";
		
		Если ПустаяСтрока(ПредставлениеМинимальногоЗначенияМесяца) Тогда
			ТекстСообщения = ТекстСообщения + Формат(МинимальноеЗначение, "ДФ='ММММ гггг'");
		Иначе
			ТекстСообщения = ТекстСообщения + ПредставлениеМинимальногоЗначенияМесяца + " (" + Формат(МинимальноеЗначение, "ДФ='ММММ гггг'") + ")"
		КонецЕсли;
		
		ОбщегоНазначения.СообщитьПользователю(
			ТекстСообщения,
			Ссылка,
			ПутьКПроверяемомуМесяцу,
			,
			Отказ);
		
	КонецЕсли;
	
КонецПроцедуры

// Проверяет корректность указанной даты выплаты, которая должна быть не меньшее даты документа
// Подразумевается, что документ содержит реквизит ПланируемаяДатаВыплаты.
//
// Параметры:
//	Объект		- ДокументОбъект
//	Отказ		- Булево
//
Процедура ПроверитьДатуВыплаты(Объект, Отказ) Экспорт
	
	ПроверитьКорректностьДаты(
		Объект.Ссылка, Объект.ПланируемаяДатаВыплаты, "ПланируемаяДатаВыплаты", Отказ, НСтр("ru='Планируемая дата выплаты'"),
		Объект.Дата, НСтр("ru='даты документа'"));
	
КонецПроцедуры

Процедура ПроверитьВозможностьСменыГоловнойОрганизации(Организация, Отказ) Экспорт
	
	ЗарплатаКадрыВнутренний.ПроверитьВозможностьСменыГоловнойОрганизации(Организация, Отказ);
	
КонецПроцедуры

Функция ОписанияРегистровСодержащихРегистрацииВНалоговомОргане() Экспорт
	
	Возврат ЗарплатаКадрыВнутренний.ОписанияРегистровСодержащихРегистрацииВНалоговомОргане();
	
КонецФункции

Процедура ДобавитьОписаниеРегистровСодержащихРегистрацииВНалоговомОргане(МассивОписаний, ПолноеИмяРегистра, ПутьКПолюПериод) Экспорт
	
	МассивОписаний.Добавить(Новый Структура("ПолноеИмяРегистра,ПутьКПолюПериод", ПолноеИмяРегистра, ПутьКПолюПериод));
	
КонецПроцедуры

Функция УсловияЗапросаПроверкиНеобходимостиЗаполненияПодчиненныхПодразделений(Запрос, ИсточникДанных)
	
	Возврат ЗарплатаКадрыВнутренний.УсловияЗапросаПроверкиНеобходимостиЗаполненияПодчиненныхПодразделений(Запрос, ИсточникДанных);

КонецФункции

Процедура ЗаполнитьПодчиненноеПодразделение(ПодразделениеОбъект, ИсточникДанных)
	
	ЗарплатаКадрыВнутренний.ЗаполнитьПодчиненноеПодразделение(ПодразделениеОбъект, ИсточникДанных);
		
КонецПроцедуры

Процедура ДобавитьПодменю(Форма, ОписаниеМеню, ГруппаПодменю)
	
	Если НЕ ПустаяСтрока(ОписаниеМеню.Заголовок) Тогда
		ГруппаПодменю.Заголовок = ОписаниеМеню.Заголовок;
	КонецЕсли; 
	
	Счетчик = 1;
	ГруппаПодменюДляРазмещенияПунктов = ГруппаПодменю;
	Для каждого ПунктМеню Из ОписаниеМеню.Пункты Цикл
		
		Если ПунктМеню.Вид = ВидГруппыФормы.Подменю Тогда
			
			ГруппаПодменю = Форма.Элементы.Добавить(ГруппаПодменюДляРазмещенияПунктов.Имя +  "Группа" + Счетчик, Тип("ГруппаФормы"), ГруппаПодменюДляРазмещенияПунктов);
			ГруппаПодменю.Вид = ПунктМеню.Вид;
			
			ДобавитьПодменю(Форма, ПунктМеню, ГруппаПодменю);
			
		ИначеЕсли ПунктМеню.Вид = ВидКнопкиФормы.КнопкаКоманднойПанели Тогда
			
			ДобавитьПунктМеню(Форма, ПунктМеню, ГруппаПодменюДляРазмещенияПунктов);
			
		Иначе
			
			ГруппаПодменюДляРазмещенияПунктов = Форма.Элементы.Добавить(ГруппаПодменюДляРазмещенияПунктов.Имя + "Разделитель" + Счетчик, Тип("ГруппаФормы"), ГруппаПодменюДляРазмещенияПунктов);
			ГруппаПодменюДляРазмещенияПунктов.Вид = ВидГруппыФормы.ГруппаКнопок;
			
		КонецЕсли; 
		
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьПунктМеню(Форма, ОписаниеМеню, ГруппаПодменю)
	
	Команда = Форма.Команды.Найти(ОписаниеМеню.ИмяКоманды);
	Если Команда = Неопределено Тогда
		Команда = Форма.Команды.Добавить(ОписаниеМеню.ИмяКоманды);
		Команда.Заголовок = ОписаниеМеню.Заголовок;
		Команда.Действие = ОписаниеМеню.Действие;
	КонецЕсли; 
	
	КнопкаФормы = Форма.Элементы.Добавить(ГруппаПодменю.Имя + ОписаниеМеню.ИмяКоманды, Тип("КнопкаФормы"), ГруппаПодменю);
	КнопкаФормы.Вид = ОписаниеМеню.Вид;
	КнопкаФормы.ИмяКоманды = ОписаниеМеню.ИмяКоманды;
	
КонецПроцедуры

Процедура ЗаполнитьЗначениеРеквизитаОрганизацияПриОднофирменномУчете(Источник, ИмяРеквизитаОрганизация = "Организация") Экспорт

	СтандартнаяОбработка = Истина;
	ЗарплатаКадрыПереопределяемый.ЗаполнитьРеквизитОрганизацияПриОднофирменномУчете(Источник, СтандартнаяОбработка, ИмяРеквизитаОрганизация);
	
	Если СтандартнаяОбработка Тогда 
		
		Если ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоОрганизацийЗарплатаКадрыБазовая") 
			Или Источник.Метаданные().Реквизиты.Найти(ИмяРеквизитаОрганизация) = Неопределено  
			Или ЗначениеЗаполнено(Источник[ИмяРеквизитаОрганизация]) Тогда 
			Возврат;
		КонецЕсли;
	
		Источник[ИмяРеквизитаОрганизация] = Справочники.Организации.ОрганизацияПоУмолчанию();
		
	КонецЕсли;
	
КонецПроцедуры

Функция ДоступныеОрганизации() Экспорт
	
	Если Не ПривилегированныйРежим()
		И УправлениеДоступом.ОграничиватьДоступНаУровнеЗаписей()
		И Не Пользователи.ЭтоПолноправныйПользователь() Тогда
		
		Возврат ЗарплатаКадрыПовтИсп.ДоступныеОрганизации();
		
	КонецЕсли;
	
	Возврат Новый Структура("Организации,Филиалы");
	
КонецФункции

Процедура СообщитьОНевозможностиИППриниматьНаРаботуСамогоСебя() Экспорт
	
	ВызватьИсключение НСтр("ru='В качестве сотрудника указан индивидуальный предприниматель.
		|Индивидуальному предпринимателю принимать себя на работу не требуется.'");
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////////////////////////
// Работа с личными данными физических лиц.

Процедура ОбработатьЗаписьНабораФИО(НаборЗаписей) Экспорт
	ТаблицаФизЛиц = НаборЗаписей.Выгрузить();
	ОбновитьНаименованияФизЛицаИСотрудника(ТаблицаФизЛиц);	
КонецПроцедуры

Процедура ОбновитьНаименованияФизЛицаИСотрудника(ТаблицаФизЛиц) Экспорт
	
 	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	
	Запрос.УстановитьПараметр("ТекущаяДата", '20990101');
	Запрос.УстановитьПараметр("ТекущийНабор", ТаблицаФизЛиц);
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ТекущийНабор.ФизическоеЛицо
	|ПОМЕСТИТЬ ВТФизЛицаТекущегоНабора
	|ИЗ
	|	&ТекущийНабор КАК ТекущийНабор
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ФИОФизическихЛицСрезПоследних.ФизическоеЛицо,
	|	ФИОФизическихЛицСрезПоследних.Фамилия,
	|	ФИОФизическихЛицСрезПоследних.Имя,
	|	ФИОФизическихЛицСрезПоследних.Отчество
	|ПОМЕСТИТЬ ВТФИОФизЛицПоследнее
	|ИЗ
	|	ВТФизЛицаТекущегоНабора КАК ФизЛицаТекущегоНабора
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизическихЛиц.СрезПоследних(
	|				&ТекущаяДата,
	|				ФизическоеЛицо В
	|					(ВЫБРАТЬ
	|						ФизЛицаТекущегоНабора.ФизическоеЛицо
	|					ИЗ
	|						ВТФизЛицаТекущегоНабора КАК ФизЛицаТекущегоНабора)) КАК ФИОФизическихЛицСрезПоследних
	|		ПО ФизЛицаТекущегоНабора.ФизическоеЛицо = ФИОФизическихЛицСрезПоследних.ФизическоеЛицо
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ФИОФизЛицПоследнее.ФизическоеЛицо,
	|	ФИОФизЛицПоследнее.Фамилия,
	|	ФИОФизЛицПоследнее.Имя,
	|	ФИОФизЛицПоследнее.Отчество,
	|	ФизическиеЛица.Наименование,
	|	ФизическиеЛица.УточнениеНаименования
	|ИЗ
	|	ВТФИОФизЛицПоследнее КАК ФИОФизЛицПоследнее
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ФизическиеЛица КАК ФизическиеЛица
	|		ПО (ФИОФизЛицПоследнее.ФизическоеЛицо = ФизическиеЛица.Ссылка
	|				И (ФизическиеЛица.Наименование <> (ВЫРАЗИТЬ(ФИОФизЛицПоследнее.Фамилия + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Имя = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Имя
	|						КОНЕЦ + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Отчество = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Отчество
	|						КОНЕЦ + ВЫБОР
	|							КОГДА ФизическиеЛица.УточнениеНаименования = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФизическиеЛица.УточнениеНаименования
	|						КОНЕЦ КАК СТРОКА(50)))
	|					ИЛИ ФизическиеЛица.ФИО <> (ВЫРАЗИТЬ(ФИОФизЛицПоследнее.Фамилия + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Имя = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Имя
	|						КОНЕЦ + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Отчество = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Отчество
	|						КОНЕЦ КАК СТРОКА(50)))))
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Сотрудники.Ссылка КАК Сотрудник,
	|	ФИОФизЛицПоследнее.Фамилия,
	|	ФИОФизЛицПоследнее.Имя,
	|	ФИОФизЛицПоследнее.Отчество,
	|	Сотрудники.УточнениеНаименования,
	|	Сотрудники.Наименование КАК СотрудникНаименование,
	|	ФизическиеЛица.УточнениеНаименования КАК УточнениеНаименованияФизЛица
	|ИЗ
	|	ВТФИОФизЛицПоследнее КАК ФИОФизЛицПоследнее
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Сотрудники КАК Сотрудники
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ФизическиеЛица КАК ФизическиеЛица
	|			ПО Сотрудники.ФизическоеЛицо = ФизическиеЛица.Ссылка
	|		ПО ФИОФизЛицПоследнее.ФизическоеЛицо = Сотрудники.ФизическоеЛицо
	|			И (Сотрудники.Наименование <> (ВЫРАЗИТЬ(ФИОФизЛицПоследнее.Фамилия + ВЫБОР
	|					КОГДА ФИОФизЛицПоследнее.Имя = """"
	|						ТОГДА """"
	|					ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Имя
	|				КОНЕЦ + ВЫБОР
	|					КОГДА ФИОФизЛицПоследнее.Отчество = """"
	|						ТОГДА """"
	|					ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Отчество
	|				КОНЕЦ + ВЫБОР
	|					КОГДА ФизическиеЛица.УточнениеНаименования = """"
	|						ТОГДА """"
	|					ИНАЧЕ "" "" + ФизическиеЛица.УточнениеНаименования
	|				КОНЕЦ + ВЫБОР
	|					КОГДА Сотрудники.УточнениеНаименования = """"
	|						ТОГДА """"
	|					ИНАЧЕ "" "" + Сотрудники.УточнениеНаименования
	|				КОНЕЦ КАК СТРОКА(50))))";
				   
	Результат = Запрос.ВыполнитьПакет();
	
	ИзменитьНаименованиеФизическихЛиц(Результат[2].Выбрать());
	ИзменитьНаименованиеСотрудников(Результат[3].Выбрать());
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыКорпоративнаяПодсистемы.ПодборПерсонала") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ПодборПерсонала");
		Модуль.ИзменитьНаименованиеКандидатов(МенеджерВременныхТаблиц);
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	
КонецПроцедуры

Процедура ИзменитьНаименованиеФизическихЛиц(ДанныеФИО)
	
	Пока ДанныеФИО.Следующий() Цикл
		
		Если ДанныеФИО.Наименование = КадровыйУчетКлиентСервер.ПолноеНаименованиеСотрудника(ДанныеФИО.Фамилия, ДанныеФИО.Имя, ДанныеФИО.Отчество, ДанныеФИО.УточнениеНаименования) Тогда
			Продолжить;
		КонецЕсли;
		
		ФизЛицоОбъект = ДанныеФИО.ФизическоеЛицо.ПолучитьОбъект();
		
		Попытка
			ФизЛицоОбъект.Заблокировать();
		Исключение
			Отказ = Истина;
			ТекстИсключенияЗаписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось изменить имя физического лица %1.
			|Возможно, данные сотрудника редактируются другим пользователем'"),
			ФизЛицоОбъект.Наименование);
			ВызватьИсключение ТекстИсключенияЗаписи;
			
		КонецПопытки;
		
		ФизЛицоОбъект.Наименование = КадровыйУчетКлиентСервер.ПолноеНаименованиеСотрудника(
				ДанныеФИО.Фамилия,
				ДанныеФИО.Имя,
				ДанныеФИО.Отчество,
				ДанныеФИО.УточнениеНаименования);
		
		ФизЛицоОбъект.Записать();
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ИзменитьНаименованиеСотрудников(ДанныеФИО)
	
	Пока ДанныеФИО.Следующий() Цикл
		
		ПолноеНаименованиеСотрудника = КадровыйУчетКлиентСервер.ПолноеНаименованиеСотрудника(
			ДанныеФИО.Фамилия,
			ДанныеФИО.Имя,
			ДанныеФИО.Отчество,
			ДанныеФИО.УточнениеНаименованияФизЛица,
			ДанныеФИО.УточнениеНаименования);
		
		Если ДанныеФИО.СотрудникНаименование = ПолноеНаименованиеСотрудника Тогда
			Продолжить;
		КонецЕсли;
		
		СотрудникОбъект = ДанныеФИО.Сотрудник.ПолучитьОбъект();
		
		Попытка
			СотрудникОбъект.Заблокировать();
		Исключение
			Отказ = Истина;
			ТекстИсключенияЗаписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось изменить имя сотрудника %1.
			|Возможно, данные сотрудника редактируются другим пользователем'"),
			СотрудникОбъект.Наименование);
			ВызватьИсключение ТекстИсключенияЗаписи;
			
		КонецПопытки;
		
		СотрудникОбъект.Наименование = ПолноеНаименованиеСотрудника;
		
		СотрудникОбъект.Записать();
	КонецЦикла;
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// Прочие процедуры и функции

Функция КоличествоНеОпределенныхЗначений(ЗаполняемыеЗначения)
	
	Количество = 0;
	
	Для Каждого КлючЗначение Из ЗаполняемыеЗначения Цикл
		Если НЕ ЗначениеЗаполнено(КлючЗначение.Значение) Тогда
			Количество = Количество + 1;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Количество;
	
КонецФункции

Процедура ПрочитатьПериодическиеСведенияОрганизации(Форма)
	
	РедактированиеПериодическихСведений.ПрочитатьЗаписьДляРедактированияВФорме(Форма, "ИсторияРегистрацийВОрганеПФР", Форма.ОрганизацияСсылка);
	Форма.ИсторияРегистрацийВОрганеПФРПериодСтрокой = ЗарплатаКадрыКлиентСервер.ПолучитьПредставлениеКвартала(Форма.ИсторияРегистрацийВОрганеПФР.Период);
	
	РедактированиеПериодическихСведений.ПрочитатьЗаписьДляРедактированияВФорме(Форма, "ТерриториальныеУсловияПФР", Форма.ОрганизацияСсылка);
	
КонецПроцедуры

Процедура ЗаписатьПериодическиеСведенияОрганизации(Форма)
	
	РедактированиеПериодическихСведений.ЗаписатьЗаписьПослеРедактированияВФорме(Форма, "ИсторияРегистрацийВОрганеПФР", Форма.ОрганизацияСсылка);
	РедактированиеПериодическихСведений.ЗаписатьЗаписьПослеРедактированияВФорме(Форма, "ТерриториальныеУсловияПФР", Форма.ОрганизацияСсылка);
	
КонецПроцедуры

Функция ПолучитьФорматЗаписиИзДереваФормата(Знач ДеревоФормата, Знач ИмяЗаписи)
	
	ТаблицаФормаЗаписи = Новый ТаблицаЗначений;
	ТаблицаФормаЗаписи.Колонки.Добавить("ИмяПоля",					Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(100)));
	ТаблицаФормаЗаписи.Колонки.Добавить("ТипДанных",				Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(10)));
	ТаблицаФормаЗаписи.Колонки.Добавить("ТипЭлемента",				Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(10)));
	ТаблицаФормаЗаписи.Колонки.Добавить("Размер",					Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5)));
	ТаблицаФормаЗаписи.Колонки.Добавить("РазрядностьДробнойЧасти",	Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5)));
	ТаблицаФормаЗаписи.Колонки.Добавить("ЭлементНеОбязателен", Новый ОписаниеТипов("Булево"));
	ТаблицаФормаЗаписи.Колонки.Добавить("НеВыводитьВФайл", Новый ОписаниеТипов("Булево"));
	
	УзлыФормата = ДеревоФормата.ДочерниеУзлы[0].ПолучитьЭлементыПоИмени(ИмяЗаписи)[0].ДочерниеУзлы;
	
	Для Каждого УзелФормата Из УзлыФормата Цикл
		
		Если ТипЗнч(УзелФормата) <> Тип("ЭлементDOM") Тогда
			Продолжить;
		КонецЕсли;
		
		// Имя поля хранится в 4-ой колонке.
		ИмяПоля = УзелФормата.ДочерниеУзлы[3].ТекстовоеСодержимое;
		Если ИмяПоля <> "" Тогда
			
			НовоеПоле = ТаблицаФормаЗаписи.Добавить();
			НовоеПоле.ИмяПоля = СокрЛП(ИмяПоля);
			// Тип данных хранится во 2-ой колонке.
			НовоеПоле.ТипДанных = ВРег(УзелФормата.ДочерниеУзлы[1].ТекстовоеСодержимое);
			
			НовоеПоле.НеВыводитьВФайл = Ложь;
			
			Если УзелФормата.ДочерниеУзлы.Количество() = 7 И УзелФормата.ДочерниеУзлы[6].ИмяУзла = "ТипЭлемента" Тогда
				НовоеПоле.ТипЭлемента = ВРег(УзелФормата.ДочерниеУзлы[6].ТекстовоеСодержимое);
			Иначе
				НовоеПоле.ТипЭлемента = "С";
			КонецЕсли;	
			
			// Размер поля хранится в 3-ей колонке.
			СтрРазмерПоля = УзелФормата.ДочерниеУзлы[2].ТекстовоеСодержимое;
			// Если указан размер поля, сохраним его.
			Если (НовоеПоле.ТипДанных = "ЧИСЛО" Или НовоеПоле.ТипДанных = "СТРОКА") И СтрРазмерПоля <> "" Тогда
				ПозицияТочки = СтрНайти(СтрРазмерПоля,".");
				Если ПозицияТочки<>0 Тогда
					НовоеПоле.Размер = Число(Лев(СтрРазмерПоля,ПозицияТочки-1));
					НовоеПоле.РазрядностьДробнойЧасти = Число(Сред(СтрРазмерПоля,ПозицияТочки+1));
				Иначе	
					НовоеПоле.Размер = Число(СтрРазмерПоля);
					НовоеПоле.РазрядностьДробнойЧасти = 0;
				КонецЕсли;	 
			КонецЕсли;	 
			// Признак обязательности элемента хранится в 5-й колонке.
			НовоеПоле.ЭлементНеОбязателен = (ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "НЕ ОБЯЗАТЕЛЬНО" Или ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "Н");
			
		КонецЕсли;	 
		
	КонецЦикла;
	
	Возврат ТаблицаФормаЗаписи;
КонецФункции

Функция РегистраторыПереносаДанных() Экспорт
	Возврат ЗарплатаКадрыВнутренний.РегистраторыПереносаДанных();
КонецФункции

// Возвращает поля представления по метаданным, используется при обработке получения данных выбора.
Функция ПоляПредставления(МетаданныеОбъекта)
	
	ПоляПредставления = Новый Структура("ПолеОсновногоПредставления,ПолеДопПредставления","","");
	
	Если МетаданныеОбъекта.ОсновноеПредставление = Метаданные.СвойстваОбъектов.ОсновноеПредставлениеСправочника.ВВидеНаименования 
		И МетаданныеОбъекта.ДлинаНаименования > 0 Тогда 
		ПоляПредставления.ПолеОсновногоПредставления = "Наименование";
		Если МетаданныеОбъекта.ДлинаКода > 0 Тогда
			ПоляПредставления.ПолеДопПредставления = "Код";
		КонецЕсли;
	ИначеЕсли МетаданныеОбъекта.ДлинаКода > 0 Тогда
		ПоляПредставления.ПолеОсновногоПредставления = "Код";
		Если МетаданныеОбъекта.ДлинаНаименования > 0 Тогда
			ПоляПредставления.ПолеДопПредставления = "Наименование";
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПоляПредставления;	
	
КонецФункции

// Возвращает представления выбираемого элемента, используется при обработке получения данных выбора.
Функция ПредставлениеВыбираемогоЭлемента(Выборка, ПоляПредставления, ПолеПоиска = Неопределено)
	
	Представление = "";
	
	Если ПолеПоиска = Неопределено Тогда
		Если ПустаяСтрока(ПоляПредставления.ПолеДопПредставления) Тогда
			Представление = СокрЛП(Выборка[ПоляПредставления.ПолеОсновногоПредставления]);
		Иначе
			Представление = СокрЛП(Выборка[ПоляПредставления.ПолеОсновногоПредставления]) + " (" + СокрЛП(Выборка[ПоляПредставления.ПолеДопПредставления]) + ")";
		КонецЕсли;
	Иначе 		
		Если ПоляПредставления.ПолеОсновногоПредставления = ПолеПоиска Тогда
			Если ПустаяСтрока(ПоляПредставления.ПолеДопПредставления) Тогда
				Представление = СокрЛП(Выборка[ПоляПредставления.ПолеОсновногоПредставления]);
			Иначе
				Представление = СокрЛП(Выборка[ПоляПредставления.ПолеОсновногоПредставления]) + " (" + СокрЛП(Выборка[ПоляПредставления.ПолеДопПредставления]) + ")";
			КонецЕсли;
		ИначеЕсли ПоляПредставления.ПолеДопПредставления = ПолеПоиска Тогда
			Представление = Выборка[ПоляПредставления.ПолеДопПредставления] + " (" + СокрЛП(Выборка[ПоляПредставления.ПолеОсновногоПредставления]) + ")";
		Иначе
			Представление = Выборка.ПолеПоиска + " (" + СокрЛП(Выборка[ПоляПредставления.ПолеОсновногоПредставления]) + ")";
		КонецЕсли; 
	КонецЕсли;
	
	Возврат Представление;	
	
КонецФункции 

// Возвращает структуру простейшего элемента меню.
//
// Параметры:
//			ВидЭлемента - значения системных перечислений:
//						ВидГруппыФормы.Подменю
//						ВидКнопкиФормы.КнопкаКоманднойПанели.
//			Заголовок
//
// ВозвращаемоеЗначение:
//			Структура - содержит ключи Вид и Заголовок.
//
Функция ЭлементМеню(ВидЭлемента = Неопределено, Заголовок = "")
	
	ОписаниеЭлемента = Новый Структура;
	ОписаниеЭлемента.Вставить("Вид", ВидЭлемента);
	ОписаниеЭлемента.Вставить("Заголовок", Заголовок);
	
	Возврат ОписаниеЭлемента;
	
КонецФункции

#Область РасчетПериодовСостоянийСотрудников

#Область МетодыДляРаботыСВыборкойДанныхПервичногоРегистра

Функция ЗначенияИзмеренийПериодовСостояний(ОписаниеРегистра)
	СтруктураЗначенийИзмерений = Новый Структура;
	
	Для Каждого Измерение Из ОписаниеРегистра.Измерения Цикл
		СтруктураЗначенийИзмерений.Вставить(Измерение);			
	КонецЦикла;	
	
	СтруктураЗначенийИзмерений.Вставить("Год");
	
	Возврат СтруктураЗначенийИзмерений;
КонецФункции	

#КонецОбласти

#Область РасчетЗаписейРегистраВторичныхДанных

Функция ВыборкаРассчитанныеПериодыСостояний(ЗначенияИзмерений, ОписаниеРегистра) Экспорт
	
	МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	СоздатьВТПоТаблицеЗначений(МенеджерВременныхТаблиц, ЗначенияИзмерений, "ВТЗначенияИзмеренийГода"); 
	Запрос = ЗапросВТПервичныеДанные(МенеджерВременныхТаблиц, ОписаниеРегистра, ЗначенияИзмерений);
	Результат = Запрос.Выполнить();
	ОткрытыеИнтервалы = Результат.Выгрузить();
	СоздатьВТЗакрытыеИнтервалы(ОткрытыеИнтервалы, МенеджерВременныхТаблиц, ОписаниеРегистра);
	
	Запрос = ЗапросРассчитанныеДаты(МенеджерВременныхТаблиц, ОписаниеРегистра);
	Результат = Запрос.Выполнить();
		
	Возврат Результат.Выбрать();
	
КонецФункции

Процедура СоздатьВТЗакрытыеИнтервалы(ОткрытыеИнтервалы, МенеджерВременныхТаблиц, ОписаниеРегистра)

	МассивОткрытыхИнтервалов = Новый Массив;
	ПредыдущееЗначениеИзмерений = ЗначенияИзмеренийПериодовСостояний(ОписаниеРегистра);
	Для каждого Интервал Из ОткрытыеИнтервалы Цикл
		Если ЗначенияИзмеренийЗаписейСостоянийОтличны(ПредыдущееЗначениеИзмерений, Интервал, ОписаниеРегистра.Измерения) Тогда
			МассивОткрытыхИнтервалов.Очистить();
			ЗаполнитьЗначенияСвойств(ПредыдущееЗначениеИзмерений, Интервал);
		КонецЕсли; 
		
		Сч = МассивОткрытыхИнтервалов.Количество() - 1;
		Пока Сч >= 0 Цикл
			ОткрытыйИнтервал = МассивОткрытыхИнтервалов[Сч];
			Если ОткрытыйИнтервал.ДатаНачалаСобытия > Интервал.ДатаНачалаСобытия Тогда
				Если ОткрытыйИнтервал.Приоритет = 0 Тогда
					Интервал.Окончание = ОткрытыйИнтервал.Начало - 86400;
				КонецЕсли;
				Сч = Сч - 1;
				Прервать;
			КонецЕсли;
			
			СуммаПоРесурсам = 0;
			Для каждого Ресурс Из ОписаниеРегистра.Ресурсы Цикл
				Если ОткрытыйИнтервал["ИспользованиеРесурса" + Ресурс] > 0 Тогда
					ОткрытыйИнтервал["ИспользованиеРесурса" + Ресурс] = ОткрытыйИнтервал["ИспользованиеРесурса" + Ресурс] 
						- Интервал["ИспользованиеРесурса" + Ресурс];
					СуммаПоРесурсам = СуммаПоРесурсам + ОткрытыйИнтервал["ИспользованиеРесурса" + Ресурс];
				КонецЕсли; 
			КонецЦикла; 
			
			Если СуммаПоРесурсам = 0 Тогда
				ОткрытыйИнтервал.Окончание = Интервал.Начало - 86400;
				МассивОткрытыхИнтервалов.Удалить(Сч);
			КонецЕсли; 
			
			Сч = Сч - 1;
		КонецЦикла; 
		
		Если Не ЗначениеЗаполнено(Интервал.Окончание) Тогда
			МассивОткрытыхИнтервалов.Добавить(Интервал);
		КонецЕсли;
	КонецЦикла;
	
	СоздатьВТПоТаблицеЗначений(МенеджерВременныхТаблиц, ОткрытыеИнтервалы, "ВТЗакрытыеИнтервалы");

КонецПроцедуры

Функция ЗапросВТПервичныеДанные(МенеджерВременныхТаблиц, ОписаниеРегистра, ЗначенияИзмерений)
	ИзмеренияОтбора = Новый Массив;
	
	Для Каждого КолонкаФильтра Из ЗначенияИзмерений.Колонки Цикл
		Если ВРег(КолонкаФильтра.Имя) <> "ГОД" Тогда 
			ИзмеренияОтбора.Добавить(КолонкаФильтра.Имя);
		КонецЕсли;	
	КонецЦикла;	
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	
	ТекстЗапроса = 
		"ВЫБРАТЬ
		|	ЗначенияИзмерений.ИзмерениеОтбора_,
		|	МИНИМУМ(ЗначенияИзмерений.Год) КАК Год
		|ПОМЕСТИТЬ ВТЗначенияИзмерений
		|ИЗ
		|	ВТЗначенияИзмеренийГода КАК ЗначенияИзмерений
		|
		|СГРУППИРОВАТЬ ПО
		|	ЗначенияИзмерений.ИзмерениеОтбора_
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ПервичныйРегистр.Измерение_,
		|	ПервичныйРегистр.Начало_ КАК Начало,
		|	ПервичныйРегистр.Окончание_ КАК Окончание,
		|	ПервичныйРегистр.Приоритет_.Порядок КАК Приоритет,
		|	ПервичныйРегистр.ДатаНачалаСобытия_ КАК ДатаНачалаСобытия,
		|	ПервичныйРегистр.Регистратор КАК Регистратор,
		|	ИзменившиесяДанные.Год КАК Год,
		|	ВЫБОР
		|		КОГДА ПервичныйРегистр.ИспользованиеРесурсаРесурс_ <> ЗНАЧЕНИЕ(Перечисление.ЗначениеРесурсаРегистровСостоянийСотрудника.НеУстановлено)
		|				И ПервичныйРегистр.ИспользованиеРесурсаРесурс_ <> ЗНАЧЕНИЕ(Перечисление.ЗначениеРесурсаРегистровСостоянийСотрудника.ПустаяСсылка)
		|			ТОГДА 1
		|		ИНАЧЕ 0
		|	КОНЕЦ КАК ИспользованиеРесурсаРесурс_,
		|	ВЫБОР
		|		КОГДА ПервичныйРегистр.ИспользованиеРесурсаРесурс_ = ЗНАЧЕНИЕ(Перечисление.ЗначениеРесурсаРегистровСостоянийСотрудника.Установлено)
		|			ТОГДА ИСТИНА
		|		ИНАЧЕ ЛОЖЬ
		|	КОНЕЦ КАК ЗарегистрированоЗначениеРесурс_,
		|	ПервичныйРегистр.Ресурс_
		|ПОМЕСТИТЬ ВТПервичныеДанные
		|ИЗ
		|	ИсточникДанных_ КАК ПервичныйРегистр
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТЗначенияИзмерений КАК ИзменившиесяДанные
		|		ПО ПервичныйРегистр.ИзмерениеОтбора_ = ИзменившиесяДанные.ИзмерениеОтбора_
		|
		|СГРУППИРОВАТЬ ПО
		|	ПервичныйРегистр.Измерение_,
		|	ПервичныйРегистр.Начало_,
		|	ПервичныйРегистр.Окончание_,
		|	ПервичныйРегистр.Приоритет_.Порядок,
		|	ПервичныйРегистр.ДатаНачалаСобытия_,
		|	ПервичныйРегистр.Регистратор,
		|	ИзменившиесяДанные.Год,
		|	ВЫБОР
		|		КОГДА ПервичныйРегистр.ИспользованиеРесурсаРесурс_ <> ЗНАЧЕНИЕ(Перечисление.ЗначениеРесурсаРегистровСостоянийСотрудника.НеУстановлено)
		|				И ПервичныйРегистр.ИспользованиеРесурсаРесурс_ <> ЗНАЧЕНИЕ(Перечисление.ЗначениеРесурсаРегистровСостоянийСотрудника.ПустаяСсылка)
		|			ТОГДА 1
		|		ИНАЧЕ 0
		|	КОНЕЦ,
		|	ВЫБОР
		|		КОГДА ПервичныйРегистр.ИспользованиеРесурсаРесурс_ = ЗНАЧЕНИЕ(Перечисление.ЗначениеРесурсаРегистровСостоянийСотрудника.Установлено)
		|			ТОГДА ИСТИНА
		|		ИНАЧЕ ЛОЖЬ
		|	КОНЕЦ,
		|	ПервичныйРегистр.Ресурс_
		|
		|ИМЕЮЩИЕ
		|	СУММА(ВЫБОР
		|			КОГДА ПервичныйРегистр.Сторно
		|				ТОГДА -1
		|			ИНАЧЕ 1
		|		КОНЕЦ) > 0
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ПервичныеДанные.Измерение_,
		|	ПервичныеДанные.Начало КАК Начало,
		|	ПервичныеДанные.ДатаНачалаСобытия КАК ДатаНачалаСобытия,
		|	ПервичныеДанные.Регистратор КАК Регистратор,
		|	ПервичныеДанные.Окончание КАК Окончание,
		|	ПервичныеДанные.Приоритет КАК Приоритет,
		|	ПервичныеДанные.ИспользованиеРесурсаРесурс_
		|ИЗ
		|	ВТПервичныеДанные КАК ПервичныеДанные
		|ГДЕ
		|	ПервичныеДанные.Окончание = ДАТАВРЕМЯ(1, 1, 1)
		|
		|УПОРЯДОЧИТЬ ПО
		|	ПервичныеДанные.Измерение_,
		|	ПервичныеДанные.Начало,
		|	ПервичныеДанные.Приоритет";
		
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ИсточникДанных_", "РегистрСведений." + ОписаниеРегистра.ИмяРегистра);
	
	// ВТЗначенияИзмерений
	Если ИзмеренияОтбора.Количество() = 0 Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ЗначенияИзмерений.ИзмерениеОтбора_", "ИСТИНА");
	Иначе
		ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, "ЗначенияИзмерений.ИзмерениеОтбора_", "ИзмерениеОтбора_", ИзмеренияОтбора);
	КонецЕсли;
	
	// Пакет ВТПервичныеДанные
	ПолеНачалоПервичногоРегистра 			= "ПервичныйРегистр." + ОписаниеРегистра.ИмяПоляДатаНачалаПериода;
	ПолеОкончаниеПервичногоРегистра 		= "ПервичныйРегистр." + ОписаниеРегистра.ИмяПоляДатаОкончанияПериода;
	ПолеСостояниеПервичногоРегистра 		= "ПервичныйРегистр." + ОписаниеРегистра.ИмяПоляПриоритет;
	ПолеДатаНачалаСобытияПервичногоРегистра = "ПервичныйРегистр." + ОписаниеРегистра.ИмяПоляДатаНачалаСобытия;
	
	ШаблонСоединения = "ПервичныйРегистр.ИзмерениеОтбора_ = ИзменившиесяДанные.ИзмерениеОтбора_";
	РазделительСоединения = Символы.ПС + "			И ";
	Если ИзмеренияОтбора.Количество() = 0 Тогда
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ШаблонСоединения, "ИСТИНА");
	Иначе
		ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, ШаблонСоединения, "ИзмерениеОтбора_", ИзмеренияОтбора, РазделительСоединения);
	КонецЕсли;
	
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, "ПервичныйРегистр.Измерение_", "Измерение_", ОписаниеРегистра.Измерения);
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ПервичныйРегистр.Начало_", 								ПолеНачалоПервичногоРегистра);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ПервичныйРегистр.Окончание_", 							ПолеОкончаниеПервичногоРегистра);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ПервичныйРегистр.Приоритет_", 							ПолеСостояниеПервичногоРегистра);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ПервичныйРегистр.ДатаНачалаСобытия_", 					ПолеДатаНачалаСобытияПервичногоРегистра);
	
	ЗаменитьШаблоныПервичныхСлужебныхРесурсов(ТекстЗапроса, ОписаниеРегистра);
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, "ПервичныйРегистр.Ресурс_", "Ресурс_", ОписаниеРегистра.Ресурсы);
	
	// Незакрытые интервалы
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, "ПервичныеДанные.Измерение_", "Измерение_", ОписаниеРегистра.Измерения);
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, "ПервичныеДанные.ИспользованиеРесурсаРесурс_", "Ресурс_", ОписаниеРегистра.Ресурсы);
	
	Запрос.Текст = ТекстЗапроса;
	
	Возврат Запрос;
	
КонецФункции

Функция ЗапросРассчитанныеДаты(МенеджерВременныхТаблиц, ОписаниеРегистра)
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	ТекстЗапроса = 
		"ВЫБРАТЬ
		|	ПервичныеДанные.Измерение_,
		|	ПервичныеДанные.Начало КАК Начало,
		|	ЕСТЬNULL(ЗакрытыеИнтервалы.Окончание, ПервичныеДанные.Окончание) КАК Окончание,
		|	ПервичныеДанные.Приоритет КАК Приоритет,
		|	ПервичныеДанные.ДатаНачалаСобытия КАК ДатаНачалаСобытия,
		|	ПервичныеДанные.Регистратор КАК Регистратор,
		|	ПервичныеДанные.Год КАК Год,
		|	ПервичныеДанные.ИспользованиеРесурсаРесурс_,
		|	ПервичныеДанные.ЗарегистрированоЗначениеРесурс_,
		|	ПервичныеДанные.Ресурс_
		|ПОМЕСТИТЬ ВТЗарегистрированныеРесурсы
		|ИЗ
		|	ВТПервичныеДанные КАК ПервичныеДанные
		|		ЛЕВОЕ СОЕДИНЕНИЕ ВТЗакрытыеИнтервалы КАК ЗакрытыеИнтервалы
		|		ПО ПервичныеДанные.Начало = ЗакрытыеИнтервалы.Начало
		|			И ПервичныеДанные.Регистратор = ЗакрытыеИнтервалы.Регистратор
		|			И ПервичныеДанные.Измерение_ = ЗакрытыеИнтервалы.Измерение_
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ВсеСобытия.Начало КАК Дата,
		|	ВсеСобытия.Измерение_,
		|	ВсеСобытия.Год
		|ПОМЕСТИТЬ ВТДатыИзмененияСостояний
		|ИЗ
		|	ВТЗарегистрированныеРесурсы КАК ВсеСобытия
		|
		|ОБЪЕДИНИТЬ
		|
		|ВЫБРАТЬ
		|	ВЫБОР
		|		КОГДА ВсеСобытия.Окончание = ДАТАВРЕМЯ(1, 1, 1)
		|			ТОГДА ВсеСобытия.Окончание
		|		ИНАЧЕ ДОБАВИТЬКДАТЕ(ВсеСобытия.Окончание, ДЕНЬ, 1)
		|	КОНЕЦ,
		|	ВсеСобытия.Измерение_,
		|	ВсеСобытия.Год
		|ИЗ
		|	ВТЗарегистрированныеРесурсы КАК ВсеСобытия
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ДатыИзмененияСостояний.Дата,
		|	НАЧАЛОПЕРИОДА(ДатыИзмененияСостояний.Дата, ГОД) КАК Год,
		|	ДатыИзмененияСостояний.Измерение_,
		|	ЗарегистрированныеРесурсы.Приоритет,
		|	ЗарегистрированныеРесурсы.ИспользованиеРесурсаРесурс_,
		|	ЗарегистрированныеРесурсы.ЗарегистрированоЗначениеРесурс_,
		|	ЗарегистрированныеРесурсы.Ресурс_,
		|	ЗарегистрированныеРесурсы.Начало,
		|	ЗарегистрированныеРесурсы.Окончание,
		|	ЗарегистрированныеРесурсы.ДатаНачалаСобытия,
		|	ЗарегистрированныеРесурсы.Регистратор
		|ПОМЕСТИТЬ ВТСостоянияДействующиеНаДаты
		|ИЗ
		|	ВТДатыИзмененияСостояний КАК ДатыИзмененияСостояний
		|		ЛЕВОЕ СОЕДИНЕНИЕ ВТЗарегистрированныеРесурсы КАК ЗарегистрированныеРесурсы
		|		ПО ДатыИзмененияСостояний.Измерение_ = ЗарегистрированныеРесурсы.Измерение_
		|			И ДатыИзмененияСостояний.Дата >= ЗарегистрированныеРесурсы.Начало
		|			И (ВЫБОР
		|				КОГДА ЗарегистрированныеРесурсы.Окончание = ДАТАВРЕМЯ(1, 1, 1)
		|					ТОГДА ИСТИНА
		|				ИНАЧЕ ДатыИзмененияСостояний.Дата <= ЗарегистрированныеРесурсы.Окончание
		|			КОНЕЦ)
		|ГДЕ
		|	ДатыИзмененияСостояний.Дата >= ДатыИзмененияСостояний.Год
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	СостоянияДействующиеНаДаты.Дата,
		|	СостоянияДействующиеНаДаты.Год,
		|	СостоянияДействующиеНаДаты.Измерение_,
		|	СостоянияДействующиеНаДаты.Приоритет,
		|	СостоянияДействующиеНаДаты.Начало,
		|	СостоянияДействующиеНаДаты.Окончание,
		|	СостоянияДействующиеНаДаты.ДатаНачалаСобытия,
		|	МИНИМУМ(СостоянияДействующиеНаДаты.ИспользованиеРесурсаРесурс_ - ЕСТЬNULL(СостоянияДействующиеНаДатыВытесняющие.ИспользованиеРесурсаРесурс_, 0)) КАК ИспользованиеРесурсаРесурс_
		|ПОМЕСТИТЬ ВТСостоянияДействующиеНаДатуСУчетомВытеснения
		|ИЗ
		|	ВТСостоянияДействующиеНаДаты КАК СостоянияДействующиеНаДаты
		|		ЛЕВОЕ СОЕДИНЕНИЕ ВТСостоянияДействующиеНаДаты КАК СостоянияДействующиеНаДатыВытесняющие
		|		ПО СостоянияДействующиеНаДаты.Дата = СостоянияДействующиеНаДатыВытесняющие.Дата
		|			И СостоянияДействующиеНаДаты.Измерение_ = СостоянияДействующиеНаДатыВытесняющие.Измерение_
		|			И (СостоянияДействующиеНаДаты.Приоритет <> СостоянияДействующиеНаДатыВытесняющие.Приоритет
		|				ИЛИ СостоянияДействующиеНаДаты.Начало <> СостоянияДействующиеНаДатыВытесняющие.Начало)
		|			И (ВЫБОР
		|				КОГДА СостоянияДействующиеНаДаты.ДатаНачалаСобытия > СостоянияДействующиеНаДатыВытесняющие.ДатаНачалаСобытия
		|						И СостоянияДействующиеНаДаты.Приоритет = СостоянияДействующиеНаДатыВытесняющие.Приоритет
		|					ТОГДА ЛОЖЬ
		|				КОГДА СостоянияДействующиеНаДаты.Начало < СостоянияДействующиеНаДатыВытесняющие.Начало
		|						И СостоянияДействующиеНаДаты.ДатаНачалаСобытия >= СостоянияДействующиеНаДатыВытесняющие.ДатаНачалаСобытия
		|						И (СостоянияДействующиеНаДаты.Окончание = ДАТАВРЕМЯ(1, 1, 1) ИЛИ СостоянияДействующиеНаДаты.Приоритет = 0)
		|					ТОГДА ЛОЖЬ
		|				КОГДА СостоянияДействующиеНаДаты.Начало >= СостоянияДействующиеНаДатыВытесняющие.Начало
		|						И СостоянияДействующиеНаДаты.ДатаНачалаСобытия < СостоянияДействующиеНаДатыВытесняющие.ДатаНачалаСобытия
		|						И (СостоянияДействующиеНаДатыВытесняющие.Окончание = ДАТАВРЕМЯ(1, 1, 1) ИЛИ СостоянияДействующиеНаДатыВытесняющие.Приоритет = 0)
		|					ТОГДА ИСТИНА
		|				КОГДА СостоянияДействующиеНаДатыВытесняющие.Окончание = ДАТАВРЕМЯ(1, 1, 1)
		|						И СостоянияДействующиеНаДаты.Окончание = ДАТАВРЕМЯ(1, 1, 1)
		|						И СостоянияДействующиеНаДатыВытесняющие.ДатаНачалаСобытия <> СостоянияДействующиеНаДаты.ДатаНачалаСобытия
		|					ТОГДА СостоянияДействующиеНаДаты.Начало < СостоянияДействующиеНаДатыВытесняющие.Начало
		|				КОГДА СостоянияДействующиеНаДаты.ДатаНачалаСобытия = СостоянияДействующиеНаДатыВытесняющие.ДатаНачалаСобытия
		|						И СостоянияДействующиеНаДаты.Приоритет = СостоянияДействующиеНаДатыВытесняющие.Приоритет
		|					ТОГДА СостоянияДействующиеНаДаты.Начало < СостоянияДействующиеНаДатыВытесняющие.Начало
		|				КОГДА СостоянияДействующиеНаДаты.Приоритет <= СостоянияДействующиеНаДатыВытесняющие.Приоритет
		|					ТОГДА ИСТИНА
		|				ИНАЧЕ ЛОЖЬ
		|			КОНЕЦ)
		|
		|СГРУППИРОВАТЬ ПО
		|	СостоянияДействующиеНаДаты.Дата,
		|	СостоянияДействующиеНаДаты.Год,
		|	СостоянияДействующиеНаДаты.Измерение_,
		|	СостоянияДействующиеНаДаты.Начало,
		|	СостоянияДействующиеНаДаты.Окончание,
		|	СостоянияДействующиеНаДаты.Приоритет,
		|	СостоянияДействующиеНаДаты.ДатаНачалаСобытия,
		|	СостоянияДействующиеНаДаты.Регистратор
		|
		|ИМЕЮЩИЕ
		|	(СостоянияДействующиеНаДаты.ДатаНачалаСобытия ЕСТЬ NULL 
		|		ИЛИ МИНИМУМ(СостоянияДействующиеНаДаты.ИспользованиеРесурсаРесурс_ - ЕСТЬNULL(СостоянияДействующиеНаДатыВытесняющие.ИспользованиеРесурсаРесурс_, 0)) > 0)
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	СостоянияДействующиеНаДатуСУчетомВытеснения.Дата КАК Дата,
		|	СостоянияДействующиеНаДатуСУчетомВытеснения.Год КАК Год,
		|	СостоянияДействующиеНаДатуСУчетомВытеснения.Измерение_,
		|	МИНИМУМ(ВЫБОР
		|			КОГДА СостоянияДействующиеНаДатыРесурсы.Начало ЕСТЬ NULL 
		|				ТОГДА ЛОЖЬ
		|			ИНАЧЕ ИСТИНА
		|		КОНЕЦ) КАК СостояниеДействует,
		|	МАКСИМУМ(ВЫБОР
		|			КОГДА СостоянияДействующиеНаДатуСУчетомВытеснения.ИспользованиеРесурсаРесурс_ > 0
		|				ТОГДА СостоянияДействующиеНаДатыРесурсы.Ресурс_
		|		КОНЕЦ) КАК Ресурс_,
		|	МАКСИМУМ(ВЫБОР
		|			КОГДА СостоянияДействующиеНаДатуСУчетомВытеснения.ИспользованиеРесурсаРесурс_ > 0
		|				ТОГДА СостоянияДействующиеНаДатыРесурсы.ЗарегистрированоЗначениеРесурс_
		|			ИНАЧЕ ЛОЖЬ
		|		КОНЕЦ) КАК ЗарегистрированоЗначениеРесурс_,
		|	МАКСИМУМ(СостоянияДействующиеНаДатуСУчетомВытеснения.ИспользованиеРесурсаРесурс_) КАК ИспользованиеРесурсаРесурс_
		|ИЗ
		|	ВТСостоянияДействующиеНаДатуСУчетомВытеснения КАК СостоянияДействующиеНаДатуСУчетомВытеснения
		|		ЛЕВОЕ СОЕДИНЕНИЕ ВТСостоянияДействующиеНаДаты КАК СостоянияДействующиеНаДатыРесурсы
		|		ПО СостоянияДействующиеНаДатуСУчетомВытеснения.Дата = СостоянияДействующиеНаДатыРесурсы.Дата
		|			И СостоянияДействующиеНаДатуСУчетомВытеснения.Измерение_ = СостоянияДействующиеНаДатыРесурсы.Измерение_
		|			И СостоянияДействующиеНаДатуСУчетомВытеснения.Приоритет = СостоянияДействующиеНаДатыРесурсы.Приоритет
		|			И СостоянияДействующиеНаДатуСУчетомВытеснения.Начало = СостоянияДействующиеНаДатыРесурсы.Начало
		|			И СостоянияДействующиеНаДатуСУчетомВытеснения.Окончание = СостоянияДействующиеНаДатыРесурсы.Окончание
		|			И СостоянияДействующиеНаДатуСУчетомВытеснения.ДатаНачалаСобытия = СостоянияДействующиеНаДатыРесурсы.ДатаНачалаСобытия
		|			И (СостоянияДействующиеНаДатуСУчетомВытеснения.Начало <> ДАТАВРЕМЯ(1, 1, 1))
		|
		|СГРУППИРОВАТЬ ПО
		|	СостоянияДействующиеНаДатуСУчетомВытеснения.Дата,
		|	СостоянияДействующиеНаДатуСУчетомВытеснения.Год,
		|	СостоянияДействующиеНаДатуСУчетомВытеснения.Измерение_
		|
		|УПОРЯДОЧИТЬ ПО
		|	СостоянияДействующиеНаДатуСУчетомВытеснения.Измерение_,
		|	СостоянияДействующиеНаДатуСУчетомВытеснения.Дата,
		|	МАКСИМУМ(СостоянияДействующиеНаДатуСУчетомВытеснения.Приоритет) УБЫВ";
		
		
	РазделительСоединения = Символы.ПС + "			И ";
	РазделительУсловия = Символы.ПС + "		ИЛИ ";
	
	//Пакет	ВТЗарегистрированныеРесурсы
	ШаблонРесурсов = 
		"ПервичныеДанные.ИспользованиеРесурсаРесурс_,
		|	ПервичныеДанные.ЗарегистрированоЗначениеРесурс_,
		|	ПервичныеДанные.Ресурс_";
	ШаблонСоединения = "ПервичныеДанные.Измерение_ = ЗакрытыеИнтервалы.Измерение_";
	
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, ШаблонРесурсов, "Ресурс_", ОписаниеРегистра.Ресурсы);
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, ШаблонСоединения, "Измерение_", ОписаниеРегистра.Измерения, РазделительСоединения); 
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, "ПервичныеДанные.Измерение_", "Измерение_", ОписаниеРегистра.Измерения); 
		
	// Пакет ВТДатыИзмененияСостояний
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, "ВсеСобытия.Измерение_", "Измерение_", ОписаниеРегистра.Измерения); 
	
	// Пакет ВТСостоянияДействующиеНаДаты
	ШаблонСоединения = "ДатыИзмененияСостояний.Измерение_ = ЗарегистрированныеРесурсы.Измерение_";
	ШаблонРесурсов = 
		"ЗарегистрированныеРесурсы.ИспользованиеРесурсаРесурс_,
		|	ЗарегистрированныеРесурсы.ЗарегистрированоЗначениеРесурс_,
		|	ЗарегистрированныеРесурсы.Ресурс_";

	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, ШаблонСоединения, "Измерение_", ОписаниеРегистра.Измерения, РазделительСоединения);
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, "ДатыИзмененияСостояний.Измерение_", "Измерение_", ОписаниеРегистра.Измерения);
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, ШаблонРесурсов, "Ресурс_", ОписаниеРегистра.Ресурсы);
	
	// Пакет ВТСостоянияДействующиеНаДатуСУчетомВытеснения
	ШаблонСоединения = "СостоянияДействующиеНаДаты.Измерение_ = СостоянияДействующиеНаДатыВытесняющие.Измерение_";
	ШаблонИспользованияРесурсов = "МИНИМУМ(СостоянияДействующиеНаДаты.ИспользованиеРесурсаРесурс_ - ЕСТЬNULL(СостоянияДействующиеНаДатыВытесняющие.ИспользованиеРесурсаРесурс_, 0))";
	ШаблонИспользованияРесурсовУсловие = ШаблонИспользованияРесурсов + " > 0";
	ШаблонИспользованияРесурсов = ШаблонИспользованияРесурсов + " КАК ИспользованиеРесурсаРесурс_";
	
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, ШаблонСоединения, "Измерение_", ОписаниеРегистра.Измерения, РазделительСоединения);
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, "СостоянияДействующиеНаДаты.Измерение_", "Измерение_", ОписаниеРегистра.Измерения);
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, ШаблонИспользованияРесурсовУсловие, "Ресурс_", ОписаниеРегистра.Ресурсы, РазделительУсловия);	
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, ШаблонИспользованияРесурсов, "Ресурс_", ОписаниеРегистра.Ресурсы);	
	
	// Пакет 6
	ШаблонСоединения = "СостоянияДействующиеНаДатуСУчетомВытеснения.Измерение_ = СостоянияДействующиеНаДатыРесурсы.Измерение_";
	ШаблонРесурсов = 
		"МАКСИМУМ(ВЫБОР
		|			КОГДА СостоянияДействующиеНаДатуСУчетомВытеснения.ИспользованиеРесурсаРесурс_ > 0
		|				ТОГДА СостоянияДействующиеНаДатыРесурсы.Ресурс_
		|		КОНЕЦ) КАК Ресурс_,
		|	МАКСИМУМ(ВЫБОР
		|			КОГДА СостоянияДействующиеНаДатуСУчетомВытеснения.ИспользованиеРесурсаРесурс_ > 0
		|				ТОГДА СостоянияДействующиеНаДатыРесурсы.ЗарегистрированоЗначениеРесурс_
		|			ИНАЧЕ ЛОЖЬ
		|		КОНЕЦ) КАК ЗарегистрированоЗначениеРесурс_,
		|	МАКСИМУМ(СостоянияДействующиеНаДатуСУчетомВытеснения.ИспользованиеРесурсаРесурс_) КАК ИспользованиеРесурсаРесурс_";
	
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, ШаблонСоединения, "Измерение_", ОписаниеРегистра.Измерения, РазделительСоединения);
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, "СостоянияДействующиеНаДатуСУчетомВытеснения.Измерение_", "Измерение_", ОписаниеРегистра.Измерения);
	ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, ШаблонРесурсов, "Ресурс_", ОписаниеРегистра.Ресурсы);
	
	МетаданныеРегистра = Метаданные.РегистрыСведений[ОписаниеРегистра.ИмяРегистра];
	МассивБулевоРесурсов = Новый Массив;
	Для Каждого Ресурс Из ОписаниеРегистра.Ресурсы Цикл
		МетаданныеРесурса = МетаданныеРегистра.Ресурсы.Найти(Ресурс);
		Если МетаданныеРесурса = Неопределено Тогда
			МетаданныеРесурса = МетаданныеРегистра.Измерения.Найти(Ресурс);
		КонецЕсли;
		Если МетаданныеРесурса <> Неопределено
			И МетаданныеРесурса.Тип.СодержитТип(Тип("Булево")) Тогда
			МассивБулевоРесурсов.Добавить(Ресурс);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого Ресурс Из МассивБулевоРесурсов Цикл
		ТекстПоиска = "МАКСИМУМ(ВЫБОР
		|			КОГДА СостоянияДействующиеНаДатуСУчетомВытеснения.ИспользованиеРесурсаРесурс_ > 0
		|				ТОГДА СостоянияДействующиеНаДатыРесурсы.Ресурс_
		|		КОНЕЦ) КАК Ресурс_,";
		
		ТекстЗамены = "МАКСИМУМ(ВЫБОР
		|			КОГДА СостоянияДействующиеНаДатуСУчетомВытеснения.ИспользованиеРесурсаРесурс_ > 0
		|				ТОГДА СостоянияДействующиеНаДатыРесурсы.Ресурс_
		|			ИНАЧЕ ЛОЖЬ
		|		КОНЕЦ) КАК Ресурс_,";
		
		ТекстПоиска = СтрЗаменить(ТекстПоиска, "Ресурс_", Ресурс);
		ТекстЗамены = СтрЗаменить(ТекстЗамены, "Ресурс_", Ресурс);
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ТекстПоиска, ТекстЗамены);
	КонецЦикла;
	
	Запрос.Текст = ТекстЗапроса;
	Возврат Запрос;
	
КонецФункции

Процедура ЗаменитьШаблонНаПоляИсточника(ТекстЗапроса, Шаблон, ЗаменяемоеЗначение, ПоляИсточника, Разделитель = Неопределено)
	
	Если Разделитель = Неопределено Тогда
	
		Разделитель = "," + Символы.ПС + Символы.Таб;
	
	КонецЕсли; 
	ТекстОписанияПолей = "";
	Для каждого Поле Из ПоляИсточника Цикл
	
		ТекстОписанияПолей = ТекстОписанияПолей + Разделитель + СтрЗаменить(Шаблон, ЗаменяемоеЗначение, Поле);
			
	КонецЦикла;
	
	ТекстОписанияПолей = Сред(ТекстОписанияПолей, СтрДлина(Разделитель) + 1);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, Шаблон, ТекстОписанияПолей);
	
КонецПроцедуры

Процедура ЗаменитьШаблоныПервичныхСлужебныхРесурсов(ТекстЗапроса, ОписаниеРегистра)
	
	РесурсыРегистра = Метаданные.РегистрыСведений.Найти(ОписаниеРегистра.ИмяРегистра).Ресурсы;
	
	ПоляИспользованияРесурсовГруппировка 	= "";
	ПоляИспользованияРесурсов 				= "";
	ПоляЗарегистрированоЗначениеГруппировка = "";
	ПоляЗарегистрированоЗначение 			= "";
	
	ШаблонИспользованияРесурсовГруппировка = 
		"ВЫБОР
		|		КОГДА ПервичныйРегистр.ИспользованиеРесурсаРесурс_ <> ЗНАЧЕНИЕ(Перечисление.ЗначениеРесурсаРегистровСостоянийСотрудника.НеУстановлено)
		|				И ПервичныйРегистр.ИспользованиеРесурсаРесурс_ <> ЗНАЧЕНИЕ(Перечисление.ЗначениеРесурсаРегистровСостоянийСотрудника.ПустаяСсылка)
		|			ТОГДА 1
		|		ИНАЧЕ 0
		|	КОНЕЦ";
		
	ШаблонИспользованияРесурсов = ШаблонИспользованияРесурсовГруппировка + " КАК ИспользованиеРесурсаРесурс_";
	
	ШаблонЗарегистрированоЗначениеГруппировка = 
		"ВЫБОР
		|		КОГДА ПервичныйРегистр.ИспользованиеРесурсаРесурс_ = ЗНАЧЕНИЕ(Перечисление.ЗначениеРесурсаРегистровСостоянийСотрудника.Установлено)
		|			ТОГДА ИСТИНА
		|		ИНАЧЕ ЛОЖЬ
		|	КОНЕЦ";
		
	ШаблонЗарегистрированоЗначение = ШаблонЗарегистрированоЗначениеГруппировка + " КАК ЗарегистрированоЗначениеРесурс_";
	
	Для каждого Ресурс Из ОписаниеРегистра.Ресурсы Цикл
	
		Если РесурсыРегистра.Найти("ИспользованиеРесурса" + Ресурс) <> Неопределено Тогда
		
			ПоляИспользованияРесурсовГруппировка = ПоляИспользованияРесурсовГруппировка + ",
				|	" + СтрЗаменить(ШаблонИспользованияРесурсовГруппировка, "Ресурс_", Ресурс);
				
			ПоляИспользованияРесурсов = ПоляИспользованияРесурсов + ",
				|	" + СтрЗаменить(ШаблонИспользованияРесурсов, "Ресурс_", Ресурс);
				
			ПоляЗарегистрированоЗначениеГруппировка = ПоляЗарегистрированоЗначениеГруппировка + ",
				|	" + СтрЗаменить(ШаблонЗарегистрированоЗначениеГруппировка, "Ресурс_", Ресурс);
				
			ПоляЗарегистрированоЗначение = ПоляЗарегистрированоЗначение + ",
				|	" + СтрЗаменить(ШаблонЗарегистрированоЗначение, "Ресурс_", Ресурс);
				
		Иначе
			
			ПоляИспользованияРесурсовГруппировка = ПоляИспользованияРесурсовГруппировка + ",
				|	1";
				
			ПоляИспользованияРесурсов = ПоляИспользованияРесурсов + ",
				|	1 КАК ИспользованиеРесурса" + Ресурс;
				
			ПоляЗарегистрированоЗначениеГруппировка = ПоляЗарегистрированоЗначениеГруппировка + ",
				|	ИСТИНА";
				
			ПоляЗарегистрированоЗначение = ПоляЗарегистрированоЗначение + ",
				|	ИСТИНА КАК ЗарегистрированоЗначение" + Ресурс;
				
			КонецЕсли;
			
	КонецЦикла;	
	
	ПоляИспользованияРесурсов 				= Сред(ПоляИспользованияРесурсов, 				4);
	ПоляИспользованияРесурсовГруппировка 	= Сред(ПоляИспользованияРесурсовГруппировка, 	4);
	ПоляЗарегистрированоЗначение 			= Сред(ПоляЗарегистрированоЗначение, 			4);
	ПоляЗарегистрированоЗначениеГруппировка = Сред(ПоляЗарегистрированоЗначениеГруппировка, 4);
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ШаблонИспользованияРесурсов,				ПоляИспользованияРесурсов);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ШаблонИспользованияРесурсовГруппировка,	ПоляИспользованияРесурсовГруппировка);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ШаблонЗарегистрированоЗначение,			ПоляЗарегистрированоЗначение);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, ШаблонЗарегистрированоЗначениеГруппировка,	ПоляЗарегистрированоЗначениеГруппировка);
	
КонецПроцедуры

Функция ЗаписьВторичныхДанныхСостоянийСоответствуетОтбору(Запись, ОписаниеРегистра)
	Если Не ЗначениеЗаполнено(ОписаниеРегистра.ОтборРассчитанныхДанныхРавно) 
		И Не ЗначениеЗаполнено(ОписаниеРегистра.ОтборРассчитанныхДанныхНеРавно)  Тогда
		
		Возврат Истина;
	КонецЕсли;
	
	СоответствуетОтборуРавно = Ложь;
	
	Если ОписаниеРегистра.ОтборРассчитанныхДанныхРавно <> Неопределено Тогда
		Для Каждого ЭлементОтбора Из ОписаниеРегистра.ОтборРассчитанныхДанныхРавно Цикл
			ПравоеЗначение = ЭлементОтбора.Значение;
			Если Запись[ЭлементОтбора.Ключ] = ПравоеЗначение.Значение 
				И (Не ПравоеЗначение.ПроверятьЗарегистрированноеЗначение
					Или Запись["ЗарегистрированоЗначение" + ЭлементОтбора.Ключ] = Истина) Тогда
				СоответствуетОтборуРавно = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;	
	КонецЕсли;	
	
	СоответствуетОтборуНеРавно = Ложь;
	
	Если ОписаниеРегистра.ОтборРассчитанныхДанныхНеРавно <> Неопределено Тогда
		Для Каждого ЭлементОтбора Из ОписаниеРегистра.ОтборРассчитанныхДанныхНеРавно Цикл
			ПравоеЗначение = ЭлементОтбора.Значение;
			Если Запись[ЭлементОтбора.Ключ] <> ПравоеЗначение.Значение 
				И (Не ПравоеЗначение.ПроверятьЗарегистрированноеЗначение
					Или Запись["ЗарегистрированоЗначение" + ЭлементОтбора.Ключ] = Истина) Тогда
				СоответствуетОтборуНеРавно = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;	
	КонецЕсли;

	Возврат СоответствуетОтборуРавно И СоответствуетОтборуНеРавно;	
КонецФункции	

Функция ПродолжатьДействиеТекущегоСостояния(ДанныеПредыдущегоСостояния, ДанныеТекущегоСостояния, ИзмеренияРасчета, Ресурсы)
	Если ЗначенияИзмеренийЗаписейСостоянийОтличны(ДанныеПредыдущегоСостояния, ДанныеТекущегоСостояния, ИзмеренияРасчета) Тогда
		Возврат Ложь;
	КонецЕсли;	
			
	Для Каждого ОписаниеРесурса Из Ресурсы Цикл
		Если ДанныеПредыдущегоСостояния[ОписаниеРесурса] <> ДанныеТекущегоСостояния[ОписаниеРесурса]
			ИЛИ ДанныеПредыдущегоСостояния["ИспользованиеРесурса" + ОписаниеРесурса] <> ДанныеТекущегоСостояния["ИспользованиеРесурса" + ОписаниеРесурса]
			ИЛИ ДанныеПредыдущегоСостояния["ЗарегистрированоЗначение" + ОписаниеРесурса] <> ДанныеТекущегоСостояния["ЗарегистрированоЗначение" + ОписаниеРесурса] Тогда
			
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции	

#КонецОбласти

#КонецОбласти

#Область РегистрыКлассификаторы

// Считывает текст из двоичных данных, используя поток в памяти.
//
// Параметры:
//   ДвоичныеДанные - ДвоичныеДанные - Двоичные данные текста.
//   Кодировка - КодировкаТекста - Кодировка текста.
//
// Возвращаемое значение:
//   Строка - Результат чтения текста из двоичных данных.
//
Функция ДвоичныеДанныеВСтроку(ДвоичныеДанные, Кодировка)
	БуферДвоичныхДанных = ПолучитьБуферДвоичныхДанныхИзДвоичныхДанных(ДвоичныеДанные);
	ПотокВПамяти = Новый ПотокВПамяти(БуферДвоичныхДанных);
	ЧтениеТекста = Новый ЧтениеТекста(ПотокВПамяти, Кодировка);
	Возврат ЧтениеТекста.Прочитать();
КонецФункции

// Вызывается при установке начальных значений регистров.
Процедура УстановитьНачальныеЗначенияАвтообновляемыхКлассификаторов(Знач ИменаОбъектовМетаданных)
	ПрименятьФильтрПоПолнымИменам = ЗначениеЗаполнено(ИменаОбъектовМетаданных);
	ФильтрПоПолнымИменам = СтрРазделить(ВРег(СокрЛП(ИменаОбъектовМетаданных)), ",", Ложь);
	
	ТаблицаКлассификаторов = АвтообновляемыеКлассификаторы();
	Для Каждого СтрокаТаблицы Из ТаблицаКлассификаторов Цикл
		Если ПрименятьФильтрПоПолнымИменам И ФильтрПоПолнымИменам.Найти(ВРег(СтрокаТаблицы.ПолноеИмя)) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(СтрокаТаблицы.ПолноеИмя);
		Менеджер.НачальноеЗаполнение();
	КонецЦикла;
КонецПроцедуры

// Загружает классификатор из веб-сервиса и возвращает его "Распакованные" данные.
//
// Параметры:
//   Идентификатор - Строка - Идентификатор классификатора в веб-сервисе.
//
// Возвращаемое значение:
//   Структура - Данные классификатора.
//
Функция ПолучитьДанныеКлассификатораИзСервиса(Идентификатор)
	МодульРаботаСКлассификаторами = ОбщегоНазначения.ОбщийМодуль("РаботаСКлассификаторами");
	
	Идентификаторы = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Идентификатор);
	РезультатПолученияФайлов = МодульРаботаСКлассификаторами.ПолучитьФайлыКлассификаторов(Идентификаторы);
	
	Если РезультатПолученияФайлов.КодОшибки = "ОбновлениеНеТребуется" Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Значение = Неопределено;
	Если Не ЗначениеЗаполнено(РезультатПолученияФайлов.КодОшибки)
		И ТипЗнч(РезультатПолученияФайлов.ДанныеКлассификаторов) = Тип("ТаблицаЗначений") Тогда
		СтрокаТаблицы = РезультатПолученияФайлов.ДанныеКлассификаторов.Найти(Идентификатор, "Идентификатор");
		Если СтрокаТаблицы <> Неопределено Тогда
			Попытка
				ДвоичныеДанные = ПолучитьИзВременногоХранилища(СтрокаТаблицы.АдресФайла);
				ТекстXML = ДвоичныеДанныеВСтроку(ДвоичныеДанные, КодировкаТекста.UTF8);
				Значение = ОбщегоНазначения.ЗначениеИзСтрокиXML(ТекстXML);
			Исключение
				Значение = Неопределено;
				ИнформацияОбОшибке = ИнформацияОбОшибке();
				РезультатПолученияФайлов.КодОшибки = "ОшибкаИзвлеченияЗначенияИзФайла";
				РезультатПолученияФайлов.СообщениеОбОшибке = КраткоеПредставлениеОшибки(ИнформацияОбОшибке);
				РезультатПолученияФайлов.ИнформацияОбОшибке = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке);
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
	
	Если Значение = Неопределено Тогда
		УровеньЖурнала = УровеньЖурналаРегистрации.Ошибка;
		ТекстЖурнала = НСтр("ru = 'При получении классификатора %1 из веб-сервиса возникла ошибка:
			|Код: %2
			|Краткая информация: %3
			|Подробная информация:
			|%4'");
		ТекстЖурнала = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстЖурнала,
			Идентификатор,
			Строка(РезультатПолученияФайлов.КодОшибки),
			Строка(РезультатПолученияФайлов.СообщениеОбОшибке),
			Строка(РезультатПолученияФайлов.ИнформацияОбОшибке));
	Иначе
		УровеньЖурнала = УровеньЖурналаРегистрации.Информация;
		ТекстЖурнала = СтрШаблон(НСтр("ru = 'Файл классификатора %1 получен из веб-сервиса.'"), Идентификатор);
	КонецЕсли;
	ЗаписьЖурналаРегистрации(
		НСтр("ru = 'Нормативно-правовая информация БЗК'", ОбщегоНазначения.КодОсновногоЯзыка()),
		УровеньЖурнала,
		,
		,
		ТекстЖурнала);
	
	Возврат Значение;
КонецФункции

#КонецОбласти

Функция НоваяТаблицаСведенияОбОтпускахСотрудниковДляРасчетаОценочныхОбязательств() Экспорт
	
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Сотрудник", Новый ОписаниеТипов("СправочникСсылка.Сотрудники"));
	Таблица.Колонки.Добавить("ОстатокОтпусков", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5, 2)));
	Таблица.Колонки.Добавить("ОтпускАвансом", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5, 2)));
	Таблица.Колонки.Добавить("СреднийЗаработок", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(15, 2)));
	
	Возврат Таблица;
	
КонецФункции	

#КонецОбласти
