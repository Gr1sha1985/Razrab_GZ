////////////////////////////////////////////////////////////////////////////////
// ЭлектронноеВзаимодействиеСлужебный: общий механизм обмена электронными документами.
//
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

#Область КомандыЭДО

// Размещает команды ЭДО на форме.
//
// Параметры:
//   Форма                            - ФормаКлиентскогоПриложения - форма, в которой необходимо разместить подменю ЭДО.
//   МестоРазмещенияКомандПоУмолчанию - ЭлементФормы - группа, в которую необходимо разместить подменю ЭДО,
//                                                     по умолчанию размещается в командную панель формы.
//   МодульПодсистемы - Строка - название модуля, в котором расположен обработчик команды;
//   НаправлениеЭД - ПеречислениеСсылка.НаправленияЭД - направление документа информационной базы;
//   ТолькоВМенюЕще - Булево - Если Истина, то команда будет размещена только в меню Еще.
//
Процедура РазместитьНаФормеКомандыЭДО(Форма, МестоРазмещенияКомандПоУмолчанию, МодульПодсистемы, НаправлениеЭД = Неопределено, ТолькоВМенюЕще = Ложь) Экспорт
	
	ИмяФормы = Форма.ИмяФормы;
	
	КомандыЭДО = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.КомандыЭДОФормы(ИмяФормы, МодульПодсистемы, НаправлениеЭД, ТолькоВМенюЕще).Скопировать();
	ОпределитьВидимостьКомандЭДОПоФункциональнымОпциям(КомандыЭДО, Форма);
	
	Если МестоРазмещенияКомандПоУмолчанию <> Неопределено Тогда
		Для Каждого КомандаЭДО Из КомандыЭДО Цикл
			Если ПустаяСтрока(КомандаЭДО.МестоРазмещения) Тогда
				КомандаЭДО.МестоРазмещения = МестоРазмещенияКомандПоУмолчанию.Имя;
			КонецЕсли;
		КонецЦикла;
		Если МодульПодсистемы = "ОбменСБанками" Тогда
			МестоРазмещенияКомандПоУмолчанию.Заголовок = НСтр("ru = '1С:ДиректБанк'");
		КонецЕсли;
	КонецЕсли;
	
	КомандыЭДО.Колонки.Добавить("ИмяКомандыНаФорме", Новый ОписаниеТипов("Строка"));
	
	ТаблицаКоманд = КомандыЭДО.Скопировать(,"МестоРазмещения");
	ТаблицаКоманд.Свернуть("МестоРазмещения");
	МестаРазмещения = ТаблицаКоманд.ВыгрузитьКолонку("МестоРазмещения");
	
	Если МестоРазмещенияКомандПоУмолчанию = Неопределено Тогда
		МестоРазмещенияКоманд = Форма.КоманднаяПанель;
		ПодменюЭДО = Форма.Элементы.Добавить(МестоРазмещенияКоманд.Имя + "КомандыЭДО", Тип("ГруппаФормы"), МестоРазмещенияКоманд);
		ПодменюЭДО.Вид = ВидГруппыФормы.Подменю;
		Если МодульПодсистемы = "ОбменСБанками" Тогда
			ПодменюЭДО.Заголовок = НСтр("ru = '1С:ДиректБанк'");
		Иначе
			ПодменюЭДО.Заголовок = НСтр("ru = 'ЭДО'");
		КонецЕсли;
		МестоРазмещенияКомандПоУмолчанию = ПодменюЭДО;
	КонецЕсли;  
	
	Если МодульПодсистемы = "ОбменСКонтрагентами" Тогда
		КартинкаОповещений = БиблиотекаКартинок["ЭмблемаСервиса1СЭДО"];
		МодульОбменСКонтрагентами = ОбщегоНазначения.ОбщийМодуль("ОбменСКонтрагентамиСлужебныйВызовСервера");
		Если МодульОбменСКонтрагентами.ЕстьСобытияЭДО() Тогда
			КартинкаОповещений = БиблиотекаКартинок["ВосклицательныйЗнакКрасный"];
		КонецЕсли;
		МестоРазмещенияКомандПоУмолчанию.Картинка = КартинкаОповещений;
	КонецЕсли;
	
	Если КомандыЭДО.Количество() = 1 Тогда
		 МестоРазмещенияКомандПоУмолчанию.Вид = ВидГруппыФормы.ГруппаКнопок; 
	 КонецЕсли; 
	 
	Для Каждого МестоРазмещения Из МестаРазмещения Цикл
		НайденныеКоманды = КомандыЭДО.НайтиСтроки(Новый Структура("МестоРазмещения,СкрытаФункциональнымиОпциями,Отключена", МестоРазмещения, Ложь, Ложь));
		ЭлементФормыДляРазмещения = Форма.Элементы.Найти(МестоРазмещения);
		Если ЭлементФормыДляРазмещения = Неопределено Тогда
			ЭлементФормыДляРазмещения = МестоРазмещенияКомандПоУмолчанию;
		КонецЕсли;
		
		Если НайденныеКоманды.Количество() > 0 Тогда
			ДобавитьКомандыЭДО(Форма, НайденныеКоманды, ЭлементФормыДляРазмещения);
		КонецЕсли;
	КонецЦикла;
	
	АдресКомандЭДОВоВременномХранилище = "АдресКомандЭДОВоВременномХранилище";
	КомандаФормы = Форма.Команды.Найти(АдресКомандЭДОВоВременномХранилище);
	Если КомандаФормы = Неопределено Тогда
		КомандаФормы = Форма.Команды.Добавить(АдресКомандЭДОВоВременномХранилище);
		КомандаФормы.Действие = ПоместитьВоВременноеХранилище(КомандыЭДО, Форма.УникальныйИдентификатор);
	Иначе
		ОбщийСписокКомандЭДОФормы = ПолучитьИзВременногоХранилища(КомандаФормы.Действие);
		Для Каждого КомандаЭДО Из КомандыЭДО Цикл
			ЗаполнитьЗначенияСвойств(ОбщийСписокКомандЭДОФормы.Добавить(), КомандаЭДО);
		КонецЦикла;
		КомандаФормы.Действие = ПоместитьВоВременноеХранилище(ОбщийСписокКомандЭДОФормы, Форма.УникальныйИдентификатор);
	КонецЕсли;
	
КонецПроцедуры

// Возвращает список команд ЭДО для указанной формы.
//
// Параметры:
//  Форма - ФормаКлиентскогоПриложения, Строка - форма или полное имя формы, для которой необходимо получить список команд ЭДО;
//  МодульПодсистемы - Строка - модуль, в котором размещены обработчики команд;
//  НаправлениеЭД - ПеречислениеСсылка.НаправленияЭД - направление документа, для которого выполняется команда;
//  ТолькоВМенюЕще - Булево - если Истина, то команда будет размещена только в меню Еще.
//
// Возвращаемое значение:
//  ТаблицаЗначений - описание см. в СоздатьКоллекциюКомандЭДО().
//
Функция КомандыЭДОФормы(Форма, МодульПодсистемы, НаправлениеЭД, ТолькоВМенюЕще) Экспорт
	
	Если ТипЗнч(Форма) = Тип("ФормаКлиентскогоПриложения") Тогда
		ИмяФормы = Форма.ИмяФормы;
	Иначе
		ИмяФормы = Форма;
	КонецЕсли;
	
	КомандыЭДО = СоздатьКоллекциюКомандЭДО();
	
	ОбъектМетаданных = Метаданные.НайтиПоПолномуИмени(ИмяФормы);
	Если ОбъектМетаданных <> Неопределено 
		И Не Метаданные.ОбщиеФормы.Содержит(ОбъектМетаданных) Тогда
		ОбъектМетаданных = ОбъектМетаданных.Родитель();
	КонецЕсли;
	
	ДобавляемыеКомандыЭДО = СоздатьКоллекциюКомандЭДО();
	МодульФормирования = ОбщегоНазначения.ОбщийМодуль(МодульПодсистемы);
	МодульФормирования.СформироватьКомандыЭДО(ОбъектМетаданных.ПолноеИмя(), ДобавляемыеКомандыЭДО, НаправлениеЭД, ТолькоВМенюЕще);
	
	Для Каждого КомандаЭДО Из ДобавляемыеКомандыЭДО Цикл
		Если КомандыЭДО.Найти(КомандаЭДО.Идентификатор, "Идентификатор") = Неопределено Тогда
			ЗаполнитьЗначенияСвойств(КомандыЭДО.Добавить(), КомандаЭДО);	
		КонецЕсли;
	КонецЦикла;
	
	КомандыЭДО.Сортировать("Порядок Возр, Представление Возр");
	
	ЧастиИмени = СтрРазделить(ИмяФормы, ".");
	КраткоеИмяФормы = ЧастиИмени[ЧастиИмени.Количество()-1];
	
	// фильтр по именам форм
	Для НомерСтроки = -КомандыЭДО.Количество() + 1 По 0 Цикл
		КомандаЭДО = КомандыЭДО[-НомерСтроки];
		СписокФорм = СтрРазделить(КомандаЭДО.СписокФорм, ",", Ложь);
		Если СписокФорм.Количество() > 0 И СписокФорм.Найти(КраткоеИмяФормы) = Неопределено Тогда
			КомандыЭДО.Удалить(КомандаЭДО);
		КонецЕсли;
	КонецЦикла;
	
	ОпределитьВидимостьКомандЭДОПоФункциональнымОпциям(КомандыЭДО, Форма);
	
	Возврат КомандыЭДО;
	
КонецФункции

#КонецОбласти

#Область Организации

// Возвращает организацию по умолчанию.
// 
// Возвращаемое значение:
//  Неопределено - не удалось определить организацию.
//  ОпределяемыеТипы.Организация - организация для автоматической подстановки.
//
Функция ОрганизацияПоУмолчанию() Экспорт
	
	Если Не Метаданные.ОпределяемыеТипы.Организация.Тип.СодержитТип(Тип("Строка")) Тогда
		ПолноеИмя = Метаданные.НайтиПоТипу(Метаданные.ОпределяемыеТипы.Организация.Тип.Типы()[0]).ПолноеИмя();
		ИмяСправочникаОрганизации = "Справочники." + СтрРазделить(ПолноеИмя, ".")[1];
		МодульОрганизации = ОбщегоНазначения.ОбщийМодуль(ИмяСправочникаОрганизации);
		ОрганизацияПоУмолчанию = МодульОрганизации.ОрганизацияПоУмолчанию();
	Иначе
		ОрганизацияПоУмолчанию = Неопределено;
	КонецЕсли;
	
	Возврат ОрганизацияПоУмолчанию;
	
КонецФункции

// Получает сокращенное наименование организации.
//
// Параметры:
//  Организация - СправочникСсылка.Организации - ссылка на организацию.
//
// Возвращаемое значение:
//  Строка - сокращенное наименование организации.
//
Функция СокращенноеНаименованиеОрганизации(Организация) Экспорт
	
	РеквизитНаименованиеОрганизации = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.ИмяНаличиеОбъектаРеквизитаВПрикладномРешении(
		"СокращенноеНаименованиеОрганизации");
	Если НЕ ЗначениеЗаполнено(РеквизитНаименованиеОрганизации) Тогда
		РеквизитНаименованиеОрганизации = "Наименование";
	КонецЕсли;
	Возврат ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Организация, РеквизитНаименованиеОрганизации);
	
КонецФункции

// Возвращает признак использования нескольких организаций.
//
// Возвращаемое значение:
//  Булево - Истина, если используется несколько организаций, иначе Ложь.
//
Функция ИспользуетсяНесколькоОрганизаций() Экспорт
	
	Возврат ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоОрганизацийБЭД");
	
КонецФункции

#КонецОбласти

#Область События

// Данная процедура используется для стандартизации всех записей событий подсистемы ЭлектронноеВзаимодействие
// в журнал регистрации. В результате в журнал добавляется группировка записей с иерархией.
//  Электронное взаимодействие:
//    |_ Общая подсистема
//    |_ Обмен с банками
//    |_ Обмен с контрагентами
//    |_ Обмен с сайтами
//    |_ Регламентные задания
//    |_ Бизнес-сеть
// Параметры:
//   ОписаниеСобытия - Строка - описание содержания события, которое требуется записать в журнал регистрации.
//   КодСобытия - Строка - код события, используется для стандартизации иерархии событий.
//                Может принимать значения: "ЭлектронноеВзаимодействие" - Общая подсистема, 
//                                          "ОбменСБанками" - Обмен с банками, 
//                                          "ОбменСКонтрагентами" - Обмен с контрагентами,
//                                          "ОбменССайтами" - Обмен с сайтами, 
//                                          "РегламентныеЗадания" - Регламентные задания, 
//                                          "БизнесСеть" - Бизнес-сеть,
//                                          "ИнтеграцияСЯндексКассой" - Интеграция с Яндекс.Кассой.
//   УровеньВажности - УровеньЖурналаРегистрации - уровень журнала регистрации (Ошибка, Информация, и т.д.).
//   ОбъектМетаданных - ОбъектМетаданных - объект метаданных, к которому относится событие.
//   ДанныеСсылка - Произвольный - данные, с которыми связано событие. Рекомендуется указывать ссылки на объекты данных
//                  (элементы справочников, документы, к которым относится событие).
//   РежимТранзакции - РежимТранзакцииЗаписиЖурналаРегистрации - указывает отношение записи к текущей транзакции.
//
Процедура ВыполнитьЗаписьСобытияПоЭДВЖурналРегистрации(ОписаниеСобытия, КодСобытия, УровеньВажности = Неопределено,
	ОбъектМетаданных = Неопределено, ДанныеСсылка = Неопределено, РежимТранзакции = Неопределено) Экспорт
	
	Если КодСобытия = "ЭлектронноеВзаимодействие" Тогда
		Подсистема = НСтр("ru = 'Общая подсистема'", ОбщегоНазначения.КодОсновногоЯзыка());
	ИначеЕсли КодСобытия = "ОбменСБанками" Тогда
		Подсистема = НСтр("ru = 'Обмен с банками'", ОбщегоНазначения.КодОсновногоЯзыка());
	ИначеЕсли КодСобытия = "ОбменСКонтрагентами" Тогда
		Подсистема = НСтр("ru = 'Обмен с контрагентами'", ОбщегоНазначения.КодОсновногоЯзыка());
	ИначеЕсли КодСобытия = "ОбменССайтами" Тогда
		Подсистема = НСтр("ru = 'Обмен с сайтами'", ОбщегоНазначения.КодОсновногоЯзыка());
	ИначеЕсли КодСобытия = "РегламентныеЗадания" Тогда
		Подсистема = НСтр("ru = 'Регламентные задания'", ОбщегоНазначения.КодОсновногоЯзыка());
	ИначеЕсли КодСобытия = "БизнесСеть" Тогда
		Подсистема = НСтр("ru = 'Бизнес-сеть'",	ОбщегоНазначения.КодОсновногоЯзыка());
	ИначеЕсли КодСобытия = "ТорговыеПредложения" Тогда
		Подсистема = НСтр("ru = 'Торговые предложения'", ОбщегоНазначения.КодОсновногоЯзыка());
	ИначеЕсли КодСобытия = "ИнтеграцияСЯндексКассой" Тогда
		Подсистема = НСтр("ru = 'Интеграция с Яндекс Кассой'", ОбщегоНазначения.КодОсновногоЯзыка());
	ИначеЕсли КодСобытия = "СопоставлениеНоменклатурыКонтрагентов" Тогда
		Подсистема = НСтр("ru = 'Сопоставление номенклатуры контрагентов'", ОбщегоНазначения.КодОсновногоЯзыка());
	Иначе
		Подсистема = НСтр("ru = 'Общая подсистема'", ОбщегоНазначения.КодОсновногоЯзыка());
	КонецЕсли;
	
	УровеньВажностиСобытия = ?(ТипЗнч(УровеньВажности) = Тип("УровеньЖурналаРегистрации"),
		УровеньВажности, УровеньЖурналаРегистрации.Ошибка);
		
	ИмяСобытия = СтрЗаменить(НСтр("ru = 'Электронное взаимодействие.%1'", ОбщегоНазначения.КодОсновногоЯзыка()),
		"%1", Подсистема);
	
	ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньВажностиСобытия, ОбъектМетаданных, ДанныеСсылка, ОписаниеСобытия,
		РежимТранзакции);
	
КонецПроцедуры

// Выводит сообщение пользователю о нехватки прав доступа.
Процедура СообщитьПользователюОНарушенииПравДоступа() Экспорт
	
	ТекстСообщения = ТекстСообщенияОНарушенииПравДоступа();
	ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
	
КонецПроцедуры

Функция ТекстСообщенияОНарушенииПравДоступа() Экспорт
	
	ТекстСообщения = НСтр("ru = 'Нарушение прав доступа.'");
	ЭлектронноеВзаимодействиеПереопределяемый.ПодготовитьТекстСообщенияОНарушенииПравДоступа(ТекстСообщения);
	Возврат ТекстСообщения;
	
КонецФункции

#КонецОбласти

#Область МетодыHTTP

// Функция формирует прокси по настройкам прокси и протоколу.
//
// Параметры:
//  Протокол - Строка - протокол для которого устанавливаются параметры прокси сервера, например http, https, ftp.
//
// Возвращаемое значение:
//  ИнтернетПрокси - описание параметров прокси-серверов.
// 
Функция СформироватьПрокси(Протокол) Экспорт
	
	// НастройкаПроксиСервера - Соответствие:
	//  ИспользоватьПрокси - использовать ли прокси-сервер;
	//  НеИспользоватьПроксиДляЛокальныхАдресов - использовать ли прокси-сервер для локальных адресов;
	//  ИспользоватьСистемныеНастройки - использовать ли системные настройки прокси-сервера;
	//  Сервер       - адрес прокси-сервера;
	//  Порт         - порт прокси-сервера;
	//  Пользователь - имя пользователя для авторизации на прокси-сервере;
	//  Пароль       - пароль пользователя.
	НастройкаПроксиСервера = ПолучениеФайловИзИнтернета.НастройкиПроксиНаСервере();
	Если НастройкаПроксиСервера <> Неопределено Тогда
		ИспользоватьПрокси = НастройкаПроксиСервера.Получить("ИспользоватьПрокси");
		ИспользоватьСистемныеНастройки = НастройкаПроксиСервера.Получить("ИспользоватьСистемныеНастройки");
		Если ИспользоватьПрокси Тогда
			Если ИспользоватьСистемныеНастройки Тогда
				// Системные настройки прокси-сервера.
				Прокси = Новый ИнтернетПрокси(Истина);
			Иначе
				// Ручные настройки прокси-сервера.
				Прокси = Новый ИнтернетПрокси;
				Прокси.Установить(Протокол, НастройкаПроксиСервера["Сервер"], НастройкаПроксиСервера["Порт"],
					НастройкаПроксиСервера["Пользователь"], НастройкаПроксиСервера["Пароль"]);
				Прокси.НеИспользоватьПроксиДляЛокальныхАдресов = НастройкаПроксиСервера["НеИспользоватьПроксиДляЛокальныхАдресов"];
			КонецЕсли;
		Иначе
			// Не использовать прокси-сервер.
			Прокси = Новый ИнтернетПрокси(Ложь);
		КонецЕсли;
	Иначе
		Прокси = Неопределено;
	КонецЕсли;
	
	Возврат Прокси;
	
КонецФункции

// Определяет параметры HTTP соединения по URL адресу.
//
// Параметры:
//  АдресСайта - Строка - URL сайта;
//  ЗащищенноеСоединение - Булево - возвращает Истина, если требуется шифрование;
//  Адрес - Строка - адрес сайта без протокола;
//  Протокол - Строка - название протокола.
//
Процедура ОпределитьПараметрыСайта(Знач АдресСайта, ЗащищенноеСоединение, Адрес, Протокол) Экспорт
	
	АдресСайта = СокрЛП(АдресСайта);
	
	АдресСайта = СтрЗаменить(АдресСайта, "\", "/");
	АдресСайта = СтрЗаменить(АдресСайта, " ", "");
	
	Если НРег(Лев(АдресСайта, 7)) = "http://" Тогда
		Протокол = "http";
		Адрес = Сред(АдресСайта,8);
		ЗащищенноеСоединение = Неопределено;
	ИначеЕсли НРег(Лев(АдресСайта, 8)) = "https://" Тогда
		Протокол =  "https";
		Адрес = Сред(АдресСайта,9);
		
		ЗащищенноеСоединение = ОбщегоНазначенияКлиентСервер.НовоеЗащищенноеСоединение();
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ФайловыеОперации

// Выгружает электронный документ в файл.
//
// Параметры:
//  ЭД - ЗначениеXDTO, ОбъектXDTO, Неопределено - Записываемое значение.
//  ИмяФайла - Строка - путь к файлу, в который сохраняются данные;
//  УказаниеТипа - НазначениеТипаXML - вариант назначения типа элемента данных XDTO.
//  ТипКодировки - Строка - файл будет записан в соответствующей кодировке.
//
Процедура ВыгрузитьЭДВФайл(ЭД, ИмяФайла, УказаниеТипа = Истина, ТипКодировки = "windows-1251", КонтекстОперации = Неопределено) Экспорт
	
	НоваяЗаписьXML = Новый ЗаписьXML;
	НоваяЗаписьXML.ОткрытьФайл(ИмяФайла, ТипКодировки);
	НоваяЗаписьXML.ЗаписатьОбъявлениеXML();
	ФабрикаXDTO.ЗаписатьXML(НоваяЗаписьXML, ЭД, , , , ?(УказаниеТипа, НазначениеТипаXML.Явное, НазначениеТипаXML.Неявное));
	НоваяЗаписьXML.Закрыть();
	
КонецПроцедуры

// Возвращает временный рабочий каталог для работы с файлами ЭДО.
// Каталог создается в каталоге временных файлов системы или ином предопределенном каталоге.
//
// Параметры:
//  Подкаталог - Строка - вложенный каталог первого уровня (не используется, оставлено для совместимости).
//  КлючУникальности - Строка - вложенный каталог второго уровня (не используется, оставлено для совместимости).
//
// Возвращаемое значение:
//  Строка - временный каталог.
//
Функция РабочийКаталог(Знач Подкаталог = "", Знач КлючУникальности = "") Экспорт
	
	ИмяКаталога = ПолучитьИмяВременногоФайла() + ПолучитьРазделительПути();
	СоздатьКаталог(ИмяКаталога);
	Возврат ИмяКаталога;
	
КонецФункции

// Определяет возможно ли без ошибки извлечь файлы из архива.
// Проверяется максимальная длина полного имени файла в 255 символов.
// 
// Параметры:
//  АрхивЧтение - ЧтениеZIPФайла - открытий zip архив.
//  КаталогРаспаковки - Строка - папка, в которую будут извлечены данные.
//  ИмяСоздаваемогоФайла - Строка - имя файла, который не может быть извлечен.
//
// Возвращаемое значение:
//  Булево - если возможно то Истина, иначе Ложь.
//
Функция ВозможноИзвлечьФайлы(АрхивЧтение, КаталогРаспаковки, ИмяСоздаваемогоФайла="") Экспорт
	
	ДлинаПутиПапки = СтрДлина(КаталогРаспаковки);
	
	Для Каждого Элемент Из АрхивЧтение.Элементы Цикл
		ИмяФайла = Элемент.ПолноеИмя;
		ДлинаИмениФайла = СтрДлина(ИмяФайла);
		ПолнаяДлина = ДлинаПутиПапки + ДлинаИмениФайла + 1;
		Если ПолнаяДлина > МаксимальнаяДлинаИмениФайла() Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Удаляет временные файлы или каталог.
//
// Параметры:
//  Путь - Строка - полный путь к файлу или каталогу
//  Маска - Строка - маска для выбора удаляемых файлов,
//        - Неопределено - удаляются все файлы и каталог <Путь>.
//
Процедура УдалитьВременныеФайлы(Путь, Маска = Неопределено) Экспорт
	
	Попытка
		УдалитьФайлы(Путь, Маска);
	Исключение
		ВидОперации = НСтр("ru = 'Удаление временного файла.'");
		ПодробныйТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ЭлектронноеВзаимодействиеСлужебныйВызовСервера.ОбработатьОшибку(ВидОперации, ПодробныйТекстОшибки, , "ЭлектронноеВзаимодействие");
	КонецПопытки;
	
КонецПроцедуры

Функция МаксимальнаяДлинаИмениФайла() Экспорт
	
	Возврат 255;
	
КонецФункции

#КонецОбласти

#Область Криптография

// Определяет, где нужно проводить крипто операции.
//
// Возвращаемое значение:
//  Булево - Истина, если криптография настроена на сервере или Ложь - если на клиенте.
//
Функция ВыполнятьКриптооперацииНаСервере() Экспорт
	
	Возврат ЭлектроннаяПодпись.СоздаватьЭлектронныеПодписиНаСервере();
	
КонецФункции

// Создает на сервере менеджер криптографии. Пароль не устанавливается.
//
// Параметры:
//  Отказ - Булево -  признак возникновения ошибки создания менеджера криптографии;
//  ПоказыватьОшибку - Булево - показывать текст ошибки.
//  Программа - Неопределено - возвращает менеджер криптографии первой
//              программы из справочника для которой удалось его создать.
//            - СправочникСсылка.ПрограммыЭлектроннойПодписиИШифрования - программа
//              для которой нужно создать и вернуть менеджер криптографии.
//
// Возвращаемое значение:
//   МенеджерКриптографии  - менеджер криптографии.
//
Функция МенеджерКриптографии(Отказ, ПоказыватьОшибку = Истина, Программа = Неопределено) Экспорт
	
	МенеджерКриптографии = ЭлектроннаяПодпись.МенеджерКриптографии("", ПоказыватьОшибку, , Программа);
	
	Если МенеджерКриптографии = Неопределено Тогда
		Отказ = Истина;
	КонецЕсли;
	
	Возврат МенеджерКриптографии;
	
КонецФункции

// Проверяет действительность подписи, без учета списка отозванных сертификатов.
// В случае ошибки генерирует исключение.
//
// Параметры:
//  МенеджерКриптографии  - МенеджерКриптографии - менеджер криптографии.
//  ДвоичныеДанныеФайла   - ДвоичныеДанные - двоичные данные файла.
//  ДвоичныеДанныеПодписи - ДвоичныеДанные - двоичные данные подписи.
//
Процедура ПроверитьПодпись(МенеджерКриптографии, ДвоичныеДанныеФайла, ДвоичныеДанныеПодписи) Экспорт
	
	МенеджерКриптографии.ПроверитьПодпись(ДвоичныеДанныеФайла, ДвоичныеДанныеПодписи);
	
КонецПроцедуры

// Формирует данные подписи объекта.
//
// Параметры:
//  МенеджерКриптографии  - МенеджерКриптографии - менеджер криптографии;
//  ОбъектДляПодписиСсылка  - ЛюбаяСсылка - ссылка на подписываемый объект;
//  ДвоичныеДанные  - ДвоичныеДанные - двоичные данные подписи;
//  СтруктураПараметровПодписи  - Структура - информация о подписи - выбранный сертификат, пароль, комментарий.
//
// Возвращаемое значение:
//   Структура   - данные для занесения в табличную часть ЭП.
//
Функция СформироватьДанныеПодписи(МенеджерКриптографии, ОбъектДляПодписиСсылка, ДвоичныеДанные, СтруктураПараметровПодписи) Экспорт
	
	МенеджерКриптографии.ПарольДоступаКЗакрытомуКлючу = СтруктураПараметровПодписи.ПарольПользователя;
	ДатаПодписи = Дата('00010101');
	
	НоваяПодписьДвоичныеДанные = МенеджерКриптографии.Подписать(ДвоичныеДанные, СтруктураПараметровПодписи.Сертификат);
	
	Отпечаток = Base64Строка(СтруктураПараметровПодписи.Сертификат.Отпечаток);
	КомуВыданСертификат = ЭлектроннаяПодпись.ПредставлениеСубъекта(СтруктураПараметровПодписи.Сертификат);
	ДвоичныеДанныеСертификата = СтруктураПараметровПодписи.Сертификат.Выгрузить();
	
	ДанныеПодписи = Новый Структура;
	ДанныеПодписи.Вставить("ОбъектСсылка",               ОбъектДляПодписиСсылка);
	ДанныеПодписи.Вставить("Отпечаток",                  Отпечаток);
	ДанныеПодписи.Вставить("ДатаПодписи",                ДатаПодписи);
	ДанныеПодписи.Вставить("Комментарий",                СтруктураПараметровПодписи.Комментарий);
	ДанныеПодписи.Вставить("ИмяФайлаПодписи",            "");
	ДанныеПодписи.Вставить("КомуВыданСертификат",        КомуВыданСертификат);
	ДанныеПодписи.Вставить("АдресФайла",                 "");
	ДанныеПодписи.Вставить("Подпись",                    НоваяПодписьДвоичныеДанные);
	ДанныеПодписи.Вставить("Сертификат",                 ДвоичныеДанныеСертификата);
	
	Возврат ДанныеПодписи;
	
КонецФункции

// Позволяет получить свойства субъекта сертификата ЭП.
//
// Параметры:
//  Сертификат ЭП - справочник-ссылка - ссылка на элемент справочника "Сертификаты ЭП".
//
// Возвращаемое значение:
//  Структура свойств субъекта сертификата.
//
Функция СвойстваСубъектаСертификата(СертификатЭП) Экспорт

	ПараметрыСертификата = ЭлектронноеВзаимодействиеСлужебныйВызовСервера.РеквизитыСертификата(СертификатЭП);
	Сертификат = Новый СертификатКриптографии(ПараметрыСертификата.ДвоичныеДанныеСертификата);
	
	Возврат ЭлектроннаяПодпись.СвойстваСубъектаСертификата(Сертификат);
	
КонецФункции

// Находит сертификат по строке отпечатка.
//
// Параметры:
//  Отпечаток  - Строка - base64 кодированный отпечаток сертификата;
//  ТолькоВЛичномХранилище  - Булево - вести поиск только в личном хранилище.
//
// Возвращаемое значение:
//   СертификатКриптографии  - сертификат криптографии.
//
Функция ПолучитьСертификатПоОтпечатку(Отпечаток, ТолькоВЛичномХранилище = Ложь) Экспорт
	
	ДвоичныеДанныеОтпечатка = Base64Значение(Отпечаток);
	
	Отказ = Ложь;
	МенеджерКриптографии = МенеджерКриптографии(Отказ);
	Если Отказ Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ХранилищеСертификатовКриптографии = Неопределено;
	Если ТолькоВЛичномХранилище Тогда
		ХранилищеСертификатовКриптографии = МенеджерКриптографии.ПолучитьХранилищеСертификатов(
			ТипХранилищаСертификатовКриптографии.ПерсональныеСертификаты);
	Иначе	
		ХранилищеСертификатовКриптографии = МенеджерКриптографии.ПолучитьХранилищеСертификатов();
	КонецЕсли;
	
	Сертификат = ХранилищеСертификатовКриптографии.НайтиПоОтпечатку(ДвоичныеДанныеОтпечатка);
	
	Возврат Сертификат;
	
КонецФункции

// Обработчик подписки на событие ЗаполнитьВидыЭДДляСертификатаЭП.
//
// Параметры:
//  Источник - СправочникОбъект.СертификатыКлючейЭлектроннойПодписиИШифрования - сертификат криптографии;
//  Отказ - Булево - Признак отказа от записи элемента.
//
Процедура ЗаполнитьВидыЭДДляСертификатаЭППередЗаписью(Источник, Отказ) Экспорт
	
	Если Источник.ОбменДанными.Загрузка Тогда
		Возврат;
	КонецЕсли;
	
	СсылкаНаОбъект = ПолучитьСсылкуОбъектаБезопасно(Источник);
	Если Источник.ЭтоНовый() Тогда
		РегистрыСведений.ПодписываемыеВидыЭД.СохранитьПодписываемыеВидыЭД(СсылкаНаОбъект);
	КонецЕсли;

КонецПроцедуры

Функция ОписаниеПрограммКриптографии() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	Программы.ИмяПрограммы КАК ИмяПрограммы,
	|	Программы.ТипПрограммы КАК ТипПрограммы
	|ИЗ
	|	Справочник.ПрограммыЭлектроннойПодписиИШифрования КАК Программы";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	НаборОписаний = Новый Массив;
	
	Пока Выборка.Следующий() Цикл
		
		Описание = ЭлектроннаяПодпись.НовоеОписаниеПрограммы();
		ЗаполнитьЗначенияСвойств(Описание, Выборка);
		НаборОписаний.Добавить(Описание);
		
	КонецЦикла;
	
	Возврат НаборОписаний;
	
КонецФункции

#КонецОбласти

#Область ТабличныйДокумент

// Скрытие областей табличного документа.
//
// Параметры:
//  ТабличныйДокумент - ТабличныйДокумент - табличный документ, где скрываются области.
//  ИменаОбластей - Строка - Имена скрываемых областей через запятую.
//  ТипСмещения - ТипСмещенияТабличногоДокумента - тип смещения удаляемой области.
//
Процедура СкрытьОбластиТабличногоДокумента(ТабличныйДокумент, ИменаОбластей, Знач ТипСмещения = Неопределено) Экспорт
	
	Если ТипСмещения = Неопределено Тогда
		ТипСмещения = ТипСмещенияТабличногоДокумента.ПоГоризонтали;
	КонецЕсли;
	
	Если ТипЗнч(ИменаОбластей) <> Тип("Массив") Тогда
		Области = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов(ИменаОбластей, ",");
	КонецЕсли;
	
	Для каждого ИмяОбласти Из Области Цикл
		
		ЕстьОбластьДД = ТабличныйДокумент.Области.Найти(СокрЛП(ИмяОбласти));
		
		Если ЕстьОбластьДД <> Неопределено Тогда
			ОбластьШапки = ТабличныйДокумент.Области.Найти("Шапка");
			ОбластьТаблицы = ТабличныйДокумент.Область(ИмяОбласти);
			
			Верх = ?(ОбластьТаблицы.Лево = 0 И ОбластьТаблицы.Право = 0 ИЛИ ОбластьШапки = Неопределено,
				ОбластьТаблицы.Верх, ОбластьШапки.Низ + 1);
				
			Если ТипСмещения = ТипСмещенияТабличногоДокумента.ПоГоризонтали Тогда
				УдаляемаяОбласть = ТабличныйДокумент.Область(Верх, ОбластьТаблицы.Лево,
					ТабличныйДокумент.ВысотаТаблицы, ОбластьТаблицы.Право);
			ИначеЕсли ТипСмещения = ТипСмещенияТабличногоДокумента.БезСмещения Тогда 
				УдаляемаяОбласть = ТабличныйДокумент.Область(Верх, ОбластьТаблицы.Лево,
					ОбластьТаблицы.Низ, ОбластьТаблицы.Право);
				Если ИмяОбласти = "ИдентификаторДокумента" Тогда
					ТипСмещения = ТипСмещенияТабличногоДокумента.ПоГоризонтали;	
				КонецЕсли;
			Иначе
				Низ = ТабличныйДокумент.ВысотаТаблицы;
				УдаляемаяОбласть = ТабличныйДокумент.Область(Верх, , Низ,);
			КонецЕсли; 
				
			ТабличныйДокумент.УдалитьОбласть(УдаляемаяОбласть, ТипСмещения);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Функция ПолучитьМакетИдентификатораДокумента() Экспорт
	
	Возврат Обработки.ЭлектронноеВзаимодействие.ПолучитьМакет(
		СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("ЭД_ИдентификаторДокумента_%1",
			ОбщегоНазначения.КодОсновногоЯзыка()));
	
КонецФункции

#КонецОбласти

#Область РаботаСXDTO

// Возвращает значение свойства XDTO
//
// Параметры:
//  ОбъектXDTO - ОбъектXDTO - объект, значение свойства которого нужно получить
//  Путь - Строка - путь к свойству, разделителем является символ ".".
// 
// Возвращаемое значение:
//  Неопределено - данное свойство отсутствует;
//  Строка - значение свойства;
//  ОбъектXDTO - объект XDTO.
//
Функция ЗначениеСвойстваXDTO(ОбъектXDTO, Путь) Экспорт
	
	Если ТипЗнч(ОбъектXDTO) <> Тип("ОбъектXDTO") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСтрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивСлов(Путь, ".");
	
	Если ОбъектXDTO.Свойства().Получить(МассивСтрок[0]) = Неопределено Тогда
		Возврат Неопределено
	КонецЕсли;
	
	Если МассивСтрок.Количество() = 1 Тогда
		Значение = ОбъектXDTO[МассивСтрок[0]];
		Если ТипЗнч(Значение) = Тип("ОбъектXDTO") И Значение.Свойства().Количество() = 0 Тогда
			Возврат Неопределено;
		КонецЕсли;
		Возврат Значение;
	Иначе
		НаборСвойств = ОбъектXDTO.Свойства();
		Свойство = НаборСвойств.Получить(МассивСтрок[0]);
		Если Свойство = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		Если Свойство.ВерхняяГраница = 1 Тогда
			ПодОбъектXDTO = ОбъектXDTO.ПолучитьXDTO(Свойство);
		Иначе
			Список = ОбъектXDTO.ПолучитьСписок(Свойство);
			Если Список.Количество() = 0 Тогда
				Возврат Неопределено;
			Иначе
				ПодОбъектXDTO = Список[0];
			КонецЕсли;
		КонецЕсли;
		МассивСтрок.Удалить(0);
		НоваяСтрока = "";
		Для Каждого Элемент Из МассивСтрок Цикл
			НоваяСтрока = НоваяСтрока + ?(ПустаяСтрока(НоваяСтрока), "", ".") + Элемент;
		КонецЦикла;
		Возврат ЗначениеСвойстваXDTO(ПодОбъектXDTO, НоваяСтрока);
	КонецЕсли;
	
КонецФункции

#КонецОбласти

#Область Преобразование

// Разделение строки на элементы массива.
//
// Параметры:
//  Строка		 - Строка - строка для разделения.
//  Разделитель	 - Строка - разделитель.
// 
// Возвращаемое значение:
//  Массив - результат разделения.
//
Функция МассивПодстрок(Знач Строка, Разделитель) Экспорт
	
	Результат = Новый Массив;
	Если ПустаяСтрока(Строка) Тогда
		Возврат Результат;
	КонецЕсли;
	
	НачПозицияПервогоЭлемента = СтрНайти(Строка, "{");
	КонПозицияПервогоЭлемента = СтрНайти(Строка, "}");
	Если НачПозицияПервогоЭлемента > 0 И КонПозицияПервогоЭлемента > 0 Тогда
		ПервыйЭлемент = Сред(Строка, НачПозицияПервогоЭлемента, КонПозицияПервогоЭлемента);
		Результат.Добавить(СокрЛП(ПервыйЭлемент));
		Строка = СокрЛП(Сред(Строка,КонПозицияПервогоЭлемента + 2));
	КонецЕсли;
	
	Пока Истина Цикл
		Позиция = СтрНайти(Строка, Разделитель);
		Если Позиция = 0 Тогда
			Прервать;
		КонецЕсли;
		
		Результат.Добавить(СокрЛП(Лев(Строка,Позиция - 1)));
		Строка = СокрЛП(Сред(Строка,Позиция + 1));
	КонецЦикла;
	
	Результат.Добавить(СокрЛП(Строка));
	
	Возврат Результат;
	
КонецФункции 

// Получение строки в формате Base64 по двоичным данным.
//
// Параметры:
//  Данные - ДвоичныеДанные - Данные, которые необходимо преобразовать в формат Base64.
// 
// Возвращаемое значение:
//  Строка - Двоичные данные в формате Base64.
//
Функция Base64СтрокаИзДвоичныхДанных(Знач Данные) Экспорт
	
	Результат = "";
	
	Если ТипЗнч(Данные) = Тип("ДвоичныеДанные") Тогда
		Результат = ПолучитьBase64СтрокуИзДвоичныхДанных(Данные);
		Результат = СтрЗаменить(Результат, Символы.ПС, "");
		Результат = СтрЗаменить(Результат, Символы.ВК, "");
		Результат = СтрЗаменить(Результат, " ", "");
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Функция ИдентификаторТовараПоСтроке(Знач СтрокаТовара, Знач МаксимальнаяДлина = Неопределено) Экспорт
	
	Если Не ЗначениеЗаполнено(МаксимальнаяДлина) Тогда
		МаксимальнаяДлина = 110;
	КонецЕсли;
	
	Идентификатор = СтрокаТовара;
	Идентификатор = ВРег(Идентификатор);
	Идентификатор = СтрЗаменить(Идентификатор, " ", "");
	
	Длина = СтрДлина(Идентификатор);
	
	Если Длина > МаксимальнаяДлина Тогда
		
		Хеширование = Новый ХешированиеДанных(ХешФункция.MD5);
		Хеширование.Добавить(Идентификатор);
		
		ХешСтрока = Строка(Хеширование.ХешСумма);
		ХешСтрока = СтрЗаменить(ХешСтрока, " ", "");
		
		ДлинаХешСтроки = СтрДлина(ХешСтрока);
		
		Идентификатор = Лев(Идентификатор, МаксимальнаяДлина - ДлинаХешСтроки) + ХешСтрока;
		
	КонецЕсли;
	
	Возврат Идентификатор;
	
КонецФункции

// Возвращает хеш сумму строки по алгоритму MD5.
//
// Параметры:
//  Данные - Строка - строка, по которой необходимо вычислить хеш.
//
// Возвращаемое значение:
//  Число - хеш, максимальная длина 20.
//
Функция Хеш_MD5_64(Знач Данные) Экспорт
	
	// Вычисляем хеш сумму по алгоритму MD5. Размер - 128 бит или 16 байт.
	Хеш = Новый ХешированиеДанных(ХешФункция.MD5);
	Хеш.Добавить(Данные);
	ДвоичныеДанныеХешСуммы = Хеш.ХешСумма;
	
	// Заберем 8 байт из середины.
	Поток = ДвоичныеДанныеХешСуммы.ОткрытьПотокДляЧтения();
	ЧтениеДанных = Новый ЧтениеДанных(Поток);
	
	// Первые 4 байта нам не интересны, пропустим.
	ЧтениеДанных.Пропустить(4);
	
	// Преобразует двоичные данные в int 64.
	Результат = ЧтениеДанных.ПрочитатьЦелое64(ПорядокБайтов.BigEndian);
	
	// Подчищаем за собой.
	ЧтениеДанных.Закрыть();
	Поток.Закрыть();
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область Локализация

// Определяет, использует ли конфигурация несколько языков.
// 
// Возвращаемое значение:
//  Булево - Истина, если в конфигурации объявлено несколько языков.
//
Функция КонфигурацияИспользуетНесколькоЯзыков() Экспорт

	Возврат Метаданные.Языки.Количество() > 1;

КонецФункции

#КонецОбласти

#Область РаботаСОбъектами

// Возвращает массив документов, которые могут быть проведены.
//
// Параметры:
//  МассивДокументов - Массив - массив ссылок на документы.
//
// Возвращаемое значение:
//  Массив - массив документов, которые можно проводить.
//
Функция МассивПроводимыхДокументов(МассивДокументов) Экспорт
	
	МассивПроводныхДокументов = Новый Массив;
	МассивТиповНеПроводныхДокументов = Новый Массив;
	Для каждого Элемент Из МассивДокументов Цикл
		ИмяДокумента = Элемент.Метаданные().ПолноеИмя();
		Если Метаданные.Документы.Содержит(Метаданные.НайтиПоПолномуИмени(ИмяДокумента)) Тогда
			
			Если Элемент.Метаданные().Проведение = Метаданные.СвойстваОбъектов.Проведение.Запретить Тогда
				Если МассивТиповНеПроводныхДокументов.Найти(ТипЗнч(Элемент)) = Неопределено Тогда
					МассивТиповНеПроводныхДокументов.Добавить(ТипЗнч(Элемент));
				КонецЕсли;
			КонецЕсли;
			
			МассивПроводныхДокументов.Добавить(Элемент)
		КонецЕсли;
	КонецЦикла;
	
	Для каждого ТипНеПроводногоДокумента Из МассивТиповНеПроводныхДокументов Цикл
		ОбщегоНазначенияКлиентСервер.УдалитьВсеВхожденияТипаИзМассива(МассивПроводныхДокументов, ТипНеПроводногоДокумента);
	КонецЦикла;
	
	Возврат МассивПроводныхДокументов;
	
КонецФункции

// Получает ссылку для объекта ИБ, в том числе нового.
//
// Параметры:
//  Объект	 - Объект - объект ссылочного типа.
// 
// Возвращаемое значение:
//  ЛюбаяСсылка - ссылка на переданный объект.
//
Функция ПолучитьСсылкуОбъектаБезопасно(Объект) Экспорт

	Ссылка = Объект.Ссылка;
	Если Ссылка.Пустая() Тогда
		Ссылка = Объект.ПолучитьСсылкуНового();
		Если Ссылка.Пустая() Тогда
			Ссылка = ОбщегоНазначения.МенеджерОбъектаПоСсылке(Ссылка).ПолучитьСсылку();
			Объект.УстановитьСсылкуНового(Ссылка);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Ссылка;

КонецФункции 

// Получает переданные реквизиты объекта или ссылки.
//
// Параметры:
//  Объект    - Объект, ЛюбаяСсылка - объект ссылочного типа или любая ссылка.
//  Реквизиты - Строка - имена реквизитов, перечисленные через запятую, в формате
//              требований к свойствам структуры.
//              Например, "Код, Наименование, Родитель".
//            - Структура, ФиксированнаяСтруктура - в качестве ключа передается
//              псевдоним поля для возвращаемой структуры с результатом, а в качестве
//              значения (опционально) фактическое имя поля в таблице.
//              Если значение не определено, то имя поля берется из ключа.
//            - Массив, ФиксированныйМассив - имена реквизитов в формате требований
//              к свойствам структуры.
// 
// Возвращаемое значение:
//  Структура - структура, в которой ключами являются имена реквизитов, а значениями - их значения.
//
Функция ЗначенияРеквизитовОбъектаИлиСсылки(Объект, Знач Реквизиты) Экспорт
	
	Если ОбщегоНазначения.ЗначениеСсылочногоТипа(Объект) Тогда
		Результат = ОбщегоНазначения.ЗначенияРеквизитовОбъекта(Объект, Реквизиты);
	Иначе
		// Передан объект - поэтому нужно составить структуру из реквизитов и прочитать в нее значения из объекта напрямую.
		Если ТипЗнч(Реквизиты) = Тип("Строка") Тогда
			Если ПустаяСтрока(Реквизиты) Тогда
				Возврат Новый Структура;
			КонецЕсли;
			Реквизиты = СтрРазделить(Реквизиты, ",", Ложь);
		КонецЕсли;
		
		Результат = Новый Структура;
		Если ТипЗнч(Реквизиты) = Тип("Структура") Или ТипЗнч(Реквизиты) = Тип("ФиксированнаяСтруктура") Тогда
			Результат = Реквизиты;
		ИначеЕсли ТипЗнч(Реквизиты) = Тип("Массив") Или ТипЗнч(Реквизиты) = Тип("ФиксированныйМассив") Тогда
			Для Каждого Реквизит Из Реквизиты Цикл
				Результат.Вставить(СтрЗаменить(Реквизит, ".", ""), Реквизит);
			КонецЦикла;
		Иначе
			ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Неверный тип второго параметра Реквизиты: %1'"), Строка(ТипЗнч(Реквизиты)));
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(Результат, Объект);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Устанавливает управляемую блокировку по значениям полей.
//
// Параметры:
//  Пространство - Строка - пространство блокировки.
//  Поля - Структура - ключ задает имя поля пространства блокировки, а значение:
//                     1. Источник задан: соответствующее поле источника, содержащее значения для блокировки.
//                     2. Источник не задан: непосредственно значение для блокировки.
//  Источник - РезультатЗапроса, Табличная часть, ТаблицаЗначений  - источник данных.
//  Режим - РежимБлокировкиДанных - режим блокировки.
//        - Неопределено - значение по умолчанию "Исключительный".
//
Процедура УстановитьУправляемуюБлокировку(Знач Пространство, Знач Поля = Неопределено, Знач Источник = Неопределено, Знач Режим = Неопределено) Экспорт
	
	Если Режим = Неопределено Тогда
		Режим = РежимБлокировкиДанных.Исключительный;
	КонецЕсли;
	
	Если Поля = Неопределено Тогда
		Поля = Новый Структура;
	КонецЕсли;
	
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить(Пространство);
	Если Источник = Неопределено Тогда
		Для каждого КлючЗначение Из Поля Цикл
			ЭлементБлокировки.УстановитьЗначение(КлючЗначение.Ключ, КлючЗначение.Значение);
		КонецЦикла;
	Иначе
		ЭлементБлокировки.ИсточникДанных = Источник;
		Для каждого КлючЗначение Из Поля Цикл
			ЭлементБлокировки.ИспользоватьИзИсточникаДанных(КлючЗначение.Ключ, КлючЗначение.Значение);
		КонецЦикла;
	КонецЕсли;
	ЭлементБлокировки.Режим = Режим;
	Блокировка.Заблокировать();
	
КонецПроцедуры

// Устанавливает управляемую блокировку по ссылке на объект.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка, по которой нужно установить блокировку.
//  Режим - РежимБлокировкиДанных - режим блокировки.
//        - Строка - допустимые значения "Разделяемый" и "Исключительный".
//        - Неопределено - значение по умолчанию "Исключительный".
//
//
Процедура УстановитьУправляемуюБлокировкуПоСсылке(Знач Ссылка, Знач Режим = Неопределено) Экспорт
	
	МетаданныеОбъекта = Ссылка.Метаданные();
	ПространствоБлокировки = МетаданныеОбъекта.ПолноеИмя();
	
	Поля = Новый Структура("Ссылка", Ссылка);
	
	УстановитьУправляемуюБлокировку(ПространствоБлокировки, Поля,, Режим);
	
КонецПроцедуры

// Устанавливает управляемую блокировку по набору записей.
// Используются установленные отборы в наборе.
//
// Параметры:
//  Набор - НаборЗаписей - набор, по которому нужно установить блокировку.
//  Режим - РежимБлокировкиДанных - режим блокировки.
//        - Строка - допустимые значения "Разделяемый" и "Исключительный".
//        - Неопределено - значение по умолчанию "Исключительный".
//
//
Процедура УстановитьУправляемуюБлокировкуПоНаборуЗаписей(Знач Набор, Знач Режим = Неопределено) Экспорт
	
	МетаданныеОбъекта = Набор.Метаданные();
	ПространствоБлокировки = МетаданныеОбъекта.ПолноеИмя();
	
	Поля = Новый Структура;
	Для каждого ЭлементОтбора Из Набор.Отбор Цикл
		Если ЭлементОтбора.Использование Тогда
			Поля.Вставить(ЭлементОтбора.ПутьКДанным, ЭлементОтбора.Значение);
		КонецЕсли;
	КонецЦикла;
	
	УстановитьУправляемуюБлокировку(ПространствоБлокировки, Поля,, Режим);
	
КонецПроцедуры

// Получает объект по ссылке для дальнейшего изменения. 
// Устанавливает управляемую и пессимистическую блокировку.
// Возможен вызов исключения, если не удалось установить пессимистическую блокировку.
//
// Параметры:
//  Ссылка - ЛюбаяСсылка - ссылка, объект которой нужно получить.
//
// Возвращаемое значение:
//  Объект,Неопределено - объект по ссылке. Неопределено, если объект отсутствует.
//
Функция ОбъектПоСсылкеДляИзменения(Знач Ссылка) Экспорт
	
	УстановитьУправляемуюБлокировкуПоСсылке(Ссылка);
	Объект = Ссылка.ПолучитьОбъект();
	
	Возврат Объект;
	
КонецФункции

// Возвращает ссылку по идентификатору и описанию типа.
//
// Параметры:
//  ИдентификаторСтрокой - Строка        - уникальный идентификатор ссылки строкой.
//  ОписаниеТипаСсылки   - ОписаниеТипов - описание типа ссылки.
//
// Возвращаемое значение:
//  Произвольный - найденная ссылка. Если не найдена, то Неопределено.
//
Функция НайтиСсылкуПоИдентификатору(Знач ИдентификаторСтрокой, Знач ОписаниеТипаСсылки) Экспорт
	
	Если Не СтроковыеФункцииКлиентСервер.ЭтоУникальныйИдентификатор(ИдентификаторСтрокой) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Идентификатор = Новый УникальныйИдентификатор(ИдентификаторСтрокой);
	НаборТипов = ОписаниеТипаСсылки.Типы();
	
	Для Каждого ТипСсылки Из НаборТипов Цикл
		
		МетаданныеСсылки = Метаданные.НайтиПоТипу(ТипСсылки);
		Если МетаданныеСсылки = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МетаданныеСсылки.ПолноеИмя());
		Ссылка = Менеджер.ПолучитьСсылку(Идентификатор);
		Если ОбщегоНазначения.СсылкаСуществует(Ссылка) Тогда
			Возврат Ссылка;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции

#КонецОбласти

#Область РаботаСМаршрутамиПодписания

////////////////////////////////////////////////////////////////////////////////
// Работа с данными маршрутов

// Формирует пустое дерево маршрута подписания со всеми необходимыми колонками.
// 
// Возвращаемое значение:
//  ДеревоЗначений - дерево маршрута подписания.
//
Функция ПустоеДеревоТребованийКПодписанию() Экспорт
	
	ДеревоПодписания = Новый ДеревоЗначений;
	ДеревоПодписания.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(36)));
	ДеревоПодписания.Колонки.Добавить("Требование", Новый ОписаниеТипов("ПеречислениеСсылка.ТребованияКПодписаниюЭД"));
	ДеревоПодписания.Колонки.Добавить("Подписант", Новый ОписаниеТипов("СправочникСсылка.Пользователи"));
	ДеревоПодписания.Колонки.Добавить("Сертификат", Новый ОписаниеТипов("СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования"));
	ДеревоПодписания.Колонки.Добавить("Организация", Метаданные.ОпределяемыеТипы.Организация.Тип);
	ДополнитьДеревоПодписанияСлужебнымиКолонками(ДеревоПодписания);

	Возврат ДеревоПодписания;
	
КонецФункции

// Формирует пустую таблицу маршрута подписания со всеми необходимыми колонками.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - таблица маршрута подписания.
//
Функция ПустаяТаблицаТребованийКПодписанию() Экспорт
	
	ТипИдентификатора = Новый ОписаниеТипов("Строка",, Новый КвалификаторыСтроки(36));
	
	ТаблицаПодписания = Новый ТаблицаЗначений;
	ТаблицаПодписания.Колонки.Добавить("Идентификатор", ТипИдентификатора);
	ТаблицаПодписания.Колонки.Добавить("ИдентификаторРодителя", ТипИдентификатора);
	ТаблицаПодписания.Колонки.Добавить("Порядок", Новый ОписаниеТипов("Число",
												  Новый КвалификаторыЧисла(10, 0, ДопустимыйЗнак.Любой)));
	ТаблицаПодписания.Колонки.Добавить("Требование", Новый ОписаниеТипов("ПеречислениеСсылка.ТребованияКПодписаниюЭД"));
	ТаблицаПодписания.Колонки.Добавить("Подписант", Новый ОписаниеТипов("СправочникСсылка.Пользователи"));
	ТаблицаПодписания.Колонки.Добавить("Сертификат", Новый ОписаниеТипов("СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования"));
	ТаблицаПодписания.Колонки.Добавить("Организация", Метаданные.ОпределяемыеТипы.Организация.Тип);
	ТаблицаПодписания.Колонки.Добавить("Текущий", Новый ОписаниеТипов("Булево"));
	ТаблицаПодписания.Колонки.Добавить("ПодписантОповещен", Новый ОписаниеТипов("Булево"));
	
	Возврат ТаблицаПодписания;
	
КонецФункции

// Заполняет таблицу подписания по дереву маршрута подписания.
//
// Параметры:
//  Таблица	 - ТаблицаЗначений, Неопределено - таблица маршрута подписания. Если не задана, будет сформирована.
//  Дерево	 - ДеревоЗначений  - дерево маршрута подписания.
//
Процедура ЗаполнитьТаблицуТребованийКПодписаниюПоДереву(Таблица, Дерево) Экспорт

	// Если таблица не задана, инициализируем ее
	Если Таблица = Неопределено Тогда
		Таблица = ПустаяТаблицаТребованийКПодписанию();
	КонецЕсли;
	
	ПрочитатьСтрокиДереваВТаблицуТребованийКПодписанию(Дерево, Таблица);

КонецПроцедуры

// Выполняет проверку маршрута на корректность и формирует результаты проверки.
//
// Параметры:
//  Маршрут - СправочникСсылка.МаршрутыПодписания - маршрут подписания.
//  ИспользуемыеСертификаты - Массив - элементы справочника "СертификатыКлючейЭлектроннойПодписиИШифрования",
//    используемые для подписания по переданному маршруту.
//  ВидыЭД - Массив - виды электронных документов, по которым производится проверка.
//  ПодписываемыеВидыЭДПереопределенные	 - ТаблицаЗначений - таблица, совпадающая по структуре с набором записей
//    регистра "ПодписываемыеВидыЭД". Необходима в случае, когда проверка выполняется при записи набор записей
//    этого регистра. В этом случае в ней нужно передать содержимое набора записей до изменения.
// 
// Возвращаемое значение:
//  Соответствие - ключом является вид электронного документа, а значением - ключевое имя ошибки.
//
Функция РезультатыПроверкиМаршрутаПоПараметрамНастройки(Маршрут, ИспользуемыеСертификаты, ВидыЭД, 
	ПодписываемыеВидыЭДПереопределенные = Неопределено) Экспорт 
	
	УстановитьПривилегированныйРежим(Истина);
	
	Результат = Новый Соответствие();
	ЕстьПодсистемаОбменСКонтрагентами = ОбщегоНазначения.ПодсистемаСуществует("ЭлектронноеВзаимодействие.ОбменСКонтрагентами");
	ЕстьПодсистемаОбменСБанками       = ОбщегоНазначения.ПодсистемаСуществует("ЭлектронноеВзаимодействие.ОбменСБанками");
	
	// Подготовим служебные переменные в зависимости от входных параметров
	Если ТипЗнч(Маршрут) = Тип("СправочникСсылка.МаршрутыПодписания") Тогда
		ВыполнятьПроверку = НЕ Маршрут.Предопределенный;
		ТаблицаМаршрута = Неопределено;
	ИначеЕсли Не ЕстьПодсистемаОбменСКонтрагентами И Не ЕстьПодсистемаОбменСБанками Тогда
		ВыполнятьПроверку = Ложь;
		ТаблицаМаршрута = Неопределено;
	Иначе
		// Передана таблица требований маршрута
		ВыполнятьПроверку = Истина;
		ТаблицаМаршрута = Маршрут;
	КонецЕсли;
	
	Если ПодписываемыеВидыЭДПереопределенные = Неопределено Тогда
		ПодписываемыеВидыЭДПереопределенные = РегистрыСведений.ПодписываемыеВидыЭД.СоздатьНаборЗаписей().Выгрузить();
	КонецЕсли;
	
	// Выполним проверку, если это необходимо
	Если ВыполнятьПроверку Тогда
		НаборыМассивовСертификатов = Новый Структура;
		
		// Получим соответствие уникальных массив сертификатов и видов документов, которые им можно подписать.
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ВидыЭД", ВидыЭД);
		Запрос.УстановитьПараметр("ТекущаяДата", ТекущаяДатаСеанса());
		Запрос.УстановитьПараметр("ИспользуемыеСертификаты", ИспользуемыеСертификаты);
		Запрос.УстановитьПараметр("ПодписываемыеВидыЭДПереопределенные", ПодписываемыеВидыЭДПереопределенные);
		
		ТекстыЗапросовПакета = Новый Массив;
		
		РазделительЭлементовПакета = "
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|
		|";
		
		// Получим виды электронных документов, которые подлежат подписи в соответствии с настройками.
		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	ПодписываемыеВидыЭДПереопределенные.СертификатЭП,
		|	ПодписываемыеВидыЭДПереопределенные.ВидЭД,
		|	ПодписываемыеВидыЭДПереопределенные.Использовать
		|ПОМЕСТИТЬ ПодписываемыеВидыЭДПереопределенные
		|ИЗ
		|	&ПодписываемыеВидыЭДПереопределенные КАК ПодписываемыеВидыЭДПереопределенные";
		ТекстыЗапросовПакета.Добавить(ТекстЗапроса);
		
		// Получим все возможные виды электронных документов.
		РазделительОбъединения = "
		|
		|ОБЪЕДИНИТЬ ВСЕ
		|
		|";
		ТекстЗапроса = "";
		ШаблонЗапроса = 
		"ВЫБРАТЬ
		|	ВидыЭД.Ссылка КАК ВидЭД
		|ПОМЕСТИТЬ ВидыЭД
		|ИЗ
		|	&ПеречислениеВидыЭлектронныхДокументов КАК ВидыЭД
		|ГДЕ
		|	ВидыЭД.Ссылка В(&ВидыЭД)";
		Если ЕстьПодсистемаОбменСКонтрагентами Тогда
			ТекстЗапроса = СтрЗаменить(ШаблонЗапроса, "&ПеречислениеВидыЭлектронныхДокументов", "Перечисление.ВидыЭД");
		КонецЕсли;
		
		Если ЕстьПодсистемаОбменСБанками Тогда
			Если ЗначениеЗаполнено(ТекстЗапроса) Тогда
				ТекстЗапроса = ТекстЗапроса + РазделительОбъединения;
				ШаблонЗапроса = СтрЗаменить(ШаблонЗапроса, "ПОМЕСТИТЬ ВидыЭД", "");
			КонецЕсли;
			
			ТекстЗапроса = ТекстЗапроса + СтрЗаменить(ШаблонЗапроса, "&ПеречислениеВидыЭлектронныхДокументов", "Перечисление.ВидыЭДОбменСБанками");
		КонецЕсли;
		ТекстыЗапросовПакета.Добавить(ТекстЗапроса);
		
		// Соберем по каждому сертификату виды документов, которые можно или нельзя им подписывать.
		ТекстЗапроса = 
		"ВЫБРАТЬ
		|	СертификатыКлючейЭлектроннойПодписиИШифрования.Ссылка КАК Сертификат
		|ПОМЕСТИТЬ ДействующиеСертификаты
		|ИЗ
		|	Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК СертификатыКлючейЭлектроннойПодписиИШифрования
		|ГДЕ
		|	СертификатыКлючейЭлектроннойПодписиИШифрования.Отозван = ЛОЖЬ
		|	И СертификатыКлючейЭлектроннойПодписиИШифрования.Отпечаток <> """"
		|	И СертификатыКлючейЭлектроннойПодписиИШифрования.ДействителенДо > &ТекущаяДата
		|	И СертификатыКлючейЭлектроннойПодписиИШифрования.Ссылка В(&ИспользуемыеСертификаты)
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ВидыЭД.ВидЭД,
		|	ДействующиеСертификаты.Сертификат
		|ПОМЕСТИТЬ СертификатыВидыЭД
		|ИЗ
		|	ВидыЭД КАК ВидыЭД
		|		ЛЕВОЕ СОЕДИНЕНИЕ ДействующиеСертификаты КАК ДействующиеСертификаты
		|		ПО (ИСТИНА)
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	СертификатыВидыЭД.Сертификат КАК Сертификат,
		|	ЕСТЬNULL(ПодписываемыеВидыЭДПереопределенные.Использовать, ЕСТЬNULL(ПодписываемыеВидыЭД.Использовать, ЛОЖЬ)) КАК Использовать,
		|	СертификатыВидыЭД.ВидЭД КАК ВидЭД
		|ИЗ
		|	СертификатыВидыЭД КАК СертификатыВидыЭД
		|		ЛЕВОЕ СОЕДИНЕНИЕ РегистрСведений.ПодписываемыеВидыЭД КАК ПодписываемыеВидыЭД
		|		ПО СертификатыВидыЭД.Сертификат = ПодписываемыеВидыЭД.СертификатЭП
		|			И СертификатыВидыЭД.ВидЭД = ПодписываемыеВидыЭД.ВидЭД
		|		ЛЕВОЕ СОЕДИНЕНИЕ ПодписываемыеВидыЭДПереопределенные КАК ПодписываемыеВидыЭДПереопределенные
		|		ПО СертификатыВидыЭД.Сертификат = ПодписываемыеВидыЭДПереопределенные.СертификатЭП
		|			И СертификатыВидыЭД.ВидЭД = ПодписываемыеВидыЭДПереопределенные.ВидЭД
		|
		|УПОРЯДОЧИТЬ ПО
		|	ВидЭД,
		|	Сертификат
		|ИТОГИ
		|	МАКСИМУМ(Использовать)
		|ПО
		|	ВидЭД";
		ТекстыЗапросовПакета.Добавить(ТекстЗапроса);
		Запрос.Текст = СтрСоединить(ТекстыЗапросовПакета, РазделительЭлементовПакета);
		
		ВыборкаВидовЭД = Запрос.Выполнить().Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
		Пока ВыборкаВидовЭД.Следующий() Цикл
			Если Не ВыборкаВидовЭД.Использовать Тогда
				Результат.Вставить(ВыборкаВидовЭД.ВидЭД, "НетДоступныхСертификатов");
			Иначе
				МассивСертификатов = Новый Массив;
				ИдентификаторМассива = "ИД_";
				Выборка = ВыборкаВидовЭД.Выбрать();
				Пока Выборка.Следующий() Цикл
					Если Не Выборка.Использовать Тогда
						Продолжить;
					КонецЕсли;
					
					Если МассивСертификатов.Найти(Выборка.Сертификат) = Неопределено Тогда
						МассивСертификатов.Добавить(Выборка.Сертификат);
						ИдентификаторМассива = ИдентификаторМассива + Строка(Выборка.Сертификат.УникальныйИдентификатор());
					КонецЕсли;
				КонецЦикла;
				
				ИдентификаторМассива = СтрЗаменить(ИдентификаторМассива, "-", "_");
				СтруктураОписанияНабораСертификатов = Неопределено;
				Если Не НаборыМассивовСертификатов.Свойство(ИдентификаторМассива, СтруктураОписанияНабораСертификатов) Тогда
					СтруктураОписанияНабораСертификатов = Новый Структура;
					СтруктураОписанияНабораСертификатов.Вставить("Сертификаты", МассивСертификатов);
					СтруктураОписанияНабораСертификатов.Вставить("ВидыЭД", Новый Массив);
					НаборыМассивовСертификатов.Вставить(ИдентификаторМассива, СтруктураОписанияНабораСертификатов);
				КонецЕсли;
				
				СтруктураОписанияНабораСертификатов.ВидыЭД.Добавить(ВыборкаВидовЭД.ВидЭД);
			КонецЕсли;
		КонецЦикла;
		
		// Подготовим в запросе таблицу маршрута, дополненную всеми возможными сертификатами для каждого элемента маршрута.
		Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц();
		Запрос.УстановитьПараметр("ПользовательНеУказан", Пользователи.СсылкаНеуказанногоПользователя());
		Запрос.УстановитьПараметр("ПустойПользователь", Справочники.Пользователи.ПустаяСсылка());
		Запрос.УстановитьПараметр("ПустойСертификат", Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования.ПустаяСсылка());
		Если ТаблицаМаршрута = Неопределено Тогда
			Запрос.УстановитьПараметр("Маршрут", Маршрут);
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	МаршрутыПодписанияТаблицаТребований.Идентификатор,
			|	МаршрутыПодписанияТаблицаТребований.ИдентификаторРодителя,
			|	МаршрутыПодписанияТаблицаТребований.Порядок,
			|	МаршрутыПодписанияТаблицаТребований.Требование,
			|	МаршрутыПодписанияТаблицаТребований.Подписант,
			|	МаршрутыПодписанияТаблицаТребований.Сертификат
			|ПОМЕСТИТЬ ТаблицаМаршрута
			|ИЗ
			|	Справочник.МаршрутыПодписания.ТаблицаТребований КАК МаршрутыПодписанияТаблицаТребований
			|ГДЕ
			|	МаршрутыПодписанияТаблицаТребований.Ссылка = &Маршрут
			|;
			|";
		Иначе
		    Запрос.УстановитьПараметр("ТаблицаМаршрута", ТаблицаМаршрута);
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	ТаблицаМаршрута.Идентификатор,
			|	ТаблицаМаршрута.ИдентификаторРодителя,
			|	ТаблицаМаршрута.Порядок,
			|	ТаблицаМаршрута.Требование,
			|	ТаблицаМаршрута.Подписант,
			|	ТаблицаМаршрута.Сертификат
			|ПОМЕСТИТЬ ТаблицаМаршрута
			|ИЗ
			|	&ТаблицаМаршрута КАК ТаблицаМаршрута
			|;
			|";
		КонецЕсли;
		Запрос.Текст = Запрос.Текст +
		"ВЫБРАТЬ
		|	ТаблицаМаршрута.Идентификатор,
		|	ТаблицаМаршрута.ИдентификаторРодителя,
		|	ТаблицаМаршрута.Порядок,
		|	ТаблицаМаршрута.Требование,
		|	ТаблицаМаршрута.Подписант,
		|	Сертификаты.Ссылка КАК Сертификат
		|ПОМЕСТИТЬ ДополненнаяТаблицаМаршрута
		|ИЗ
		|	ТаблицаМаршрута КАК ТаблицаМаршрута
		|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.СертификатыКлючейЭлектроннойПодписиИШифрования КАК Сертификаты
		|		ПО ((ТаблицаМаршрута.Подписант = Сертификаты.Пользователь
		|				ИЛИ Сертификаты.Пользователь В (&ПустойПользователь, &ПользовательНеУказан)
		|				ИЛИ ТаблицаМаршрута.Подписант = &ПустойПользователь)
		|				И (ТаблицаМаршрута.Сертификат = Сертификаты.Ссылка
		|					ИЛИ ТаблицаМаршрута.Сертификат = &ПустойСертификат))";
		Запрос.Выполнить();
		
		// Обойдем набор сертификатов и проверим для каждого набора валидность маршрута
		Для Каждого СтруктураНабораСертификатов Из НаборыМассивовСертификатов Цикл
			Запрос.УстановитьПараметр("НаборСертификатов", СтруктураНабораСертификатов.Значение.Сертификаты);
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	ДополненнаяТаблицаМаршрута.Идентификатор,
			|	ДополненнаяТаблицаМаршрута.ИдентификаторРодителя,
			|	ДополненнаяТаблицаМаршрута.Порядок,
			|	ДополненнаяТаблицаМаршрута.Требование,
			|	ДополненнаяТаблицаМаршрута.Подписант,
			|	МАКСИМУМ(ВЫБОР
			|			КОГДА ДополненнаяТаблицаМаршрута.Сертификат В (&НаборСертификатов)
			|				ТОГДА ИСТИНА
			|			ИНАЧЕ ЛОЖЬ
			|		КОНЕЦ) КАК ТребованиеВыполнимо
			|ИЗ
			|	ДополненнаяТаблицаМаршрута КАК ДополненнаяТаблицаМаршрута
			|
			|СГРУППИРОВАТЬ ПО
			|	ДополненнаяТаблицаМаршрута.Идентификатор,
			|	ДополненнаяТаблицаМаршрута.ИдентификаторРодителя,
			|	ДополненнаяТаблицаМаршрута.Порядок,
			|	ДополненнаяТаблицаМаршрута.Требование,
			|	ДополненнаяТаблицаМаршрута.Подписант";
			ТаблицаТребований = Запрос.Выполнить().Выгрузить();
			ДеревоТребований = Неопределено;
			ЗаполнитьДеревоПоТаблицеТребованийКПодписанию(ДеревоТребований, ТаблицаТребований);
			
			ЕстьНевыполнимыеТребования = Ложь;
			ОбработатьДеревоПодписания(ДеревоТребований, Ложь, Истина, Ложь,, Истина, ЕстьНевыполнимыеТребования);
			Если ДеревоТребований.Строки.Количество() = 0 ИЛИ ЕстьНевыполнимыеТребования Тогда
				Для Каждого ВидЭД Из СтруктураНабораСертификатов.Значение.ВидыЭД Цикл
					Результат.Вставить(ВидЭД, "НетДоступныхСертификатовДляНекоторыхШаговМаршрута");
				КонецЦикла;
			ИначеЕсли ДеревоТребований.Строки[0].Вес > СтруктураНабораСертификатов.Значение.Сертификаты.Количество() Тогда
				Для Каждого ВидЭД Из СтруктураНабораСертификатов.Значение.ВидыЭД Цикл
					Результат.Вставить(ВидЭД, "ДлинаМаршрутаБольшеКоличестваДоступныхСертификатов");
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 

// Выводит ошибки, найденные в результате проверки маршрута подписания, если таковые обнаружены.
//
// Параметры:
//  РезультатыПроверки	 - Соответствие - см. описание значения, возвращаемого функцией 
//    ЭлектронноеВзаимодействиеСлужебный.РезультатыПроверкиМаршрутаПоПараметрамНастройки.
//  НастройкаОбмена		 - СправочникСсылка, РегистрСведенийКлючЗаписи - ссылка или ключ настройки.
//  Маршрут              - СправочникСсылка.МаршрутыПодписания - маршрут подписания.
//  Отказ				 - Булево - устанавливается в Истина, если параметр РезультатыПроверки содержит ошибки.
//  ИсключаемыеОшибки	 - Строка - строка идентификаторов ошибок, перечисленных через запятую, по которым выводить 
//    сообщения не нужно.
//  КонтекстОперации - Структура - Контекст операции, см. ЭлектронноеВзаимодействиеСлужебный.НовыйКонтекстОперации.
//
Процедура ВывестиРезультатыПроверкиМаршрута(РезультатыПроверки, НастройкаОбмена, Маршрут, Отказ,
	ИсключаемыеОшибки = "", Знач ПредставлениеНастройки = "", КонтекстОперации = Неопределено) Экспорт
	
	Если РезультатыПроверки.Количество() Тогда
		ИсключаемыеОшибки = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИсключаемыеОшибки,, Истина, Истина);
		
		ЕстьОбменСКонтрагентами = ОбщегоНазначения.ПодсистемаСуществует("ЭлектронноеВзаимодействие.ОбменСКонтрагентами");
		ЕстьОбменСБанками = ОбщегоНазначения.ПодсистемаСуществует("ЭлектронноеВзаимодействие.ОбменСБанками");
		
		ИмяТипаНастройкиОбменСБанками = "СправочникСсылка.НастройкиОбменСБанками";
		ИмяТипаНастройкиОтправкиЭДО   = "РегистрСведенийКлючЗаписи.НастройкиОтправкиЭлектронныхДокументов";
		
		Если ЕстьОбменСБанками И ТипЗнч(НастройкаОбмена) = Тип(ИмяТипаНастройкиОбменСБанками) Тогда
			ТаблицаНастроек = НастройкаОбмена.ИсходящиеДокументы.Выгрузить();
			ИмяКолонкиТаблицыНастроек = "ИсходящийДокумент";
		ИначеЕсли ЕстьОбменСКонтрагентами И ТипЗнч(НастройкаОбмена) = Тип(ИмяТипаНастройкиОтправкиЭДО) Тогда
			МенеджерНастроек = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени("РегистрСведений.НастройкиОтправкиЭлектронныхДокументовПоВидам");
			ТаблицаНастроек = МенеджерНастроек.СоздатьНастройкиОтправкиДокументов();
			ИмяКолонкиТаблицыНастроек = "ВидДокумента";
		КонецЕсли;
		
		Если Не ЗначениеЗаполнено(ПредставлениеНастройки) Тогда
			ПредставлениеНастройки = Строка(НастройкаОбмена);
		КонецЕсли;
		
		Для Каждого РезультатПроверки Из РезультатыПроверки Цикл
			Если ИсключаемыеОшибки.Найти(РезультатПроверки.Значение) = Неопределено Тогда
				ВидЭДОшибки = РезультатПроверки.Ключ;
				ИдентификаторОшибки = РезультатПроверки.Значение;
				
				Если ОбщегоНазначения.ЭтоСсылка(ТипЗнч(НастройкаОбмена)) Тогда
					ТипНастройки = Метаданные.НайтиПоТипу(ТипЗнч(НастройкаОбмена)).ПредставлениеОбъекта;
				Иначе
					ТипНастройки = Метаданные.НайтиПоТипу(ТипЗнч(НастройкаОбмена)).ПредставлениеЗаписи;
				КонецЕсли;
				
				СтрокаТаблицыНастроек = ТаблицаНастроек.Найти(ВидЭДОшибки, ИмяКолонкиТаблицыНастроек);
				НомерСтроки = ТаблицаНастроек.Индекс(СтрокаТаблицыНастроек) + 1;
				
				Если ЕстьОбменСБанками И ТипЗнч(НастройкаОбмена) = Тип(ИмяТипаНастройкиОбменСБанками) Тогда
					МодульПодсистемы = ОбщегоНазначения.ОбщийМодуль("ОбменСБанкамиСлужебный");
				ИначеЕсли ЕстьОбменСКонтрагентами И ТипЗнч(НастройкаОбмена) = Тип(ИмяТипаНастройкиОтправкиЭДО) Тогда
					МодульПодсистемы = ОбщегоНазначения.ОбщийМодуль("ОбменСКонтрагентамиСлужебный");
				КонецЕсли;
				
				ИмяПоляОшибки = МодульПодсистемы.ИмяПоляДляОтображенияОшибкиПоМаршруту(НастройкаОбмена, НомерСтроки);
				
				ШаблонОшибки = "%3 ""%4"": " 
					+ ПредставлениеОшибкиНесоответствияМаршрутаНастройкам(
						ИдентификаторОшибки);
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонОшибки, ВидЭДОшибки, 
					Маршрут, ТипНастройки, ПредставлениеНастройки);
					
				Если КонтекстОперации = Неопределено Тогда
					Если ЕстьОбменСКонтрагентами И ТипЗнч(НастройкаОбмена) = Тип(ИмяТипаНастройкиОтправкиЭДО) Тогда
						КлючДанных = МодульПодсистемы.СсылкаНаОбъектНастройкиЭДО(НастройкаОбмена.Отправитель, НастройкаОбмена.Получатель, НастройкаОбмена.Договор);
					Иначе 
						КлючДанных = НастройкаОбмена;
					КонецЕсли;
					ОбщегоНазначения.СообщитьПользователю(ТекстОшибки, КлючДанных, ИмяПоляОшибки, "Запись", Отказ);
				Иначе 
					Ошибка = ЭлектронноеВзаимодействиеОбработкаОшибокКлиентСервер.НоваяОшибка(НСтр("ru = 'Проверка маршрута подписания'"),
						ЭлектронноеВзаимодействиеОбработкаОшибокКлиентСервер.ВидОшибкиМаршрутПодписания(), ТекстОшибки, ТекстОшибки,
						Новый Структура("СсылкаНаОбъект", Маршрут));
					ЭлектронноеВзаимодействиеОбработкаОшибок.ДобавитьОшибку(КонтекстОперации, Ошибка, Ложь);
					Отказ = Истина;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

// Формирует маршрут подписания электронного документа в соответствии с настройками системы и данными документа
// и возвращает таблицу подписания.
//
// Параметры:
//  ЭлектронныйДокумент	 - СправочникСсылка.ЭДПрисоединенныеФайлы, ДокументСсылка.СообщениеОбменСБанками - ссылка на
//    объект, для которого формируется маршрут подписания.
//  Маршрут              - СправочникСсылка.МаршрутыПодписания - маршрут подписания.
//  УсловиеПодписания	 - ПеречислениеСсылка.ТребованияКПодписаниюЭД - требование к подписанию. Используется совместно
//    с параметром "СписокПодписантов" и задает логическое условие для объединения переданных подписантов.
//  СписокПодписантов	 - Массив - подписанты маршрута. Содержит элементы типа "СправочникСсылка.Пользователи" или
//    строки табличной части таблицы подписания. Используется совместно с параметром "УсловиеПодписания".
//  ВесМаршрута			 - Число - в данную переменную будет возвращено максимально возможное количество подписей.
//
// Возвращаемое значение:
// См. ТаблицаМаршрутаПоПараметрам
//
Функция СформироватьМаршрутПодписанияЭД(ЭлектронныйДокумент, Маршрут, УсловиеПодписания = Неопределено, 
	СписокПодписантов = Неопределено, ВесМаршрута = 0) Экспорт
	
	ТаблицаПодписания = ТаблицаМаршрутаПоПараметрам(ЭлектронныйДокумент, Маршрут, УсловиеПодписания, СписокПодписантов,
		ВесМаршрута);
		
	УстановитьПривилегированныйРежим(Истина);
	
	// Запишем полученные данные в регистр
	НаборЗаписей = РегистрыСведений.СостояниеПодписанияЭД.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Объект.Установить(ЭлектронныйДокумент);
	НаборЗаписей.Загрузить(ТаблицаПодписания);
	НаборЗаписей.Записать();
		
	УстановитьПривилегированныйРежим(Ложь);
	
	Возврат ТаблицаПодписания;
	
КонецФункции

// Формирует таблицу маршрута подписания по переданным параметрам.
//
// Параметры:
//  ЭлектронныйДокумент	 - СправочникСсылка.ЭДПрисоединенныеФайлы, ДокументСсылка.СообщениеОбменСБанками - ссылка на
//    объект, для которого формируется маршрут подписания.
//  Маршрут              - СправочникСсылка.МаршрутыПодписания - маршрут подписания.
//  УсловиеПодписания	 - ПеречислениеСсылка.ТребованияКПодписаниюЭД - требование к подписанию. Используется совместно
//    с параметром "СписокПодписантов" и задает логическое условие для объединения переданных подписантов.
//  СписокПодписантов	 - Массив - подписанты маршрута. Содержит элементы типа "СправочникСсылка.Пользователи" или
//    строки табличной части таблицы подписания. Используется совместно с параметром "УсловиеПодписания".
//  ВесМаршрута			 - Число - в данную переменную будет возвращено максимально возможное количество подписей.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - таблица подписания.
//
Функция ТаблицаМаршрутаПоПараметрам(ЭлектронныйДокумент, Маршрут, УсловиеПодписания = Неопределено, 
	СписокПодписантов = Неопределено, ВесМаршрута = 0) Экспорт
	
	// Подготовим таблицу маршрута
	СхемаПодписания = Маршрут.СхемаПодписания;
	Если СхемаПодписания = Перечисления.СхемыПодписанияЭД.ПоПравилам Тогда
		ТаблицаПодписания = Маршрут.ТаблицаТребований.Выгрузить();
	Иначе
		ТаблицаПодписания = ТаблицаПодписанияПоПараметрам(СхемаПодписания, УсловиеПодписания, СписокПодписантов);
	КонецЕсли;
	
	// Рассчитаем вес маршрута и проставим текущие шаги
	ДеревоПодписания = Неопределено;
	ЗаполнитьДеревоПоТаблицеТребованийКПодписанию(ДеревоПодписания, ТаблицаПодписания);
	ОбработатьДеревоПодписания(ДеревоПодписания, Ложь, Ложь, Истина,, Истина);
	
	// Конвертируем обратно в таблицу, чтобы подготовить таблицу к записи в регистр
	ТаблицаПодписания = Неопределено;
	ЗаполнитьТаблицуТребованийКПодписаниюПоДереву(ТаблицаПодписания, ДеревоПодписания);
	ТаблицаПодписания.Колонки.Добавить("Объект", Метаданные.РегистрыСведений.СостояниеПодписанияЭД.Измерения.Объект.Тип);
	ТаблицаПодписания.ЗаполнитьЗначения(ЭлектронныйДокумент, "Объект");
	
	Для Каждого СтрокаТаблицыПодписания Из ТаблицаПодписания Цикл
		
		Если Не СтрокаТаблицыПодписания.Текущий Тогда
			Продолжить;
		КонецЕсли;
		
		ТекущийИдентификаторРодителя = СтрокаТаблицыПодписания.ИдентификаторРодителя;
				
		Пока ЗначениеЗаполнено(ТекущийИдентификаторРодителя) Цикл
			СтрокаРодителя = ТаблицаПодписания.Найти(ТекущийИдентификаторРодителя, "Идентификатор");
			Если СтрокаРодителя.Порядок <> 1 Тогда
				СтрокаТаблицыПодписания.Текущий = Ложь;
			КонецЕсли;
			ТекущийИдентификаторРодителя = СтрокаРодителя.ИдентификаторРодителя;
		КонецЦикла;
	
	КонецЦикла;
	
	// Вернем вес маршрута
	Если ДеревоПодписания.Строки.Количество() > 0 Тогда
		ВесМаршрута = ДеревоПодписания.Строки[0].Вес;
	Иначе
		ВесМаршрута = 0;
	КонецЕсли;
	
	Возврат ТаблицаПодписания;
	
КонецФункции

// Обновляет маршрут подписания документа при установке очередной подписи и возвращает таблицу подписания.
// При этом из маршрута удаляются невыполнимые и уже выполненные требования / подписи.
//
// Параметры:
//  ЭлектронныйДокумент	 - СправочникСсылка.ЭДПрисоединенныеФайлы, ДокументСсылка.СообщениеОбменСБанками - ссылка на
//    объект, для которого формируется маршрут подписания.
//  Сертификат			 - СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования - сертификат, по которому
//    установлена подпись.
//  ВесМаршрута			 - Число - в данную переменную будет возвращено максимально возможное количество подписей.
//  Пользователь		 - СправочникСсылка.Пользователи - пользователь, установивший подпись. Необязательный: если не
//    указан, будет использован текущий пользователь.
//
Функция ОбновитьМаршрутПриПодписании(ЭлектронныйДокумент, Знач Сертификат, ВесМаршрута = 0,
	Знач Пользователь = Неопределено) Экспорт

	Если ТипЗнч(Сертификат) = Тип("СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования") Тогда
		Если Пользователь = Неопределено Тогда
			Пользователь = Пользователи.ТекущийПользователь();
		КонецЕсли;
		
		НачатьТранзакцию();
		Попытка
			ОтборПоОбъекту = Новый Структура("Объект", ЭлектронныйДокумент);
			УстановитьУправляемуюБлокировку("РегистрСведений.СостояниеПодписанияЭД", ОтборПоОбъекту);
			// Запросим дерево из регистра и посчитаем сразу логический результат по строкам
			Запрос = Новый Запрос;
			Запрос.УстановитьПараметр("Документ", ЭлектронныйДокумент);
			Запрос.УстановитьПараметр("Пользователь", Пользователь);
			Запрос.УстановитьПараметр("ПустойПользователь", Справочники.Пользователи.ПустаяСсылка());
			Запрос.УстановитьПараметр("Сертификат", Сертификат);
			Запрос.УстановитьПараметр("Организация", Сертификат.Организация);
			Запрос.УстановитьПараметр("ПустойСертификат", Справочники.СертификатыКлючейЭлектроннойПодписиИШифрования.ПустаяСсылка());
			Запрос.УстановитьПараметр("ПустаяОрганизация", Метаданные.ОпределяемыеТипы.Организация.Тип.ПривестиЗначение());
			Запрос.Текст = 
			"ВЫБРАТЬ
			|	ТаблицаПодписанияЭД.Идентификатор,
			|	ТаблицаПодписанияЭД.Порядок,
			|	ТаблицаПодписанияЭД.Требование,
			|	ТаблицаПодписанияЭД.Подписант,
			|	ТаблицаПодписанияЭД.Сертификат,
			|	ТаблицаПодписанияЭД.Организация,
			|	МАКСИМУМ(ВЫБОР
			|			КОГДА ТаблицаПодписанияЭД.Текущий
			|					И (ТаблицаПодписанияЭД.Подписант = &Пользователь ИЛИ ТаблицаПодписанияЭД.Подписант = &ПустойПользователь)
			|					И (ТаблицаПодписанияЭД.Сертификат = &Сертификат ИЛИ ТаблицаПодписанияЭД.Сертификат = &ПустойСертификат)
			|					И (ТаблицаПодписанияЭД.Организация = &Организация ИЛИ ТаблицаПодписанияЭД.Организация = &ПустаяОрганизация)
			|					И ТаблицаПодписанияЭД.Порядок = 1
			|				ТОГДА ИСТИНА
			|			ИНАЧЕ ЛОЖЬ
			|		КОНЕЦ) КАК Выполнено,
			|	МАКСИМУМ(ВЫБОР
			|			КОГДА ТаблицаПодписанияЭД.Текущий
			|					И (ТаблицаПодписанияЭД.Подписант = &Пользователь ИЛИ ТаблицаПодписанияЭД.Подписант = &ПустойПользователь)
			|					И (ТаблицаПодписанияЭД.Сертификат = &Сертификат ИЛИ ТаблицаПодписанияЭД.Сертификат = &ПустойСертификат)
			|					И (ТаблицаПодписанияЭД.Организация = &Организация ИЛИ ТаблицаПодписанияЭД.Организация = &ПустаяОрганизация)
			|					И ТаблицаПодписанияЭД.Порядок = 1
			|				ТОГДА ИСТИНА
			|			ИНАЧЕ ЛОЖЬ
			|		КОНЕЦ) КАК ВыполненоМаксимум,
			|	ТаблицаПодписанияЭД.ИдентификаторРодителя,
			|	ТаблицаПодписанияЭД.ПодписантОповещен
			|ИЗ
			|	РегистрСведений.СостояниеПодписанияЭД КАК ТаблицаПодписанияЭД
			|ГДЕ
			|	ТаблицаПодписанияЭД.Объект = &Документ
			|
			|СГРУППИРОВАТЬ ПО
			|	ТаблицаПодписанияЭД.Идентификатор,
			|	ТаблицаПодписанияЭД.Порядок,
			|	ТаблицаПодписанияЭД.Требование,
			|	ТаблицаПодписанияЭД.Подписант,
			|	ТаблицаПодписанияЭД.Сертификат,
			|	ТаблицаПодписанияЭД.Организация,
			|	ТаблицаПодписанияЭД.ИдентификаторРодителя,
			|	ТаблицаПодписанияЭД.ПодписантОповещен
			|
			|УПОРЯДОЧИТЬ ПО
			|	ИдентификаторРодителя,
			|	Порядок";
			УстановитьПривилегированныйРежим(Истина);
			ТаблицаПодписания = Запрос.Выполнить().Выгрузить();
			УстановитьПривилегированныйРежим(Ложь);
			
			// Загрузим текущую таблицу подписания в дерево
			ДеревоПодписания = Неопределено;
			ЗаполнитьДеревоПоТаблицеТребованийКПодписанию(ДеревоПодписания, ТаблицаПодписания);
			
			// Оптимизируем дерево, удалив отработанные и заведомо ложные строки, а также проставим текущие сертификаты.
			ОбработатьДеревоПодписания(ДеревоПодписания, Ложь, Истина, Истина,, Истина);
			
			// Получим снова таблицу, дополним ее и запишем в регистр
			ТаблицаПодписания = Неопределено;
			ЗаполнитьТаблицуТребованийКПодписаниюПоДереву(ТаблицаПодписания, ДеревоПодписания);
			ТаблицаПодписания.Колонки.Добавить("Объект");
			ТаблицаПодписания.ЗаполнитьЗначения(ЭлектронныйДокумент, "Объект");
			
			УстановитьПривилегированныйРежим(Истина);
			
			НаборЗаписей = РегистрыСведений.СостояниеПодписанияЭД.СоздатьНаборЗаписей();
			НаборЗаписей.Отбор.Объект.Установить(ЭлектронныйДокумент);
			НаборЗаписей.Загрузить(ТаблицаПодписания);
			НаборЗаписей.Записать();
			
			УстановитьПривилегированныйРежим(Ложь);
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
		
		// Вернем вес маршрута
		Если ДеревоПодписания.Строки.Количество() > 0 Тогда
			ВесМаршрута = ДеревоПодписания.Строки[0].Вес;
		Иначе 
			ВесМаршрута = 0;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ТаблицаПодписания;
	
КонецФункции

// Определяет, все ли необходимые подписи на документе установлены.
//
// Параметры:
//  ЭлектронныйДокумент	 - СправочникСсылка.ЭДПрисоединенныеФайлы, ДокументСсылка.СообщениеОбменСБанками - ссылка на
//    объект, для которого формируется маршрут подписания.
// 
// Возвращаемое значение:
//  Булево - Истина, все необходимые для выполнения маршрута подписания подписи установлены.
//
Функция МаршрутПодписанияЗавершен(ЭлектронныйДокумент) Экспорт

	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ЭлектронныйДокумент", ЭлектронныйДокумент);
	Запрос.Текст =
	"ВЫБРАТЬ
	|	СостояниеПодписанияДокумента.Объект КАК Документ
	|ИЗ
	|	РегистрСведений.СостояниеПодписанияЭД КАК СостояниеПодписанияДокумента
	|ГДЕ
	|	СостояниеПодписанияДокумента.Объект = &ЭлектронныйДокумент";
	
	УстановитьПривилегированныйРежим(Истина);
	Возврат Запрос.Выполнить().Пустой();

КонецФункции

// Очищает маршрут подписания документа. Используется, когда процесс подписания прекращается в
//   нештатном режиме (не при установке очередной подписи).
//
// Параметры:
//  ЭлектронныеДокументы - Массив - подписываемые электронные документы.
//                       - СправочникСсылка.ЭДПрисоединенныеФайлы - подписываемый электронный документ.
//                       - ДокументСсылка.СообщениеОбменСБанками - подписываемый электронный документ.
//
Процедура ОчиститьМаршрутПодписания(ЭлектронныеДокументы) Экспорт

	Если ТипЗнч(ЭлектронныеДокументы) = Тип("Массив") Тогда
		МассивДокументов = ЭлектронныеДокументы;
	Иначе
	    МассивДокументов = Новый Массив;
		МассивДокументов.Добавить(ЭлектронныеДокументы);
	КонецЕсли;
	
	НачатьТранзакцию();
	Попытка
		Для каждого Объект Из МассивДокументов Цикл
			ОтборПоОбъекту = Новый Структура("Объект", Объект);
			УстановитьУправляемуюБлокировку("РегистрСведений.СостояниеПодписанияЭД", ОтборПоОбъекту);
		КонецЦикла;
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("ЭлектронныеДокументы", МассивДокументов);
		Запрос.Текст =
		"ВЫБРАТЬ
		|	СостояниеПодписанияЭД.Объект
		|ИЗ
		|	РегистрСведений.СостояниеПодписанияЭД КАК СостояниеПодписанияЭД
		|ГДЕ
		|	СостояниеПодписанияЭД.Объект В(&ЭлектронныеДокументы)";
		УстановитьПривилегированныйРежим(Истина);
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			НаборЗаписейМаршрута = РегистрыСведений.СостояниеПодписанияЭД.СоздатьНаборЗаписей();
			НаборЗаписейМаршрута.Отбор.Объект.Установить(Выборка.Объект);
			НаборЗаписейМаршрута.Записать();
		КонецЦикла;
		УстановитьПривилегированныйРежим(Ложь);
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;

КонецПроцедуры

// Помещает во временное хранилище настройки выбора маршрута подписания.
//
// Параметры:
//  Владелец						 - ФормаКлиентскогоПриложения, Строка - уникальный идентификатор формы, во временное хранилище которой надо
//    поместить данные и вернуть новый адрес. Или адрес во временном хранилище, по которому надо поместить данные.
//  ЗадаватьМаршрутВручную			 - Булево - признак того, что маршрут будет указываться непосредственно при отправке
//    документа на подпись.
//  Подписанты						 - ТаблицаЗначений - таблица состава подписантов с колонками:
//    * Подписант - СправочникСсылка.Пользователи - пользователь, который может установить подпись.
//    * Сертификат - СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования - сертификат, которым можно 
//      подписать документ.
//  ФиксированныйМаршрут			 - СправочникСсылка.МаршрутыПодписания - маршрут, по которому будет подписываться документ.
//  ДоступныеДляВыбораСертификаты	 - Массив - содержит сертификаты, которыми можно подписывать документ в соответствии
//    с настройками.
// 
// Возвращаемое значение:
//  Строка - адрес настроек во временном хранилище.
//
Функция СохранитьНастройкиВыбораМаршрута(Владелец, ЗадаватьМаршрутВручную, Подписанты = Неопределено, 
	ФиксированныйМаршрут = Неопределено, ДоступныеДляВыбораСертификаты = Неопределено) Экспорт

	Настройки = НовыеНастройкиВыбораМаршрута(ЗадаватьМаршрутВручную,
		Подписанты, ФиксированныйМаршрут, ДоступныеДляВыбораСертификаты);
	УИДВладельца = ?(ТипЗнч(Владелец) = Тип("ФормаКлиентскогоПриложения"), Владелец.УникальныйИдентификатор, Владелец);
		
	Возврат ПоместитьВоВременноеХранилище(Настройки, УИДВладельца);

КонецФункции 

// Формирует представление параметров маршрута подписания документа.
//
// Параметры:
//  ЗадаватьМаршрутВручную			 - Булево - признак того, что маршрут будет указываться непосредственно при отправке
//    документа на подпись.
//  Подписанты						 - ТаблицаЗначений - таблица состава подписантов с колонками:
//    * Подписант - СправочникСсылка.Пользователи - пользователь, который может установить подпись.
//    * Сертификат - СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования - сертификат, которым можно 
//      подписать документ.
//  ФиксированныйМаршрут			 - СправочникСсылка.МаршрутыПодписания - маршрут, по которому будет подписываться документ.
// 
// Возвращаемое значение:
//  Строка - строковое представление параметров маршрута.
//
Функция ПредставлениеМаршрутаВыбранногоВДокументе(ЗадаватьМаршрутВручную, Подписанты = Неопределено, 
	ФиксированныйМаршрут = Неопределено) Экспорт

	Если ЗадаватьМаршрутВручную Тогда
		ПредставлениеНастроек = СтрШаблон(НСтр("ru = 'Подписи по списку (%1)'"), Подписанты.Количество());
	Иначе
		Если Не ЗначениеЗаполнено(ФиксированныйМаршрут) Тогда
			ПредставлениеНастроек = ПредставлениеНеВыбранногоМаршрута();
		Иначе 
			ПредставлениеНастроек = ФиксированныйМаршрут;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПредставлениеНастроек;

КонецФункции 

// Формирует представление невыбранного маршрута подписания.
// 
// Возвращаемое значение:
//  Строка - представление маршрута.
//
Функция ПредставлениеНеВыбранногоМаршрута() Экспорт

	Возврат НСтр("ru = '<не задан>'");

КонецФункции 

// Возвращает список возможных подписантов маршрута.
//
// Параметры:
//  Маршрут - СправочникСсылка.МаршрутыПодписания - маршрут подписания.
// 
// Возвращаемое значение:
//  Массив Из СправочникСсылка.Пользователи - возможные подписанты маршрута.
//
Функция ВозможныеПодписантыМаршрута(Маршрут) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	МаршрутыПодписанияТаблицаТребований.Подписант КАК Подписант
		|ИЗ
		|	Справочник.МаршрутыПодписания.ТаблицаТребований КАК МаршрутыПодписанияТаблицаТребований
		|ГДЕ
		|	МаршрутыПодписанияТаблицаТребований.Ссылка = &Маршрут
		|	И МаршрутыПодписанияТаблицаТребований.Подписант <> ЗНАЧЕНИЕ(Справочник.Пользователи.ПустаяСсылка)";
	
	Запрос.УстановитьПараметр("Маршрут", Маршрут);
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("Подписант"); 
	
КонецФункции

// Фиксирует факт отправки оповещения участнику маршрута о необходимости подписания электронного документа.
//
// Параметры:
//  ОбъектПодписания - СправочникСсылка.ЭДПрисоединенныеФайлы, ДокументСсылка.СообщениеОбменСБанками - ссылка на
//    объект, для которого было отправлено оповещение.
//  Подписант - СправочникСсылка.Пользователи - пользователь, которому было отправлено оповещение.
//
Процедура ЗафиксироватьФактОповещенияУчастникаМаршрутаОПодписании(ОбъектПодписания, Подписант) Экспорт
	
	Записывать = Ложь;
	УстановитьПривилегированныйРежим(Истина);
	НаборЗаписей = РегистрыСведений.СостояниеПодписанияЭД.СоздатьНаборЗаписей();
	НаборЗаписей.Отбор.Объект.Установить(ОбъектПодписания);
	
	НачатьТранзакцию();
	Попытка
		УстановитьУправляемуюБлокировкуПоНаборуЗаписей(НаборЗаписей);
		НаборЗаписей.Прочитать();
		Для каждого Запись Из НаборЗаписей Цикл
			Если Запись.Подписант = Подписант И Не Запись.ПодписантОповещен Тогда
				Запись.ПодписантОповещен = Истина;
				Записывать = Истина;
			КонецЕсли;
		КонецЦикла;
		Если Записывать Тогда
			НаборЗаписей.Записать();
		КонецЕсли;
		УстановитьПривилегированныйРежим(Ложь);
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ИмяСобытия = НСтр("ru = 'Запись факта оповещения о подписании электронного документа'", ОбщегоНазначения.КодОсновногоЯзыка());
		ЗаписьЖурналаРегистрации(ИмяСобытия, УровеньЖурналаРегистрации.Ошибка,,, ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Отрисовка дерева

// Заполняет на форме дерево маршрута подписания.
//
// Параметры:
//  Форма				 - ФормаКлиентскогоПриложения - форма, на которой нужно отрисовать дерево маршрута подписания.
//  ИсточникДанных		 - СправочникСсылка.ЭДПрисоединенныеФайлы - ссылка на электронный документ.
//                       - ДокументСсылка.СообщениеОбменСБанками - ссылка на электронный документ.
//                       - ТаблицаЗначений - готовая таблица маршрута подписания.
//  ИмяРеквизитаДерева	 - Строка - имя реквизита дерева маршрута на форме.
//  ИмяОсновногоРеквизита- Строка - имя реквизита дерева, который будет выводиться в основной колонке.
//
Процедура ЗаполнитьДеревоМаршрутаНаФорме(Форма, ИсточникДанных, ИмяРеквизитаДерева = "ДеревоТребований",
	ИмяОсновногоРеквизита = "Подписант", Вес = 0) Экспорт
	
	// Подготовим таблицу маршрута в зависимости от типа переданного значения
	Если ОбщегоНазначения.ЗначениеСсылочногоТипа(ИсточникДанных) Тогда
		// Передана ссылка на документ-владелец маршрута
		Запрос = Новый Запрос;
		Запрос.УстановитьПараметр("Объект", ИсточникДанных);
		Запрос.Текст = 
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	СостояниеПодписанияЭД.Идентификатор КАК Идентификатор,
		|	СостояниеПодписанияЭД.ИдентификаторРодителя КАК ИдентификаторРодителя,
		|	СостояниеПодписанияЭД.Порядок КАК Порядок,
		|	СостояниеПодписанияЭД.Требование,
		|	СостояниеПодписанияЭД.Подписант,
		|	СостояниеПодписанияЭД.Сертификат,
		|	СостояниеПодписанияЭД.Организация
		|ИЗ
		|	РегистрСведений.СостояниеПодписанияЭД КАК СостояниеПодписанияЭД
		|ГДЕ
		|	СостояниеПодписанияЭД.Объект = &Объект
		|
		|УПОРЯДОЧИТЬ ПО
		|	ИдентификаторРодителя,
		|	Порядок";
		УстановитьПривилегированныйРежим(Истина);
		ТаблицаМаршрута = Запрос.Выполнить().Выгрузить();
		УстановитьПривилегированныйРежим(Ложь);
	Иначе
		// Передана готовая таблица маршрута
		ТаблицаМаршрута = ИсточникДанных;
	КонецЕсли;
	
	// Заполним дерево из табличной части
	Дерево = Форма.РеквизитФормыВЗначение(ИмяРеквизитаДерева);
	Дерево.Строки.Очистить();
	ЗаполнитьДеревоПоТаблицеТребованийКПодписанию(Дерево, ТаблицаМаршрута);
	Форма.ЗначениеВРеквизитФормы(Дерево, ИмяРеквизитаДерева);
	
	// Инициализируем вспомогательные колонки в дереве
	ЗаполнитьВспомогательныеКолонкиВДеревеМаршрута(Форма[ИмяРеквизитаДерева], ИмяОсновногоРеквизита);
	
	// Просчитаем вес дерева.
	ОбработатьДеревоПодписания(Дерево, Ложь, Ложь, Ложь,, Истина);
	Если Дерево.Строки.Количество() > 0 Тогда
		Вес = Дерево.Строки[0].Вес;
	Иначе 
		Вес = 0;
	КонецЕсли;

КонецПроцедуры

// Устанавливает у дерева маршрута на форме условное оформление.
//
// Параметры:
//  Форма				               - ФормаКлиентскогоПриложения - форма, содержащая дерево маршрута подписания.
//  ИмяРеквизитаДерева	               - Строка - имя реквизита дерева маршрута на форме.
//  ОформитьКолонкуПодписант           - Булево - признак необходимости установки условного оформления для колонки
//    "Подписант".
//  ОформитьВидимостьКолонкиСертификат - Булево - признак необходимости установки условного оформления для колонки
//    "Сертификат".
//
Процедура УстановитьУсловноеОформлениеДереваМаршрута(Форма, ИмяРеквизитаДерева = "ДеревоТребований", 
	ОформитьКолонкуПодписант = Истина, ОформитьВидимостьКолонкиСертификат = Истина) Экспорт

	// Видимость колонки "Сертификат"
	Если ОформитьВидимостьКолонкиСертификат Тогда
		Если ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(Форма.Объект, "ВидПодписи") Тогда
			Элемент = Форма.УсловноеОформление.Элементы.Добавить();
			ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
			ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяРеквизитаДерева + "Сертификат");
			
			ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных("Объект.ВидПодписи");
			ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
			ОтборЭлемента.ПравоеЗначение = Перечисления.ВидыЭлектронныхПодписей.Простая;
			
			Элемент.Оформление.УстановитьЗначениеПараметра("Видимость", Ложь);
			Элемент.Оформление.УстановитьЗначениеПараметра("Отображать", Ложь);
		КонецЕсли;
		Элемент = Форма.УсловноеОформление.Элементы.Добавить();
		
		ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
		ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяРеквизитаДерева + "Сертификат");

		ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяРеквизитаДерева + ".ЭтоСтрокаУсловия");
		ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		ОтборЭлемента.ПравоеЗначение = Истина;

		Элемент.Оформление.УстановитьЗначениеПараметра("Видимость", Ложь);
		Элемент.Оформление.УстановитьЗначениеПараметра("Отображать", Ложь);
	КонецЕсли;
	
	// Текст пустой колонки "Сертификат"
	Элемент = Форма.УсловноеОформление.Элементы.Добавить();
	
	ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
	ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяРеквизитаДерева + "Сертификат");

	ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяРеквизитаДерева + ".Сертификат");
	ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;

	Элемент.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = 'любым сертификатом'"));
	Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ПоясняющийТекст);
	
	// Текст пустой колонки "Подписант"
	Если ОформитьКолонкуПодписант Тогда
		Элемент = Форма.УсловноеОформление.Элементы.Добавить();
	
		ПолеЭлемента = Элемент.Поля.Элементы.Добавить();
		ПолеЭлемента.Поле = Новый ПолеКомпоновкиДанных(ИмяРеквизитаДерева + "ОсновноеЗначение");

		ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяРеквизитаДерева + ".Подписант");
		ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено;
		
		ОтборЭлемента = Элемент.Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ОтборЭлемента.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяРеквизитаДерева + ".ЭтоСтрокаУсловия");
		ОтборЭлемента.ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		ОтборЭлемента.ПравоеЗначение = Ложь;

		Элемент.Оформление.УстановитьЗначениеПараметра("Текст", НСтр("ru = 'любой пользователь'"));
		Элемент.Оформление.УстановитьЗначениеПараметра("ЦветТекста", ЦветаСтиля.ПоясняющийТекст);
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область ОбработкаОшибок

// Добавляет в ошибку в хранилище накопленных ошибок.
//
// Параметры:
//  Ошибки			         - Массив - ошибки, накопленные за время обработки. Элементами массива являются структуры.
//                                      Состав структур см. в ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки().
//  ТекстОшибки				 - Строка - текст фиксируемой ошибки.
//  ПараметрыОбработкиОшибок - Структура - используется для указания указания параметров действий по клику на ошибке,
//                                         формируется функцией ЭлектронноеВзаимодействиеКлиентСервер.НовыеПараметрыОбработкиОшибки.
//  ИндексВставки			 - Число - индекс позиции вставки в массиве ошибок.
//
Процедура ДобавитьОшибку(Ошибки, ТекстОшибки, ПараметрыОбработкиОшибки = Неопределено, ИндексВставки = Неопределено) Экспорт

	Если Ошибки = Неопределено Тогда
		Ошибки = Новый Массив;
	КонецЕсли;
	
	ДанныеОшибки = ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки();
	
	Если ПараметрыОбработкиОшибки <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(ДанныеОшибки, ПараметрыОбработкиОшибки);
	КонецЕсли;
	
	// Выводим указанный текст ошибки, только если он не был переопределен в параметрах обработки ошибки.
	Если Не ЗначениеЗаполнено(ДанныеОшибки.ТекстОшибки) Тогда
		ДанныеОшибки.Вставить("ТекстОшибки", ТекстОшибки);
	КонецЕсли;
	
	Если ИндексВставки = Неопределено Тогда
		Ошибки.Добавить(ДанныеОшибки);
	Иначе
		Ошибки.Вставить(ИндексВставки, ДанныеОшибки);
	КонецЕсли;

КонецПроцедуры

// Преобразует массив ошибок в строку.
//
// Параметры:
//  Ошибки - Массив - ошибки, накопленные за время обработки. Элементами массива являются структуры.
//                    Состав структур см. в ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки().
// 
// Возвращаемое значение:
//  Строка - единая строка сообщения об ошибке.
//
Функция СоединитьОшибки(Ошибки) Экспорт

	МассивОшибок = Новый Массив;
	
	Если ЗначениеЗаполнено(Ошибки) Тогда
		Для Каждого ОписаниеОшибки Из Ошибки Цикл
			МассивОшибок.Добавить(ОписаниеОшибки.ТекстОшибки);
		КонецЦикла;
	КонецЕсли;
	
	Возврат СтрСоединить(МассивОшибок, Символы.ПС);

КонецФункции 

// Возвращает стандартный текст ошибки для незаполненного значения дерева.
// 
// Возвращаемое значение:
//  Строка - текст ошибки.
//
Функция ТекстОшибкиНеЗаполненногоЗначенияДерева() Экспорт
	
	Возврат НСтр("ru = 'значение не заполнено'");

КонецФункции

// Возвращает стандартный текст ошибки для неверно заполненного значения дерева.
// 
// Возвращаемое значение:
//  Строка - текст ошибки.
//
Функция ТекстОшибкиНеверноЗаполненногоЗначенияДерева() Экспорт
	
	Возврат НСтр("ru = 'значение указано неверно'");

КонецФункции

Функция СформироватьТекстИсключения(Знач ТипИсключения, Знач Параметр) Экспорт
	
	ЧастиТекста = Новый Массив;
	Если ТипИсключения = "НедопустимыеПараметрыМетода" Тогда
		
		ЧастиТекста.Добавить(НСтр("ru = 'Недопустимые параметры метода'"));
		ЧастиТекста.Добавить(Параметр);
		
	Иначе
		
		ЧастиТекста.Добавить(НСтр("ru = 'Неизвестная ошибка'"));
		Если ЗначениеЗаполнено(Параметр) Тогда
			ЧастиТекста.Добавить(Параметр);
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат СтрСоединить(ЧастиТекста, Символы.ПС);
	
КонецФункции

// Возвращает текст сообщения пользователю по коду ошибки.
//
// Параметры:
//  КодОшибки - Строка * код ошибки.
//  СтороннееОписаниеОшибки - Строка - описание ошибки переданное другой системой.
//
// Возвращаемое значение:
//  Строка - переопределенное описание ошибки.
//
Функция ПолучитьСообщениеОбОшибке(КодОшибки, СтороннееОписаниеОшибки = "") Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	ШаблонСообщения = НСтр("ru = 'Код ошибки %1. %2'");
	
	СообщенияОшибок = Новый Соответствие;
	ИнициализацияСообщенийОшибок(СообщенияОшибок);
	
	СообщениеОбОшибке = СообщенияОшибок.Получить(КодОшибки);
	Если СообщениеОбОшибке = Неопределено ИЛИ НЕ ЗначениеЗаполнено(СообщениеОбОшибке) Тогда
		СообщениеОбОшибке = СтороннееОписаниеОшибки;
	КонецЕсли;
	
	ЭлектронноеВзаимодействиеПереопределяемый.ИзменитьСообщениеОбОшибке(КодОшибки, СообщениеОбОшибке);
	
	ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонСообщения, КодОшибки, СообщениеОбОшибке);
	
	Возврат ТекстСообщения;
	
КонецФункции

#КонецОбласти

#Область АвтоматизированноеТестирование
// Выводит область ячеек в табличный документ, предварительно присвоив имена параметризованным ячейкам.
//
// Параметры:
//  ТабличныйДокумент	 - ТабличныйДокумент - результирующий документ.
//  ОбластьМакета		 - ТабличныйДокумент - табличный документ для вывода.
//  ПрефиксДляИмен		 - Строка - префикс для имен ячеек (рекомендуется передавать имя области).
//  ИндексПрефикса		 - Число - индекс или номер строки, который будет прибавлен к префиксу 
//                                 (используется для областей, входящих в таблицы).
//  Уровень				 - Число - см. ТабличныйДокумент.Вывести.
//  ИмяГруппы			 - Строка - см. ТабличныйДокумент.Вывести.
//  Открыта				 - Булево - см. ТабличныйДокумент.Вывести.
//
Процедура ВывестиОбластьВТабличныйДокумент(ТабличныйДокумент, Знач ОбластьМакета, Знач ПрефиксДляИмен, 
	Знач ИндексПрефикса = "", Уровень = Неопределено, ИмяГруппы = Неопределено, Открыта = Истина) Экспорт

	ПрисвоитьИменаЯчейкамТабличногоДокумента(ОбластьМакета, ПрефиксДляИмен, ИндексПрефикса);
 
	ТабличныйДокумент.Вывести(ОбластьМакета, Уровень, ИмяГруппы, Открыта);

КонецПроцедуры

// Присоединяет область ячеек к табличному документу, предварительно присвоив имена параметризованным ячейкам.
//
// Параметры:
//  ТабличныйДокумент	 - ТабличныйДокумент - результирующий документ.
//  ОбластьМакета		 - ТабличныйДокумент - табличный документ для вывода.
//  ПрефиксДляИмен		 - Строка - префикс для имен ячеек (рекомендуется передавать имя области).
//  ИндексПрефикса		 - Число - индекс или номер строки, который будет прибавлен к префиксу 
//                                 (используется для областей, входящих в таблицы).
//  Уровень				 - Число - см. ТабличныйДокумент.Присоединить.
//  ИмяГруппы			 - Строка - см. ТабличныйДокумент.Присоединить.
//  Открыта				 - Булево - см. ТабличныйДокумент.Присоединить.
//
Процедура ПрисоединитьОбластьКТабличномуДокументу(ТабличныйДокумент, Знач ОбластьМакета, Знач ПрефиксДляИмен, 
	Знач ИндексПрефикса = "", Уровень = Неопределено, ИмяГруппы = Неопределено, Открыта = Истина) Экспорт

	ПрисвоитьИменаЯчейкамТабличногоДокумента(ОбластьМакета, ПрефиксДляИмен, ИндексПрефикса);
 
	ТабличныйДокумент.Присоединить(ОбластьМакета, Уровень, ИмяГруппы, Открыта);

КонецПроцедуры

// Производит вставку области ячеек в табличный документ, предварительно присвоив имена параметризованным ячейкам.
//
// Параметры:
//  ТабличныйДокумент	 - ТабличныйДокумент - результирующий документ.
//  ИсходнаяОбласть		 - ТабличныйДокумент - табличный документ для вставки.
//  ПрефиксДляИмен		 - Строка - префикс для имен ячеек (рекомендуется передавать имя области).
//  ИндексПрефикса		 - Число - индекс или номер строки, который будет прибавлен к префиксу 
//                                 (используется для областей, входящих в таблицы).
//  ОбластьПриемник		 - ОбластьЯчеекТабличногоДокумента - см. ТабличныйДокумент.ВставитьОбласть.
//  Сдвиг			     - ТипСмещенияТабличногоДокумента - см. ТабличныйДокумент.ВставитьОбласть.
//  ЗаполнятьПараметры	 - Булево - см. ТабличныйДокумент.ВставитьОбласть.
//
Процедура ВставитьОбластьВТабличныйДокумент(ТабличныйДокумент, Знач ИсходнаяОбласть, Знач ПрефиксДляИмен,
	Знач ИндексПрефикса = "", Знач ОбластьПриемник = Неопределено, Сдвиг = Неопределено, ЗаполнятьПараметры = Истина) Экспорт

	ПрисвоитьИменаЯчейкамТабличногоДокумента(ИсходнаяОбласть, ПрефиксДляИмен, ИндексПрефикса);
 
	ТабличныйДокумент.ВставитьОбласть(ИсходнаяОбласть.Область(), ОбластьПриемник, Сдвиг, ЗаполнятьПараметры);

КонецПроцедуры

#КонецОбласти

#Область РаботаСДеревомДанных

// Создает пустой объект ДереваРазбора.
//
// Возвращаемое значение:
//   ДеревоЗначений - пустое дерево с колонками.
//
Функция ИнициализироватьДеревоРазбора() Экспорт
	
	ДеревоРазбора = Новый ДеревоЗначений;
	ДеревоРазбора.Колонки.Добавить("ТипОбъекта");
	ДеревоРазбора.Колонки.Добавить("СсылкаНаОбъект");
	ДеревоРазбора.Колонки.Добавить("ОписаниеТипа");
	ДеревоРазбора.Колонки.Добавить("ИндексСтроки");
	ДеревоРазбора.Колонки.Добавить("Реквизит");
	ДеревоРазбора.Колонки.Добавить("ЗначениеРеквизита");
	ДеревоРазбора.Колонки.Добавить("ОписаниеОбъекта");
	ДеревоРазбора.Колонки.Добавить("ВидЭД");
	ДеревоРазбора.Колонки.Добавить("ВерсияФормата");
	ДеревоРазбора.Колонки.Добавить("ИД");
	ДеревоРазбора.Колонки.Добавить("НаправлениеЭД");
	ДеревоРазбора.Колонки.Добавить("ДопДанные");
	
	ДеревоРазбора.Колонки.Добавить("ТипЭлементаВерсииЭД");
	
	Возврат ДеревоРазбора;
	
КонецФункции

// Находит или создает новый тип в дереве разбора.
//
// Параметры:
//    ДеревоРазбора - ДеревоЗначений - исходное дерево значений;
//    ЗначениеТипаОбъекта - Произвольный - искомый тип объекта.
//
// Возвращаемое значение:
//  СтрокаДереваЗначений - найденная или созданная строка.
//
Функция НайтиСоздатьТипОбъектаВДеревеРазбора(ДеревоРазбора, ЗначениеТипаОбъекта) Экспорт
	
	НайденнаяСтрока = ДеревоРазбора.Строки.Найти(ЗначениеТипаОбъекта, "ТипОбъекта");
	Если НайденнаяСтрока = Неопределено Тогда
		НайденнаяСтрока = ДеревоРазбора.Строки.Добавить();
		НайденнаяСтрока.ТипОбъекта = ЗначениеТипаОбъекта;
		НайденнаяСтрока.ИндексСтроки = Строка(ДеревоРазбора.Строки.Индекс(НайденнаяСтрока));
	КонецЕсли;
	
	Возврат НайденнаяСтрока;
	
КонецФункции

// Добавляет реквизит в шапку объекта.
//
// Параметры:
//  СтрокаЭлементов - СтрокаДереваЗначений - текущая строка дерева значений;
//  ИмяРеквизита - Строка - название добавляемого реквизита;
//  ЗначениеРеквизита - Произвольный - значение добавляемого реквизита;
//  СсылкаНаОбъект - Произвольный - ссылка на связанный объект информационной базы.
//
Процедура ДобавитьРеквизитШапкиОбъекта(СтрокаЭлементов, ИмяРеквизита, ЗначениеРеквизита, СсылкаНаОбъект = Неопределено) Экспорт
	
	НовСтрока = СтрокаЭлементов.Строки.Добавить();
	НовСтрока.Реквизит = ИмяРеквизита;
	НовСтрока.ЗначениеРеквизита = ЗначениеРеквизита;
	Если СсылкаНаОбъект <> Неопределено Тогда
		НовСтрока.СсылкаНаОбъект = СсылкаНаОбъект;
	КонецЕсли;
	
КонецПроцедуры

// Добавляет дополнительные реквизиты в табличную часть объекта.
//
// Параметры:
//  СтрокаЭлементов - СтрокаДереваЗначений - строка дерева значений, в которую помещаются дополнительные реквизиты;
//  ИмяТЧ - Строка - название табличной части в дереве значений;
//  СписокРеквизитов - СписокЗначений - список помещаемых реквизитов.
//
Процедура ДобавитьРеквизитыТЧОбъекта(СтрокаЭлементов, ИмяТЧ, СписокРеквизитов) Экспорт
	
	// Добавить в реквизиты ТЧ ОбменСКонтрагентами
	НовСтрока          = СтрокаЭлементов.Строки.Добавить();
	НовСтрока.Реквизит = ИмяТЧ;
	Для Каждого ТекЭлСписка Из СписокРеквизитов Цикл
		НовСтрокаТЧ                   = НовСтрока.Строки.Добавить();
		НовСтрокаТЧ.Реквизит          = ТекЭлСписка.Представление;
		НовСтрокаТЧ.ЗначениеРеквизита = ТекЭлСписка.Значение;
	КонецЦикла;
	
КонецПроцедуры

// Добавляет дополнительные реквизиты в дерево данных.
//
// Параметры:
//  СтрокаДереваРазбора - СтрокаДереваЗначений - строка дерева, в которую помещаются дополнительные реквизиты;
//  ДопРеквизиты        - Структура            - коллекция помещаемых дополнительных реквизитов;
//  ДеревоРазбора       - ДеревоЗначений       - исходное дерево данных;
//  Отказ               - Булево               - признак возникновения ошибки выполнения метода.
//
Процедура ДобавитьДопРеквизиты(СтрокаДереваРазбора, ДопРеквизиты, ДеревоРазбора, Отказ = Ложь, Знач СсылкиНаОбъектыПоИндексам = Неопределено) Экспорт
	
	Для Каждого ТекЭл Из ДопРеквизиты Цикл
		
		Если НЕ ТипЗнч(ТекЭл.Значение) = Тип("ОбъектXDTO") Тогда
					
			Если ЗначениеЗаполнено(ТекЭл.Значение) Тогда
				Если ТипЗнч(ТекЭл.Значение) = Тип("Массив") И НЕ ТекЭл.Ключ = "ЗначенияСвойств" И НЕ ТекЭл.Ключ = "Картинки" Тогда
					Для Каждого ТекЭлМассива Из ТекЭл.Значение Цикл
						Если ТипЗнч(ТекЭлМассива) = Тип("Структура") Тогда
							ДобавитьДопРеквизиты(СтрокаДереваРазбора, ТекЭлМассива, ДеревоРазбора, Отказ, СсылкиНаОбъектыПоИндексам);
						КонецЕсли;
					КонецЦикла;
				Иначе
					// Поищем, возможно уже есть такой реквизит с таким же значением.
					НайденнаяСтрока = СтрокаДереваРазбора.Строки.Найти(ТекЭл.Ключ, "Реквизит", Истина);
					Если НайденнаяСтрока <> Неопределено И НайденнаяСтрока.ЗначениеРеквизита = ТекЭл.Значение Тогда
						Продолжить;
					КонецЕсли;
					
					НовСтрока = СтрокаДереваРазбора.Строки.Добавить();
					НовСтрока.Реквизит          = ТекЭл.Ключ;
					НовСтрока.ЗначениеРеквизита = ТекЭл.Значение;
					// Если ИндексСтроки, то попытка найти СсылкуНаОбъект.
					Если ТипЗнч(НовСтрока.ЗначениеРеквизита) = Тип("Строка") Тогда
						
						Если СсылкиНаОбъектыПоИндексам <> Неопределено Тогда
							СсылкаНаОбъект = СсылкиНаОбъектыПоИндексам.Получить(НовСтрока.ЗначениеРеквизита);
							Если ЗначениеЗаполнено(СсылкаНаОбъект) Тогда
								НовСтрока.СсылкаНаОбъект = СсылкаНаОбъект;
							КонецЕсли;
						Иначе
							НайденнаяСтрока = ДеревоРазбора.Строки.Найти(НовСтрока.ЗначениеРеквизита, "ИндексСтроки", Истина);
							Если НайденнаяСтрока <> Неопределено Тогда
								Если ЗначениеЗаполнено(НайденнаяСтрока.СсылкаНаОбъект) Тогда
									НовСтрока.СсылкаНаОбъект = НайденнаяСтрока.СсылкаНаОбъект;
								КонецЕсли;
							КонецЕсли;
						КонецЕсли;
						
					КонецЕсли;
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Определяет тип объекта по текстовому представлению.
//
// Параметры:
//  ОписаниеТипаОбъекта - Строка - текстовое представление типа объекта.
//
// Возвращаемое значение:
//  Строка - тип справочника.
//
Функция ТипОбъекта(ОписаниеТипаОбъекта) Экспорт
	
	ТипОбъекта = Неопределено;
	
	ИмяПрикладногоСправочника = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.ИмяПрикладногоСправочника(ОписаниеТипаОбъекта);
	Если ЗначениеЗаполнено(ИмяПрикладногоСправочника) Тогда
		ТипОбъекта = "СправочникСсылка." + ИмяПрикладногоСправочника;
	КонецЕсли;
	
	Возврат ТипОбъекта;
	
КонецФункции

// Значение реквизита в дереве.
//
// Параметры:
//  ДеревоДанных - ДеревоЗначений - объект поиска.
//  ПолныйПуть - Произвольный - значение поиска.
//  СообщатьОбОшибке - Булево - если Истина сообщать об ошибках поиска.
// 
// Возвращаемое значение:
//  Произвольный - результат поиска.
//
Функция ЗначениеРеквизитаВДереве(ДеревоДанных, ПолныйПуть, СообщатьОбОшибке = Истина,
	НайденнаяСтрока = Неопределено, Типизировать = Ложь) Экспорт
	
	НайденнаяСтрока = ДеревоДанных.Строки.Найти(ПолныйПуть, "ПолныйПуть", Истина);
	Если НайденнаяСтрока <> Неопределено Тогда
		Результат = НайденнаяСтрока.Значение;
		
		Если Типизировать Тогда
			Результат = НайденнаяСтрока.ТипЗначения.ПривестиЗначение(НайденнаяСтрока.Значение);
		КонецЕсли;
		
		Возврат Результат;
	ИначеЕсли СообщатьОбОшибке Тогда
		ТекстСообщения = НСтр("ru = 'Не найдено поле в дереве данных по полному пути <%1>'");
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстСообщения, ПолныйПуть);
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
	КонецЕсли;
	
КонецФункции

// Добавляет значение в дерево данных.
//
// Параметры:
//  ДеревоДанных - ДеревоЗначений - дерево, в которое помещается новое значение;
//  ИмяРеквизита - Строка - название помещаемого реквизита;
//  ЗначениеРеквизита - Произвольный - значение помещаемого реквизита.
//
Процедура ДобавитьЗначениеВДерево(ДеревоДанных, ИмяРеквизита, ЗначениеРеквизита) Экспорт
	
	СтрокаДерева = ДеревоДанных.Строки.Найти(ИмяРеквизита);
	Если СтрокаДерева = Неопределено Тогда
		СтрокаДерева = ДеревоДанных.Строки.Добавить();
	КонецЕсли;
	НомерУровня = СтрЧислоВхождений(ИмяРеквизита, ".") + 1;
	СтрокаДерева.ПолныйПуть = ИмяРеквизита;
	СтрокаДерева["Уровень" + НомерУровня] = ЭлектронноеВзаимодействие.НазваниеКолонки(ИмяРеквизита);
	СтрокаДерева.Значение = ЗначениеРеквизита;

КонецПроцедуры

// Проверяет заполнение обязательных реквизитов дерева
// Параметры:
//  ДеревоДанных                            - деревоЗначений - дерево с данными.
//  Ошибки                                  - Массив - ошибки, накопленные за время обработки. Элементами массива являются структуры.
//                                                     Состав структур см. в ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки().
//  ДатаПоФорматуФНС                        - Булево - если установлена в Истину, значения типа "Дата" будут проверяться дополнительно
//                                                     на вхождение в диапазон лет 1900-2099 (требование схем ФНС).
//
Процедура ПроверитьЗаполнениеРеквизитовДереваДанныхРекурсивно(ДеревоДанных, Ошибки, ДатаПоФорматуФНС = Ложь) Экспорт
	
	ПроверитьЗаполнениеРеквизитовДереваДанныхСлужебная(ДеревоДанных, Ошибки, Ложь,,, ДатаПоФорматуФНС);
	
КонецПроцедуры

// Добавляет в ошибку в хранилище накопленных ошибок.
//
// Параметры:
//  Ошибки			 				 - Массив - ошибки, накопленные за время обработки. Элементами массива являются структуры.
//                                     Состав структур см. в ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки().
//  СтрокаДерева			 		 - СтрокаДереваЗначений - строка дерева электронного документа, по реквизиту которой
//                                     фиксируется ошибка.
//  ТекстОшибки				 		 - Строка - текст фиксируемой ошибки.
//  ПодставлятьИмяРеквизита	 		 - Булево - если Истина, в начало сообщения об ошибке будет подставлено
//                                     прикладное имя реквизита.
//  НомерСтрокиДанных		 		 - Число - если указана, будет подставлена в имя реквизита.
//  ПрикладноеПредставлениеРеквизита - Строка - если указано, представление реквизита не будет получаться по строке дерева - 
//                                     будет использовано указанное представление.
//
Процедура ДобавитьОшибкуПроверкиДереваДанных(Ошибки, СтрокаДерева, ТекстОшибки, ПодставлятьИмяРеквизита = Истина,
	НомерСтрокиДанных = Неопределено, ПрикладноеПредставлениеРеквизита = "") Экспорт
	
	// Даже если по каким-то причинам не нашли строку дерева, все равно выдаем ошибку. Лучше выдать неполное сообщение
	// об ошибке, чем пропустить некорректный документ.
	Если СтрокаДерева <> Неопределено Тогда
		ПроверитьЗаполненностьПараметровОбработкиОшибок(СтрокаДерева);
		
		ПараметрыОбработкиОшибки = ПараметрыОшибкиПоСтрокеДерева(СтрокаДерева);
	
		Если ПодставлятьИмяРеквизита Тогда
			Если Не ЗначениеЗаполнено(ПрикладноеПредставлениеРеквизита) Тогда
				ПрикладноеПредставлениеРеквизита = ПрикладноеПредставлениеПоСтрокеДерева(СтрокаДерева, НомерСтрокиДанных);
			КонецЕсли;

			ТекстОшибки = СтрШаблон("%1: %2", ПрикладноеПредставлениеРеквизита, ТекстОшибки);
		КонецЕсли;
	Иначе
		ПараметрыОбработкиОшибки = ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки();
	КонецЕсли;
	
	ДобавитьОшибку(Ошибки, ТекстОшибки, ПараметрыОбработкиОшибки);

КонецПроцедуры

// Формирует дерево данных для заполнения или чтения прикладным решением.
//
// Параметры:
//  Макет - Макет - Макет с описанием структуры дерева (см. Обработка.ОбменСКонтрагентами.Макеты).
//
// Возвращаемое значение:
//  ДеревоЗначений - Дерево документа.
//
Функция ДеревоЭлектронногоДокумента(Макет) Экспорт
	
	ВысотаТаблицы = Макет.ВысотаТаблицы;
	ШиринаТаблицы = Макет.ШиринаТаблицы;
	ТаблицаЗначений = Новый ТаблицаЗначений;
	
	// Считаем колонки из макета и добавим их в таблицу значений.
	Для НомерКолонки = 1 По ШиринаТаблицы Цикл
		ОбластьШапки = Макет.Область(5,НомерКолонки);
		Если Не ЗначениеЗаполнено(ОбластьШапки.Текст) Тогда
			ОбластьШапки = Макет.Область(4,НомерКолонки);
		КонецЕсли;
		НазваниеКолонки = ОбластьШапки.Текст;
		ТаблицаЗначений.Колонки.Добавить(НазваниеКолонки);
	КонецЦикла;
	
	// Считаем все перечисленные в макете реквизиты и добавим в таблицу значений.
	Для НомерСтроки = 7 По ВысотаТаблицы Цикл
		НоваяСтрока = ТаблицаЗначений.Добавить();
		Для НомерКолонки = 0 По ШиринаТаблицы-1 Цикл
			НоваяСтрока.Установить(НомерКолонки, Макет.Область(НомерСтроки, НомерКолонки + 1).Текст);
		КонецЦикла;
		ДобавитьСтрокиТипаВТаблицуДереваДокумента(ТаблицаЗначений, НоваяСтрока, Макет);
	КонецЦикла;
	
	// Добавим служебные колонки, не описанные в макете.
	ДобавитьСлужебныеКолонкиВТаблицуДереваДокумента(ТаблицаЗначений);
	
	// Добавим некоторые колонки при необходимости (для совместимости с макетами старого формата).
	КолонкиДереваДокумента = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.КолонкиДереваДокумента();
	Для Каждого Колонка Из КолонкиДереваДокумента Цикл
		Если ТаблицаЗначений.Колонки.Найти(Колонка) = Неопределено Тогда
			ТаблицаЗначений.Колонки.Добавить(Колонка);
		КонецЕсли;
	КонецЦикла;
	
	КолУровней = 0;
	
	// Перенесем колонки в дерево значений и заодно вычислим максимальный уровень.
	ДеревоЗначений = Новый ДеревоЗначений;
	Для Каждого Колонка Из ТаблицаЗначений.Колонки Цикл
		ДеревоЗначений.Колонки.Добавить(Колонка.Имя);
		Если СтрНайти(Колонка.Имя, "Уровень") > 0 Тогда
			НомерУровня = Число(Сред(Колонка.Имя, 8, 2));
			Если НомерУровня > КолУровней Тогда
				КолУровней = НомерУровня;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	// Рекурсивно заполним дерево по таблице.
	ПолныйПуть = "";
	РекурсивноЗаполнитьСтрокиДерева(ДеревоЗначений, 1, КолУровней, ПолныйПуть, ТаблицаЗначений, 0);
	
	Возврат ДеревоЗначений;
	
КонецФункции

// Значение реквизита строки дерева разбора.
//
// Параметры:
//  ДеревоРазбора	 - ДеревоЗначений - объект поиска.
//  СтрокаДерева	 - КоллекцияСтрокДереваЗначений - строка дерева значений.
//  ПутьКРеквизиту	 - Строка - путь к реквизиту.
// 
// Возвращаемое значение:
//  Произвольный - результат поиска.
//
Функция ЗначениеРеквизитаСтрокиДереваРазбора(ДеревоРазбора, СтрокаДерева, ПутьКРеквизиту) Экспорт
	
	ПозТочки = СтрНайти(ПутьКРеквизиту, ".");
	Если ПозТочки > 0 Тогда
		ИмяГлавногоРеквизита     = Лев(ПутьКРеквизиту, ПозТочки - 1);
		ИмяПодчиненногоРеквизита = Прав(ПутьКРеквизиту, СтрДлина(ПутьКРеквизиту) - ПозТочки);
	Иначе
		ИмяГлавногоРеквизита     = ПутьКРеквизиту;
		ИмяПодчиненногоРеквизита = "";
	КонецЕсли;
	
	ГлавныйРеквизит = СтрокаДерева.Строки.Найти(ИмяГлавногоРеквизита, "Реквизит");
	
	Если ГлавныйРеквизит <> Неопределено Тогда
		ЗначениеГлавногоРеквизита = ГлавныйРеквизит.ЗначениеРеквизита;
		Если ИмяПодчиненногоРеквизита <> "" Тогда
			СтрокаПоСсылке = Неопределено;
			Если ЭтоСсылочноеЗначениеДереваРазбора(ДеревоРазбора, ЗначениеГлавногоРеквизита, СтрокаПоСсылке) Тогда
				Возврат ЗначениеРеквизитаСтрокиДереваРазбора(ДеревоРазбора, СтрокаПоСсылке, ИмяПодчиненногоРеквизита);
			КонецЕсли;
			
			// Нет возможности получить значение подчиненного реквизита.
			Возврат Неопределено;
		Иначе
			// Не требуется получать значение подчиненного реквизита.
			Возврат ЗначениеГлавногоРеквизита
		КонецЕсли;
	Иначе
		// Нет такого реквизита.
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции

// См. ЭлектронноеВзаимодействие.ДанныеЭлементаДереваЭлектронногоДокумента
Функция ДанныеЭлементаДереваЭлектронногоДокумента(Знач Дерево, Знач Путь) Экспорт
	
	ЭлементДерева = Дерево.Строки.Найти(Путь, "ПолныйПуть", Истина);
	Если ЭлементДерева = Неопределено Тогда
		ВызватьИсключение СформироватьТекстИсключения(
			"НедопустимыеПараметрыМетода", "ДанныеЭлементаДереваЭлектронногоДокумента/НеверноеЗначениеПараметра/Путь");
	КонецЕсли;
	
	Данные = Неопределено;
	
	Если ЭлементДерева.Признак = "Таблица" Тогда
		
		Данные = ДанныеТаблицыДереваЭлектронногоДокумента(ЭлементДерева);
		
	ИначеЕсли ЭлементДерева.Признак = "Группа" Тогда
		
		Данные = ДанныеГруппыДереваЭлектронногоДокумента(ЭлементДерева);
		
	ИначеЕсли ЭлементДерева.Признак = "Выбор" Тогда
		
		Данные = ДанныеВыбораДереваЭлектронногоДокумента(ЭлементДерева);
		
	Иначе
		
		Данные = ДанныеЗначенияДереваЭлектронногоДокумента(ЭлементДерева);
		
	КонецЕсли;
	
	Возврат Данные;
	
КонецФункции

#КонецОбласти

#Область ОбработкаСхемыЗапросов

// Объединить запросы.
//
// Параметры:
//  Запрос1	 - Запрос - запрос приемник.
//  Запрос2	 - Запрос, Строка - запрос источник.
//
Процедура ОбъединитьЗапросы(ЗапросПриемник, ЗапросТекстИсточник) Экспорт 
	
	Схема1 = Новый СхемаЗапроса;
	Схема1.УстановитьТекстЗапроса(ЗапросПриемник.Текст);
	
	Схема2 = Новый СхемаЗапроса;
	Если ТипЗнч(ЗапросТекстИсточник) = Тип("Строка") Тогда
		Схема2.УстановитьТекстЗапроса(ЗапросТекстИсточник);
	Иначе
		// Вариант запроса.
		Схема2.УстановитьТекстЗапроса(ЗапросТекстИсточник.Текст);
		Для каждого ЭлементКоллекции Из ЗапросТекстИсточник.Параметры Цикл
			ЗапросПриемник.Параметры.Добавить(ЭлементКоллекции.Ключ, ЭлементКоллекции.Значение);
		КонецЦикла;
	КонецЕсли;
	
	Для каждого ЭлементКоллекции2 Из Схема2.ПакетЗапросов Цикл
		
		ИндексЗапроса2 = Схема2.ПакетЗапросов.Индекс(ЭлементКоллекции2);
		ПакетДобавлен = Ложь;
		Для каждого ЭлементКоллекции1 Из Схема1.ПакетЗапросов Цикл
			Если ТипЗнч(ЭлементКоллекции1) = Тип("ЗапросУничтоженияТаблицыСхемыЗапроса") Тогда
				Продолжить;
			КонецЕсли;
			
			Представление1 = ЭлементКоллекции1.Представление();
			Представление2 = ЭлементКоллекции1.Представление();
			ТаблицаПомещения1 = "";
			ТаблицаПомещения2 = "";
			
			Если ТипЗнч(ЭлементКоллекции1) = Тип("ЗапросУничтоженияТаблицыСхемыЗапроса") Тогда
				ПсевдонимИсточника1 = ЭлементКоллекции1.ИмяТаблицы;
			Иначе
				ПсевдонимИсточника1 = ЭлементКоллекции1.Операторы[0].Источники[0].Источник.Псевдоним;
				ТаблицаПомещения1   = ЭлементКоллекции1.ТаблицаДляПомещения;
			КонецЕсли;
			
			Если ТипЗнч(ЭлементКоллекции2) = Тип("ЗапросУничтоженияТаблицыСхемыЗапроса") Тогда
				ПсевдонимИсточника2 = ЭлементКоллекции2.ИмяТаблицы;
			Иначе
				ПсевдонимИсточника2 = ЭлементКоллекции2.Операторы[0].Источники[0].Источник.Псевдоним;
				ТаблицаПомещения2   = ЭлементКоллекции2.ТаблицаДляПомещения;
			КонецЕсли;
			
			Если ЗначениеЗаполнено(Представление1)
				И ПсевдонимИсточника1 = ПсевдонимИсточника2
				И ТаблицаПомещения1 = ТаблицаПомещения2 Тогда
				ОбъединитьПакетЗапросов(ЭлементКоллекции1, Схема2.ПакетЗапросов.Получить(ИндексЗапроса2));
				ПакетДобавлен = Истина;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
		Если Не ПакетДобавлен Тогда
			// Добавление подзапроса в запрос приемник.
			ДобавитьЗапросВПакет(Схема1, ЭлементКоллекции2);
		КонецЕсли;
		
	КонецЦикла;
	
	ЗапросПриемник.Текст = Схема1.ПолучитьТекстЗапроса();
	
КонецПроцедуры

#КонецОбласти

// Получает файл из Интернета по протоколу http(s), либо ftp и сохраняет его во временное хранилище.
// Примечание: После получения файла временное хранилище необходимо самостоятельно очистить
// при помощи метода УдалитьИзВременногоХранилища. Если этого не сделать, то файл будет находиться
// в памяти сервера до конца сеанса.
//
// Параметры:
//   URL                - Строка - url файла в формате [Протокол://]<Сервер>/<Путь к файлу на сервере>.
//   ПараметрыПолучения - Структура - см. ПолучениеФайловИзИнтернетаКлиентСервер.ПараметрыПолученияФайла.
//   ПараметрыЖурналирования - Неопределено - журналирования не требуется
//                           - Структура - Необходимо вести журнал обмена. Содержит поля:
//                               * ОбщийМодуль - ОбщийМодуль - общий модуль, методы которого будут вызываться для сохранения журнала:
//                                   - Перед отправкой данных вызывается ОбщийМодуль.ПриОтправкеДанныхHTTP(URL, HTTPСоединение, HTTPЗапрос, ПараметрыЖурналирования)
//                                   - После получения ответа вызывается: ОбщийМодуль.ПриПолученииДанныхHTTP(HTTPОтвет, ИмяФайла, ПараметрыЖурналирования)
//
// Возвращаемое значение:
//   Структура - Структура со свойствами:
//      * Статус            - Булево - результат получения файла.
//      * Путь   - Строка   - адрес временного хранилища с двоичными данными файла,
//                            ключ используется только если статус Истина.
//      * СообщениеОбОшибке - Строка - сообщение об ошибке, если статус Ложь.
//      * Заголовки         - Соответствие - см. в синтаксис-помощнике описание параметра Заголовки объекта HTTPОтвет.
//      * КодСостояния      - Число - Добавляется при возникновении ошибки.
//                                    См. в синтаксис-помощнике описание параметра КодСостояния объекта HTTPОтвет.
//
Функция СкачатьФайлВоВременноеХранилище(Знач URL, ПараметрыПолучения = Неопределено, ПараметрыЖурналирования = Неопределено) Экспорт
	
	НастройкаСохранения = Новый Соответствие;
	НастройкаСохранения.Вставить("МестоХранения", "ВременноеХранилище");
	
	Возврат СкачатьФайл(URL, ПараметрыПолучения, НастройкаСохранения, ПараметрыЖурналирования);
	
КонецФункции

// Возвращает текст расшифровки кода состояния HTTP
//
// Параметры:
//  КодСостояния - Число - код состояния HTTP
// 
// Возвращаемое значение:
//  Строка - подробное описание кода.
//
Функция РасшифровкаКодаСостоянияHTTP(КодСостояния) Экспорт
	
	Если КодСостояния = 304 Тогда // Not Modified
		Расшифровка = НСтр("ru = 'Нет необходимости повторно передавать запрошенные ресурсы.'");
	ИначеЕсли КодСостояния = 400 Тогда // Bad Request
		Расшифровка = НСтр("ru = 'Запрос не может быть исполнен.'");
	ИначеЕсли КодСостояния = 401 Тогда // Unauthorized
		Расшифровка = НСтр("ru = 'Попытка авторизации на сервере была отклонена.'");
	ИначеЕсли КодСостояния = 402 Тогда // Payment Required
		Расшифровка = НСтр("ru = 'Требуется оплата.'");
	ИначеЕсли КодСостояния = 403 Тогда // Forbidden
		Расшифровка = НСтр("ru = 'К запрашиваемому ресурсу нет доступа.'");
	ИначеЕсли КодСостояния = 404 Тогда // Not Found
		Расшифровка = НСтр("ru = 'Запрашиваемый ресурс не найден на сервере.'");
	ИначеЕсли КодСостояния = 405 Тогда // Method Not Allowed
		Расшифровка = НСтр("ru = 'Метод запроса не поддерживается сервером.'");
	ИначеЕсли КодСостояния = 406 Тогда // Not Acceptable
		Расшифровка = НСтр("ru = 'Запрошенный формат данных не поддерживается сервером.'");
	ИначеЕсли КодСостояния = 407 Тогда // Proxy Authentication Required
		Расшифровка = НСтр("ru = 'Ошибка аутентификации на прокси-сервере'");
	ИначеЕсли КодСостояния = 408 Тогда // Request Timeout
		Расшифровка = НСтр("ru = 'Время ожидания сервером передачи от клиента истекло.'");
	ИначеЕсли КодСостояния = 409 Тогда // Conflict
		Расшифровка = НСтр("ru = 'Запрос не может быть выполнен из-за конфликтного обращения к ресурсу.'");
	ИначеЕсли КодСостояния = 410 Тогда // Gone
		Расшифровка = НСтр("ru = 'Ресурс на сервере был перемешен.'");
	ИначеЕсли КодСостояния = 411 Тогда // Length Required
		Расшифровка = НСтр("ru = 'Сервер требует указание ""Content-length."" в заголовке запроса.'");
	ИначеЕсли КодСостояния = 412 Тогда // Precondition Failed
		Расшифровка = НСтр("ru = 'Запрос не применим к ресурсу'");
	ИначеЕсли КодСостояния = 413 Тогда // Request Entity Too Large
		Расшифровка = НСтр("ru = 'Сервер отказывается обработать, слишком большой объем передаваемых данных.'");
	ИначеЕсли КодСостояния = 414 Тогда // Request-URL Too Long
		Расшифровка = НСтр("ru = 'Сервер отказывается обработать, слишком длинный URL.'");
	ИначеЕсли КодСостояния = 415 Тогда // Unsupported Media-Type
		Расшифровка = НСтр("ru = 'Сервер заметил, что часть запроса была сделана в неподдерживаемом формат'");
	ИначеЕсли КодСостояния = 416 Тогда // Requested Range Not Satisfiable
		Расшифровка = НСтр("ru = 'Часть запрашиваемого ресурса не может быть предоставлена'");
	ИначеЕсли КодСостояния = 417 Тогда // Expectation Failed
		Расшифровка = НСтр("ru = 'Сервер не может предоставить ответ на указанный запрос.'");
	ИначеЕсли КодСостояния = 429 Тогда // Too Many Requests
		Расшифровка = НСтр("ru = 'Слишком много запросов за короткое время.'");
	ИначеЕсли КодСостояния = 500 Тогда // Internal Server Error
		Расшифровка = НСтр("ru = 'Внутренняя ошибка сервера.'");
	ИначеЕсли КодСостояния = 501 Тогда // Not Implemented
		Расшифровка = НСтр("ru = 'Сервер не поддерживает метод запроса.'");
	ИначеЕсли КодСостояния = 502 Тогда // Bad Gateway
		Расшифровка = НСтр("ru = 'Сервер, выступая в роли шлюза или прокси-сервера, 
		                         |получил недействительное ответное сообщение от вышестоящего сервера.'");
	ИначеЕсли КодСостояния = 503 Тогда // Server Unavailable
		Расшифровка = НСтр("ru = 'Сервер временно не доступен.'");
	ИначеЕсли КодСостояния = 504 Тогда // Gateway Timeout
		Расшифровка = НСтр("ru = 'Сервер в роли шлюза или прокси-сервера 
		                         |не дождался ответа от вышестоящего сервера для завершения текущего запроса.'");
	ИначеЕсли КодСостояния = 505 Тогда // HTTP Version Not Supported
		Расшифровка = НСтр("ru = 'Сервер не поддерживает указанную в запросе версию протокола HTTP'");
	ИначеЕсли КодСостояния = 506 Тогда // Variant Also Negotiates
		Расшифровка = НСтр("ru = 'Сервер настроен некорректно, и не способен обработать запрос.'");
	ИначеЕсли КодСостояния = 507 Тогда // Insufficient Storage
		Расшифровка = НСтр("ru = 'На сервере недостаточно места для выполнения запроса.'");
	ИначеЕсли КодСостояния = 509 Тогда // Bandwidth Limit Exceeded
		Расшифровка = НСтр("ru = 'Сервер превысил отведенное ограничение на потребление трафика.'");
	ИначеЕсли КодСостояния = 510 Тогда // Not Extended
		Расшифровка = НСтр("ru = 'Сервер требует больше информации о совершаемом запросе.'");
	ИначеЕсли КодСостояния = 511 Тогда // Network Authentication Required
		Расшифровка = НСтр("ru = 'Требуется авторизация на сервере.'");
	Иначе 
		Расшифровка = НСтр("ru = '<Неизвестный код состояния>.'");
	КонецЕсли;
	
	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		НСтр("ru = '[%1] %2'"), 
		КодСостояния, 
		Расшифровка);
	
КонецФункции

// Создает структуру, описывающую выполняемую операцию. Используется в процедурах: ЭлектронноеВзаимодействиеОбработкаОшибок.ДобавитьОшибку,
// ЭлектронноеВзаимодействиеОбработкаОшибокКлиент.ДобавитьОшибку, ЭлектронноеВзаимодействиеОбработкаОшибок.ОбработатьОшибки.
// В структуру нельзя помещать мутабельные объекты, т.к. она может передаваться между клиентом и сервером.
// 
// Возвращаемое значение:
//   Структура - с ключами:
//      * ЗаголовокОперации           - Строка - заголовок, который будет выведен в форму мастера диагностики и в форму
//                                               вывода ошибок.
//      * Диагностика                 - Структура - с ключами:
//         * Ошибки                   - Массив из см. ЭлектронноеВзаимодействиеОбработкаОшибокКлиентСервер.НоваяОшибка - ошибки,
//                                               возникшие в процессе выполнения операции.
//      * ТекущаяУчетнаяЗапись        - Строка - идентификатор учетной записи, по которой возникла ошибка, используется
//                                               для управления свойством "УчетнаяЗапись" добавляемых ошибок.
//                                               После установки значения этого свойства, свойству "УчетнаяЗапись" ошибок,
//                                               добавленных в контекст будет присвоено значение свойства "ТекущаяУчетнаяЗапись".
//      * РезультатыОтправкиПолучения - Структура - с ключами:
//         * Успешные                 - Массив из ДокументСсылка.ЭлектронныйДокументВходящий - содержит ссылки на успешно
//                                               отправленные/полученные электронные документы документы или пакеты электронных
//                                               документов.
//         * -- // --                 - Массив из ДокументСсылка.ЭлектронныйДокументИсходящий - описание см. выше.
//         * -- // --                 - Массив из ДокументСсылка.ПакетЭД - описание см. выше.
//         * Неудачные                - Массив - содержит ссылки на неудачно отправленные/полученные документы, типы параметров
//                                               как у ключа Успешные.
//
Функция НовыйКонтекстОперации() Экспорт
	
	Контекст = ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыйКонтекстОперации();
	Контекст.Вставить("ДатаНачалаОперации", ТекущаяДатаСеанса());
	
	Возврат Контекст;
	
КонецФункции

#Область Диагностика

// Вызывается при формировании файла с информацией для техподдержки.
//
// Параметры:
//  Текст                    - Строка - текст с описанием параметров системы, вида: "Имя параметра: [ЗначениеПараметра]".
//                                      Значения параметров заполняется из параметра ТехническаяИнформация.
//  ТехническаяИнформация    - Структура - содержит значения параметров для подстановки в текст с описанием
//                                      параметров системы, см. параметр Текст.
//
// Пример:
// Текст = Текст + "Дополнительный параметр: [ДополнительныйПараметр]";
// ТехническаяИнформация.Вставить("ДополнительныйПараметр", "значение дополнительного параметра");
//
Процедура ПриФормированииФайлаСИнформациейДляТехподдержки(Текст, ТехническаяИнформация) Экспорт
	
	// ОбменСКонтрагентами начало
	Если ОбщегоНазначения.ПодсистемаСуществует("ЭлектронноеВзаимодействие.ОбменСКонтрагентами") Тогда
		МодульПодсистемы = ОбщегоНазначения.ОбщийМодуль("ОбменСКонтрагентамиСлужебный");
		МодульПодсистемы.ПриФормированииФайлаСИнформациейДляТехподдержки(Текст, ТехническаяИнформация);
	КонецЕсли;
	// ОбменСКонтрагентами конец
	
КонецПроцедуры

// Вызывается при формировании архива с информацией для техподдержки.
//
// Параметры:
//  ФайлыДляТехподдержки - Массив из Строка - содержит пути к файлам на сервере, которые будут помещены в архив
//                                  с информацией для техподдержки
//
// Пример:
// ИмяФайла = ПолучитьИмяВременногоФайла("zip");
// ПакетЭД.Записать(ИмяФайла);
// ФайлыДляТехподдержки.Добавить(ПакетЭД);
//
Процедура ПриФормированииФайловДляТехподдержки(ФайлыДляТехподдержки, КонтекстОперации) Экспорт
	
	// ОбменСКонтрагентами начало
	Если ОбщегоНазначения.ПодсистемаСуществует("ЭлектронноеВзаимодействие.ОбменСКонтрагентами") Тогда
		МодульПодсистемы = ОбщегоНазначения.ОбщийМодуль("ОбменСКонтрагентамиСлужебный");
		МодульПодсистемы.ПриФормированииФайловДляТехподдержки(ФайлыДляТехподдержки, КонтекстОперации);
	КонецЕсли;
	// ОбменСКонтрагентами конец
	
КонецПроцедуры

#КонецОбласти

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ЭтоСсылочноеЗначениеДереваРазбора(ДеревоРазбора, Значение, СтрокаПоСсылке = Неопределено)
	
	ЗначениеСтрокой = Строка(Значение);
	
	Если СтрНайти(ЗначениеСтрокой, "_") > 0 Тогда
		СтрокаПоСсылке =  ДеревоРазбора.Строки.Найти(ЗначениеСтрокой, "ИндексСтроки", Истина);
	КонецЕсли;
	
	Возврат ?(СтрокаПоСсылке = Неопределено, Ложь, Истина);
	
КонецФункции

// Создает пустую таблицу для размещения в нее команд ЭДО.
// 
// Возвращаемое значение:
//  ТаблицаЗначений - описание команд ЭДО:
//
//  * Идентификатор - Строка - Идентификатор команды ЭДО, по которому менеджер ЭДО определяет печатную
//                             форму, которую необходимо сформировать.
//                             Пример: "СчетЗаказ".
//                  - Массив - список идентификаторов команд ЭДО.
//
//  * Представление - Строка            - Представление команды в меню ЭДО. 
//                                         Пример: "Просмотр документа".
//
//  * Обработчик    - Строка            - (необязательный) Клиентский обработчик команды, в который необходимо передать
//                                        управление.
//
//  * Порядок       - Число             - (необязательный) Значение от 1 до 100, указывающее порядок размещения команды
//                                        по отношению к другим командам. Сортировка команд меню ЭДО осуществляется
//                                        сначала по полю Порядок, затем по представлению.
//                                        Значение по умолчанию: 50.
//
//  * Картинка      - Картинка          - (необязательный) Картинка, которая отображается возле команды в меню ЭДО.
//                                         Пример: БиблиотекаКартинок.ФорматPDF.
//
//  * СписокФорм    - Строка            - (необязательный) Имена форм через запятую, в которых должна отображаться
//                                        команда. Если параметр не указан, то команда ЭДО будет отображаться во
//                                        всех формах объекта, где встроена подсистема ЭДО.
//                                         Пример: "ФормаДокумента".
//
//  * МестоРазмещения - Строка          - (необязательный) Имя командной панели формы, в которую необходимо разместить
//                                        команду ЭДО. Параметр необходимо использовать только в случае, когда на
//                                        форме размещается более одного подменю "ЭДО". В остальных случаях место
//                                        размещения необходимо задавать в модуле формы при вызове метода.
//                                        
//  * ФункциональныеОпции - Строка      - (необязательный) Имена функциональных опций через запятую, от которых зависит
//                                        доступность команды ЭДО.
//
Функция СоздатьКоллекциюКомандЭДО()
	
	Результат = Новый ТаблицаЗначений;
	
	// описание
	Результат.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Строка"));
	Результат.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка"));
	
	//////////
	// Опции (необязательные параметры).
	
	// Альтернативный обработчик команды.
	Результат.Колонки.Добавить("Обработчик", Новый ОписаниеТипов("Строка"));
	
	// представление
	Результат.Колонки.Добавить("Порядок", Новый ОписаниеТипов("Число"));
	Результат.Колонки.Добавить("Картинка", Новый ОписаниеТипов("Картинка"));
	Результат.Колонки.Добавить("Отображение", Новый ОписаниеТипов("ОтображениеКнопки"));
	
	// Имена форм для размещения команд, разделитель - запятая.
	Результат.Колонки.Добавить("СписокФорм", Новый ОписаниеТипов("Строка"));
	Результат.Колонки.Добавить("МестоРазмещения", Новый ОписаниеТипов("Строка"));
	// Имена функциональных опций, влияющих на видимость команды, разделитель - запятая.
	Результат.Колонки.Добавить("ФункциональныеОпции", Новый ОписаниеТипов("Строка"));
	
	Результат.Колонки.Добавить("РежимИспользованияПараметра", Новый ОписаниеТипов("РежимИспользованияПараметраКоманды"));
	
	// дополнительные параметры
	Результат.Колонки.Добавить("ДополнительныеПараметры", Новый ОписаниеТипов("Структура"));
	
	// Специальный режим выполнения команды
	// по умолчанию выполняется запись модифицированного объекта перед выполнением команды.
	Результат.Колонки.Добавить("НеВыполнятьЗаписьВФорме", Новый ОписаниеТипов("Булево"));
	
	// Для служебного использования.
	Результат.Колонки.Добавить("СкрытаФункциональнымиОпциями", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("УникальныйИдентификатор", Новый ОписаниеТипов("Строка"));
	Результат.Колонки.Добавить("Отключена", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("УправлениеВидимостью", Новый ОписаниеТипов("Структура"));
	
	Результат.Колонки.Добавить("ТолькоВоВсехДействиях", Новый ОписаниеТипов("Булево"));
	Результат.Колонки.Добавить("Недоступна", Новый ОписаниеТипов("Булево"));
	
	Возврат Результат;
	
КонецФункции

// Создает подменю "ЭДО" на форме и добавляет в него команды ЭДО.
// Если команда ЭДО одна, то вместо подменю добавляется кнопка с названием печатной формы.
Процедура ДобавитьКомандыЭДО(Форма, КомандыЭДО, Знач МестоРазмещенияКоманд = Неопределено)
	
	ПараметрыУправленияВидимостьюЭДО = Новый Структура("ЕстьУсловияВидимости, КомандыСУсловиямиВидимости", Ложь, Новый Массив);
	
	МестоРазмещения = МестоРазмещенияКоманд;
	Для Каждого ОписаниеКомандыЭДО Из КомандыЭДО Цикл
		
		// Отключение команды загрузки ЭД и поиск ЭД по QR-коду без ЭП в формах документов.
		Если ОписаниеКомандыЭДО.Идентификатор = "ЗагрузитьЧерезБизнесСеть"
			Или ОписаниеКомандыЭДО.Идентификатор = "НайтиПоQRКоду" Тогда
			МассивРеквизитов = Форма.ПолучитьРеквизиты();
			ЭтоФормаОбъекта = Ложь;
			Для Каждого Реквизит Из МассивРеквизитов Цикл
				Если Реквизит.Имя = "Объект" Тогда
					ЭтоФормаОбъекта = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если ЭтоФормаОбъекта Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		
		НомерКоманды = ОписаниеКомандыЭДО.Владелец().Индекс(ОписаниеКомандыЭДО);
		ИмяКоманды = МестоРазмещенияКоманд.Имя + ОписаниеКомандыЭДО.Идентификатор + НомерКоманды;
		
		КомандаФормы = Форма.Команды.Добавить(ИмяКоманды);
		КомандаФормы.Действие = "Подключаемый_ВыполнитьКомандуЭДО";
		КомандаФормы.Заголовок = ОписаниеКомандыЭДО.Представление;
		КомандаФормы.ИзменяетСохраняемыеДанные = Ложь;
		
		Если ЗначениеЗаполнено(ОписаниеКомандыЭДО.Отображение) Тогда 
			КомандаФормы.Отображение = ОписаниеКомандыЭДО.Отображение;
		Иначе 
			КомандаФормы.Отображение = ОтображениеКнопки.КартинкаИТекст;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(ОписаниеКомандыЭДО.Картинка) Тогда
			КомандаФормы.Картинка = ОписаниеКомандыЭДО.Картинка;
		КонецЕсли;
		
		ОписаниеКомандыЭДО.ИмяКомандыНаФорме = ИмяКоманды;
		Видимость = Не ОписаниеКомандыЭДО.Недоступна;
		
		Если ОписаниеКомандыЭДО.УправлениеВидимостью.Свойство("Использовать")
			И ОписаниеКомандыЭДО.УправлениеВидимостью.Использовать
			И Видимость Тогда
			
			ПараметрыУправленияВидимостьюЭДО.ЕстьУсловияВидимости = Истина;
			УсловияВидимости = Новый Структура;
			УсловияВидимости.Вставить("ИмяВФорме", ИмяКоманды);
			УсловияВидимости.Вставить("ИмяРеквизитаУсловия", Неопределено);
			УсловияВидимости.Вставить("ИмяАлгоритмаПроверкиУсловия", Неопределено);
			УсловияВидимости.Вставить("ЗначениеУсловия", Неопределено);
			ЗаполнитьЗначенияСвойств(УсловияВидимости, ОписаниеКомандыЭДО.УправлениеВидимостью);
			
			ПараметрыУправленияВидимостьюЭДО.КомандыСУсловиямиВидимости.Добавить(УсловияВидимости);
			Видимость = Ложь;
		КонецЕсли;
		
		// Для платформенной команды ввода на основании не добавляем префикс, чтобы команды не отделялись чертой.
		Если ОписаниеКомандыЭДО.МестоРазмещения = "ФормаСоздатьНаОсновании" Тогда
			МестоРазмещенияИмя = ОписаниеКомандыЭДО.МестоРазмещения;
		Иначе
			МестоРазмещенияИмя = МестоРазмещенияКоманд.Имя + ОписаниеКомандыЭДО.МестоРазмещения;
		КонецЕсли;
	
		Если Форма.Элементы.Найти(МестоРазмещенияИмя) = Неопределено Тогда
			МестоРазмещения = Форма.Элементы.Добавить(МестоРазмещенияИмя, Тип("ГруппаФормы"), МестоРазмещения);
			МестоРазмещения.Вид = ВидГруппыФормы.ГруппаКнопок;
			МестоРазмещения.Заголовок = СтрЗаменить(ОписаниеКомандыЭДО.МестоРазмещения, "КомандыЭДО", "");
		КонецЕсли;
		
		НовыйЭлемент = Форма.Элементы.Добавить(ИмяКоманды, Тип("КнопкаФормы"), МестоРазмещения);
		НовыйЭлемент.Вид = ВидКнопкиФормы.КнопкаКоманднойПанели;
		НовыйЭлемент.ИмяКоманды = ИмяКоманды;
		НовыйЭлемент.Видимость = Видимость;
		НовыйЭлемент.ТолькоВоВсехДействиях = ОписаниеКомандыЭДО.ТолькоВоВсехДействиях;
		
	КонецЦикла;
	
	Если ПараметрыУправленияВидимостьюЭДО.ЕстьУсловияВидимости Тогда
		
		Проверка = Новый Структура("ПараметрыУправленияВидимостьюЭДО", NULL);
		ЗаполнитьЗначенияСвойств(Проверка, Форма);
		
		Если Проверка.ПараметрыУправленияВидимостьюЭДО <> NULL Тогда
			Если ТипЗнч(Форма.ПараметрыУправленияВидимостьюЭДО) = Тип("Структура") 
				И Форма.ПараметрыУправленияВидимостьюЭДО.Свойство("КомандыСУсловиямиВидимости") Тогда
				ОбщегоНазначенияКлиентСервер.ДополнитьМассив(ПараметрыУправленияВидимостьюЭДО.КомандыСУсловиямиВидимости,
				Форма.ПараметрыУправленияВидимостьюЭДО.КомандыСУсловиямиВидимости, Истина)
			КонецЕсли;
		Иначе
			ДобавляемыеРеквизиты = Новый Массив;
			Реквизит = Новый РеквизитФормы("ПараметрыУправленияВидимостьюЭДО", Новый ОписаниеТипов());
			ДобавляемыеРеквизиты.Добавить(Реквизит);
			Форма.ИзменитьРеквизиты(ДобавляемыеРеквизиты);
			
		КонецЕсли;
		
		Форма.ПараметрыУправленияВидимостьюЭДО = ПараметрыУправленияВидимостьюЭДО;
		
	КонецЕсли;
	
КонецПроцедуры

// Фильтрует список команд ЭДО в соответствии с установленными функциональными опциями.
Процедура ОпределитьВидимостьКомандЭДОПоФункциональнымОпциям(КомандыЭДО, Форма = Неопределено)
	Для НомерКоманды = -КомандыЭДО.Количество() + 1 По 0 Цикл
		ОписаниеКомандыЭДО = КомандыЭДО[-НомерКоманды];
		ФункциональныеОпцииКомандыЭДО = СтрРазделить(ОписаниеКомандыЭДО.ФункциональныеОпции, ", ", Ложь);
		ВидимостьКоманды = ФункциональныеОпцииКомандыЭДО.Количество() = 0;
		Для Каждого ФункциональнаяОпция Из ФункциональныеОпцииКомандыЭДО Цикл
			Если ТипЗнч(Форма) = Тип("ФормаКлиентскогоПриложения") Тогда
				ВидимостьКоманды = ВидимостьКоманды Или Форма.ПолучитьФункциональнуюОпциюФормы(ФункциональнаяОпция);
			Иначе
				ВидимостьКоманды = ВидимостьКоманды Или ПолучитьФункциональнуюОпцию(ФункциональнаяОпция);
			КонецЕсли;
			
			Если ВидимостьКоманды Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		ОписаниеКомандыЭДО.СкрытаФункциональнымиОпциями = Не ВидимостьКоманды;
	КонецЦикла;
КонецПроцедуры

#Область РаботаСМаршрутамиПодписанияСлужебныеПроцедурыИФункции

Процедура ПрочитатьСтрокиТаблицыТребованийКПодписаниюВДерево(СтрокиТаблицы, РодительскийУзелДерева, Таблица)

	ПодчиненныеУзлы = РодительскийУзелДерева.Строки;
	
	// В этих переменных будем хранить результаты подсчетов по истинности узлов
	ВыполненоМинимум = Истина;
	ВыполненоМаксимум = Ложь;
	ВыполненоОбщийМаксимум = Ложь;
	
	// В этих переменных будем хранить результаты подсчетов по истинности узлов
	ВыполнимоМинимум = Истина;
	ВыполнимоМаксимум = Ложь;
	
	Для Каждого СтрокаТаблицы Из СтрокиТаблицы Цикл		
		НовыйУзел = ПодчиненныеУзлы.Добавить();
		ЗаполнитьЗначенияСвойств(НовыйУзел, СтрокаТаблицы);

		ДочерниеСтроки = Таблица.НайтиСтроки(Новый Структура("ИдентификаторРодителя", СтрокаТаблицы.Идентификатор));
		ПрочитатьСтрокиТаблицыТребованийКПодписаниюВДерево(ДочерниеСтроки, НовыйУзел, Таблица);
		
		// Рассчитаем истинность
		Если НовыйУзел.Выполнено < ВыполненоМинимум Тогда
			ВыполненоМинимум = НовыйУзел.Выполнено;
		КонецЕсли;
		
		Если НовыйУзел.Выполнено > ВыполненоМаксимум Тогда
			ВыполненоМаксимум = НовыйУзел.Выполнено;
		КонецЕсли;
		
		Если НовыйУзел.Выполнено ИЛИ НовыйУзел.ВыполненоМаксимум Тогда
			ВыполненоОбщийМаксимум = Истина;
		КонецЕсли;
		
		// Рассчитаем выполнимость
		Если ВыполнимоМинимум > НовыйУзел.ТребованиеВыполнимо Тогда
			ВыполнимоМинимум = НовыйУзел.ТребованиеВыполнимо;
		КонецЕсли;
		
		Если ВыполнимоМаксимум < НовыйУзел.ТребованиеВыполнимо Тогда
			ВыполнимоМаксимум = НовыйУзел.ТребованиеВыполнимо;
		КонецЕсли;
	КонецЦикла;
	
	Если ТипЗнч(РодительскийУзелДерева) = Тип("СтрокаДереваЗначений") 
			И ЗначениеЗаполнено(РодительскийУзелДерева.Требование) Тогда
		РодительскийУзелДерева.Выполнено = ?(РодительскийУзелДерева.Требование = Перечисления.ТребованияКПодписаниюЭД.ИЛИ, 
			ВыполненоМаксимум, ВыполненоМинимум);
		РодительскийУзелДерева.ВыполненоМаксимум = ВыполненоОбщийМаксимум;
		
		РодительскийУзелДерева.ТребованиеВыполнимо = ?(
			РодительскийУзелДерева.Требование = Перечисления.ТребованияКПодписаниюЭД.ИЛИ, ВыполнимоМаксимум, ВыполнимоМинимум);
	КонецЕсли;

КонецПроцедуры

Процедура ПрочитатьСтрокиДереваВТаблицуТребованийКПодписанию(РодительскийУзелДерева, Таблица)

	Если ТипЗнч(РодительскийУзелДерева) = Тип("ДеревоЗначений") Тогда
		ИдентификаторРодителя = ПустойУникальныйИдентификатор();
		УчитыватьПорядок = Ложь;
	Иначе
		ИдентификаторРодителя = РодительскийУзелДерева.Идентификатор;
		УчитыватьПорядок = РодительскийУзелДерева.Требование = Перечисления.ТребованияКПодписаниюЭД.ПоПорядку;
	КонецЕсли;
	
	ПодчиненныеУзлы = РодительскийУзелДерева.Строки;
	Порядок = 1;
	Для Каждого Узел Из ПодчиненныеУзлы Цикл
		НоваяСтрокаТаблицы = Таблица.Добавить();
		Если Не ЗначениеЗаполнено(Узел.Идентификатор) Тогда
			Узел.Идентификатор = Строка(Новый УникальныйИдентификатор());
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(НоваяСтрокаТаблицы, Узел);
		НоваяСтрокаТаблицы.ИдентификаторРодителя = ИдентификаторРодителя;
		НоваяСтрокаТаблицы.Порядок = Порядок;
		
		Если УчитыватьПорядок Тогда
			Порядок = Порядок + 1;	
		КонецЕсли;
		
		ПрочитатьСтрокиДереваВТаблицуТребованийКПодписанию(Узел, Таблица);
	КонецЦикла;

КонецПроцедуры

Процедура ОбработатьДеревоПодписания(РодительскийУзелДерева, УдалятьНевыполнимыеТребования, Оптимизировать,
	ПроставитьТекущие, Знач УдалятьЛожные = Ложь, ПросчитатьВес = Ложь, ЕстьНевыполнимыеТребования = Ложь)

	Если ТипЗнч(РодительскийУзелДерева) = Тип("ДеревоЗначений") ИЛИ ЗначениеЗаполнено(РодительскийУзелДерева.Требование) Тогда
		СтрокиДляУдаления = Новый Массив;
		
		ПроставлятьТекущиеВоВсехСтроках = ТипЗнч(РодительскийУзелДерева) = Тип("ДеревоЗначений") 
			ИЛИ РодительскийУзелДерева.Требование = Перечисления.ТребованияКПодписаниюЭД.И
			ИЛИ РодительскийУзелДерева.Требование = Перечисления.ТребованияКПодписаниюЭД.ИЛИ;
		ТекущийПроставлен = Ложь;
		
		ВесСумма = 0;
		ВесМаксимум = 0;
		Для Каждого СтрокаДерева Из РодительскийУзелДерева.Строки Цикл
			Если НЕ СтрокаДерева.ТребованиеВыполнимо Тогда
				ЕстьНевыполнимыеТребования = Истина;
			КонецЕсли;
			
			Если Оптимизировать И ((УдалятьЛожные И НЕ СтрокаДерева.ВыполненоМаксимум) ИЛИ СтрокаДерева.Выполнено)
					ИЛИ УдалятьНевыполнимыеТребования И НЕ СтрокаДерева.ТребованиеВыполнимо Тогда
				СтрокиДляУдаления.Добавить(СтрокаДерева);
			Иначе
				ТекУдалятьЛожные = СтрокаДерева.Требование = Перечисления.ТребованияКПодписаниюЭД.ИЛИ 
					И СтрокаДерева.ВыполненоМаксимум;
				ОбработатьДеревоПодписания(СтрокаДерева, УдалятьНевыполнимыеТребования, Оптимизировать, 
					ПроставитьТекущие, ТекУдалятьЛожные, ПросчитатьВес, ЕстьНевыполнимыеТребования);
				
				Если НЕ ЗначениеЗаполнено(СтрокаДерева.Требование) И Не ТекущийПроставлен Тогда
					СтрокаДерева.Текущий = Истина;
					
					Если НЕ ПроставлятьТекущиеВоВсехСтроках Тогда
						ТекущийПроставлен = Истина;
					КонецЕсли;
				КонецЕсли;
				
				ВесСумма = ВесСумма + СтрокаДерева.Вес;
				Если СтрокаДерева.Вес > ВесМаксимум Тогда
					ВесМаксимум = СтрокаДерева.Вес;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого СтрокаДляУдаления Из СтрокиДляУдаления Цикл
			РодительскийУзелДерева.Строки.Удалить(СтрокаДляУдаления);
		КонецЦикла;
		
		Если ПросчитатьВес И ТипЗнч(РодительскийУзелДерева) <> Тип("ДеревоЗначений") Тогда
			РодительскийУзелДерева.Вес = ?(РодительскийУзелДерева.Требование = Перечисления.ТребованияКПодписаниюЭД.ИЛИ, 
				ВесМаксимум, ВесСумма);
		КонецЕсли;
	Иначе // это строка подписанта
		Если ПросчитатьВес Тогда
			РодительскийУзелДерева.Вес = 1;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

Процедура ЗаполнитьВспомогательныеКолонкиВДеревеМаршрута(УзелДерева, ИмяОсновногоРеквизита = "Подписант")

	СтрокиДерева = УзелДерева.ПолучитьЭлементы();
	Для Каждого СтрокаДерева Из СтрокиДерева Цикл
	    ЗаполнитьВспомогательныеКолонкиВДеревеМаршрута(СтрокаДерева, ИмяОсновногоРеквизита);
		ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.ЗаполнитьСлужебныеРеквизитыСтрокиДерева(СтрокаДерева, ИмяОсновногоРеквизита);
	КонецЦикла;

КонецПроцедуры

Функция ТаблицаПодписанияПоПараметрам(СхемаПодписания, УсловиеПодписания, СписокПодписантов)

	Результат = ПустаяТаблицаТребованийКПодписанию();
	Если СхемаПодписания = Перечисления.СхемыПодписанияЭД.ОднойДоступнойПодписью Тогда
		СтрокаТребования = Результат.Добавить();
		СтрокаТребования.ИдентификаторРодителя = ПустойУникальныйИдентификатор();
		СтрокаТребования.Идентификатор = Строка(Новый УникальныйИдентификатор());
		СтрокаТребования.Требование = Перечисления.ТребованияКПодписаниюЭД.ИЛИ;
		
		СтрокаПодписанта = Результат.Добавить();
		СтрокаПодписанта.ИдентификаторРодителя = СтрокаТребования.Идентификатор;
		СтрокаПодписанта.Идентификатор = Строка(Новый УникальныйИдентификатор());
		СтрокаПодписанта.Подписант = Справочники.Пользователи.ПустаяСсылка();
	ИначеЕсли СхемаПодписания = Перечисления.СхемыПодписанияЭД.УказыватьПриСоздании Тогда
		СтрокаТребования = Результат.Добавить();
		СтрокаТребования.ИдентификаторРодителя = ПустойУникальныйИдентификатор();
		СтрокаТребования.Идентификатор = Строка(Новый УникальныйИдентификатор());
		СтрокаТребования.Требование = УсловиеПодписания;
		
		Для Каждого Подписант Из СписокПодписантов Цикл
			СтрокаПодписанта = Результат.Добавить();
			СтрокаПодписанта.ИдентификаторРодителя = СтрокаТребования.Идентификатор;
			СтрокаПодписанта.Идентификатор = Строка(Новый УникальныйИдентификатор());
			
			Если ТипЗнч(Подписант) = Тип("СтрокаТаблицыЗначений") Тогда
				ЗаполнитьЗначенияСвойств(СтрокаПодписанта, Подписант);
			Иначе
				СтрокаПодписанта.Подписант = Подписант;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции 

// Заполняет дерево значений по таблице маршрута подписания.
//
// Параметры:
//  Дерево	 - ДеревоЗначений, Неопределено - дерево для формирования маршрута. Если не задано, будет сформировано.
//  Таблица	 - ТаблицаЗначений - таблица маршрута подписания. По структуре должна соответствовать табличной части
//    "ТаблицаТребований" справочника "МаршрутыПодписания".
//
Процедура ЗаполнитьДеревоПоТаблицеТребованийКПодписанию(Дерево, Таблица)
	
	// Если дерево не задано, инициализируем его
	Если Дерево = Неопределено Тогда
		Дерево = ПустоеДеревоТребованийКПодписанию();
	Иначе
		ДополнитьДеревоПодписанияСлужебнымиКолонками(Дерево);
	КонецЕсли;
	
	ПараметрыПоиска = Новый Структура("ИдентификаторРодителя", ПустойУникальныйИдентификатор());
	СтрокиВерхнегоУровня = Таблица.НайтиСтроки(ПараметрыПоиска);
	ПрочитатьСтрокиТаблицыТребованийКПодписаниюВДерево(СтрокиВерхнегоУровня, Дерево, Таблица);
	
КонецПроцедуры

// Возвращает пустой идентификатор строки дерева / таблицы маршрута подписания.
// 
// Возвращаемое значение:
//  Строка - строка, выступающая в качестве пустого идентификатора.
//
Функция ПустойУникальныйИдентификатор() 
	
	Возврат "";
	
КонецФункции

// Формирует набор параметров для выбора маршрута.
//
// Параметры:
//  ЗадаватьМаршрутВручную			 - Булево - признак того, что маршрут будет указываться непосредственно при отправке
//    документа на подпись.
//  Подписанты						 - ТаблицаЗначений - таблица состава подписантов с колонками:
//    * Подписант - СправочникСсылка.Пользователи - пользователь, который может установить подпись.
//    * Сертификат - СправочникСсылка.СертификатыКлючейЭлектроннойПодписиИШифрования - сертификат, которым можно 
//      подписать документ.
//  ФиксированныйМаршрут			 - СправочникСсылка.МаршрутыПодписания - маршрут, по которому будет подписываться документ.
//  ДоступныеДляВыбораСертификаты	 - Массив - содержит сертификаты, которыми можно подписывать документ в соответствии
//    с настройками.
// 
// Возвращаемое значение:
//  Структура - параметры выбора маршрута.
//
Функция НовыеНастройкиВыбораМаршрута(ЗадаватьМаршрутВручную, Подписанты = Неопределено,
	ФиксированныйМаршрут = Неопределено, ДоступныеДляВыбораСертификаты = Неопределено)

	ПредставлениеНастроек = ПредставлениеМаршрутаВыбранногоВДокументе(
		ЗадаватьМаршрутВручную, Подписанты, ФиксированныйМаршрут);
	
	Настройки = Новый Структура;
	Настройки.Вставить("ЗадаватьМаршрутВручную", ЗадаватьМаршрутВручную);
	Настройки.Вставить("Подписанты", Подписанты);
	Настройки.Вставить("Маршрут", ФиксированныйМаршрут);
	Настройки.Вставить("ПредставлениеНастроек", ПредставлениеНастроек);
	Настройки.Вставить("ДоступныеДляВыбораСертификаты", ДоступныеДляВыбораСертификаты);
		
	Возврат Настройки;

КонецФункции

// Добавляет при необходимости в дерево подписания служебные колонки, необходимые для работы служебных механизмов.
//
// Параметры:
//  Дерево - ДеревоЗначений - дерево маршрута подписания.
//
Процедура ДополнитьДеревоПодписанияСлужебнымиКолонками(Дерево)
	
	Дерево.Колонки.Добавить("Текущий", Новый ОписаниеТипов("Булево"));
	Дерево.Колонки.Добавить("ТребованиеВыполнимо", Новый ОписаниеТипов("Булево"));
	Дерево.Колонки.Добавить("Выполнено", Новый ОписаниеТипов("Булево"));
	Дерево.Колонки.Добавить("ВыполненоМаксимум", Новый ОписаниеТипов("Булево"));
	Дерево.Колонки.Добавить("Вес", Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(2)));
	Дерево.Колонки.Добавить("ПодписантОповещен", Новый ОписаниеТипов("Булево"));

КонецПроцедуры

// Формирует представление ошибки проверки корректности маршрута подписания.
//
// Параметры:
//  ИдентификаторОшибки	 - Строка - идентификатор ошибки.
// 
// Возвращаемое значение:
//  Строка - представление ошибки.
//
Функция ПредставлениеОшибкиНесоответствияМаршрутаНастройкам(ИдентификаторОшибки)

	Ошибки = Новый Структура;
	Ошибки.Вставить("НетДоступныхСертификатов", 
		НСтр("ru = 'Нет доступных сертификатов для подписания документов ""%1""'"));
	Ошибки.Вставить("ДлинаМаршрутаБольшеКоличестваДоступныхСертификатов", 
		НСтр("ru = 'Возможное количество подписей по маршруту ""%2"" больше количества доступных сертификатов по документам ""%1""'"));
	Ошибки.Вставить("НетДоступныхСертификатовДляНекоторыхШаговМаршрута", 
		НСтр("ru = 'Нет доступных сертификатов для подписания документов ""%1"" на некоторых шагах маршрута ""%2""'"));
	
	Возврат Ошибки[ИдентификаторОшибки];

КонецФункции

#КонецОбласти

#Область АвтоматизированноеТестированиеСлужебныеПроцедурыИФункции

// Присваивает имена параметризованным ячейкам переданной области
//
// Параметры:
//  ОбластьМакета		 - ТабличныйДокумент - табличный документ.
//  ПрефиксДляИмен		 - Строка - префикс для имен ячеек (рекомендуется передавать имя области).
//  ИндексПрефикса		 - Число - индекс или номер строки, который будет прибавлен к префиксу.
//
Процедура ПрисвоитьИменаЯчейкамТабличногоДокумента(ОбластьМакета, Знач ПрефиксДляИмен, Знач ИндексПрефикса)
	
	// Обойдем все ячейки выводимой области и заполним имена для ячеек, содержащих параметры.
	Для НомерСтроки = 1 По ОбластьМакета.ВысотаТаблицы Цикл
		Для НомерКолонки = 1 По ОбластьМакета.ШиринаТаблицы Цикл
			Ячейка = ОбластьМакета.Область(НомерСтроки, НомерКолонки);
			Если Ячейка.Заполнение = ТипЗаполненияОбластиТабличногоДокумента.Параметр
				И ЗначениеЗаполнено(Ячейка.Параметр) Тогда
				Ячейка.Имя = ПрефиксДляИмен + ИндексПрефикса + "_" + Ячейка.Параметр;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры

#КонецОбласти

#Область РаботаСДеревомДанныхСлужебныеПроцедурыИФункции

Функция ДанныеГруппыДереваЭлектронногоДокумента(Знач ГруппаДерева)
	
	Данные = Новый Структура;
	
	Для каждого СтрокаДерева Из ГруппаДерева.Строки Цикл
		
		ИмяПоля = ЭлектронноеВзаимодействие.НазваниеКолонки(СтрокаДерева.ПолныйПуть);
		Значение = ДанныеЭлементаДереваЭлектронногоДокумента(ГруппаДерева, СтрокаДерева.ПолныйПуть);
		
		Данные.Вставить(ИмяПоля, Значение);
		
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции

Функция ДанныеВыбораДереваЭлектронногоДокумента(Знач ВыборДерева)
	
	Данные = Новый Структура;
	
	Для каждого СтрокаДерева Из ВыборДерева.Строки Цикл
		
		ИмяПоля = ЭлектронноеВзаимодействие.НазваниеКолонки(СтрокаДерева.ПолныйПуть);
		Если ИмяПоля <> ВыборДерева.Значение Тогда
			Продолжить;
		КонецЕсли;
		Значение = ДанныеЭлементаДереваЭлектронногоДокумента(ВыборДерева, СтрокаДерева.ПолныйПуть);
		
		Данные.Вставить(ИмяПоля, Значение);
		
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции

Функция ДанныеТаблицыДереваЭлектронногоДокумента(Знач ТаблицаДерева)
	
	Данные = Новый ТаблицаЗначений;
	
	СтрокаНомерСтроки = ТаблицаДерева.Строки[0];
	Для Каждого СтрокаКолонки Из СтрокаНомерСтроки.Строки Цикл
		ИмяКолонки = ЭлектронноеВзаимодействие.НазваниеКолонки(СтрокаКолонки.ПолныйПуть);
		Данные.Колонки.Добавить(ИмяКолонки);
	КонецЦикла;
	
	Если Не ЗначениеЗаполнено(ТаблицаДерева.Значение) Тогда
		Возврат Данные;
	КонецЕсли;
	
	Для Каждого СтрокаНомерСтроки Из ТаблицаДерева.Строки Цикл
		
		НоваяСтрока = Данные.Добавить();
		
		Для Каждого СтрокаКолонки Из СтрокаНомерСтроки.Строки Цикл
			
			ИмяКолонки = ЭлектронноеВзаимодействие.НазваниеКолонки(СтрокаКолонки.ПолныйПуть);
			НоваяСтрока[ИмяКолонки] = ДанныеЭлементаДереваЭлектронногоДокумента(СтрокаНомерСтроки, СтрокаКолонки.ПолныйПуть);
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Данные;
	
КонецФункции

Функция ДанныеЗначенияДереваЭлектронногоДокумента(Знач ЗначениеДерева)
	
	Значение = ЗначениеДерева.Значение;
	
	Если Не ЗначениеЗаполнено(Значение) Тогда
		
		Если ЗначениеДерева.Типы = "Строка" Тогда
			Значение = "";
		ИначеЕсли ЗначениеДерева.Типы = "Число" Тогда
			Значение = 0;
		ИначеЕсли ЗначениеДерева.Типы = "Дата" Тогда
			Значение = Дата(1, 1, 1);
		Иначе
			Значение = Неопределено;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции

// Формирует прикладное представление реквизита дерева электронного документа.
//
// Параметры:
//  СтрокаДереваДанных	 - СтрокаДереваЗначений - строка реквизита дерева электронного документа.
//  НомерСтрокиДанных	 - Число - номер строки, который будет подставлен по возможности в представление.
// 
// Возвращаемое значение:
//  Строка - прикладное представление реквизита дерева.
//
Функция ПрикладноеПредставлениеПоСтрокеДерева(СтрокаДереваДанных, НомерСтрокиДанных = Неопределено)
	
	ШаблонПрикладногоПредставления = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.ПрикладноеПредставлениеРеквизита(
		СтрокаДереваДанных.КодПредставления);
		
	Если НомерСтрокиДанных = Неопределено Тогда
		ПрикладноеПредставление = ШаблонПрикладногоПредставления;
	Иначе
		Если СтрНайти(ШаблонПрикладногоПредставления, "%1") > 0 Тогда
			ПрикладноеПредставление = СтрШаблон(ШаблонПрикладногоПредставления, Формат(НомерСтрокиДанных, "ЧГ="));
		Иначе
			ПрикладноеПредставление = ШаблонПрикладногоПредставления;
		КонецЕсли;
		
	КонецЕсли;
	
	Если Не ЗначениеЗаполнено(ПрикладноеПредставление) Тогда
		ПрикладноеПредставление = СтрЗаменить(СтрокаДереваДанных.ПолныйПуть, ".", " - ");
		
		Если ЗначениеЗаполнено(НомерСтрокиДанных) Тогда
			ПрикладноеПредставление = СтрШаблон("%1(%2)", ПрикладноеПредставление, Формат(НомерСтрокиДанных, "ЧГ="));
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПрикладноеПредставление;

КонецФункции

Функция ПараметрыОбработкиОшибкиУказаны(СтрокаДерева)

	Результат = Ложь;
	
	Если СтрокаДерева <> Неопределено Тогда
		Результат = ЗначениеЗаполнено(СтрокаДерева.ТекстОшибки)
			ИЛИ ЗначениеЗаполнено(СтрокаДерева.ПутьКДаннымСообщения) И СтрокаДерева.КлючСообщения <> Неопределено
			ИЛИ ЗначениеЗаполнено(СтрокаДерева.НавигационнаяСсылка)
			ИЛИ ЗначениеЗаполнено(СтрокаДерева.ИмяФормы);
	КонецЕсли;
	
	Возврат Результат;

КонецФункции 

Функция ПараметрыОшибкиПоСтрокеДерева(СтрокаДерева)

	ДанныеОшибки = ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки(СтрокаДерева.КлючСообщения,
		СтрокаДерева.ПутьКДаннымСообщения, СтрокаДерева.НавигационнаяСсылка, СтрокаДерева.ИмяФормы, 
		СтрокаДерева.ПараметрыФормы, СтрокаДерева.ТекстОшибки);
	
	Возврат ДанныеОшибки;

КонецФункции

Функция ПолучитьПредставлениеТипаПоСтрокеДерева(Строка, ДатаПоФорматуФНС = Ложь)

	ОписанияСтроками = Новый Массив;
	
	ОписаниеТипа = Строка.ТипЗначения;
	Для Каждого Тип Из ОписаниеТипа.Типы() Цикл
		ПредставлениеТипа = НРег(Строка(Тип));
		
		Если Тип = Тип("Строка") Тогда
			Если ОписаниеТипа.КвалификаторыСтроки.Длина > 0 Тогда
				Если ОписаниеТипа.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Переменная Тогда
					ПредставлениеСтроки = СтрШаблон(НСтр("ru = 'до %1 символов'"), ОписаниеТипа.КвалификаторыСтроки.Длина);
				Иначе
					ПредставлениеСтроки = СтрШаблон(НСтр("ru = '%1 символов'"), ОписаниеТипа.КвалификаторыСтроки.Длина);
				КонецЕсли;
				
				ПредставлениеТипа = СтрШаблон(НСтр("ru = '%1 %2'"), ПредставлениеТипа, ПредставлениеСтроки);
			КонецЕсли;
		ИначеЕсли Тип = Тип("Число") Тогда
			Если ОписаниеТипа.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Неотрицательный Тогда
				ПредставлениеТипа = СтрШаблон(НСтр("ru = 'неотрицательное %1'"), ПредставлениеТипа);
			КонецЕсли;
			
			Если ОписаниеТипа.КвалификаторыЧисла.Разрядность > 0 Тогда
				ПредставлениеТипа = СтрШаблон(НСтр("ru = '%1 формата %2.%3'"), ПредставлениеТипа, 
					ОписаниеТипа.КвалификаторыЧисла.Разрядность - ОписаниеТипа.КвалификаторыЧисла.РазрядностьДробнойЧасти,
					ОписаниеТипа.КвалификаторыЧисла.РазрядностьДробнойЧасти);
			КонецЕсли;
		ИначеЕсли Тип = Тип("Дата") И ДатаПоФорматуФНС Тогда
			ПредставлениеТипа = СтрШаблон(НСтр("ru = '%1 с 01.01.1900 до 31.12.2099 г.'"), ПредставлениеТипа);
		КонецЕсли;
		
		ОписанияСтроками.Добавить(ПредставлениеТипа);
	КонецЦикла;
	
	Возврат СтрСоединить(ОписанияСтроками, " ИЛИ ");

КонецФункции

Процедура ПроверитьЗаполненностьПараметровОбработкиОшибок(СтрокаДерева)
	
	// Если при внедрении не указали параметры обработки ошибки для реквизитов, для которых это обязательно, будет выдано исключение.
	Если НРег(СтрокаДерева.ПараметрыОбработкиОбязательны) = "да" И Не ПараметрыОбработкиОшибкиУказаны(СтрокаДерева) Тогда
		ТекстИсключения = СтрШаблон(НСтр("ru = 'Не указаны параметры обработки ошибки для реквизита %1'"),
			СтрокаДерева.ПолныйПуть);
		ВызватьИсключение ТекстИсключения;
	КонецЕсли;
	
КонецПроцедуры

// Проверяет заполнение обязательных реквизитов дерева.
// Только для внутреннего использования.
// Параметры:
//  ДеревоДанных                            - деревоЗначений - дерево с данными.
//  Ошибки                                  - Массив - ошибки, накопленные за время обработки. Элементами массива являются структуры.
//                                                     Состав структур см. в ЭлектронноеВзаимодействиеСлужебныйКлиентСервер.НовыеПараметрыОшибки().
//  ЭтоТаблица                              - Булево - если Истина, то проверяется табличная часть.
//  НомерСтроки                             - Число, Неопределено - номер проверяемой строки табличной части.
//  ПроверятьОбязательностьПараметровОшибки - Булево - определяет, нужно ли проверять, заданы ли параметры обработки ошибок
//                                                     в тех реквизитах, для которых это обязательно.
//  ДатаПоФорматуФНС                        - Булево - если установлена в Истину, значения типа "Дата" будут проверяться дополнительно
//                                                     на вхождение в диапазон лет 1900-2099 (требование схем ФНС).
//
Процедура ПроверитьЗаполнениеРеквизитовДереваДанныхСлужебная(ДеревоДанных, Ошибки, ЭтоТаблица,
	НомерСтроки = Неопределено, ПроверятьОбязательностьПараметровОшибки = Истина, ДатаПоФорматуФНС = Ложь)
	
	НомерСтрокиДляПодстановки = ?(ЭтоТаблица, НомерСтроки, Неопределено);
	СтрокаДерева = Неопределено; // в этой переменной будем хранить последнюю считанную строку дерева данных
	
	Для Каждого СтрокаДерева Из ДеревоДанных.Строки Цикл
		ТекстОшибки = "";
		
		РеквизитЗаполненИлиОбязателен = ЗначениеЗаполнено(СтрокаДерева.Значение) ИЛИ НРег(СтрокаДерева.Обязательное) = "да";
		
		// Проверяем заполнение самого реквизита.
		ПроверитьЗаполнениеРеквизитаДереваДанных(СтрокаДерева, ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС, ТекстОшибки);
	
		Если ЗначениеЗаполнено(ТекстОшибки) Тогда
			ДобавитьОшибкуПроверкиДереваДанных(Ошибки, СтрокаДерева, ТекстОшибки,, НомерСтрокиДляПодстановки);
			
			Продолжить;
		КонецЕсли;
		
		// Запускаем проверки подчиненных реквизитов, если это структурированное значение.
		Если СтрокаДерева.Признак = "Таблица" И (ТипЗнч(СтрокаДерева.Значение) = Тип("Число") И СтрокаДерева.Значение > 0 ИЛИ СтрокаДерева.Обязательное = "Да")Тогда
			Для Каждого СтрокаТаблицы Из СтрокаДерева.Строки Цикл
				ПроверитьЗаполнениеРеквизитовДереваДанныхСлужебная(СтрокаТаблицы, Ошибки, Истина, СтрокаТаблицы.Значение,
					РеквизитЗаполненИлиОбязателен И ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС);
			КонецЦикла;
		ИначеЕсли СтрокаДерева.Признак = "Выбор" И (ЗначениеЗаполнено(СтрокаДерева.Значение) ИЛИ СтрокаДерева.Обязательное = "Да") Тогда
			ПроверяемаяСтрока = СтрокаДерева.Строки.Найти(СтрокаДерева.ПолныйПуть + "." + СтрокаДерева.Значение, "ПолныйПуть");
			Если ЗначениеЗаполнено(ПроверяемаяСтрока) Тогда
				// Поскольку сменили текущую строку дерева, нужно проверить заполнение самого реквизита.
				ПроверитьЗаполнениеРеквизитаДереваДанных(ПроверяемаяСтрока, ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС, ТекстОшибки);
			
				Если ЗначениеЗаполнено(ТекстОшибки) Тогда
					ДобавитьОшибкуПроверкиДереваДанных(Ошибки, ПроверяемаяСтрока, ТекстОшибки,, НомерСтрокиДляПодстановки);
					
					Продолжить;
				КонецЕсли;
				
				ПроверитьЗаполнениеРеквизитовДереваДанныхСлужебная(ПроверяемаяСтрока, Ошибки, Ложь,,
					РеквизитЗаполненИлиОбязателен И ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС);
			Иначе
				ТекстОшибки = ТекстОшибкиНеЗаполненногоЗначенияДерева();
				
				ДобавитьОшибкуПроверкиДереваДанных(Ошибки, СтрокаДерева, ТекстОшибки);
			КонецЕсли;
		ИначеЕсли СтрокаДерева.Признак = "Группа" И СтрокаДерева.Значение = Истина И СтрокаДерева.Строки.Количество() > 0 Тогда
			ПроверитьЗаполнениеРеквизитовДереваДанныхСлужебная(СтрокаДерева, Ошибки, Ложь,,
				РеквизитЗаполненИлиОбязателен И ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС);
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ПроверитьЗаполнениеРеквизитаДереваДанных(СтрокаДерева, ПроверятьОбязательностьПараметровОшибки, ДатаПоФорматуФНС, ТекстОшибки)
	
	// Не проверяем, заполнены ли параметры обработки ошибок только если реквизит необязателен и не заполнен:
	// такая ситуация может возникнуть для условно-обязательных реквизитов. Для них параметры обработки ошибки могли быть
	// заданы только при заполнении реквизита. А поскольку заполнения не было, то и параметры не были указаны.
	РеквизитЗаполненИлиОбязателен = ЗначениеЗаполнено(СтрокаДерева.Значение) ИЛИ НРег(СтрокаДерева.Обязательное) = "да";
	Если ПроверятьОбязательностьПараметровОшибки И РеквизитЗаполненИлиОбязателен Тогда
		ПроверитьЗаполненностьПараметровОбработкиОшибок(СтрокаДерева);
	КонецЕсли;
	
	// Проверим строку на заполненность, если реквизит обязательный.
	Если СтрокаДерева.Обязательное = "Да" И Не ЗначениеЗаполнено(СтрокаДерева.Значение) Тогда
		
		ТекстОшибки = ТекстОшибкиНеЗаполненногоЗначенияДерева();
		
		// Проверим строку на соответствие типу
	ИначеЕсли ЗначениеЗаполнено(СтрокаДерева.Значение) И СтрокаДерева.ТипЗначения <> Неопределено
		И Не ЗначениеВСтрокеДереваСоответствуетТипу(СтрокаДерева, ДатаПоФорматуФНС) Тогда
		
		ШаблонОшибки = НСтр("ru = 'неверный тип значения ""%1"" (ожидаемый тип: %2)'");
		ПредставлениеТипаЗначения = ПолучитьПредставлениеТипаПоСтрокеДерева(СтрокаДерева, ДатаПоФорматуФНС);
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ШаблонОшибки, СтрокаДерева.Значение,
		ПредставлениеТипаЗначения);
		
	КонецЕсли;
	
КонецПроцедуры

Функция ЗначениеВСтрокеДереваСоответствуетТипу(СтрокаДерева, ДатаПоФорматуФНС = Ложь)

	Результат = СтрокаДерева.ТипЗначения.ПривестиЗначение(СтрокаДерева.Значение) = СтрокаДерева.Значение;
	
	// Выполним дополнительную проверку для форматов ФНС.
	Если Результат И ДатаПоФорматуФНС И ТипЗнч(СтрокаДерева.Значение) = Тип("Дата") Тогда
		Если СтрокаДерева.Значение < Дата(1900, 1, 1) ИЛИ СтрокаДерева.Значение >= Дата(2100, 1, 1) Тогда
			Результат = Ложь;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

Процедура ДобавитьСлужебныеКолонкиВТаблицуДереваДокумента(ТаблицаДерева)

	Колонки = Новый Массив;
	
	Колонки.Добавить("ТипЗначения");
	Колонки.Добавить("Значение");
	Колонки.Добавить("ПолныйПуть");
	Колонки.Добавить("ТекстОшибки");
	Колонки.Добавить("ПутьКДаннымСообщения");
	Колонки.Добавить("КлючСообщения");
	Колонки.Добавить("НавигационнаяСсылка");
	Колонки.Добавить("ИмяФормы");
	Колонки.Добавить("ПараметрыФормы");
	
	Для Каждого Колонка Из Колонки Цикл
		Если ТаблицаДерева.Колонки.Найти(Колонка) = Неопределено Тогда
			ТаблицаДерева.Колонки.Добавить(Колонка);
		КонецЕсли;
	КонецЦикла;
	
	// Сдвинем колонки "Значение" и "ПолныйПуть" в начало для удобства отладки.
	КолонкаЗначение = ТаблицаДерева.Колонки.Найти("Значение");
	ТаблицаДерева.Колонки.Сдвинуть("Значение", -ТаблицаДерева.Колонки.Индекс(КолонкаЗначение));
	КолонкаПолныйПуть = ТаблицаДерева.Колонки.Найти("ПолныйПуть");
	ТаблицаДерева.Колонки.Сдвинуть("ПолныйПуть", -ТаблицаДерева.Колонки.Индекс(КолонкаПолныйПуть));

КонецПроцедуры

Процедура РекурсивноЗаполнитьСтрокиДерева(ДеревоЗначений, Знач НомерУровня, КолУровней, Знач ПолныйПутьВДереве, ТЗ, НомерСтрокиТЗ)
	
	ЛокальныйПуть = ПолныйПутьВДереве;
	СтрокаТекУровня = Неопределено;
	Пока НомерСтрокиТЗ < ТЗ.Количество() Цикл
		СтрокаТЗ = ТЗ[НомерСтрокиТЗ];
		Для Сч = НомерУровня По КолУровней Цикл
			ИдТекУровня = "Уровень" + Сч;
			Если ТЗ.Колонки.Найти(ИдТекУровня) <> Неопределено И ЗначениеЗаполнено(СтрокаТЗ[ИдТекУровня]) Тогда
				Если НомерУровня < Сч Тогда
					РекурсивноЗаполнитьСтрокиДерева(СтрокаТекУровня, Сч, КолУровней, ЛокальныйПуть, ТЗ, НомерСтрокиТЗ);
				ИначеЕсли НомерУровня = Сч Тогда
					СтрокаТекУровня = ДеревоЗначений.Строки.Добавить();
					ЗаполнитьЗначенияСвойств(СтрокаТекУровня, СтрокаТЗ);
					СтрокаТекУровня.ТипЗначения = ЭлектронноеВзаимодействиеСлужебныйПовтИсп.ОписаниеТипаПоПараметрам(СтрокаТЗ.Типы, СтрокаТЗ.КвалификаторыЧисла, СтрокаТЗ.КвалификаторыСтроки, СтрокаТЗ.КвалификаторыДаты);
					ЛокальныйПуть = ?(ПолныйПутьВДереве = "", "", ПолныйПутьВДереве + ".") + СтрокаТекУровня["Уровень" + Сч];
					СтрокаТекУровня.ПолныйПуть = ЛокальныйПуть;
				КонецЕсли;
				НомерСтрокиТЗ = НомерСтрокиТЗ + 1;
				Прервать;
			КонецЕсли;
			Если Сч >= КолУровней Тогда
				НомерСтрокиТЗ = НомерСтрокиТЗ - 1;
				Возврат;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьСтрокиТипаВТаблицуДереваДокумента(ТаблицаМакета, СтрокаТаблицы, Макет)
	
	ИмяОбластиТипа = СтрокаТаблицы.Признак;
	
	Если Не ЗначениеЗаполнено(ИмяОбластиТипа) Тогда
		Возврат;
	КонецЕсли;
	Если Макет.Области.Найти(ИмяОбластиТипа) = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	МакетТипа = Макет.ПолучитьОбласть(ИмяОбластиТипа);
	
	ТаблицаТипа = ТаблицаМакета.СкопироватьКолонки();
	
	ВысотаТаблицы = МакетТипа.ВысотаТаблицы;
	ШиринаТаблицы = МакетТипа.ШиринаТаблицы;
	
	Для НомерСтроки = 1 По ВысотаТаблицы Цикл
		НоваяСтрока = ТаблицаТипа.Добавить();
		Для НомерКолонки = 1 По ШиринаТаблицы Цикл
			НоваяСтрока.Установить(НомерКолонки - 1, МакетТипа.Область(НомерСтроки, НомерКолонки).Текст);
		КонецЦикла;
		ДобавитьСтрокиТипаВТаблицуДереваДокумента(ТаблицаТипа, НоваяСтрока, Макет);
	КонецЦикла;
	
	СдвигУровня = 0;
	СчетчикУровня = 1;
	Пока Истина Цикл
		ИмяКолонки = "Уровень" + Формат(СчетчикУровня, "ЧГ=0");
		Если ТаблицаМакета.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
			Прервать;
		КонецЕсли;
		ЗначениеКолонки = СтрокаТаблицы[ИмяКолонки];
		Если ЗначениеЗаполнено(ЗначениеКолонки) Тогда
			СдвигУровня = СчетчикУровня - 1;
			Прервать;
		КонецЕсли;
		СчетчикУровня = СчетчикУровня + 1;
	КонецЦикла;
	
	// Из первой строки берем только признак.
	СтрокаТаблицы.Признак = ТаблицаТипа[0].Признак;
	
	Для НомерСтроки = 2 По ТаблицаТипа.Количество() Цикл
		
		СтрокаТаблицыТипа = ТаблицаТипа[НомерСтроки - 1];
		СтрокаТаблицыМакета = ТаблицаМакета.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыМакета, СтрокаТаблицыТипа);
		
		Если ЗначениеЗаполнено(СтрокаТаблицы.КодПредставления)
			И ЗначениеЗаполнено(СтрокаТаблицыТипа.КодПредставления) Тогда
			СтрокаТаблицыМакета.КодПредставления = СтрШаблон("%1_%2", СтрокаТаблицы.КодПредставления, СтрокаТаблицыТипа.КодПредставления);
		КонецЕсли;
		
		// Вычислим текущий уровень.
		ТекущийУровень = 0;
		СчетчикУровня = 1;
		Пока Истина Цикл
			ИмяКолонки = "Уровень" + Формат(СчетчикУровня, "ЧГ=0");
			Если ТаблицаМакета.Колонки.Найти(ИмяКолонки) = Неопределено Тогда
				Прервать;
			КонецЕсли;
			ЗначениеКолонки = СтрокаТаблицыМакета[ИмяКолонки];
			Если ЗначениеЗаполнено(ЗначениеКолонки) Тогда
				ТекущийУровень = СчетчикУровня;
				Прервать;
			КонецЕсли;
			СчетчикУровня = СчетчикУровня + 1;
		КонецЦикла;
		// Сдвинем уровень.
		Если ЗначениеЗаполнено(СдвигУровня) Тогда
			НовыйУровень = ТекущийУровень + СдвигУровня;
			ИмяКолонкиТекущий = "Уровень" + Формат(ТекущийУровень, "ЧГ=0");
			ИмяКолонкиНовый = "Уровень" + Формат(НовыйУровень, "ЧГ=0");
			Если ТаблицаМакета.Колонки.Найти(ИмяКолонкиНовый) = Неопределено Тогда
				ТаблицаМакета.Колонки.Добавить(ИмяКолонкиНовый);
			КонецЕсли;
			СтрокаТаблицыМакета[ИмяКолонкиНовый] = СтрокаТаблицыМакета[ИмяКолонкиТекущий];
			СтрокаТаблицыМакета[ИмяКолонкиТекущий] = "";
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

Функция СкачатьФайл(Знач URL, Знач ПараметрыПолучения, Знач НастройкаСохранения, Знач ПараметрыЖурналирования)
	
	НастройкиПолучения = ПараметрыПолученияФайла();
	Если ПараметрыПолучения <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(НастройкиПолучения, ПараметрыПолучения);
	КонецЕсли;
	
	Если НастройкаСохранения.Получить("МестоХранения") <> "ВременноеХранилище" Тогда
		НастройкаСохранения.Вставить("Путь", НастройкиПолучения.ПутьДляСохранения);
	КонецЕсли;
	
	НастройкаПроксиСервера = ПолучениеФайловИзИнтернета.НастройкиПроксиНаСервере();
	
	Перенаправления = Новый Массив;
	
	Возврат ПолучитьФайлИзИнтернет(URL, НастройкаСохранения, НастройкиПолучения,
		НастройкаПроксиСервера, Перенаправления, ПараметрыЖурналирования);
	
КонецФункции

Функция ПолучитьФайлИзИнтернет(Знач URL, Знач НастройкаСохранения, Знач НастройкаСоединения, Знач НастройкиПрокси, Перенаправления, ПараметрыЖурналирования)
	
	СтруктураURI = ОбщегоНазначенияКлиентСервер.СтруктураURI(URL);
	
	Сервер        = СтруктураURI.Хост;
	ПутьНаСервере = СтруктураURI.ПутьНаСервере;
	Протокол      = СтруктураURI.Схема;
	
	Если ПустаяСтрока(Протокол) Тогда 
		Протокол = "http";
	КонецЕсли;
	
	ЗащищенноеСоединение = НастройкаСоединения.ЗащищенноеСоединение;
	ИмяПользователя      = НастройкаСоединения.Пользователь;
	ПарольПользователя   = НастройкаСоединения.Пароль;
	Порт                 = НастройкаСоединения.Порт;
	Таймаут              = НастройкаСоединения.Таймаут;
	
	Если (Протокол = "https" Или Протокол = "ftps") И ЗащищенноеСоединение = Неопределено Тогда
		ЗащищенноеСоединение = Истина;
	КонецЕсли;
	
	Если ЗащищенноеСоединение = Истина Тогда
		ЗащищенноеСоединение = ОбщегоНазначенияКлиентСервер.НовоеЗащищенноеСоединение();
	ИначеЕсли ЗащищенноеСоединение = Ложь Тогда
		ЗащищенноеСоединение = Неопределено;
		// Иначе параметр ЗащищенноеСоединение был задан в явном виде.
	КонецЕсли;
	
	Если Порт = Неопределено Тогда
		Порт = СтруктураURI.Порт;
	КонецЕсли;
	
	Если НастройкиПрокси = Неопределено Тогда 
		Прокси = Неопределено;
	Иначе 
		Прокси = НовыйИнтернетПрокси(НастройкиПрокси, Протокол);
	КонецЕсли;
	
	Если НастройкаСохранения["Путь"] <> Неопределено Тогда
		ПутьДляСохранения = НастройкаСохранения["Путь"];
	Иначе
		// Временный файл должен удаляться вызывающим кодом.
		ПутьДляСохранения = ПолучитьИмяВременногоФайла();
	КонецЕсли;
	
	Если Таймаут = Неопределено Тогда 
		Таймаут = АвтоматическоеОпределениеТаймаута();
	КонецЕсли;
	
	ИспользуетсяFTPПротокол = (Протокол = "ftp" Или Протокол = "ftps");
	
	Заголовки                    = НастройкаСоединения.Заголовки;
	ИспользоватьАутентификациюОС = НастройкаСоединения.ИспользоватьАутентификациюОС;
	
	Попытка
		
		Если Таймаут = АвтоматическоеОпределениеТаймаута() Тогда
			
			Соединение = Новый HTTPСоединение(
				Сервер, 
				Порт, 
				ИмяПользователя, 
				ПарольПользователя,
				Прокси, 
				7, 
				ЗащищенноеСоединение, 
				ИспользоватьАутентификациюОС);
			
			РазмерФайла = РазмерФайлаHTTP(Соединение, ПутьНаСервере, Заголовки);
			Таймаут = ТаймаутПоРазмеруФайла(РазмерФайла);
			
		КонецЕсли;
		
		Соединение = Новый HTTPСоединение(
			Сервер, 
			Порт, 
			ИмяПользователя, 
			ПарольПользователя,
			Прокси, 
			Таймаут, 
			ЗащищенноеСоединение, 
			ИспользоватьАутентификациюОС);
		
		Сервер = Соединение.Сервер;
		Порт   = Соединение.Порт;
		
		ЗапросHTTP = Новый HTTPЗапрос(ПутьНаСервере, Заголовки);
		ЗапросHTTP.Заголовки.Вставить("Accept-Charset", "UTF-8");
		ЗапросHTTP.Заголовки.Вставить("X-1C-Request-UID", Строка(Новый УникальныйИдентификатор));
		Если ПараметрыЖурналирования <> Неопределено Тогда
			ПараметрыЖурналирования.ОбщийМодуль.ПриОтправкеДанныхHTTP(
				"GET", URL, Соединение, ЗапросHTTP, ПараметрыЖурналирования);
		КонецЕсли;
		ОтветHTTP = Соединение.Получить(ЗапросHTTP, ПутьДляСохранения);
		
		Если ПараметрыЖурналирования <> Неопределено Тогда
			ПараметрыЖурналирования.ОбщийМодуль.ПриПолученииДанныхHTTP(ОтветHTTP, ПутьДляСохранения, ПараметрыЖурналирования);
		КонецЕсли;
		
	Исключение
		
		РезультатДиагностики = ПолучениеФайловИзИнтернета.ДиагностикаСоединения(URL);
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось установить HTTP-соединение с сервером %1:%2
			           |по причине:
			           |%3
			           |
			           |Результат диагностики:
			           |%4'"),
			Сервер, Формат(Порт, "ЧГ="),
			КраткоеПредставлениеОшибки(ИнформацияОбОшибке()),
			РезультатДиагностики.ОписаниеОшибки);
		
		ДописатьПредставлениеПеренаправлений(Перенаправления, ТекстОшибки);
		
		Возврат РезультатПолученияФайла(Ложь, ТекстОшибки);
		
	КонецПопытки;
	
	Попытка
		
		Если ОтветHTTP.КодСостояния = 301 // 301 Moved Permanently
			Или ОтветHTTP.КодСостояния = 302 // 302 Found, 302 Moved Temporarily
			Или ОтветHTTP.КодСостояния = 303 // 303 See Other by GET
			Или ОтветHTTP.КодСостояния = 307 // 307 Temporary Redirect
			Или ОтветHTTP.КодСостояния = 308 Тогда // 308 Permanent Redirect
			
			Если Перенаправления.Количество() > 7 Тогда
				ВызватьИсключение 
					НСтр("ru = 'Превышено количество перенаправлений.'");
			Иначе 
				
				НовыйURL = ОтветHTTP.Заголовки["Location"];
				
				Если НовыйURL = Неопределено Тогда 
					ВызватьИсключение 
						НСтр("ru = 'Некорректное перенаправление, отсутствует HTTP-заголовок ответа ""Location"".'");
				КонецЕсли;
				
				НовыйURL = СокрЛП(НовыйURL);
				
				Если ПустаяСтрока(НовыйURL) Тогда
					ВызватьИсключение 
						НСтр("ru = 'Некорректное перенаправление, пустой HTTP-заголовок ответа ""Location"".'");
				КонецЕсли;
				
				Если Перенаправления.Найти(НовыйURL) <> Неопределено Тогда
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Циклическое перенаправление.
						           |Попытка перейти на %1 уже выполнялась ранее.'"),
						НовыйURL);
				КонецЕсли;
				
				Перенаправления.Добавить(URL);
				
				Если Не СтрНачинаетсяС(НовыйURL, "http") Тогда
					// <схема>://<хост>:<порт>/<путь>
					НовыйURL = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						"%1://%2:%3/%4", Протокол, Сервер, Формат(Порт, "ЧГ="), НовыйURL);
				КонецЕсли;
				
				Возврат ПолучитьФайлИзИнтернет(НовыйURL, НастройкаСохранения, НастройкаСоединения,
					НастройкиПрокси, Перенаправления, ПараметрыЖурналирования);
				
			КонецЕсли;
			
		КонецЕсли;
		
		Если ОтветHTTP.КодСостояния < 200 Или ОтветHTTP.КодСостояния >= 300 Тогда
			
			Если ОтветHTTP.КодСостояния = 304 Тогда
				
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Сервер убежден, что с вашего последнего запроса его ответ не изменился:
					           |%1'"),
					РасшифровкаКодаСостоянияHTTP(ОтветHTTP.КодСостояния));
				
				ДописатьТелоОтветаСервера(ПутьДляСохранения, ТекстОшибки);
				
				ВызватьИсключение ТекстОшибки;
				
			ИначеЕсли ОтветHTTP.КодСостояния < 200
				Или ОтветHTTP.КодСостояния >= 300 И ОтветHTTP.КодСостояния < 400 Тогда
				
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Неподдерживаемый ответ сервера:
					           |%1'"),
					РасшифровкаКодаСостоянияHTTP(ОтветHTTP.КодСостояния));
				
				ДописатьТелоОтветаСервера(ПутьДляСохранения, ТекстОшибки);
				
				ВызватьИсключение ТекстОшибки;
				
			ИначеЕсли ОтветHTTP.КодСостояния >= 400 И ОтветHTTP.КодСостояния < 500 Тогда 
				
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Ошибка при выполнении запроса:
					           |%1'"),
					РасшифровкаКодаСостоянияHTTP(ОтветHTTP.КодСостояния));
				
				ДописатьТелоОтветаСервера(ПутьДляСохранения, ТекстОшибки);
				
				ВызватьИсключение ТекстОшибки;
				
			Иначе 
				
				ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Ошибка сервера при обработке запроса к ресурсу:
					           |%1'"),
					РасшифровкаКодаСостоянияHTTP(ОтветHTTP.КодСостояния));
				
				ДописатьТелоОтветаСервера(ПутьДляСохранения, ТекстОшибки);
				
				ВызватьИсключение ТекстОшибки;
				
			КонецЕсли;
			
		КонецЕсли;
		
	Исключение
		
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось получить файл %1 с сервера %2:%3
			           |по причине:
			           |%4'"),
			URL, Сервер, Формат(Порт, "ЧГ="),
			КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
		
		ДописатьПредставлениеПеренаправлений(Перенаправления, ТекстОшибки);
		
		СообщениеОбОшибке = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1
			           |
			           |Трассировка:
			           |ЗащищенноеСоединение: %2
			           |Таймаут: %3
			           |ИспользоватьАутентификациюОС: %4'"),
			ТекстОшибки,
			Формат(Соединение.Защищенное, "БЛ=Нет; БИ=Да"),
			Формат(Соединение.Таймаут, "ЧГ=0"),
			Формат(Соединение.ИспользоватьАутентификациюОС, "БЛ=Нет; БИ=Да"));
		
		ДописатьЗаголовкиHTTP(ЗапросHTTP, СообщениеОбОшибке);
		ДописатьЗаголовкиHTTP(ОтветHTTP, СообщениеОбОшибке);
		
		ВидОперации = НСтр("ru = 'Получение файла через интернет'");
		ЭлектронноеВзаимодействие.ОбработатьОшибку(ВидОперации, СообщениеОбОшибке, , "ЭлектронноеВзаимодействие");
		
		Возврат РезультатПолученияФайла(Ложь, ТекстОшибки, ОтветHTTP);
		
	КонецПопытки;
	
	// Если сохраняем файл в соответствии с настройкой.
	Если НастройкаСохранения["МестоХранения"] = "ВременноеХранилище" Тогда
		КлючУникальности = Новый УникальныйИдентификатор;
		Адрес = ПоместитьВоВременноеХранилище (Новый ДвоичныеДанные(ПутьДляСохранения), КлючУникальности);
		Возврат РезультатПолученияФайла(Истина, Адрес, ОтветHTTP);
	ИначеЕсли НастройкаСохранения["МестоХранения"] = "Клиент"
		Или НастройкаСохранения["МестоХранения"] = "Сервер" Тогда
		Возврат РезультатПолученияФайла(Истина, ПутьДляСохранения, ОтветHTTP);
	Иначе
		ВызватьИсключение НСтр("ru = 'Не указано место для сохранения файла.'");
	КонецЕсли;
	
КонецФункции

Процедура ДописатьТелоОтветаСервера(ПутьКФайлу, ТекстОшибки)
	
	ТелоОтветаСервера = ТекстИзHTMLИзФайла(ПутьКФайлу);
	
	Если Не ПустаяСтрока(ТелоОтветаСервера) Тогда 
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1
			           |
			           |Сообщение, полученное от сервера:
			           |%2'"),
			ТекстОшибки,
			ТелоОтветаСервера);
	КонецЕсли;
	
КонецПроцедуры

Функция ТекстИзHTMLИзФайла(ПутьКФайлу)
	
	ФайлОтвета = Новый ЧтениеТекста(ПутьКФайлу, КодировкаТекста.UTF8);
	ИсходныйТекст = ФайлОтвета.Прочитать(1024 * 15);
	ТекстОшибки = СтроковыеФункцииКлиентСервер.ИзвлечьТекстИзHTML(ИсходныйТекст);
	ФайлОтвета.Закрыть();
	
	Возврат ТекстОшибки;
	
КонецФункции

// Функция, заполняющая структуру по параметрам.
//
// Параметры:
// УспехОперации - булево - успех или неуспех операции.
// СообщениеПуть - строка - 
//
// Возвращаемое значение - структура:
//          поле успех - булево
//          поле путь  - строка.
//
Функция РезультатПолученияФайла(Знач Статус, Знач СообщениеПуть, HTTPОтвет = Неопределено)
	
	Результат = Новый Структура("Статус", Статус);
	
	Если Статус Тогда
		Результат.Вставить("Путь", СообщениеПуть);
	Иначе
		Результат.Вставить("СообщениеОбОшибке", СообщениеПуть);
		Результат.Вставить("КодСостояния", 1);
	КонецЕсли;
	
	Если HTTPОтвет <> Неопределено Тогда
		ЗаголовкиОтвета = HTTPОтвет.Заголовки;
		Если ЗаголовкиОтвета <> Неопределено Тогда
			Результат.Вставить("Заголовки", ЗаголовкиОтвета);
		КонецЕсли;
		
		Результат.Вставить("КодСостояния", HTTPОтвет.КодСостояния);
		
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

Процедура ДописатьПредставлениеПеренаправлений(Перенаправления, ТекстОшибки)
	
	Если Перенаправления.Количество() > 0 Тогда 
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1
			           |
			           |Выполненные перенаправления (%2):
			           |%3'"),
			ТекстОшибки,
			Перенаправления.Количество(),
			СтрСоединить(Перенаправления, Символы.ПС));
	КонецЕсли;
	
КонецПроцедуры

Функция ТаймаутПоРазмеруФайла(Размер)
	
	БайтВМегабайте = 1048576;
	
	Если Размер > БайтВМегабайте Тогда
		КоличествоСекунд = Окр(Размер / БайтВМегабайте * 128);
		Возврат ?(КоличествоСекунд > 43200, 43200, КоличествоСекунд);
	КонецЕсли;
	
	Возврат 128;
	
КонецФункции

// Возвращает прокси по настройкам НастройкаПроксиСервера для заданного протокола Протокол.
//
// Параметры:
//   НастройкаПроксиСервера - Соответствие:
//		ИспользоватьПрокси - использовать ли прокси-сервер.
//		НеИспользоватьПроксиДляЛокальныхАдресов - использовать ли прокси-сервер для локальных адресов.
//		ИспользоватьСистемныеНастройки - использовать ли системные настройки прокси-сервера.
//		Сервер       - адрес прокси-сервера.
//		Порт         - порт прокси-сервера.
//		Пользователь - имя пользователя для авторизации на прокси-сервере.
//		Пароль       - пароль пользователя.
//		ИспользоватьАутентификациюОС - Булево - признак использования аутентификации средствами операционной системы.
//   Протокол - строка - протокол для которого устанавливаются параметры прокси сервера, например "http", "https",
//                       "ftp".
// 
// Возвращаемое значение:
//   ИнтернетПрокси
// 
Функция НовыйИнтернетПрокси(НастройкаПроксиСервера, Протокол)
	
	Если НастройкаПроксиСервера = Неопределено Тогда
		// Системные установки прокси-сервера.
		Возврат Неопределено;
	КонецЕсли;
	
	ИспользоватьПрокси = НастройкаПроксиСервера.Получить("ИспользоватьПрокси");
	Если Не ИспользоватьПрокси Тогда
		// Не использовать прокси-сервер.
		Возврат Новый ИнтернетПрокси(Ложь);
	КонецЕсли;
	
	ИспользоватьСистемныеНастройки = НастройкаПроксиСервера.Получить("ИспользоватьСистемныеНастройки");
	Если ИспользоватьСистемныеНастройки Тогда
		// Системные настройки прокси-сервера.
		Возврат Новый ИнтернетПрокси(Истина);
	КонецЕсли;
	
	// Настройки прокси-сервера, заданные вручную.
	Прокси = Новый ИнтернетПрокси;
	
	// Определение адреса и порта прокси-сервера.
	ДополнительныеНастройки = НастройкаПроксиСервера.Получить("ДополнительныеНастройкиПрокси");
	ПроксиПоПротоколу = Неопределено;
	Если ТипЗнч(ДополнительныеНастройки) = Тип("Соответствие") Тогда
		ПроксиПоПротоколу = ДополнительныеНастройки.Получить(Протокол);
	КонецЕсли;
	
	ИспользоватьАутентификациюОС = НастройкаПроксиСервера.Получить("ИспользоватьАутентификациюОС");
	ИспользоватьАутентификациюОС = ?(ИспользоватьАутентификациюОС = Истина, Истина, Ложь);
	
	Если ТипЗнч(ПроксиПоПротоколу) = Тип("Структура") Тогда
		Прокси.Установить(Протокол, ПроксиПоПротоколу.Адрес, ПроксиПоПротоколу.Порт,
			НастройкаПроксиСервера["Пользователь"], НастройкаПроксиСервера["Пароль"], ИспользоватьАутентификациюОС);
	Иначе
		Прокси.Установить(Протокол, НастройкаПроксиСервера["Сервер"], НастройкаПроксиСервера["Порт"], 
			НастройкаПроксиСервера["Пользователь"], НастройкаПроксиСервера["Пароль"], ИспользоватьАутентификациюОС);
	КонецЕсли;
	
	Прокси.НеИспользоватьПроксиДляЛокальныхАдресов = НастройкаПроксиСервера["НеИспользоватьПроксиДляЛокальныхАдресов"];
	
	АдресаИсключений = НастройкаПроксиСервера.Получить("НеИспользоватьПроксиДляАдресов");
	Если ТипЗнч(АдресаИсключений) = Тип("Массив") Тогда
		Для каждого АдресИсключения Из АдресаИсключений Цикл
			Прокси.НеИспользоватьПроксиДляАдресов.Добавить(АдресИсключения);
		КонецЦикла;
	КонецЕсли;
	
	Возврат Прокси;
	
КонецФункции

Функция АвтоматическоеОпределениеТаймаута()
	
	Возврат -1;
	
КонецФункции

Процедура ДописатьЗаголовкиHTTP(Объект, ТекстОшибки)
	
	Если ТипЗнч(Объект) = Тип("HTTPЗапрос") Тогда 
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1
			           |
			           |HTTP запрос:
			           |Адрес ресурса: %2
			           |Заголовки: %3'"),
			ТекстОшибки,
			Объект.АдресРесурса,
			ПредставлениеЗаголовковHTTP(Объект.Заголовки));
	ИначеЕсли ТипЗнч(Объект) = Тип("HTTPОтвет") Тогда
		ТекстОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1
			           |
			           |HTTP ответ:
			           |Код ответа: %2
			           |Заголовки: %3'"),
			ТекстОшибки,
			Объект.КодСостояния,
			ПредставлениеЗаголовковHTTP(Объект.Заголовки));
	КонецЕсли;
	
КонецПроцедуры

Функция ПредставлениеЗаголовковHTTP(Заголовки)
	
	ПредставлениеЗаголовков = "";
	
	Для каждого Заголовок Из Заголовки Цикл 
		ПредставлениеЗаголовков = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = '%1
			           |%2: %3'"), 
			ПредставлениеЗаголовков,
			Заголовок.Ключ, Заголовок.Значение);
	КонецЦикла;
		
	Возврат ПредставлениеЗаголовков;
	
КонецФункции

Функция ПараметрыПолученияФайла()
	
	ПараметрыПолучения = Новый Структура;
	ПараметрыПолучения.Вставить("ПутьДляСохранения", Неопределено);
	ПараметрыПолучения.Вставить("Пользователь", Неопределено);
	ПараметрыПолучения.Вставить("Пароль", Неопределено);
	ПараметрыПолучения.Вставить("Порт", Неопределено);
	ПараметрыПолучения.Вставить("Таймаут", АвтоматическоеОпределениеТаймаута());
	ПараметрыПолучения.Вставить("ЗащищенноеСоединение", Неопределено);
	ПараметрыПолучения.Вставить("ПассивноеСоединение", Неопределено);
	ПараметрыПолучения.Вставить("Заголовки", Новый Соответствие);
	ПараметрыПолучения.Вставить("ИспользоватьАутентификациюОС", Ложь);
	ПараметрыПолучения.Вставить("УровеньИспользованияЗащищенногоСоединения", Неопределено);
	
	Возврат ПараметрыПолучения;
	
КонецФункции

Функция РазмерФайлаHTTP(СоединениеHTTP, Знач ПутьНаСервере, Знач Заголовки = Неопределено)
	
	ЗапросHTTP = Новый HTTPЗапрос(ПутьНаСервере, Заголовки);
	Попытка
		ПолученныеЗаголовки = СоединениеHTTP.ПолучитьЗаголовки(ЗапросHTTP);// HEAD
	Исключение
		Возврат 0;
	КонецПопытки;
	РазмерСтрокой = ПолученныеЗаголовки.Заголовки["Content-Length"];
	
	ТипЧисло = Новый ОписаниеТипов("Число");
	РазмерФайла = ТипЧисло.ПривестиЗначение(РазмерСтрокой);
	
	Возврат РазмерФайла;
	
КонецФункции

Процедура ИнициализацияСообщенийОшибок(СообщенияОшибок)
	
	// Общие коды ошибок
	СообщенияОшибок.Вставить("001", );
	СообщенияОшибок.Вставить("002", );
	СообщенияОшибок.Вставить("003", );
	СообщенияОшибок.Вставить("004", );
	СообщенияОшибок.Вставить("005", );
	СообщенияОшибок.Вставить("006", НСтр("ru = 'Невозможно извлечь файлы из архива. Путь к файлам архива должен быть короче 256 символов.
										|Возможные способы устранения ошибки:
										| - в настройках операционной системы, в переменных среды, изменить путь к временным файлам;'"));
	СообщенияОшибок.Вставить("007", НСтр("ru = 'Невозможно записать файл. Путь к файлу должен быть короче 256 символов.
										|Возможные способы устранения ошибки:
										| - в настройках операционной системы, в переменных среды, изменить путь к временным файлам;'"));
	// Коды ошибок 1С
	СообщенияОшибок.Вставить("0", НСтр("ru = 'Одна из имеющихся в запросе подписей принадлежит неизвестному лицу.'"));
	СообщенияОшибок.Вставить("2", НСтр("ru = 'Одна из подписей неверна'"));
	СообщенияОшибок.Вставить("3", НСтр("ru = 'Должны быть представлены две разные подписи.'"));
	СообщенияОшибок.Вставить("4", НСтр("ru = 'Неверный тип содержимого: двоичный.'"));
	СообщенияОшибок.Вставить("5", НСтр("ru = 'Должна быть предоставлена хотя бы одна подпись.'"));
	СообщенияОшибок.Вставить("6", НСтр("ru = 'Не все подписи отличаются.'"));
	СообщенияОшибок.Вставить("7", НСтр("ru = 'Все подписи не обеспечивают уровень полномочий, необходимых для операции.'"));
	СообщенияОшибок.Вставить("8", НСтр("ru = 'Один из подписантов неизвестен.'"));
	СообщенияОшибок.Вставить("9", НСтр("ru = 'Содержимое типа транспортного сообщения является неправильным, ожидается: application/xml.'"));
	СообщенияОшибок.Вставить("10", НСтр("ru = 'Содержимое типа делового сообщения неверно, ожидается: application/xml.'"));
	СообщенияОшибок.Вставить("11", НСтр("ru = 'Не все подписи соответствуют одному и тому же клиенту.'"));
	СообщенияОшибок.Вставить("12", НСтр("ru = 'Всех имеющихся в запросе подписей недостаточно для того, чтобы получить право на доступ к запрашиваемому счету.'"));
	СообщенияОшибок.Вставить("13", НСтр("ru = 'HTTP запрос URL неверный. Поддерживаются только запросы ресурсов и состояния.'"));
	СообщенияОшибок.Вставить("14", НСтр("ru = 'Ошибка проверки транспортного контейнера.'"));
	СообщенияОшибок.Вставить("15", НСтр("ru = 'Ошибка проверки контейнера бизнес данных.
	                                          |Необходимо обратиться в тех.поддержку банка'"));
	СообщенияОшибок.Вставить("16", НСтр("ru = 'В выписке счета слишком малая начальная дата.'"));
	СообщенияОшибок.Вставить("17", НСтр("ru = 'В выписке счета слишком большая конечная дата.'"));
	СообщенияОшибок.Вставить("18", НСтр("ru = 'Неверная дата документа.'"));
	СообщенияОшибок.Вставить("19", НСтр("ru = 'Счет банка не соответствует БИК.'"));
	СообщенияОшибок.Вставить("21", НСтр("ru = 'Неразрешенная инструкция.'"));
	
	СообщенияОшибок.Вставить("100", НСтр("ru = 'Не удалось создать менеджер криптографии на компьютере.'"));
	СообщенияОшибок.Вставить("101", НСтр("ru = 'Сертификат не найден в хранилище сертификатов на компьютере.'"));
	СообщенияОшибок.Вставить("102", НСтр("ru = 'Сертификат не действителен.'"));
	СообщенияОшибок.Вставить("103", НСтр("ru = 'Не удалось выполнить операции шифрования/расшифровки на компьютере.'"));
	СообщенияОшибок.Вставить("104", НСтр("ru = 'Не удалось выполнить операции формирования/проверки ЭП на компьютере.'"));
	СообщенияОшибок.Вставить("105", НСтр("ru = 'Нет доступных сертификатов в хранилище сертификатов на компьютере.'"));
	
	СообщенияОшибок.Вставить("110", НСтр("ru = 'Не удалось создать менеджер криптографии на сервере.'"));
	СообщенияОшибок.Вставить("111", НСтр("ru = 'Сертификат не найден в хранилище сертификатов на сервере.'"));
	СообщенияОшибок.Вставить("112", НСтр("ru = 'Сертификат не действителен.'"));
	СообщенияОшибок.Вставить("113", НСтр("ru = 'Не удалось выполнить операции шифрования/расшифровки на сервере.'"));
	СообщенияОшибок.Вставить("114", НСтр("ru = 'Не удалось выполнить операции формирования/проверки ЭП на сервере.'"));
	СообщенияОшибок.Вставить("115", НСтр("ru = 'Нет доступных сертификатов в хранилище сертификатов на сервере.'"));
	
	СообщенияОшибок.Вставить("106", НСтр("ru = 'Версия платформы 1С ниже ""8.2.17"".'"));
	СообщенияОшибок.Вставить("107", НСтр("ru = 'Не удалось создать каталоги обмена.'"));
	
	СообщенияОшибок.Вставить("121", НСтр("ru = 'Не удалось соединиться с FTP сервером.'"));
	СообщенияОшибок.Вставить("122", НСтр("ru = 'Невозможно создать каталог, так как на FTP ресурсе существует файл с таким именем.'"));
	СообщенияОшибок.Вставить("123", НСтр("ru = 'Невозможно создать каталог.'"));
	СообщенияОшибок.Вставить("124", НСтр("ru = 'Невозможно открыть каталог.'"));
	СообщенияОшибок.Вставить("125", НСтр("ru = 'Произошла ошибка при поиске файлов на FTP ресурсе.'"));
	СообщенияОшибок.Вставить("126", НСтр("ru = 'Различаются данные записанного, а затем прочитанного тестового файла в каталоге.'"));
	СообщенияОшибок.Вставить("127", НСтр("ru = 'Не удалось записать файл в каталог.'"));
	СообщенияОшибок.Вставить("128", НСтр("ru = 'Не удалось прочитать файл в каталоге.'"));
	СообщенияОшибок.Вставить("129", НСтр("ru = 'Не удалось удалить файл.'"));
	
	// Коды ошибок оператора Такском.
	// Метод CertificateLogin: идентификация и авторизация.
	// Синхронный режим без обращения к БД.
	СообщенияОшибок.Вставить("2501", ); // Не указан идентификатор вендора (название параметра?) 400 0501.
	СообщенияОшибок.Вставить("3109", ); // Не указан сертификат 403 3100.
	СообщенияОшибок.Вставить("3107", ); // Некорректное тело сертификата 403 3107.
	СообщенияОшибок.Вставить("3101", ); // Сертификат просрочен 403 3101.
	СообщенияОшибок.Вставить("3102", ); // Для указанного сертификата не удалось построить цепочку доверия 403 3102.
	
	// Синхронный режим с обращением в БД.
	СообщенияОшибок.Вставить("1301", ); // Вендор с указанным идентификатором не прошел авторизацию 401 1300.
	СообщенияОшибок.Вставить("3103", НСтр("ru = 'Сертификат не привязан к ID Такском. Необходимо привязать сертификат в ручную на Админ.Такском.'")); // Сертификат не связан ни с одним абонентом Такском 403 3103
	СообщенияОшибок.Вставить("3104", ); // Сертификат связан с несколькими абонентами, но не указан идентификатор абонента (TaxcomID) 403 3104
	СообщенияОшибок.Вставить("3105", ); // Сертификат связан с несколькими абонентами, но указанный идентификатор абонента (TaxcomID) имеет неправильный формат 403 3105
	СообщенияОшибок.Вставить("3106", ); // Сертификат связан с несколькими абонентами, но указанный идентификатор абонента (TaxcomID) не связан ни с одним абонентом Такском 403 3106
	СообщенияОшибок.Вставить("1102", ); // Абоненту запрещен доступ к API 401 1100.
	СообщенияОшибок.Вставить("1101", ); // Доступ для данного абонента заблокирован 401 1101.
	СообщенияОшибок.Вставить("3108", ); // Сертификат отозван (в будущем) 403 3108.
	
	// Метод SendMessage: загрузка транспортных контейнеров
	// Синхронный режим без обращения к БД.
	СообщенияОшибок.Вставить("1201", ); // Истек 5-ти минутный срок действия токена (требуется повторная авторизация) 401 1200
	СообщенияОшибок.Вставить("2118", ); // Размер отправляемого контейнера не соответствует допустимому диапазону от 0 до (цифра!) 400 0100
	СообщенияОшибок.Вставить("2107", ); // Отправляемый контейнер не является ZIP-архивом 400 0107
	СообщенияОшибок.Вставить("2108", ); // В контейнере отсутствует необходимый файл meta.xml 400 0108
	СообщенияОшибок.Вставить("2109", ); // Файл meta.xml не является XML-файлом (стандарты?) 400 0109
	СообщенияОшибок.Вставить("2111", ); // Структура файла meta.xml не соответствует принятой схеме 400 0111
	СообщенияОшибок.Вставить("2101", ); // В файле meta.xml не указан корректный идентификатор документооборота (DocFlowID) 400 0101
	СообщенияОшибок.Вставить("2102", ); // В отправляемом контейнере обнаружены файлы, связанные более чем с одним документооборотом 400 0102
	СообщенияОшибок.Вставить("2113", ); // В данном документообороте возможна отправка только одного файла 400 0113
	СообщенияОшибок.Вставить("2103", ); // В файле meta.xml отсутствует код регламента (ReglamentCode) 400 0103
	СообщенияОшибок.Вставить("2114", ); // В файле meta.xml указан некорректный код регламента (ReglamentCode) 400 0114
	СообщенияОшибок.Вставить("2104", ); // В файле meta.xml отсутствует код транзакции (TransactionCode) 400 0104
	СообщенияОшибок.Вставить("2303", ); // Транзакция с кодом <TransactionCode> недопустима в документообороте < ReglamentCode > 400 0300
	СообщенияОшибок.Вставить("3108", ); // Файл <имя файла>, указанный в meta.xml, не найден в отправляемом контейнере 400 0105
	СообщенияОшибок.Вставить("0110", ); // Файл card.xml не является XML-файлом 400 0110
	СообщенияОшибок.Вставить("0112", ); // Структура файла card.xml не соответствует принятой схеме 400 0112
	СообщенияОшибок.Вставить("0106", НСтр("ru = 'В соглашении указан идентификатор организации некорректного формата.'")); // Неверный формат идентификатора отправителя (название параметра?) в файле card.xml 400 0106
	СообщенияОшибок.Вставить("0115", ); // Неверный формат идентификатора получателя (название параметра?) в файле card.xml 400 0115
	
	// Синхронный режим с обращением к БД
	СообщенияОшибок.Вставить("0201", ); // Идентификатор отправителя (название параметра?) соответствует учетной записи 400 0201
	СообщенияОшибок.Вставить("0401", ); // Документооборот с указанным идентификатором уже зарегистрирован (DocFlowID) 400 0401
	СообщенияОшибок.Вставить("0402", ); // Документооборот с указанным идентификатором не зарегистрирован (DocFlowID) 400 0402
	СообщенияОшибок.Вставить("0301", ); // Данная транзакция <код транзакции> уже была осуществлена для данного документооборота < DocFlowID > 400 0301
	
	// Асинхронный режим
	СообщенияОшибок.Вставить("0202", НСтр("ru = 'В соглашении указан идентификатор контрагента не зарегистрированный в Такском.'")); // Получатель с указанным идентификатором не зарегистрирован 0202
	СообщенияОшибок.Вставить("0203", ); // Получатель с указанным идентификатором не является контрагентом отправителя 0203
	СообщенияОшибок.Вставить("3200", ); // Документ не может быть отправлен в связи с ограничениями тарификации 3200
	
	// Метод GetMessageList: получение входящих транспортных контейнеров
	// Синхронный режим без обращения к БД.
	СообщенияОшибок.Вставить("0503", ); // Отсутствует обязательный параметр «метка времени (название параметра)» 400 0503
	СообщенияОшибок.Вставить("0504", ); // Некорректный формат метки времени 400 0504
	
	// Метод GetMessage: выгрузка входящих транспортных контейнеров
	// Синхронный режим без обращения к БД.
	СообщенияОшибок.Вставить("0505", ); // Отсутствует обязательный параметр идентификатор контейнера (документооборота) 400 0505
	СообщенияОшибок.Вставить("0502", ); // Неправильный формат идентификатора документооборота 400 0502
	
	// Синхронный режим с обращением к БД
	СообщенияОшибок.Вставить("4100", ); // Сообщение с данным <DocFlowID> идентификатором документооборота не найдено 404 4100
	
	// Общие ошибки сервера Такском
	СообщенияОшибок.Вставить("5101", ); // Внутренняя ошибка сервера 500 0000
	
КонецПроцедуры

#Область ОбработкаСхемыЗапросов

// Объединить пакет запросов.
//
// Параметры:
//  Запрос1 - ПакетЗапросовСхемыЗапроса - пакет запроса являющимся приемником.
//  Запрос2 - ПакетЗапросовСхемыЗапроса - пакет запроса являющимся источником.
//
Процедура ОбъединитьПакетЗапросов(Запрос1, Запрос2)
	
	Если Запрос2.Операторы.Количество() > 1 Тогда
		ВызватьИсключение НСтр("ru = 'Объединение запросов производится только для одного оператора'");
	КонецЕсли;
	
	// Обработка операторов.
	Для каждого Источники2 Из Запрос2.Операторы[0].Источники Цикл
		
		Если Запрос1.Операторы[0].Источники.НайтиПоПсевдониму(Источники2.Источник.Псевдоним) = Неопределено Тогда
			Запрос1.Операторы[0].Источники.Добавить(Источники2.Источник.ИмяТаблицы, Источники2.Источник.Псевдоним);
		КонецЕсли;
		
	КонецЦикла;
	
	// Добавление выбираемых полей.
	Для каждого ВыбираемоеПоле2 Из Запрос2.Операторы[0].ВыбираемыеПоля Цикл
		ИндексКолонки2 = Запрос2.Операторы[0].ВыбираемыеПоля.Индекс(ВыбираемоеПоле2);
		Колонка2 = Запрос2.Колонки.Получить(ИндексКолонки2);
		Колонка1 = Запрос1.Колонки.Найти(Колонка2.Псевдоним);
		Если Колонка1 = Неопределено Тогда
			Запрос1.Операторы[0].ВыбираемыеПоля.Добавить(Строка(ВыбираемоеПоле2));
			// Установка имени колонки.
			Колонка1 = Запрос1.Колонки.Получить(Запрос1.Колонки.Количество()-1);
			Колонка1.Псевдоним = Колонка2.Псевдоним;
		Иначе
			Запрос1.Операторы[0].ВыбираемыеПоля.Добавить(Строка(ВыбираемоеПоле2),
				Запрос1.Колонки.Индекс(Колонка1));
		КонецЕсли;
	КонецЦикла;
	
	Для каждого Источники2 Из Запрос2.Операторы[0].Источники Цикл
		
		Если Источники2.Соединения.Количество() = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		Источник1 = Запрос1.Операторы[0].Источники.НайтиПоПсевдониму(Источники2.Источник.Псевдоним);
		ПсевдонимыИсточника1 = Новый Массив;
		Для каждого Соединение1 Из Источник1.Соединения Цикл
			ПсевдонимыИсточника1.Добавить(Соединение1.Источник.Источник.Псевдоним);
		КонецЦикла;
		
		СписокКорректировкиСоединений = Новый Соответствие;
		Для каждого Соединение2 Из Источники2.Соединения Цикл
			
			Псевдоним2 = Соединение2.Источник.Источник.Псевдоним;
			Если ПсевдонимыИсточника1.Найти(Псевдоним2) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ИсточникСхемы = Запрос1.Операторы[0].Источники.НайтиПоПсевдониму(Псевдоним2);
			Если ИсточникСхемы = Неопределено Тогда
				Источник1.Соединения.Добавить(Соединение2.Источник, Строка(Соединение2.Условие));
			Иначе
				Источник1.Соединения.Добавить(ИсточникСхемы, Строка(Соединение2.Условие));
				ПоследнееСоединение = Источник1.Соединения.Получить(Источник1.Соединения.Количество()-1);
				Если ПоследнееСоединение.ТипСоединения <> Соединение2.ТипСоединения Тогда
					СписокКорректировкиСоединений.Вставить(ПоследнееСоединение, Соединение2.ТипСоединения);
				КонецЕсли;
			КонецЕсли;
			
		КонецЦикла;
		
		Если СписокКорректировкиСоединений.Количество() Тогда
			Для каждого Соединение1 Из СписокКорректировкиСоединений Цикл
				Соединение1.Ключ.ТипСоединения = Соединение1.Значение;
			КонецЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
	// Перебор и подстановка полей запроса.
	Для каждого Колонка2 Из Запрос2.Колонки Цикл
		Колонка1 = Запрос1.Колонки.Найти(Колонка2.Псевдоним);
		Если Колонка1 <> Неопределено Тогда
			Если ПоляСхемыЗапросовИдентичны(Колонка1.Поля, Колонка2.Поля) Тогда
				Продолжить;
			КонецЕсли;
			ИндексКолонки1 = Запрос1.Колонки.Индекс(Колонка1);
			ИндексКолонки2 = Запрос2.Колонки.Индекс(Колонка2);
			Запрос1.Операторы[0].ВыбираемыеПоля.Установить(ИндексКолонки1, Запрос2.Операторы[0].ВыбираемыеПоля.Получить(ИндексКолонки2));
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Добавить запрос в пакет запросов.
//
// Параметры:
//  Схема1 - СхемаЗапроса - пакет запроса являющимся приемником.
//  Запрос2 - ПакетЗапросовСхемыЗапроса - пакет запроса являющимся источником.
//
Процедура ДобавитьЗапросВПакет(Схема1, ЗапросСхемы2)
	
	ЗапросСхемы1 = Схема1.ПакетЗапросов.Добавить(ТипЗнч(ЗапросСхемы2));
	ЗаполнитьЗначенияСвойств(ЗапросСхемы1, ЗапросСхемы2);
	
	Если ТипЗнч(ЗапросСхемы2) = Тип("ЗапросУничтоженияТаблицыСхемыЗапроса") Тогда
		// Для уничтожения таблицы ничего не заполняется.
		Возврат;
	КонецЕсли;
	
	// Кэширование полей в колонках источника.
	ПоляПоКолонкам2 = Новый Соответствие;
	Для каждого ЭлементКоллекцииКолонки2 Из ЗапросСхемы2.Колонки Цикл
		Для каждого ЭлементКоллекцииПоляКолонок2 Из ЭлементКоллекцииКолонки2.Поля Цикл
			ПоляПоКолонкам2.Вставить(ЭлементКоллекцииПоляКолонок2, ЗапросСхемы2.Колонки.Индекс(ЭлементКоллекцииКолонки2));
		КонецЦикла;
	КонецЦикла;
	
	// Добавление операторов запроса.
	Для каждого ОператорЗапросаСхемы2 Из ЗапросСхемы2.Операторы Цикл
		
		// Обход автоматического создания первого оператора запроса.
		Если ЗапросСхемы2.Операторы.Индекс(ОператорЗапросаСхемы2) = 0 Тогда
			ОператорЗапросаСхемы1 = ЗапросСхемы1.Операторы.Получить(0);
		Иначе
			ОператорЗапросаСхемы1 = ЗапросСхемы1.Операторы.Добавить();
		КонецЕсли;
		
		ЗаполнитьЗначенияСвойств(ОператорЗапросаСхемы1, ОператорЗапросаСхемы2);
		
		// Добавление источников запроса.
		Для каждого Источники2 Из ОператорЗапросаСхемы2.Источники Цикл
			Источник1 = ОператорЗапросаСхемы1.Источники.Добавить(Источники2.Источник.ИмяТаблицы, Источники2.Источник.Псевдоним);
		КонецЦикла;
		
		// Добавление выбираемых полей.
		Для каждого ВыбираемоеПоле2 Из ОператорЗапросаСхемы2.ВыбираемыеПоля Цикл
			
			ИндексКолонки2 = ОператорЗапросаСхемы2.ВыбираемыеПоля.Индекс(ВыбираемоеПоле2);
			Колонка2 = ЗапросСхемы2.Колонки.Получить(ИндексКолонки2);
			Колонка1 = ЗапросСхемы1.Колонки.Найти(Колонка2.Псевдоним);
			
			ИндексКолонки = ПоляПоКолонкам2.Получить(ВыбираемоеПоле2);
			Если Колонка1 = Неопределено Тогда
				ОператорЗапросаСхемы1.ВыбираемыеПоля.Добавить(Строка(ВыбираемоеПоле2));
				// Установка имени колонки.
				Колонка1 = ЗапросСхемы1.Колонки.Получить(ЗапросСхемы1.Колонки.Количество()-1);
				Колонка1.Псевдоним = Колонка2.Псевдоним;
			Иначе
				ОператорЗапросаСхемы1.ВыбираемыеПоля.Добавить(Строка(ВыбираемоеПоле2), ИндексКолонки);
			КонецЕсли;
		КонецЦикла;
		
		// Добавление соединений.
		СписокКорректировкиСоединений = Новый Соответствие;
		Для каждого Источники2 Из ОператорЗапросаСхемы2.Источники Цикл
			Источник1 = ОператорЗапросаСхемы1.Источники.Получить(ОператорЗапросаСхемы2.Источники.Индекс(Источники2));
			Для каждого Соединение2 Из Источники2.Соединения Цикл
				Источник1.Соединения.Добавить(Соединение2.Источник.Источник.Псевдоним, Строка(Соединение2.Условие));
				ПоследнееСоединение = Источник1.Соединения.Получить(Источник1.Соединения.Количество()-1);
				Если ПоследнееСоединение.ТипСоединения <> Соединение2.ТипСоединения Тогда
					СписокКорректировкиСоединений.Вставить(ПоследнееСоединение, Соединение2.ТипСоединения);
				КонецЕсли;
			КонецЦикла;
			Если СписокКорректировкиСоединений.Количество() Тогда
				Для каждого Соединение1 Из СписокКорректировкиСоединений Цикл
					Соединение1.Ключ.ТипСоединения = Соединение1.Значение;
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		
		// Добавление отборов.
		Для каждого ОтборыЗапроса2 Из ОператорЗапросаСхемы2.Отбор Цикл
			ОператорЗапросаСхемы1.Отбор.Добавить(Строка(ОтборыЗапроса2));
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры

// Служебная функция - определение идентичности полей схемы запросов.
//
// Параметры:
//  Коллекция1	 - ПоляСхемыЗапроса - поля схемы приемника.
//  Коллекция2	 - ПоляСхемыЗапроса - поля схемы источника.
// 
// Возвращаемое значение:
//  Булево - результат сравнения.
//
Функция ПоляСхемыЗапросовИдентичны(Коллекция1, Коллекция2)
	
	Если Коллекция1.Количество() <> Коллекция2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для НомерИндекса = 0 По Коллекция1.Количество() - 1 Цикл
		Если Коллекция1[НомерИндекса] <> Коллекция2[НомерИндекса] Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

#КонецОбласти

#КонецОбласти



