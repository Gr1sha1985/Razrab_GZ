#Область ПрограммныйИнтерфейс

#Область ДляВызоваИзДругихПодсистем

// СтандартныеПодсистемы.ОбновлениеВерсииИБ

////////////////////////////////////////////////////////////////////////////////
// Сведения о библиотеке (или конфигурации).

// См. ОбновлениеИнформационнойБазыБСП.ПриДобавленииПодсистемы.
Процедура ПриДобавленииПодсистемы(Описание) Экспорт
	
	Описание.Имя = "ЗарплатаКадрыБазовая";
	Описание.Версия = "3.1.14.465";
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Обработчики обновления информационной базы.

// См. ОбновлениеИнформационнойБазыБСП.ПриДобавленииОбработчиковОбновления.
Процедура ПриДобавленииОбработчиковОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Процедура = "ОбновлениеИнформационнойБазыЗарплатаКадрыБазовый.СоздатьВалютуУчетаЗаработнойПлаты";
	Обработчик.НачальноеЗаполнение = Истина;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Процедура = "ОбновлениеИнформационнойБазыЗарплатаКадрыБазовый.ОтключитьДопустимостьМножестваЗначенийРабочегоТелефона";
	Обработчик.НачальноеЗаполнение = Истина;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Процедура = "РегистрыСведений.ДополнительныеНастройкиЗарплатаКадры.НачальноеЗаполнение";
	Обработчик.НачальноеЗаполнение = Истина;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Процедура = "Справочники.СпособыОкругленияПриРасчетеЗарплаты.НачальноеЗаполнение";
	Обработчик.НачальноеЗаполнение = Истина;
	
	Если ЗарплатаКадры.АвтономнаяРаботаРазрешеноИзменениеДанных(Метаданные.РегистрыСведений.МинимальнаяОплатаТрудаРФ) Тогда
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия = "3.1.14.368";
		Обработчик.Процедура = "РегистрыСведений.МинимальнаяОплатаТрудаРФ.НачальноеЗаполнение";
		Обработчик.ОбщиеДанные = Истина;
		Обработчик.НачальноеЗаполнение = Истина;
	КонецЕсли;
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "3.1.9.20";
	Обработчик.Процедура = "УправлениеСвойствамиБЗК.УстановитьДоступностьВсехНаборовДополнительныхРеквизитов";
	Обработчик.НачальноеЗаполнение = Истина;
	Обработчик.РежимВыполнения = "Отложенно";
	Обработчик.Идентификатор = Новый УникальныйИдентификатор("a4d6148a-b158-4dd9-97c7-4e1f5445f9e5");
	Обработчик.Комментарий = НСтр("ru = 'Установка параметров для набора дополнительных свойств объектов библиотеки Зарплата и кадры (базовая)'");
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "3.1.11.39";
	Обработчик.Процедура = "ОбновлениеИнформационнойБазыЗарплатаКадрыБазовый.ОтключитьВыполнятьРасчетЗарплатыБезОптимизации";
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия          = "3.1.13.4";
	Обработчик.РежимВыполнения = ОсновнойРежимВыполненияОбновления();
	Обработчик.Идентификатор   = Новый УникальныйИдентификатор("34c7d08f-89a2-4da6-baa9-7b63f2b1d51b");
	Обработчик.Процедура       = "Справочники.СпособыОкругленияПриРасчетеЗарплаты.ПереименоватьСуществующийСпособОкругленияБезОкругления";
	Обработчик.Комментарий     = НСтр("ru = 'Переименовать существующий способ округления ""Без округления"" в ""Округление до копеек""'");
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия          = "3.1.13.4";
	Обработчик.РежимВыполнения = ОсновнойРежимВыполненияОбновления();
	Обработчик.Идентификатор   = Новый УникальныйИдентификатор("3ce61054-519c-42b8-8674-e97b9ce773cb");
	Обработчик.Процедура       = "Справочники.СпособыОкругленияПриРасчетеЗарплаты.СоздатьНовыйСпособОкругленияБезОкругления";
	Обработчик.Комментарий     = НСтр("ru = 'Создать новый способ округления ""Без округления""'");
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия          = "3.1.14.4";
	Обработчик.РежимВыполнения = ОсновнойРежимВыполненияОбновления();
	Обработчик.Идентификатор   = Новый УникальныйИдентификатор("01ddab49-8544-425f-91b8-00d3c7d78291");
	Обработчик.Процедура       = "ЗарплатаКадрыПериодическиеРегистры.УстановитьСпособФормированияИнтервальныхРегистров";
	Обработчик.Комментарий     = НСтр("ru = 'Установить способ формирования интервальных регистров'");
	
	Если ЗарплатаКадры.АвтономнаяРаботаРазрешеноИзменениеДанных(Метаданные.РегистрыСведений.ДатыВступленияВСилуНА) Тогда
		Обработчик = Обработчики.Добавить();
		Обработчик.Версия = "3.1.14.458";
		Обработчик.Процедура = "РегистрыСведений.ДатыВступленияВСилуНА.НачальноеЗаполнение";
		Обработчик.ОбщиеДанные = Истина;
		Обработчик.НачальноеЗаполнение = Истина;
	КонецЕсли;
	
	КадровыйУчет.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	УчетНДФЛ.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	УчетНДФЛДокументы.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	РасчетЗарплаты.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	ВзаиморасчетыССотрудниками.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	ОбменСБанкамиПоЗарплатнымПроектам.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	УчетСтраховыхВзносов.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	ПерсонифицированныйУчет.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	УчетНачисленнойЗарплаты.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	ОтражениеЗарплатыВБухучете.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	УчетПособийСоциальногоСтрахования.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	УчетСтажаПФР.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	УчетРабочегоВремени.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	ЗарплатаКадрыСоставДокументов.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	ПодписиДокументов.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	КабинетСотрудника.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыПриложения.ЗарплатаКадрыДляНебольшихОрганизаций.Выплаты") Тогда
		МодульВыплатаЗарплатыДляНебольшихОрганизаций = ОбщегоНазначения.ОбщийМодуль("ВыплатаЗарплатыДляНебольшихОрганизаций");
		МодульВыплатаЗарплатыДляНебольшихОрганизаций.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыПриложения.УчетДепонированнойЗарплаты") Тогда
		МодульУчетДепонированнойЗарплаты = ОбщегоНазначения.ОбщийМодуль("УчетДепонированнойЗарплаты");
		МодульУчетДепонированнойЗарплаты.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыПриложения.КонфигурацииЗарплатаКадры") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("КонфигурацииЗарплатаКадры");
		Модуль.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыПриложения.ЗарплатаКадрыДляНебольшихОрганизаций.РасчетЗарплаты") Тогда
		МодульРасчетЗарплатыДляНебольшихОрганизаций = ОбщегоНазначения.ОбщийМодуль("РасчетЗарплатыДляНебольшихОрганизаций");
		МодульРасчетЗарплатыДляНебольшихОрганизаций.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыПриложения.ОценочныеОбязательстваЗарплатаКадры") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("РезервОтпусков");
		Модуль.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыПриложения.ЗарплатаКадрыДляНебольшихОрганизаций.ОтражениеЗарплатыВБухгалтерскомУчете") Тогда
		Модуль = ОбщегоНазначения.ОбщийМодуль("ОтражениеЗарплатыВБухучетеДляНебольшихОрганизаций");
		Модуль.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	КонецЕсли;
	
	Если ОбщегоНазначения.ПодсистемаСуществует("ЗарплатаКадрыПриложения.ЗарплатаКадрыДляНебольшихОрганизаций") Тогда
		МодульЗарплатаКадрыДляНебольшихОрганизаций = ОбщегоНазначения.ОбщийМодуль("ЗарплатаКадрыДляНебольшихОрганизаций");
		МодульЗарплатаКадрыДляНебольшихОрганизаций.ЗарегистрироватьОбработчикиОбновления(Обработчики);
	КонецЕсли;

КонецПроцедуры

// См. ОбновлениеИнформационнойБазыПереопределяемый.ПередОбновлениемИнформационнойБазы.
Процедура ПередОбновлениемИнформационнойБазы() Экспорт
	
КонецПроцедуры

// См. ОбновлениеИнформационнойБазыПереопределяемый.ПослеОбновленияИнформационнойБазы.
Процедура ПослеОбновленияИнформационнойБазы(Знач ПредыдущаяВерсия, Знач ТекущаяВерсия,
		Знач ВыполненныеОбработчики, ВыводитьОписаниеОбновлений, МонопольныйРежим) Экспорт
	
КонецПроцедуры

// См. ОбновлениеИнформационнойБазыПереопределяемый.ПриПодготовкеМакетаОписанияОбновлений.
Процедура ПриПодготовкеМакетаОписанияОбновлений(Знач Макет) Экспорт
	
	// Не используется в БСП.
	
КонецПроцедуры

// См. ОбновлениеИнформационнойБазыБСП.ПриОпределенииРежимаОбновленияДанных.
Процедура ПриОпределенииРежимаОбновленияДанных(РежимОбновленияДанных, СтандартнаяОбработка) Экспорт
	
КонецПроцедуры

// См. ОбновлениеИнформационнойБазыБСП.ПриДобавленииОбработчиковПереходаСДругойПрограммы.
Процедура ПриДобавленииОбработчиковПереходаСДругойПрограммы(Обработчики) Экспорт
	
КонецПроцедуры

// См. ОбновлениеИнформационнойБазыБСП.ПриЗавершенииПереходаСДругойПрограммы.
Процедура ПриЗавершенииПереходаСДругойПрограммы(ПредыдущееИмяКонфигурации, ПредыдущаяВерсияКонфигурации, Параметры) Экспорт
	
КонецПроцедуры

// Конец СтандартныеПодсистемы.ОбновлениеВерсииИБ

#КонецОбласти

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

Функция ОсновнойРежимВыполненияОбновления() Экспорт
	РежимОбновления = "Монопольно";
	ЗарплатаКадрыПереопределяемый.УстановитьОсновнойРежимВыполненияОбновления(РежимОбновления);
	Возврат РежимОбновления;
КонецФункции

Процедура УстановитьПараметрОбновления(ПараметрыОбновления, ИмяПараметра, Значение) Экспорт
	Если ПараметрыОбновления <> НеОпределено Тогда
		ПараметрыОбновления[ИмяПараметра] = Значение;
	КонецЕсли;
КонецПроцедуры

Функция ПодготовитьОбновлениеДанных(ПараметрыОбновления, ИмяПространстваБлокировки, ПолеБлокировки, ЗначениеБлокировки) Экспорт
	Если ПараметрыОбновления = НеОпределено Тогда
		Возврат Истина;
	КонецЕсли;
	НачатьТранзакцию();
	Блокировка = Новый БлокировкаДанных;
	ЭлементБлокировки = Блокировка.Добавить(ИмяПространстваБлокировки);
	Если ЗначениеЗаполнено(ПолеБлокировки) Тогда
		ЭлементБлокировки.УстановитьЗначение(ПолеБлокировки, ЗначениеБлокировки);
	КонецЕсли;
	Попытка 
		Блокировка.Заблокировать();
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Обновление информационной базы.Ошибка блокировки'", ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Предупреждение, , ЗначениеБлокировки, ИмяПространстваБлокировки);
		Возврат Ложь;
	КонецПопытки;
	Возврат Истина;
КонецФункции

Процедура ЗавершитьОбновлениеДанных(ПараметрыОбновления) Экспорт
	Если ПараметрыОбновления = НеОпределено Тогда
		Возврат;
	КонецЕсли;
	ЗафиксироватьТранзакцию();
КонецПроцедуры

// Конструктор структуры для метода НачатьОбновлениеДанных, описывающая блокировку объекта.
//
// Параметры:
//	МетаданныеОбъекта - ОбъектМетаданных - метаданные объекта, на который будет накладываться блокировка.
//	ПоляБлокировки - Строка - строка, в которой через запятую перечислены поля по которым будет накладываться блокировка
//						если блокируемый объект является независимым регистром сведений.
//
//  Возвращаемое значение:
//  	Структура с полями:
//		* ПространствоБлокировки - Строка - имя поля пространства блокировки
//		* ПоляБлокировки - Структура - структура в которой Ключ свойства соответствует имени поля блокировки.
//
Функция ОписаниеБлокируемыхДанных(Знач МетаданныеОбъекта, Знач ПоляБлокировки = Неопределено) Экспорт
	
	Описание = Новый Структура("ПространствоБлокировки, ПоляБлокировки");
	
	Если ОбщегоНазначения.ЭтоОбъектСсылочногоТипа(МетаданныеОбъекта) Тогда
		Описание.ПространствоБлокировки = МетаданныеОбъекта.ПолноеИмя();
		Описание.ПоляБлокировки = Новый Структура("Ссылка");
		ПроверитьВалидностьПолейБлокировки("Ссылка", ПоляБлокировки);
	ИначеЕсли ОбщегоНазначения.ЭтоРегистрБухгалтерии(МетаданныеОбъекта) 
		Или ОбщегоНазначения.ЭтоРегистрНакопления(МетаданныеОбъекта)
		Или ОбщегоНазначения.ЭтоРегистрРасчета(МетаданныеОбъекта) Тогда
		Описание.ПространствоБлокировки = МетаданныеОбъекта.ПолноеИмя() + ".НаборЗаписей";
		Описание.ПоляБлокировки = Новый Структура("Регистратор");
		ПроверитьВалидностьПолейБлокировки("Регистратор", ПоляБлокировки);
	ИначеЕсли ОбщегоНазначения.ЭтоРегистрСведений(МетаданныеОбъекта) Тогда
		Если МетаданныеОбъекта.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
			Описание.ПространствоБлокировки = МетаданныеОбъекта.ПолноеИмя() + ".НаборЗаписей";
			Описание.ПоляБлокировки = Новый Структура("Регистратор");
			ПроверитьВалидностьПолейБлокировки("Регистратор", ПоляБлокировки);
		Иначе
			Описание.ПространствоБлокировки = МетаданныеОбъекта.ПолноеИмя();
			Если ПоляБлокировки = Неопределено Тогда
				Описание.ПоляБлокировки = Новый Структура;
			Иначе
				Описание.ПоляБлокировки = Новый Структура(ПоляБлокировки);
				
				Если Описание.ПоляБлокировки.Количество() = 0 Тогда
					Шаблон = НСтр("ru = 'Неверное имя полей блокировки %1'", ОбщегоНазначения.КодОсновногоЯзыка());
					ВызватьИсключение СтрШаблон(Шаблон, МетаданныеОбъекта.ПолноеИмя());
				КонецЕсли;
			КонецЕсли;	
			
			МассивИзмерений = ОбщегоНазначения.ВыгрузитьКолонку(МетаданныеОбъекта.Измерения, "Имя");
			Если МетаданныеОбъекта.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
				МассивИзмерений.Добавить("Период");
			КонецЕсли;
			Для Каждого ПолеБлокировки Из Описание.ПоляБлокировки Цикл
				Если МассивИзмерений.Найти(ПолеБлокировки.Ключ) = Неопределено Тогда
					Шаблон = НСтр("ru = 'Неверное имя поля блокировки %1'", ОбщегоНазначения.КодОсновногоЯзыка());
					ВызватьИсключение СтрШаблон(Шаблон, ПолеБлокировки.Ключ);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	ИначеЕсли Метаданные.РегистрыРасчета.Содержит(МетаданныеОбъекта.Родитель())
		И МетаданныеОбъекта.Родитель().Перерасчеты.Найти(МетаданныеОбъекта.Имя) = МетаданныеОбъекта Тогда
		Описание.ПространствоБлокировки = МетаданныеОбъекта.ПолноеИмя() + ".НаборЗаписей";
		Описание.ПоляБлокировки = Новый Структура("ОбъектПерерасчета");
		ПроверитьВалидностьПолейБлокировки("ОбъектПерерасчета", ПоляБлокировки);
	ИначеЕсли ОбщегоНазначения.ЭтоПоследовательность(МетаданныеОбъекта) Тогда
		Описание.ПространствоБлокировки = МетаданныеОбъекта.ПолноеИмя() + ".НаборЗаписей";
		Описание.ПоляБлокировки = Новый Структура("Регистратор");
		ПроверитьВалидностьПолейБлокировки("Регистратор", ПоляБлокировки);
	ИначеЕсли ОбщегоНазначения.ЭтоКонстанта(МетаданныеОбъекта) Тогда
		Описание.ПространствоБлокировки = МетаданныеОбъекта.ПолноеИмя();
		Описание.ПоляБлокировки = Новый Структура;
	Иначе
		ВызватьИсключение НСтр("ru = 'Недопустимый тип объекта'", ОбщегоНазначения.КодОсновногоЯзыка());
	КонецЕсли;
	
	Возврат Описание;
	
КонецФункции

// Вызывается перед обновлением объектов, наборов записей.
// В отложенном режиме открывает транзакцию и устанавливает блокировку на обновляемые объекты.
//
// Параметры:
//	ОписаниеБлокируемыхДанных - Структура, Массив - структура или массив структур, сформированных
//				методом ОписаниеБлокируемыхДанных
//	ПараметрыОбновления - Структура - структура, которая приходит на вход в обработчик при отложенном обновлении
//						- Неопределенно - при монопольном обновлении
//
// Возвращаемое значение:
//	Булево - Истина, если блокировки успешно установлены,
//		либо обновление происходит в монопольном режиме.
//
Функция НачатьОбновлениеДанных(Знач ОписаниеБлокируемыхДанных, Знач ПараметрыОбновления) Экспорт
	
	Если ПараметрыОбновления = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	
	НачатьТранзакцию();
	
	Попытка
		Блокировка = Новый БлокировкаДанных;
		Если ТипЗнч(ОписаниеБлокируемыхДанных) = Тип("Массив") Тогда 
			Для Каждого ЭлементОписания Из ОписаниеБлокируемыхДанных Цикл
				ДобавитьБлокировкуДанных(Блокировка,ЭлементОписания);
			КонецЦикла;
		Иначе
			ДобавитьБлокировкуДанных(Блокировка, ОписаниеБлокируемыхДанных);
		КонецЕсли;
		Блокировка.Заблокировать();
	Исключение
		ОтменитьТранзакцию();
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Обновление информационной базы.Ошибка блокировки'", ОбщегоНазначения.КодОсновногоЯзыка()),
			УровеньЖурналаРегистрации.Предупреждение);
		Возврат Ложь;
	КонецПопытки;
	
	Возврат Истина;
	
КонецФункции

// Выполняет запрос получения порции обновляемых данных. 
// Добавляет в запрос, формирующий список объектов к обновлению, количество обрабатываемых в итерации 
// выполнения обработчика объектов (конструкцию ПЕРВЫЕ N).
// В случае если порция обрабатываемых данных помещается во временную таблицу, добавляется еще один запрос вида «ВЫБРАТЬ
// ПЕРВЫЕ 1 ИСТИНА ИЗ <ВТДанныеКОбработке>
//
// Параметры:
//	Запрос - Запрос - Запрос получения объектов для обновления
//	ПараметрыОбновления - Структура - структура, которая приходит на вход в обработчик при отложенном обновлении
//						- Неопределенно - при монопольном обновлении
//	КоличествоОбрабатываемыхОбъектов - Число - количество отбираемых объектов к обновлению.
//										Значение по умолчанию 1000. 
//										При монопольном режиме обновления ограничения снимаются.
//	ИмяВТОбновляемыеДанные - Строка - имя временной таблицы, куда помещаются объекты к обновлению. 
//								К запросу, формирующему эту таблицу будет добавляться конструкция ПЕРВЫЕ N. 
//								Если значение не передано, то запросом, формирующим список объектов к обновлению, считается последний запрос пакета. 
//
// Возвращаемое значение:
//	РезультатЗапроса - если передано имя временной таблицы, то в результате запроса признак что есть отобранные объекты,
//						если не передано имя временной таблицы то отобранные объекты к обновлению.
//
Функция ВыполнитьЗапросПолученияОбновляемыхДанных(Запрос, Знач ПараметрыОбновления, Знач ИмяВТОбновляемыеДанные = "", КоличествоОбрабатываемыхОбъектов = 1000) Экспорт
	
	Если ПараметрыОбновления = Неопределено Тогда
		КоличествоОбрабатываемыхОбъектов = Неопределено;
	КонецЕсли;
	
	СхемаЗапроса = Новый СхемаЗапроса;
	СхемаЗапроса.УстановитьТекстЗапроса(Запрос.Текст);
	КоличествоЗапросов = СхемаЗапроса.ПакетЗапросов.Количество();
	Если ПустаяСтрока(ИмяВТОбновляемыеДанные) Тогда
		ЗапросВыбора = СхемаЗапроса.ПакетЗапросов[КоличествоЗапросов - 1]; 
	Иначе
		ЗапросВыбораНеНайден = Истина;
		Для Индекс = 1 По КоличествоЗапросов Цикл
			ЗапросВыбора = СхемаЗапроса.ПакетЗапросов[КоличествоЗапросов - Индекс];
			Если ЗапросВыбора.ТаблицаДляПомещения = ИмяВТОбновляемыеДанные Тогда
				ЗапросВыбораНеНайден = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если ЗапросВыбораНеНайден Тогда
			ВызватьИсключение НСтр("ru = 'Не определен запрос выбора данных. Ошибка в имени временной таблицы получения данных'", ОбщегоНазначения.КодОсновногоЯзыка());
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого ОператорВыбора Из ЗапросВыбора.Операторы Цикл
		ОператорВыбора.КоличествоПолучаемыхЗаписей = КоличествоОбрабатываемыхОбъектов;
	КонецЦикла;
	
	Если Не ПустаяСтрока(ИмяВТОбновляемыеДанные) Тогда
		ЗапросВыбора = СхемаЗапроса.ПакетЗапросов.Добавить();
		ОператорВыбора = ЗапросВыбора.Операторы[0];
		ОператорВыбора.КоличествоПолучаемыхЗаписей = 1;
		ОператорВыбора.ВыбираемыеПоля.Добавить("ИСТИНА");
		ОператорВыбора.Источники.Добавить(ИмяВТОбновляемыеДанные);
	КонецЕсли;
	
	Запрос.Текст = СхемаЗапроса.ПолучитьТекстЗапроса();
	
	Возврат Запрос.Выполнить();
	
КонецФункции

Процедура ЗавершитьОбработчик(ПараметрыОбновления) Экспорт
	УстановитьПараметрОбновления(ПараметрыОбновления, "ОбработкаЗавершена", Истина);
КонецПроцедуры

Процедура ПродолжитьОбработчик(ПараметрыОбновления) Экспорт
	УстановитьПараметрОбновления(ПараметрыОбновления, "ОбработкаЗавершена", Ложь);
КонецПроцедуры

// Перезаполняет наборы записей регистров накопления по документам-регистраторам исправленными данными и записывает их.
//
// Параметры: 
//  ИмяРегистра - Строка - 
//  ТекстЗапроса - Строка - текст исполняемого запроса, в котором обязательно присутствует 
//			поле Регистратор, остальные поля должны соответствовать 
//          полям записи заполняемого регистра, в результате должны 
//          присутствовать все заполняемые поля;
//			кроме того, результат запроса должен быть упорядочен, 
//			первое поле упорядочивания - Регистратор
//  ПараметрыЗапроса - Структура - необязательный, содержит имена и значения параметров,
//          которые требуются запросу.
//  МенеджерВременныхТаблиц - МенеджерВременныхТаблиц - необязательный, если передан, содержит 
//          необходимые основному запросу временные таблицы.
//	ПараметрыОбновления - Структура - структура, которая приходит на вход в обработчик при отложенном обновлении.
//
Процедура ОбработатьНаборыЗаписейРегистраНакопления(ИмяРегистра, ТекстЗапроса, ПараметрыЗапроса = Неопределено, МенеджерВременныхТаблиц = Неопределено, ПараметрыОбновления = Неопределено) Экспорт
	
	Запрос = Новый Запрос;
	Если МенеджерВременныхТаблиц <> Неопределено Тогда
		Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц
	КонецЕсли;
	Запрос.Текст = ТекстЗапроса;
	Если ЗначениеЗаполнено(ПараметрыЗапроса) Тогда
		Для каждого КлючИЗначение Из ПараметрыЗапроса Цикл
			Запрос.УстановитьПараметр(КлючИЗначение.Ключ, КлючИЗначение.Значение)
		КонецЦикла;
	КонецЕсли;
	Результат = Запрос.Выполнить();
	Если Не Результат.Пустой() Тогда
		ОбработатьНаборыЗаписейРегистраНакопленияПоРезультатуЗапроса(ИмяРегистра, Результат, ПараметрыОбновления)
	Иначе
		УстановитьПараметрОбновления(ПараметрыОбновления, "ОбработкаЗавершена", Истина)
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

#Область ОбработчикиОбновленияИнформационнойБазы

Процедура СоздатьВалютуУчетаЗаработнойПлаты() Экспорт
	
	// Создаем "Рубли".
	
	Коды = Новый Массив;
	Коды.Добавить("643");
	
	РаботаСКурсамиВалют.ДобавитьВалютыПоКоду(Коды);
	
КонецПроцедуры

Процедура ОтключитьДопустимостьМножестваЗначенийРабочегоТелефона() Экспорт
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ
		|	ФизическиеЛицаКонтактнаяИнформация.Ссылка,
		|	КОЛИЧЕСТВО(РАЗЛИЧНЫЕ ФизическиеЛицаКонтактнаяИнформация.НомерСтроки) КАК Количество
		|ПОМЕСТИТЬ ВТКоличествоЗаписейНаФизическоеЛицо
		|ИЗ
		|	Справочник.ФизическиеЛица.КонтактнаяИнформация КАК ФизическиеЛицаКонтактнаяИнформация
		|ГДЕ
		|	ФизическиеЛицаКонтактнаяИнформация.Вид = ЗНАЧЕНИЕ(Справочник.ВидыКонтактнойИнформации.ТелефонРабочийФизическиеЛица)
		|
		|СГРУППИРОВАТЬ ПО
		|	ФизическиеЛицаКонтактнаяИнформация.Ссылка
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	МАКСИМУМ(КоличествоЗаписейНаФизическоеЛицо.Количество) КАК МаксимальноеКоличество
		|ПОМЕСТИТЬ ВТМаксимальноеКоличествоЗаписей
		|ИЗ
		|	ВТКоличествоЗаписейНаФизическоеЛицо КАК КоличествоЗаписейНаФизическоеЛицо
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	ВидыКонтактнойИнформации.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ВидыКонтактнойИнформации КАК ВидыКонтактнойИнформации
		|		ЛЕВОЕ СОЕДИНЕНИЕ ВТМаксимальноеКоличествоЗаписей КАК МаксимальноеКоличествоЗаписей
		|		ПО (ЕСТЬNULL(МаксимальноеКоличествоЗаписей.МаксимальноеКоличество, 0) > 1)
		|ГДЕ
		|	ВидыКонтактнойИнформации.Ссылка = ЗНАЧЕНИЕ(Справочник.ВидыКонтактнойИнформации.ТелефонРабочийФизическиеЛица)
		|	И ВидыКонтактнойИнформации.РазрешитьВводНесколькихЗначений
		|	И МаксимальноеКоличествоЗаписей.МаксимальноеКоличество ЕСТЬ NULL ");
		
	РезультатЗапроса = Запрос.Выполнить();
	Если РезультатЗапроса.Пустой() Тогда
		Возврат;
	КонецЕсли;
	
	// ТелефонРабочийФизическиеЛица
	СвойстваВидаКИ = УправлениеКонтактнойИнформацией.ПараметрыВидаКонтактнойИнформации(Перечисления.ТипыКонтактнойИнформации.Телефон);
	СвойстваВидаКИ.Вид = Справочники.ВидыКонтактнойИнформации.ТелефонРабочийФизическиеЛица;
	СвойстваВидаКИ.МожноИзменятьСпособРедактирования = Истина;
	СвойстваВидаКИ.ОбязательноеЗаполнение = Ложь;
	СвойстваВидаКИ.РазрешитьВводНесколькихЗначений = Ложь;
	УправлениеКонтактнойИнформацией.УстановитьСвойстваВидаКонтактнойИнформации(СвойстваВидаКИ);
	
КонецПроцедуры

Процедура ОтключитьВыполнятьРасчетЗарплатыБезОптимизации() Экспорт

	Если Константы.ВыполнятьРасчетЗарплатыБезОптимизации.Получить() Тогда
		Константы.ВыполнятьРасчетЗарплатыБезОптимизации.Установить(Ложь);
	КонецЕсли;

КонецПроцедуры

#КонецОбласти

Процедура ЗаменитьСсылкиВСсылочныхОбъектах(СоответствиеСсылок, МассивСсылок, РеквизитыМетаданных, ИзмененныеОбъекты) Экспорт
	
	НайденныеОбъекты = НайтиПоСсылкам(МассивСсылок);
	
	ОбъектыМетаданных = Новый Соответствие;
	Для Каждого Реквизит Из РеквизитыМетаданных Цикл
		МетаданныеРодителя = МетаданныеРодителя(Реквизит);
		МассивРеквизитов = ОбъектыМетаданных[МетаданныеРодителя];
		Если МассивРеквизитов = Неопределено Тогда
			МассивРеквизитов = Новый Массив;
		КонецЕсли;
		МассивРеквизитов.Добавить(Реквизит);
		ОбъектыМетаданных.Вставить(МетаданныеРодителя, МассивРеквизитов);
	КонецЦикла;
	
	Для Каждого СтрокаТаблицы Из НайденныеОбъекты Цикл
		МассивРеквизитов = ОбъектыМетаданных[СтрокаТаблицы.Метаданные];
		Если МассивРеквизитов = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		Объект = ИзмененныеОбъекты[СтрокаТаблицы.Данные];
		Если Объект = Неопределено Тогда
			Объект = СтрокаТаблицы.Данные.ПолучитьОбъект();
			Если Объект = Неопределено Тогда
				// Например, если ссылка "битая".
				Продолжить;
			КонецЕсли;
			ИзмененныеОбъекты.Вставить(СтрокаТаблицы.Данные, Объект);
		КонецЕсли;
		Для Каждого Реквизит Из МассивРеквизитов Цикл
			// Это реквизит объекта
			Если СтрокаТаблицы.Метаданные.Реквизиты.Содержит(Реквизит) Тогда
				Объект[Реквизит.Имя] = СоответствиеСсылок[Объект["Удалить" + Реквизит.Имя]];
				Продолжить;
			КонецЕсли;
			// Это реквизит табличной части
			ТабличнаяЧасть = Реквизит.Родитель();
			Для Каждого СтрокаТабличнойЧасти Из Объект[ТабличнаяЧасть.Имя] Цикл
				СтрокаТабличнойЧасти[Реквизит.Имя] = СоответствиеСсылок[СтрокаТабличнойЧасти["Удалить" + Реквизит.Имя]];
			КонецЦикла;
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаменитьСсылкиВЗановоСозданномПодчиненномРегистреСведений(МетаданныеРегистра, Поля, СоответствиеСсылок) Экспорт
	
	ТекстЗапроса = 
		"ВЫБРАТЬ
		|	*
		|ИЗ
		|	РегистрСведений.Удалить#ИмяРегистра КАК Прежняя
		|
		|УПОРЯДОЧИТЬ ПО
		|	Регистратор,
		|	НомерСтроки";
		
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#ИмяРегистра", МетаданныеРегистра.Имя);
	
	НаборЗаписей = РегистрыСведений[МетаданныеРегистра.Имя].СоздатьНаборЗаписей();
	ПрежнийНабор = РегистрыСведений["Удалить" + МетаданныеРегистра.Имя].СоздатьНаборЗаписей();
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Выборка = Запрос.Выполнить().Выбрать();
	Пока Выборка.СледующийПоЗначениюПоля("Регистратор") Цикл
		НаборЗаписей.Очистить();
		Пока Выборка.Следующий() Цикл
			СтрокаНабора = НаборЗаписей.Добавить();
			ЗаполнитьЗначенияСвойств(СтрокаНабора, Выборка);
			Для Каждого Поле Из Поля Цикл
				СтрокаНабора[Поле.Имя] = СоответствиеСсылок[Выборка[Поле.Имя]];
			КонецЦикла;
		КонецЦикла;
		НаборЗаписей.Отбор.Регистратор.Установить(Выборка.Регистратор);
		НаборЗаписей.ОбменДанными.Загрузка = Истина;
		НаборЗаписей.Записать();
		// Удаляем прежний набор записей
		ПрежнийНабор.Отбор.Регистратор.Установить(Выборка.Регистратор);
		ПрежнийНабор.ОбменДанными.Загрузка = Истина;
		ПрежнийНабор.Записать();
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаменитьСсылкиВРегистре(МетаданныеРегистра, Поля, СоответствиеСсылок) Экспорт
	
	ТекстЗапроса = 
		"ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	&Измерения
		|ПОМЕСТИТЬ ВТИзмерения
		|ИЗ
		|	#ПолноеИмяРегистра КАК Таблица
		|ГДЕ
		|	&СтрокаУсловия
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ
		|	Таблица.*
		|ИЗ
		|	#ПолноеИмяРегистра КАК Таблица
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ ВТИзмерения КАК Измерения
		|		ПО &СтрокаСоединения
		|
		|УПОРЯДОЧИТЬ ПО
		|	&Порядок";
		
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#ПолноеИмяРегистра", МетаданныеРегистра.ПолноеИмя());
	
	Запрос = Новый Запрос;
	
	СтрокаУсловия = "";
	Для Каждого Поле Из Поля Цикл
		НовыеМетаданные = Метаданные.НайтиПоТипу(Поле.Тип.Типы()[0]);
		ПрежниеМетаданные = Метаданные.НайтиПоПолномуИмени(СтрЗаменить(НовыеМетаданные.ПолноеИмя(), НовыеМетаданные.Имя, "Удалить" + НовыеМетаданные.Имя));
		Запрос.УстановитьПараметр(Поле.Имя + "ПустаяСсылка", ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(НовыеМетаданные.ПолноеИмя()).ПустаяСсылка());
		Запрос.УстановитьПараметр("Удалить" + Поле.Имя + "ПустаяСсылка", ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(ПрежниеМетаданные.ПолноеИмя()).ПустаяСсылка());
		Если Не ПустаяСтрока(СтрокаУсловия) Тогда
			СтрокаУсловия = СтрокаУсловия + " ИЛИ ";
		КонецЕсли;
		СтрокаУсловия = СтрокаУсловия + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"(Таблица.%1 = &%1ПустаяСсылка И Таблица.Удалить%1 <> &Удалить%1ПустаяСсылка)", Поле.Имя);
	КонецЦикла;
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&СтрокаУсловия", СтрокаУсловия);
	
	МассивИзмерений = Новый Массив;
	Если Метаданные.РегистрыНакопления.Содержит(МетаданныеРегистра) 
		Или МетаданныеРегистра.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
		МассивИзмерений.Добавить("Регистратор");
	Иначе
		МассивИзмерений = ОбщегоНазначения.ВыгрузитьКолонку(МетаданныеРегистра.Измерения, "Имя");
		Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			МассивИзмерений.Добавить("Период");
		КонецЕсли;
	КонецЕсли;
	
	Измерения = "";
	СтрокаСоединения = "";
	Порядок = "";
	Для Каждого Измерение Из МассивИзмерений Цикл
		Если Не ПустаяСтрока(Измерения) Тогда
			Измерения = Измерения + ",";
		КонецЕсли;
		Измерения = Измерения + Измерение;
		Если Не ПустаяСтрока(СтрокаСоединения) Тогда
			СтрокаСоединения = СтрокаСоединения + " И ";
		КонецЕсли;
		СтрокаСоединения = СтрокаСоединения + СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			"(Таблица.%1 = Измерения.%1)", Измерение);
		Если Не ПустаяСтрока(Порядок) Тогда
			Порядок = Порядок + ",";
		КонецЕсли;
		Порядок = Порядок + "Таблица." + Измерение;
	КонецЦикла;
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Измерения", Измерения);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&СтрокаСоединения", СтрокаСоединения);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&Порядок", Порядок);
	
	НаборЗаписей = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МетаданныеРегистра.ПолноеИмя()).СоздатьНаборЗаписей();
	
	Запрос.Текст = ТекстЗапроса;
	Выборка = Запрос.Выполнить().Выбрать();
	
	ОтборИзмерений = Новый Структура(Измерения);
	
	Пока Выборка.Следующий() Цикл
		НаборИзмеренийСовпадает = Истина;
		Для Каждого Измерение Из МассивИзмерений Цикл 
			Если Выборка[Измерение] <> ОтборИзмерений[Измерение] Тогда
				НаборИзмеренийСовпадает = Ложь;
				Прервать;
			КонецЕсли;
		КонецЦикла;	
		Если Не НаборИзмеренийСовпадает Тогда
			Если НаборЗаписей.Количество() > 0 Тогда
				Для Каждого Измерение Из МассивИзмерений Цикл
					НаборЗаписей.Отбор[Измерение].Установить(ОтборИзмерений[Измерение]);
				КонецЦикла;
				НаборЗаписей.ОбменДанными.Загрузка = Истина;
				НаборЗаписей.Записать();
			КонецЕсли;
			НаборЗаписей.Очистить();
			ЗаполнитьЗначенияСвойств(ОтборИзмерений, Выборка);
		КонецЕсли;
		
		СтрокаНабора = НаборЗаписей.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаНабора, Выборка);
		Для Каждого Поле Из Поля Цикл
			СтрокаНабора[Поле.Имя] = СоответствиеСсылок[Выборка["Удалить" + Поле.Имя]];
		КонецЦикла;
	КонецЦикла;
	
	Если НаборЗаписей.Количество() > 0 Тогда
		Для Каждого Измерение Из МассивИзмерений Цикл
			НаборЗаписей.Отбор[Измерение].Установить(Выборка[Измерение]);
		КонецЦикла;
		НаборЗаписей.ОбменДанными.Загрузка = Истина;
		НаборЗаписей.Записать();
	КонецЕсли;
	
КонецПроцедуры

Функция СоответствиеСсылок(МетаданныеСправочника, ИмяКлюча) Экспорт
	
	ТекстЗапроса = 
		"ВЫБРАТЬ
		|	ПрежняяТаблица.Ссылка КАК ПрежняяСсылка,
		|	НоваяТаблица.Ссылка
		|ИЗ
		|	Справочник.#ИмяТаблицы КАК НоваяТаблица
		|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Удалить#ИмяТаблицы КАК ПрежняяТаблица
		|		ПО (ПрежняяТаблица.#ИмяКлюча = НоваяТаблица.#ИмяКлюча)";
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#ИмяКлюча", ИмяКлюча);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#ИмяТаблицы", МетаданныеСправочника.Имя);
	
	Запрос = Новый Запрос(ТекстЗапроса);
	Выборка = Запрос.Выполнить().Выбрать();
	
	СоответствиеСсылок = Новый Соответствие;
	Пока Выборка.Следующий() Цикл
		СоответствиеСсылок.Вставить(Выборка.ПрежняяСсылка, Выборка.Ссылка);
	КонецЦикла;
	
	Возврат СоответствиеСсылок;
	
КонецФункции

Функция МетаданныеРодителя(ОбъектМетаданных)
	
	МетаданныеРодителя = ОбъектМетаданных.Родитель();
	Если ТипЗнч(МетаданныеРодителя) = Тип("ОбъектМетаданныхКонфигурация") Тогда
		Возврат ОбъектМетаданных;
	КонецЕсли;
	
	Возврат МетаданныеРодителя(МетаданныеРодителя)
	
КонецФункции

Процедура ДобавитьБлокировкуДанных(Блокировка, ОписаниеБлокируемыхДанных)
	ЭлементБлокировки = Блокировка.Добавить(ОписаниеБлокируемыхДанных.ПространствоБлокировки);
	Для Каждого ПолеБлокировки Из ОписаниеБлокируемыхДанных.ПоляБлокировки Цикл
		ЭлементБлокировки.УстановитьЗначение(ПолеБлокировки.Ключ, ПолеБлокировки.Значение);
	КонецЦикла;
КонецПроцедуры

Процедура ПроверитьВалидностьПолейБлокировки(ВалидноеИмя, ПоляБлокировки)
	Если ПоляБлокировки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ВалидноеИмя <> ПоляБлокировки Тогда
		Шаблон = НСтр("ru = 'Неверное имя поля блокировки %1'", ОбщегоНазначения.КодОсновногоЯзыка());
		ВызватьИсключение СтрШаблон(Шаблон, ПоляБлокировки);
	КонецЕсли;
	
КонецПроцедуры

Процедура ОбработатьНаборыЗаписейРегистраНакопленияПоРезультатуЗапроса(ИмяРегистра, Результат, ПараметрыОбновления) 
	
	УстановитьПараметрОбновления(ПараметрыОбновления, "ОбработкаЗавершена", Ложь);
	Выборка = Результат.Выбрать();
	Пока Выборка.СледующийПоЗначениюПоля("Регистратор") Цикл
		Если Не ПодготовитьОбновлениеДанных(ПараметрыОбновления, "РегистрНакопления." + ИмяРегистра + ".НаборЗаписей", "Регистратор", Выборка.Регистратор) Тогда
			Продолжить;
		КонецЕсли;
		НаборЗаписей = РегистрыНакопления[ИмяРегистра].СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.Регистратор.Установить(Выборка.Регистратор);
		Пока Выборка.Следующий() Цикл
			ЗаполнитьЗначенияСвойств(НаборЗаписей.Добавить(), Выборка);
		КонецЦикла;
		ОбновлениеИнформационнойБазы.ЗаписатьДанные(НаборЗаписей);
		ЗавершитьОбновлениеДанных(ПараметрыОбновления);
	КонецЦикла;

КонецПроцедуры

#КонецОбласти