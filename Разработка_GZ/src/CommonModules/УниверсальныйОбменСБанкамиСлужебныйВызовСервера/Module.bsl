#Область СлужебныйПрограммныйИнтерфейс

Функция ИзвлечьИнформациюОКриптопровайдереПоСертификату(Знач Сертификаты) Экспорт
	
	Для Каждого Сертификат Из Сертификаты Цикл
		Сертификат.Вставить("Криптопровайдер", ИзвлечьКриптопровайдер(Сертификат.Сертификат));
		Сертификат.Удалить("Сертификат");
	КонецЦикла;
	
	Возврат Сертификаты;
	
КонецФункции

Функция ИзвлечьКриптопровайдер(Сертификат) Экспорт
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла("cer");
	Сертификат.Записать(ИмяВременногоФайла);
	
	Буфер = Новый БуферДвоичныхДанных(7);
	Буфер.Установить(0, 6);
	Буфер.Установить(1, 5);
	
	Байты = ПрочитатьФайлВМассив(ИмяВременногоФайла);
	
	БайтыСигнатурыПоиска = Новый Массив; // Ищем OID 1.2.643.100.111
	БайтыСигнатурыПоиска.Добавить(6);
	БайтыСигнатурыПоиска.Добавить(5);
	БайтыСигнатурыПоиска.Добавить(42);
	БайтыСигнатурыПоиска.Добавить(133);
	БайтыСигнатурыПоиска.Добавить(3);
	БайтыСигнатурыПоиска.Добавить(100);
	БайтыСигнатурыПоиска.Добавить(111);
	
	Индекс = 0;
	ИндексНачалаСигнатуры = 0;
	СигнатураНайдена = Ложь;
	Для Каждого Байт Из Байты Цикл
		Если Байт = БайтыСигнатурыПоиска[0] Тогда
			СигнатураНайдена = Истина;
			Для Индекс2 = 1 По 6 Цикл
				Если Байты[Индекс2 + Индекс] <> БайтыСигнатурыПоиска[Индекс2] Тогда
					СигнатураНайдена = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если СигнатураНайдена Тогда
				ИндексНачалаСигнатуры = Индекс;
				Прервать;
			КонецЕсли;
		КонецЕсли;
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Криптопровайдер = "";
	Если СигнатураНайдена Тогда
		КоличествоБайтПодТекст = Байты[ИндексНачалаСигнатуры + БайтыСигнатурыПоиска.Количество() + 1];
		НачалоТекста = ИндексНачалаСигнатуры + БайтыСигнатурыПоиска.Количество() + 4;
		
		БайтыДляЗаписи = Новый Массив;
		Для Индекс = НачалоТекста По НачалоТекста + КоличествоБайтПодТекст - 3 Цикл
			БайтыДляЗаписи.Добавить(Байты[Индекс]);
		КонецЦикла;
		
		ИмяФайла = ПолучитьИмяВременногоФайла("txt");
		ЗаписатьФайлИзМассива(ИмяФайла, БайтыДляЗаписи);
		
		ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, "utf-8");
		Криптопровайдер = ЧтениеТекста.Прочитать();
		ЧтениеТекста.Закрыть();
		
		УниверсальныйОбменСБанками.УдалитьВременныйФайл(ИмяФайла);
	КонецЕсли;
	
	УниверсальныйОбменСБанками.УдалитьВременныйФайл(ИмяВременногоФайла);
	
	Если СтрНайти(НРег(Криптопровайдер), "cryptopro") ИЛИ СтрНайти(НРег(Криптопровайдер), "криптопро") Тогда
		Криптопровайдер = УниверсальныйОбменСБанкамиКлиентСервер.КриптопровайдерCryptoPro();
	ИначеЕсли СтрНайти(НРег(Криптопровайдер), "vipnet") ИЛИ СтрНайти(НРег(Криптопровайдер), "випнет") Тогда
		Криптопровайдер = УниверсальныйОбменСБанкамиКлиентСервер.КриптопровайдерViPNet();
	Иначе
		Криптопровайдер = Неопределено;
	КонецЕсли;
	
	Возврат Криптопровайдер;
	
КонецФункции

// Возвращает отдельные свойства сертификата в формате X.509 в соответствие с https://tools.ietf.org/html/rfc5280.
//
// Параметры:
//   ДанныеСертификата - ДвоичныеДанные, Строка - файл (двоичные данные, адрес во временном хранилище или строка Base64
//                                                при Настройки.ЭтоСтрокаBase64 = Истина) в формате X.509.
//   Настройки - Неопределено - настройки по умолчанию.
//             - Структура:
//     ЭтоЭлектроннаяПодписьВМоделиСервиса - Булево - по умолчанию Истина, влияет на имя события при записи в журнал регистрации.
//     ЭтоСтрокаBase64                     - Булево - по умолчанию Ложь, при Истина ДанныеСертификата задает строку Base64.
//     ВозможенФорматBase64                - Булево - по умолчанию Ложь, при Истина двоичные данные в ДанныеСертификата
//                                                    могут быть в формате Base64, в том числе с заголовками сертификата,
//                                                    корректность чтения определяется по прочитанному алгоритму
//     ВозвращатьИсключения                - Булево - по умолчанию Истина, генерировать исключения при неверной структуре данных.
//
// Возвращаемое значение:
//   Структура - свойства криптосообщения.
//     Размер                  - Число - размер файла в байтах.
//     Версия                  - Число - версия формата сертификата, 0 - v1, 1 - v2, 2 - v3.
//     СерийныйНомер           - ДвоичныеДанные - серийный номер сертификата.
//     АлгоритмПубличногоКлюча - Строка - "GOST R 34.10-2001", "GOST R 34.10-2012-256", "GOST R 34.10-2012-512"
//                                        или OID нераспознанного алгоритма.
//
Функция ПолучитьСвойстваСертификата(Знач ДанныеСертификата, Настройки = Неопределено) Экспорт
	
	НастройкиВызова = Новый Структура;
	НастройкиВызова.Вставить("ЭтоЭлектроннаяПодписьВМоделиСервиса", Истина);
	НастройкиВызова.Вставить("ЭтоСтрокаBase64", 					Ложь);
	НастройкиВызова.Вставить("ВозможенФорматBase64", 				Ложь);
	НастройкиВызова.Вставить("ВозвращатьИсключения", 				Истина);
	Если Настройки <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(НастройкиВызова, Настройки);
	КонецЕсли;
	
	СвойстваСертификата = Новый Структура;
	СвойстваСертификата.Вставить("Размер", 					0);
	СвойстваСертификата.Вставить("Версия", 					0);
	СвойстваСертификата.Вставить("СерийныйНомер", 			0);
	СвойстваСертификата.Вставить("АлгоритмПубличногоКлюча", "");
	
	Если НастройкиВызова.ЭтоСтрокаBase64 Тогда
		ДанныеСертификата = Base64Значение(ДанныеСертификата);
	ИначеЕсли ТипЗнч(ДанныеСертификата) = Тип("Строка") И ЭтоАдресВременногоХранилища(ДанныеСертификата) Тогда
		ДанныеСертификата = ПолучитьИзВременногоХранилища(ДанныеСертификата);
	КонецЕсли;
	
	СвойстваСертификата.Размер = ДанныеСертификата.Размер();
	
	Если НастройкиВызова.ВозможенФорматBase64 И СвойстваСертификата.Размер < 65536 Тогда
		НастройкиВызова.ЭтоСтрокаBase64 		= Ложь;
		НастройкиВызова.ВозможенФорматBase64 	= Ложь;
		СвойстваСертификата = ПолучитьСвойстваСертификата(ДанныеСертификата, НастройкиВызова);
		
		Если НЕ ЗначениеЗаполнено(СвойстваСертификата.АлгоритмПубличногоКлюча) Тогда
			ОбъектЧтениеДанных = Новый ЧтениеДанных(ДанныеСертификата, "windows-1251");
			Попытка
				ТекстСертификата = ОбъектЧтениеДанных.ПрочитатьСимволы();
			Исключение
				ИмяСобытия = ?(НастройкиВызова.ЭтоЭлектроннаяПодписьВМоделиСервиса,
					НСтр("ru = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение сертификата'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
					НСтр("ru = 'Сервис криптографии.Чтение сертификата'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()));
				ЗаписьЖурналаРегистрации(
					ИмяСобытия,
					УровеньЖурналаРегистрации.Ошибка,,,
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				Если НастройкиВызова.ВозвращатьИсключения Тогда
					ВызватьИсключение;
				КонецЕсли;
			КонецПопытки;
			ОбъектЧтениеДанных.Закрыть();
			
			ТекстСертификата = СокрЛП(ТекстСертификата);
			Если СтрНачинаетсяС(ТекстСертификата, "-----BEGIN CERTIFICATE-----")
				И СтрЗаканчиваетсяНа(ТекстСертификата, "-----END CERTIFICATE-----") Тогда
				ДлинаТекстаСертификата = СтрДлина(ТекстСертификата);
				ТекстСертификата = Сред(ТекстСертификата, 28, ДлинаТекстаСертификата - 52);
				ТекстСертификата = СокрЛП(ТекстСертификата);
			КонецЕсли;
			
			НастройкиВызова.ЭтоСтрокаBase64 		= Истина;
			НастройкиВызова.ВозможенФорматBase64 	= Ложь;
			СвойстваСертификата = ПолучитьСвойстваСертификата(ТекстСертификата, НастройкиВызова);
		КонецЕсли;
		
		Возврат СвойстваСертификата;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СвойстваСертификата.Размер) Тогда
		Возврат СвойстваСертификата;
	КонецЕсли;
	
	ОбъектЧтениеДанных = Новый ЧтениеДанных(ДанныеСертификата);
	Попытка
		// https://tools.ietf.org/html/rfc5280#section-4
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // Certificate ::= SEQUENCE...
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // TBSCertificate ::= SEQUENCE...
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 2 Тогда
			Если СвойстваБлока.Класс <> "CONTEXT-SPECIFIC" ИЛИ СвойстваБлока.Тег <> 0 Тогда // version [0] EXPLICIT Version DEFAULT v1
				ОбъектЧтениеДанных.Закрыть();
				Возврат СвойстваСертификата;
			КонецЕсли;
			
			СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		КонецЕсли;
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 2 Тогда // Version ::= INTEGER {v1(0), v2(1), v3(2)}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		ВерсияСертификата = ПрочитатьЦелоеЧисло(ОбъектЧтениеДанных, СвойстваБлока);
		Если ВерсияСертификата < 0 ИЛИ ВерсияСертификата > 2 Тогда
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		СвойстваСертификата.Версия = ВерсияСертификата;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		СвойстваСертификата.СерийныйНомер = ПрочитатьДвоичныеДанные(ОбъектЧтениеДанных,
			СвойстваБлока); // serialNumber CertificateSerialNumber ::= INTEGER
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // signature AlgorithmIdentifier = SEQUENCE {...}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // issuer RDNSequence ::= SEQUENCE {...}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // validity Validity ::= SEQUENCE {...}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // subject RDNSequence ::= SEQUENCE {...}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // subjectPublicKeyInfo SubjectPublicKeyInfo ::= SEQUENCE...
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // algorithm AlgorithmIdentifier = SEQUENCE...
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		АлгоритмПубличногоКлюча = ПрочитатьAlgorithmIdentifier(ОбъектЧтениеДанных, СвойстваСертификата, СвойстваБлока, Истина);
		Если АлгоритмПубличногоКлюча = Неопределено Тогда
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		СвойстваСертификата.АлгоритмПубличногоКлюча = АлгоритмПубличногоКлюча;
	Исключение
		ИмяСобытия = ?(НастройкиВызова.ЭтоЭлектроннаяПодписьВМоделиСервиса,
			НСтр("ru = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение сертификата'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			НСтр("ru = 'Сервис криптографии.Чтение сертификата'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()));
		ЗаписьЖурналаРегистрации(
			ИмяСобытия,
			УровеньЖурналаРегистрации.Ошибка,,,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Если НастройкиВызова.ВозвращатьИсключения Тогда
			ВызватьИсключение;
		КонецЕсли;
	КонецПопытки;
	ОбъектЧтениеДанных.Закрыть();
	
	Возврат СвойстваСертификата;
	
КонецФункции

// Возвращает свойства криптосообщения в формате PKCS #7 в соответствии с https://tools.ietf.org/html/rfc2315.
//
// Параметры:
//   Криптосообщение - ДвоичныеДанные, Строка - файл (двоичные данные, адрес во временном хранилище или строка Base64
//                                              при Настройки.ЭтоСтрокаBase64 = Истина) в формате PKCS #7.
//   Настройки - Неопределено - настройки по умолчанию.
//             - Структура:
//     ПрочитатьПодписанныеДанные          - Булево - по умолчанию Истина, для типа SignedData возвращать Содержимое.
//     ПрочитатьИздателяИСерийныйНомер     - Булево - по умолчанию Истина, для типа SignedData в Подписанты возвращать
//                                                    Идентификатор, Издатель, СерийныйНомер, Сертификат,
//                                                    для типа EnvelopedData в Получатели возвращать Идентификатор, Издатель,
//                                                    СерийныйНомер.
//     ПрочитатьАлгоритмПубличногоКлюча    - Булево - по умолчанию Ложь, для типа EnvelopedData в Получатели возвращать
//                                                    АлгоритмПубличногоКлюча.
//     ЭтоЭлектроннаяПодписьВМоделиСервиса - Булево - по умолчанию Истина, влияет на имя события при записи в журнал регистрации.
//     ЭтоСтрокаBase64                     - Булево - по умолчанию Ложь, при Истина Криптосообщение задает строку Base64.
//     ВозвращатьИсключения                - Булево - по умолчанию Истина, генерировать исключения при неверной структуре данных.
//
// Возвращаемое значение:
//   Структура - свойства криптосообщения.
//    Общие свойства:
//    * Тип - Строка - Unknown - файл неподдерживаемого формат, EnvelopedData - зашифрованные данные, SignedData - подпись.
//    * Размер - Число - размер файла в байтах.
//    
//    Свойства для типа SignedData:
//    * Подписанты - Массив - подписанты сообщения.
//       ** Идентификатор - Строка - идентификатор сертификата
//       ** Издатель - Структура - издатель сертификата
//           *** <X1>.<X2>. ... .<XN>, где X<i> - это компонента идентификатора OID
//       ** СерийныйНомер - ДвоичныеДанные - серийный номер сертификата
//       ** Сертификат - ДвоичныеДанные - файл сертификата
//       ** АлгоритмХеширования - Строка - название алгоритма или OID нераспознанного алгоритма.
//       ** АлгоритмПодписи - Строка - "GOST R 34.10-2001", "GOST R 34.10-2012-256", "GOST R 34.10-2012-512"
//                                     или OID нераспознанного алгоритма.
//    * Сертификаты - Массив - файлы сертификатов.
//    * СпискиОтзываСертификатов - Массив - файлы списков отзыва сертификатов.
//    * Содержимое - ДвоичныеДанные - подписанные данные для прикрепленной подписи.
//
//    Свойства для типа EnvelopedData:
//    * Получатели - Массив - получатели зашифрованного сообщения.
//       ** Идентификатор - Строка - идентификатор сертификата
//       ** Издатель - Структура - издатель сертификата
//           *** OID<X1>_<X2>_..._<XN>, где X<i> - это компонента идентификатора OID
//       ** СерийныйНомер - ДвоичныеДанные - серийный номер сертификата
//       ** АлгоритмПубличногоКлюча - Строка - "GOST R 34.10-2001", "GOST R 34.10-2012-256", "GOST R 34.10-2012-512"
//                                             или OID нераспознанного алгоритма, возвращается при задании
//                                             Настройки.ПрочитатьАлгоритмПубличногоКлюча = Истина
//
Функция ПолучитьСвойстваКриптосообщения(Знач Криптосообщение, Настройки = Неопределено) Экспорт
	
	НастройкиВызова = Новый Структура;
	НастройкиВызова.Вставить("ПрочитатьПодписанныеДанные", 			Истина);
	НастройкиВызова.Вставить("ПрочитатьИздателяИСерийныйНомер", 	Истина);
	НастройкиВызова.Вставить("ПрочитатьАлгоритмПубличногоКлюча", 	Ложь);
	НастройкиВызова.Вставить("ЭтоЭлектроннаяПодписьВМоделиСервиса", Истина);
	НастройкиВызова.Вставить("ЭтоСтрокаBase64", 					Ложь);
	НастройкиВызова.Вставить("ВозвращатьИсключения", 				Истина);
	Если Настройки <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(НастройкиВызова, Настройки);
	КонецЕсли;
	
	СвойстваКриптосообщения = Новый Структура;
	СвойстваКриптосообщения.Вставить("Тип", "Unknown");
	
	Если НастройкиВызова.ЭтоСтрокаBase64 Тогда
		Криптосообщение = Base64Значение(Криптосообщение);
	ИначеЕсли ТипЗнч(Криптосообщение) = Тип("Строка") И ЭтоАдресВременногоХранилища(Криптосообщение) Тогда
		Криптосообщение = ПолучитьИзВременногоХранилища(Криптосообщение);
	КонецЕсли;
	СвойстваКриптосообщения.Вставить("Размер", Криптосообщение.Размер());
	
	Если Не ЗначениеЗаполнено(СвойстваКриптосообщения.Размер) Тогда
		Возврат СвойстваКриптосообщения;
	КонецЕсли;
	
	ЧтениеДанных = Новый ЧтениеДанных(Криптосообщение);
	Попытка
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер); // contentType
		Если Свойства.РазмерБлока > 100 ИЛИ Свойства.РазмерБлока = 0 Тогда // Защита от считывания лишних данных
			ЧтениеДанных.Закрыть();
			Возврат СвойстваКриптосообщения;
		КонецЕсли;
		
		Тип = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства);
		
		// PKCS #7: EnvelopedData https://tools.ietf.org/html/rfc2315#section-10.1
		Если Тип = "1.2.840.113549.1.7.3" Тогда
			СвойстваКриптосообщения = ПрочитатьEnvelopedData(ЧтениеДанных, СвойстваКриптосообщения, НастройкиВызова);
			
		// PKCS #7: SignedData https://tools.ietf.org/html/rfc2315#section-9.1	
		ИначеЕсли Тип = "1.2.840.113549.1.7.2" Тогда
			СвойстваКриптосообщения = ПрочитатьSignedData(ЧтениеДанных, СвойстваКриптосообщения, НастройкиВызова);
		КонецЕсли;
	Исключение
		ИмяСобытия = ?(НастройкиВызова.ЭтоЭлектроннаяПодписьВМоделиСервиса,
			НСтр("ru = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение PKCS7'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()),
			НСтр("ru = 'Сервис криптографии.Чтение PKCS7'", ОбщегоНазначенияКлиентСервер.КодОсновногоЯзыка()));
		ЗаписьЖурналаРегистрации(
			ИмяСобытия,
			УровеньЖурналаРегистрации.Ошибка,,,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Если НастройкиВызова.ВозвращатьИсключения Тогда
			ВызватьИсключение;
		КонецЕсли;
	КонецПопытки;
	ЧтениеДанных.Закрыть();
	
	Возврат СвойстваКриптосообщения;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ЗаписатьФайлИзМассива(ИмяФайла, Массив)
	
	ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, "ISO-8859-1", Символы.ПС,, Символы.ПС);
	
	Для ИндексВМассиве = 0 По Массив.ВГраница() Цикл
		СимволИзМассива = Символ(Массив[ИндексВМассиве]);
		ЗаписьТекста.Записать(СимволИзМассива);
	КонецЦикла;
	ЗаписьТекста.Закрыть();
	
КонецПроцедуры

Функция ПрочитатьФайлВМассив(ИмяФайла)
	
	Результат = Новый Массив;
	
	ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, "ISO-8859-1", Символы.ПС, Символы.ПС);
	
	Пока Истина Цикл
		СимволТекста = ЧтениеТекста.Прочитать(1);
		Если СимволТекста = Неопределено Тогда
			Прервать;
		КонецЕсли;
		КодСимволаТекста = КодСимвола(СимволТекста);
		
		Результат.Добавить(КодСимволаТекста);
	КонецЦикла;
	ЧтениеТекста.Закрыть();
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область БазовыеФункцииЧтенияASN1

Функция ПрочитатьДату(ЧтениеДанных, Свойства)
	
	Если Свойства.Тег = 23 Тогда // UTCTime https://www.obj-sys.com/asn1tutorial/node15.html
		Возврат Дата("20" + Сред(ПрочитатьСтроку(ЧтениеДанных, Свойства), 1, 12));
	Иначе
		Возврат '0001-01-01';	
	КонецЕсли;
	
КонецФункции

Функция ПрочитатьДвоичныеДанные(ЧтениеДанных, Свойства)
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Поток = Новый ПотокВПамяти(Буфер);
	
	Возврат Поток.ЗакрытьИПолучитьДвоичныеДанные();
	
КонецФункции

Функция ПрочитатьСтроку(ЧтениеДанных, Свойства)
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Поток = Новый ПотокВПамяти(Буфер);
	
	Если Свойства.Тег = 30 Тогда // BMPString
		Кодировка = "utf-16";	
	ИначеЕсли Свойства.Тег = 28 Тогда // UniversalString
		Кодировка = "utf-32";
	Иначе
		Кодировка = "utf-8";	
	КонецЕсли;
	
	ЧтениеТекста = Новый ЧтениеТекста(Поток, Кодировка);
	Строка = ЧтениеТекста.Прочитать();
	ЧтениеТекста.Закрыть();
	Поток.Закрыть();
	
	// Дополнительная защита от ошибок сериализации из-за нечитаемых символов
	Возврат УниверсальныйОбменСБанкамиКлиентСервер.ЗаменитьНечитаемыеСимволы(Строка);
	
КонецФункции

Функция ПрочитатьЦелоеЧисло(ЧтениеДанных, Свойства)
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Значение = 0;
	Для Каждого Байт Из Буфер Цикл
		Значение = Значение * 256 + Байт;
	КонецЦикла;
	
	Возврат Значение;
	
КонецФункции

Функция ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства)
	
	ОбъектныйИдентификатор = Новый Массив;
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Если Буфер[0] < 40 Тогда
		SID1 = 0;
	ИначеЕсли Буфер[0] < 80 Тогда
		SID1 = 1;
	Иначе
		SID1 = 2;
	КонецЕсли;
	ОбъектныйИдентификатор.Добавить(Формат(SID1, "ЧРГ=; ЧГ="));
	
	// SID2
	ОбъектныйИдентификатор.Добавить(Буфер[0] - SID1 * 40);
	
	// Остальные SID
	Для Индекс = 1 По Буфер.Размер - 1 Цикл
		ОбъектныйИдентификатор.Добавить(Формат(ПрочитатьСоставляющуюОбъектногоИдентификатора(Буфер, Индекс), "ЧРГ=; ЧГ="));
	КонецЦикла;
	
	Возврат СтрСоединить(ОбъектныйИдентификатор, ".");
		
КонецФункции

Функция ПрочитатьСоставляющуюОбъектногоИдентификатора(Буфер, ТекущийБайт)
	
	МаскаЗначащиеБиты = 127; // 0111 1111
	МаскаСтаршийБит = 128;   // 1000 0000
	
	Множители = Новый Массив;	
	Пока Истина Цикл
		Байт = Буфер[ТекущийБайт];
		ДлинныйРазмер = Булево(ПобитовоеИ(Буфер[ТекущийБайт], МаскаСтаршийБит));
	 	Если ДлинныйРазмер Тогда
			Множители.Добавить(ПобитовоеИ(Буфер[ТекущийБайт], МаскаЗначащиеБиты));
		Иначе
			Множители.Добавить(Байт);
			Прервать;
		КонецЕсли;
		
		ТекущийБайт = ТекущийБайт + 1;
		Если ТекущийБайт > Буфер.Размер Тогда
			ВызватьИсключение("Ошибка разбора OID");
		КонецЕсли;
	КонецЦикла;
	
	Результат = 0;
	Для Индекс = 0 По Множители.ВГраница() Цикл
		Показатель = Множители.ВГраница() - Индекс;
		Результат = Результат + Множители[Индекс] * Pow(128, Показатель);
	КонецЦикла;

	Возврат Результат;
	
КонецФункции

Функция КлассТегаБлока(Байт)
	
	МаскаКлассБлока = 192; // 1100 0000	
	Класс = ПобитовоеИ(Байт, МаскаКлассБлока);
	
	Если Класс = 0 Тогда
		Возврат "UNIVERSAL";
	ИначеЕсли Класс = 192 Тогда
		Возврат "PRIVATE";
	ИначеЕсли Класс = 64 Тогда
		Возврат "APPLICATION";
	Иначе
		Возврат "CONTEXT-SPECIFIC";
	КонецЕсли;
	
КонецФункции

Функция ТегБлока(Байт)
	
	МаскаТег = 31; // 0001 1111
	Возврат ПобитовоеИ(Байт, МаскаТег);
	
КонецФункции

Функция ПрочитатьСвойстваБлока(ЧтениеДанных, РазмерДанных)
	
	Свойства = Новый Структура;
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(1);
	
	МаскаЗначащиеБиты = 127; // 0111 1111
	МаскаСтаршийБит = 128;   // 1000 0000
	
	Свойства.Вставить("Класс", КлассТегаБлока(Буфер[0]));
	Свойства.Вставить("Тег", ТегБлока(Буфер[0]));
		
	// Прочитать размер блока
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(1);
	Если Буфер[0] = 128 Тогда // Используется потоковый способ кодирования, т.е. размер блока не указан (окончание блока 00 00)
		РазмерБлока = -1;
	Иначе
		ДлинныйРазмер = Булево(ПобитовоеИ(Буфер[0], МаскаСтаршийБит));
		Если ДлинныйРазмер Тогда
			КоличествоБайтовПодРазмер = ПобитовоеИ(Буфер[0], МаскаЗначащиеБиты);
			Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(КоличествоБайтовПодРазмер);
			РазмерБлока = 0;
			Для Каждого Байт Из Буфер Цикл
				РазмерБлока = РазмерБлока * 256 + Байт;
				
				Если РазмерБлока > РазмерДанных Тогда
					ВызватьИсключение("Размер блока превышает размер файла");
				КонецЕсли;
			КонецЦикла;
			
		Иначе
			РазмерБлока = ПобитовоеИ(Буфер[0], МаскаЗначащиеБиты);	
		КонецЕсли;
	КонецЕсли;
	
	Если РазмерБлока > РазмерДанных Тогда
		ВызватьИсключение("Размер блока превышает размер файла");
	КонецЕсли;
	
	Свойства.Вставить("РазмерБлока", РазмерБлока);
	
	Возврат Свойства;
	
КонецФункции

Процедура ПропуститьБлок(ЧтениеДанных, СколькоБайт)
	
	ЧтениеДанных.Пропустить(СколькоБайт);
	
КонецПроцедуры

Процедура ПропуститьДо(ЧтениеДанных, Граница)
	
	ТекущаяПозиция = ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Если ТекущаяПозиция >= Граница Тогда
		Возврат;
	КонецЕсли;
	
	ЧтениеДанных.Пропустить(Граница - ТекущаяПозиция);
	
КонецПроцедуры

Функция ИдентификаторСертификата(Знач Сертификат) Экспорт
	
	Если ТипЗнч(Сертификат) = Тип("СертификатКриптографии") ИЛИ Сертификат.Свойство("СерийныйНомер") Тогда
		СерийныйНомер = Сертификат.СерийныйНомер;
		Издатель = Сертификат.Издатель;
	Иначе
		СертификатКриптографии = Новый СертификатКриптографии(Сертификат.Сертификат);
		СерийныйНомер = СертификатКриптографии.СерийныйНомер;
		Издатель = СертификатКриптографии.Издатель;
	КонецЕсли;		
	
	СписокOID = Новый СписокЗначений;
	Для Каждого OID Из Издатель Цикл
		Если Не СтрНачинаетсяС(OID.Ключ, "OID") Тогда
			Продолжить;
		КонецЕсли;
		СписокOID.Добавить(OID.Значение, СтрЗаменить(Сред(OID.Ключ, 4), "_", "."));
	КонецЦикла;
	
	Ключи = СтрРазделить("2.5.4.3,2.5.4.4,2.5.4.6,2.5.4.7,2.5.4.8,2.5.4.10,2.5.4.11,2.5.4.12,2.5.4.42,1.2.840.113549.1.9.1", ",");
	Свойства = Новый СписокЗначений;
	Для Каждого Элемент Из СписокOID Цикл
		Если Ключи.Найти(Элемент.Представление) <> Неопределено Тогда
			Свойства.Добавить(Элемент.Значение, Элемент.Представление);
		КонецЕсли;
	КонецЦикла;
	
	СерийныйНомерСтрока = НРег(СтрЗаменить(СерийныйНомер, " ", ""));
	
	Свойства.СортироватьПоПредставлению(НаправлениеСортировки.Возр);
	
	МассивЗначений = Свойства.ВыгрузитьЗначения();
	
	МассивЗначений.Добавить(СерийныйНомерСтрока);
	
	ИздательИСерийныйНомер = СтрСоединить(МассивЗначений, "#");
	
	Хеширование = Новый ХешированиеДанных(ХешФункция.SHA1);
	Хеширование.Добавить(ИздательИСерийныйНомер);
	
	Возврат НРег(СтрЗаменить(Хеширование.ХешСумма, " ", ""));	
	
КонецФункции

#КонецОбласти 

#Область ФункцииЧтенияPKCS7

Функция ПрочитатьEnvelopedData(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер); 
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	Версия = ПрочитатьЦелоеЧисло(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	
	СвойстваКриптосообщения.Вставить("Получатели", ПрочитатьRecipientInfos(ЧтениеДанных, СвойстваКриптосообщения, Настройки));
	СвойстваКриптосообщения.Вставить("Тип", "EnvelopedData");
	
	Возврат СвойстваКриптосообщения;

КонецФункции

Функция ПрочитатьSignedData(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер); 
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	Версия = ПрочитатьЦелоеЧисло(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	
	// DigestAlgorithmIdentifiers
	ПропуститьБлок(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер).РазмерБлока);
	
	Если Настройки.ПрочитатьПодписанныеДанные Тогда
		СвойстваКриптосообщения.Вставить("Содержимое", ПрочитатьContentInfo(ЧтениеДанных, СвойстваКриптосообщения));
	Иначе
		СвойстваПоследовательности = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		ПропуститьБлок(ЧтениеДанных, СвойстваПоследовательности.РазмерБлока);
	КонецЕсли;
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	СвойстваКриптосообщения.Вставить("Сертификаты", ПрочитатьCertificates(ЧтениеДанных, СвойстваКриптосообщения, Свойства));
	СвойстваКриптосообщения.Вставить("СпискиОтзываСертификатов", ПрочитатьCertificateRevocationLists(ЧтениеДанных, СвойстваКриптосообщения, Свойства));
	СвойстваКриптосообщения.Вставить("Подписанты", ПрочитатьSignerInfos(ЧтениеДанных, СвойстваКриптосообщения, Свойства, Настройки));
	СвойстваКриптосообщения.Вставить("Тип", "SignedData");
	
	Возврат СвойстваКриптосообщения;
	
КонецФункции

Функция ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения, Свойства = Неопределено, ПроверитьТип = Ложь)
	
	Если Свойства = Неопределено Тогда
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецЕсли;
	КонецБлока = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	Если ПроверитьТип И (Свойства.Класс <> "UNIVERSAL" ИЛИ Свойства.Тег <> 6) Тогда // algorithm OBJECT IDENTIFIER
		Возврат Неопределено;
	КонецЕсли;
	ИдентификаторАлгоритма = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства);
	
	ПропуститьБлок(ЧтениеДанных, КонецБлока - ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
	
	ОбъектныеИдентификаторы = Новый Соответствие;
	ОбъектныеИдентификаторы.Вставить("1.2.643.2.2.9", "GOST R 34.11-94");
	ОбъектныеИдентификаторы.Вставить("1.2.643.2.2.19", "GOST R 34.10-2001");
	
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.1.1", "GOST R 34.10-2012-256");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.1.2", "GOST R 34.10-2012-512");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.2.2", "GOST R 34.11-2012-256");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.2.3", "GOST R 34.11-2012-512");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.3.2", "GOST R 34.10-2012-256 + GOST R 34.11-2012-256");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.3.3", "GOST R 34.10-2012-512 + GOST R 34.11-2012-512");
	
	Идентификатор = ОбъектныеИдентификаторы.Получить(ИдентификаторАлгоритма);
	Если Идентификатор = Неопределено Тогда
		Идентификатор = ИдентификаторАлгоритма;
	КонецЕсли;
	
	Возврат Идентификатор;
	
КонецФункции

Функция ПрочитатьIssuerAndSerialNumber(ЧтениеДанных, СвойстваКриптосообщения, КонецБлока)
	
	Издатель = Новый Структура;
	
	// https://tools.ietf.org/html/rfc5652#section-10.2.4
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	Граница = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	
	Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		Идентификатор = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства);
		
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		Значение = ПрочитатьСтроку(ЧтениеДанных, Свойства);
		
		// В отличии от БРО формируем список OID совместимый с сервисом криптографии
		СоответствиеOIDИмя = СоответствиеOIDИмя();
		Издатель.Вставить(СоответствиеOIDИмя.Получить(Идентификатор), Значение);
	КонецЦикла;
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	ИздательСерийныйНомер = Новый Структура;
	ИздательСерийныйНомер.Вставить("СерийныйНомер", ПрочитатьДвоичныеДанные(ЧтениеДанных, Свойства));
	ИздательСерийныйНомер.Вставить("Издатель", Издатель);
	ИздательСерийныйНомер.Вставить("Идентификатор", ИдентификаторСертификата(ИздательСерийныйНомер));
	
	ПропуститьБлок(ЧтениеДанных, КонецБлока - ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
	
	Возврат ИздательСерийныйНомер;
	
КонецФункции

Функция СоответствиеOIDИмя()
	
	СоответствиеOID = Новый Соответствие;
	СоответствиеOID.Вставить("2.5.4.3", "CN"); // commonName
	СоответствиеOID.Вставить("2.5.4.6", "C"); // countryName
	СоответствиеOID.Вставить("2.5.4.8", "ST"); // stateOrProvinceName
	СоответствиеOID.Вставить("2.5.4.7", "L"); // localityName
	СоответствиеOID.Вставить("2.5.4.9", "STREET"); // streetAddress
	СоответствиеOID.Вставить("2.5.4.10", "O"); // organizationName
	СоответствиеOID.Вставить("2.5.4.11", "OU"); // organizationUnitName
	СоответствиеOID.Вставить("2.5.4.12", "T"); // title
	СоответствиеOID.Вставить("1.2.643.100.1", "OGRN"); // ОГРН
	СоответствиеOID.Вставить("1.2.643.100.5", "OGRNIP"); // ОГРНИП
	СоответствиеOID.Вставить("1.2.643.100.3", "SNILS"); // СНИЛС
	СоответствиеOID.Вставить("1.2.643.3.131.1.1", "INN"); // ИНН
	СоответствиеOID.Вставить("1.2.840.113549.1.9.1", "E"); // emailAddress	
	СоответствиеOID.Вставить("2.5.4.4", "SN"); // surname
	СоответствиеOID.Вставить("2.5.4.42", "GN"); // givenName
	
	Возврат СоответствиеOID;
	
КонецФункции

Функция ПрочитатьRecipientInfos(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	Получатели = Новый Массив;
		
	СвойстваНабора = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	Граница = СвойстваНабора.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	
	Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл
		Получатели.Добавить(ПрочитатьRecipientInfo(ЧтениеДанных, СвойстваКриптосообщения, Настройки));
	КонецЦикла;
	
	Возврат Получатели;
	
КонецФункции

Функция ПрочитатьRecipientInfo(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецБлокаRecipientInfo = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Версия = ПрочитатьЦелоеЧисло(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Получатель = ПрочитатьIssuerAndSerialNumber(
			ЧтениеДанных,
			СвойстваКриптосообщения,
			Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
		
	Иначе
		ПропуститьБлок(ЧтениеДанных, Свойства.РазмерБлока);
		Получатель = Новый Структура;
	КонецЕсли;
	
	Если Настройки.ПрочитатьАлгоритмПубличногоКлюча Тогда
		Получатель.Вставить("АлгоритмПубличногоКлюча", ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения));
	КонецЕсли;
	ПропуститьБлок(ЧтениеДанных, КонецБлокаRecipientInfo - ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
	
	Возврат Получатель;
	
КонецФункции

Функция ПрочитатьContentInfo(ЧтениеДанных, СвойстваКриптосообщения)
	
	Содержимое = Base64Значение("");
	
	СвойстваПоследовательности = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	Если СвойстваПоследовательности.РазмерБлока > 11 Тогда
		Тип = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		Содержимое = ПрочитатьДвоичныеДанные(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	Иначе
		ПропуститьБлок(ЧтениеДанных, СвойстваПоследовательности.РазмерБлока);
	КонецЕсли;
	
	Возврат Содержимое;
	
КонецФункции

Функция ПрочитатьSignerInfos(ЧтениеДанных, СвойстваКриптосообщения, СвойстваНабора, Настройки)
	
	СертификатыСИдентификаторами = Новый Соответствие;
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Для Каждого Сертификат Из СвойстваКриптосообщения.Сертификаты Цикл
			СертификатыСИдентификаторами.Вставить(ИдентификаторСертификата(Новый Структура("Сертификат", Сертификат)), Сертификат);
		КонецЦикла;
	КонецЕсли;

	Подписанты = Новый Массив;
	
	Граница = СвойстваНабора.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	
	Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл
		Подписанты.Добавить(ПрочитатьSignerInfo(ЧтениеДанных, СвойстваКриптосообщения, СертификатыСИдентификаторами, Настройки));
	КонецЦикла;
	
	Возврат Подписанты;
	
КонецФункции

Функция ПрочитатьSignerInfo(ЧтениеДанных, СвойстваКриптосообщения, СертификатыСИдентификаторами, Настройки)
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецБлокаSignerInfo = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Версия = ПрочитатьЦелоеЧисло(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	Подписант = Новый Структура;
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		ИздательСерийныйНомер = ПрочитатьIssuerAndSerialNumber(
			ЧтениеДанных, СвойстваКриптосообщения, Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
		
		Подписант.Вставить("Сертификат", ИздательСерийныйНомер);
		
		Сертификат = СертификатыСИдентификаторами.Получить(Подписант.Сертификат.Идентификатор);
		Если ЗначениеЗаполнено(Сертификат) Тогда
			Подписант.Сертификат.Вставить("Сертификат", Сертификат);
		КонецЕсли;
		
	Иначе
		ПропуститьБлок(ЧтениеДанных, Свойства.РазмерБлока);
	КонецЕсли;
	
	Подписант.Вставить("АлгоритмХеширования", ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения));
	
	ПодписанныеАтрибуты = ПрочитатьAuthenticatedAttributes(ЧтениеДанных, СвойстваКриптосообщения, Свойства, Настройки);
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Подписант.Вставить("ПодписанныеАтрибуты", ПодписанныеАтрибуты);
	КонецЕсли;
	
	Подписант.Вставить("АлгоритмПодписи", ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения, Свойства));
	Подпись = ПрочитатьДвоичныеДанные(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	
	НеподписанныеАтрибуты = ПрочитатьUnauthenticatedAttributes(ЧтениеДанных, СвойстваКриптосообщения, Свойства);
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Подписант.Вставить("НеподписанныеАтрибуты", НеподписанныеАтрибуты);
	КонецЕсли;
	
	Возврат Подписант;
	
КонецФункции

Функция ПрочитатьCertificates(ЧтениеДанных, СвойстваКриптосообщения, СвойстваБлока)
	
	Граница = СвойстваБлока.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();

	Сертификаты = Новый Массив;
	
	// certificates [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 0 Тогда
		Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл 
			Сертификат = ПрочитатьДвоичныеДанные(ЧтениеДанных, СвойстваБлока);
			Сертификаты.Добавить(Сертификат);
		КонецЦикла;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецЕсли;
	
	Возврат Сертификаты;
	
КонецФункции

Функция ПрочитатьCertificateRevocationLists(ЧтениеДанных, СвойстваКриптосообщения, СвойстваБлока)
	
	Граница = СвойстваБлока.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();

	СпискиОтзываСертификатов = Новый Массив;
	
	// crls  [1] IMPLICIT CertificateRevocationLists OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 1 Тогда
		Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл 
			СписокОтзываСертификатов = ПрочитатьДвоичныеДанные(ЧтениеДанных, СвойстваБлока);
			СпискиОтзываСертификатов.Добавить(СписокОтзываСертификатов);
		КонецЦикла;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецЕсли;
	
	Возврат СпискиОтзываСертификатов;
	
КонецФункции

Функция ПрочитатьAuthenticatedAttributes(ЧтениеДанных, СвойстваКриптосообщения, СвойстваБлока, Настройки)
	
	ПодписанныеАтрибуты = Новый Структура;
	СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	// authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 0 Тогда
		ГраницаБлока = СвойстваБлока.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
		Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
			Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < ГраницаБлока Цикл
				СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
				КонецБлока = ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() + СвойстваБлока.РазмерБлока;
				Идентификатор = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
				Если Идентификатор = "1.2.840.113549.1.9.5" Тогда // signingTime
					ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
					ПодписанныеАтрибуты.Вставить(
						"ВремяПодписания", 
						ПрочитатьДату(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер))); 
				Иначе
					ПропуститьДо(ЧтениеДанных, КонецБлока);
				КонецЕсли;
			КонецЦикла;
			
		Иначе
			ПропуститьДо(ЧтениеДанных, ГраницаБлока);
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецЕсли;
	
	Возврат ПодписанныеАтрибуты;
	
КонецФункции

Функция ПрочитатьUnauthenticatedAttributes(ЧтениеДанных, СвойстваКриптосообщения, СвойстваБлока)
	
	НеподписанныеАтрибуты = Новый Структура;
	
	Если ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() >= СвойстваКриптосообщения.Размер Тогда
		Возврат НеподписанныеАтрибуты;
	КонецЕсли;
	
	СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	// unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 1 Тогда
		ПропуститьБлок(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер).РазмерБлока);
	КонецЕсли;
	
	Возврат НеподписанныеАтрибуты;
	
КонецФункции

#КонецОбласти

