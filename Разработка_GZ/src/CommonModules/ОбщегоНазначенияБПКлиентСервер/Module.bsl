
////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ОШИБКАМИ

// Функция убирает из текста сообщения служебную информацию.
//
// Параметры
//  ТекстСообщения - Строка - Исходный текст сообщения.
//
// Возвращаемое значение:
//   Строка - Текст сообщения без служебной информации.
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = СтрНайти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = СтрНайти(ТекстСообщения, "}:");

	Если ОкончаниеСлужебногоСообщения > 0
		И НачалоСлужебногоСообщения > 0
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда

		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));

	КонецЕсли;

	Возврат СокрЛП(ТекстСообщения);

КонецФункции

// Возвращает строковое представление незаполненного значения, принятое в конфигурации.
// Возвращаемое значение:
//  Строка
Функция ПредставлениеНезаполненногоЗначения() Экспорт
	
	Возврат "<...>";
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// МАТЕМАТИКА

// Выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения.
//
// Параметры:
//  РаспределяемаяСумма - Число - сумма, которую надо распределить;
//  Коэффициенты - Массив - коэффициенты распределения;
//  Точность - Число - точность округления при распределении. Необязателен.
//
// Возвращаемое значение:
//  Массив - массив размерностью равный массиву коэффициентов, содержит
//           суммы в соответствии с весом коэффициента (из массива коэффициентов).
//           В случае если распределить не удалось (сумма = 0, кол-во коэффициентов = 0,
//           или суммарный вес коэффициентов = 0), тогда возвращается значение Неопределено.
//
Функция РаспределитьПропорционально(Знач РаспределяемаяСумма, Знач Коэффициенты, Знач Точность = 2) Экспорт

	Если Коэффициенты.Количество() = 0 Или Не ЗначениеЗаполнено(РаспределяемаяСумма) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ИндексМаксимальногоКоэффициента = 0;
	МаксимальныйКоэффициент = 0;
	РаспределеннаяСумма = 0;
	СуммаКоэффициентов  = 0;
	
	Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
		Коэффициент = Коэффициенты[Индекс];
		
		АбсолютноеЗначениеКоэффициента = ?(Коэффициент > 0, Коэффициент, -Коэффициент);
		Если МаксимальныйКоэффициент < АбсолютноеЗначениеКоэффициента Тогда
			МаксимальныйКоэффициент = АбсолютноеЗначениеКоэффициента;
			ИндексМаксимальногоКоэффициента = Индекс;
		КонецЕсли;
		
		СуммаКоэффициентов = СуммаКоэффициентов + Коэффициент;
	КонецЦикла;
	
	Если СуммаКоэффициентов = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Результат = Новый Массив(Коэффициенты.Количество());
	
	Для Индекс = 0 По Коэффициенты.Количество() - 1 Цикл
		Результат[Индекс] = Окр(РаспределяемаяСумма * Коэффициенты[Индекс] / СуммаКоэффициентов, Точность, 1);
		РаспределеннаяСумма = РаспределеннаяСумма + Результат[Индекс];
	КонецЦикла;
	
	Дельта = РаспределяемаяСумма - РаспределеннаяСумма;
	
	Если Дельта > 0 Тогда 
		
		// Погрешности округления отнесем на коэффициент с максимальным весом.
		Если Не РаспределеннаяСумма = РаспределяемаяСумма Тогда
			Результат[ИндексМаксимальногоКоэффициента] = Результат[ИндексМаксимальногоКоэффициента] + Дельта;
		КонецЕсли;
		
	ИначеЕсли Дельта < 0 Тогда 
		
		// Если распределили больше чем положено, размазываем погрешность по ближайшим максимальным весам.
		ЗначениеПогрешности = 1 / Pow(10, Точность);
		КоличествоЭлементовПогрешности = -Дельта / ЗначениеПогрешности;
		
		КоэффициентыРешето = Новый Массив(Новый ФиксированныйМассив(Коэффициенты));
		
		Для Сч = 1 По КоличествоЭлементовПогрешности Цикл 
			МаксимальныйКоэффициент = МаксимальноеЗначениеВМассиве(КоэффициентыРешето);
			Индекс = КоэффициентыРешето.Найти(МаксимальныйКоэффициент);
			Результат[Индекс] = Результат[Индекс] - ЗначениеПогрешности;
			КоэффициентыРешето[Индекс] = 0;
		КонецЦикла;
		
	Иначе 
		// Если Дельта = 0, то все идеально.
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

Функция МаксимальноеЗначениеВМассиве(Массив)
	
	// Рассчитываем, что на вход будет получен массив, в котором все элементы либо все положительные, либо отрицательные.
	// Поэтому для определения максимального значения сравниваем абсолютное значение элемента.
	//
	// В случае, если на вход получен массив, в котором элементы с разными знаками, то максимальное значение будет
	// определено не правильно. Но этот случай оставлен для совместимости с предыдущими версиями.
	
	МаксимальноеЗначение = 0;
	Множитель            = 1;
	Для Индекс = 0 По Массив.Количество() - 1 Цикл
		Значение = Массив[Индекс];
		АбсолютноеЗначение = ?(Значение> 0, Значение, -Значение);
		Если МаксимальноеЗначение < АбсолютноеЗначение Тогда
			МаксимальноеЗначение = АбсолютноеЗначение;
			Множитель = ?(Значение > 0, 1, -1);
		КонецЕсли;
	КонецЦикла;
	
	Возврат МаксимальноеЗначение * Множитель;
	
КонецФункции

// Определяет знак числа, например, для определения, что знаки двух чисел совпадают или не совпадают.
//
// Параметры:
//  Значение - Число - проверяемое число
// 
// Возвращаемое значение:
//  Число - -1 для отрицательных, 1 для положительных, 0 для нуля
//
Функция ЗнакЧисла(Значение) Экспорт
	
	Если Значение > 0 Тогда
		Возврат 1;
	ИначеЕсли Значение < 0 Тогда
		Возврат -1;
	Иначе
		Возврат 0;
	КонецЕсли;
	
КонецФункции

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип - Тип - Тип, пустое значение которого нужно получить.
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт

	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;

	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";

	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';

	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;

	Иначе
		Возврат Новый (ЗаданныйТип);

	КонецЕсли;

КонецФункции // ПустоеЗначениеТипа();

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С МАССИВАМИ

// Удаление из массива пустых элементов
//
// Параметры:
//   МассивЭлементов - Массив
//
Процедура УдалитьНеЗаполненныеЭлементыМассива(МассивЭлементов) Экспорт

	Колво = МассивЭлементов.Количество();
	Для н=1 По Колво Цикл
		Если НЕ ЗначениеЗаполнено(МассивЭлементов[Колво-н]) Тогда
			МассивЭлементов.Удалить(Колво-н);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Функция проверяет, что две переданные даты находятся между разными элементами 
// упорядоченного массива.
//
// Параметры:
//	Дата1 Дата2 - Дата - Две даты, которые необходимо проверить.
//	ИнтервалДат - Массив - Упорядоченный массив дат, каждый элемент которого определяет
//							новую границу интервала.
//
Функция ДатыПринадлежатРазнымИнтервалам(Знач Дата1, Знач Дата2, ИнтервалДат) Экспорт

	Результат = Ложь;

	Индекс1 = -1;
	
	Индекс2 = -1;
	
	Дата1 = НачалоДня(Дата1);
	Дата2 = НачалоДня(Дата2);
	
	ВГраницаИнтервалаДат = ИнтервалДат.ВГраница();
	Для ТекИндекс = 0 По ВГраницаИнтервалаДат Цикл
		ДатаИнтервала = НачалоДня(ИнтервалДат[ТекИндекс]);
	
		Если ДатаИнтервала <= Дата1 Тогда
			Индекс1 = ТекИндекс;
		КонецЕсли;
		
		Если ДатаИнтервала <= Дата2 Тогда
			Индекс2 = ТекИндекс;
		КонецЕсли;
		
	КонецЦикла;

	Если Индекс1 <> Индекс2 Тогда
		Результат = Истина;
	Иначе
		Результат = Ложь;
	КонецЕсли;

	Возврат Результат;

КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ФУНКЦИОНАЛЬНЫМИ ОПЦИЯМИ

// Процедура устанавливает функциональные опции формы.
//
// Параметры:
//	Форма - ФормаКлиентскогоПриложения - Форма, в которой требуется установить функциональные опции.
//	Организация - СправочникСсылка.Организации - Ссылка на организацию.
//	Период - Дата - Дата установки периодических опций.
//
Процедура УстановитьПараметрОрганизацияФункциональныхОпцийФормы(Форма, Организация, Период = Неопределено) Экспорт

	ПараметрыФО = Новый Структура();
	ПараметрыФО.Вставить("Организация", Организация);
	Если Период <> Неопределено Тогда
		ПараметрыФО.Вставить("Период", ОбщегоНазначенияБПВызовСервера.ПериодНастройкиСистемыНалогообложения(Организация, Период));
	КонецЕсли;
	
	Форма.УстановитьПараметрыФункциональныхОпцийФормы(ПараметрыФО);
	
КонецПроцедуры

// Процедура устанавливает функциональные опции формы документа.
//
// Параметры:
//	Форма - ФормаКлиентскогоПриложения - Форма, в которой требуется установить функциональные опции.
//
Процедура УстановитьПараметрыФункциональныхОпцийФормыДокумента(Форма) Экспорт
	
	УстановитьПараметрОрганизацияФункциональныхОпцийФормы(Форма, Форма.Объект.Организация, Форма.Объект.Дата);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////

// Функция возвращает текст надписи "Цены и валюта".
//
Функция СформироватьНадписьЦеныИВалюта(СтруктураНадписи) Экспорт
	Перем ВалютаРегламентированногоУчета;
	
	ТекстНадписи = "";
	
	Если НЕ СтруктураНадписи.Свойство("ВалютаРегламентированногоУчета", ВалютаРегламентированногоУчета) Тогда
		ВалютаРегламентированногоУчета = ОбщегоНазначенияБПВызовСервераПовтИсп.ПолучитьВалютуРегламентированногоУчета();
	КонецЕсли;
	
	// Тип цен
	Если СтруктураНадписи.Свойство("ТипЦен")
		И ЗначениеЗаполнено(СтруктураНадписи.ТипЦен) Тогда
		ТекстНадписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Тип цен: %1 '"), СтруктураНадписи.ТипЦен);
	КонецЕсли;
		
	// НДС в сумме
	Если СтруктураНадписи.Свойство("НДСНеВыделять") 
		И СтруктураНадписи.НДСНеВыделять Тогда 
		ТекстНадписи = ТекстНадписи + ?(ПустаяСтрока(ТекстНадписи), НСтр("ru = 'НДС не выделять'"), НСтр("ru = '(НДС не выделять)'"));
	ИначеЕсли СтруктураНадписи.Свойство("ДокументБезНДС") 
		И СтруктураНадписи.ДокументБезНДС Тогда 
		ТекстНадписи = ТекстНадписи + ?(ПустаяСтрока(ТекстНадписи), НСтр("ru = 'Документ без НДС'"), НСтр("ru = '(Документ без НДС)'"));
	ИначеЕсли СтруктураНадписи.Свойство("СуммаВключаетНДС") Тогда
		Если СтруктураНадписи.СуммаВключаетНДС Тогда
			ТекстНадписи = ТекстНадписи + ?(ПустаяСтрока(ТекстНадписи), НСтр("ru = 'НДС в сумме'"), НСтр("ru = '(НДС в сумме)'")); 
		Иначе
			ТекстНадписи = ТекстНадписи + ?(ПустаяСтрока(ТекстНадписи), НСтр("ru = 'НДС сверху'"), НСтр("ru = '(НДС сверху)'")); 
		КонецЕсли;
	КонецЕсли;

	// Валюта
	Если СтруктураНадписи.Свойство("ВалютаДокумента")
		И ЗначениеЗаполнено(СтруктураНадписи.ВалютаДокумента) Тогда
		Если СтруктураНадписи.ВалютаДокумента <> ВалютаРегламентированногоУчета Тогда
			ТекстНадписи = ТекстНадписи + ?(ПустаяСтрока(ТекстНадписи), "", ", ") + НСтр("ru = '%1%2 = %3 %4'");
			ТекстНадписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				ТекстНадписи,
				?(СтруктураНадписи.Кратность = 1, "", СтруктураНадписи.Кратность),
				СтруктураНадписи.ВалютаДокумента,
				СтруктураНадписи.Курс,
				ВалютаРегламентированногоУчета);
		ИначеЕсли СтруктураНадписи.Свойство("ЕстьВалютныйУчет") И СтруктураНадписи.ЕстьВалютныйУчет Тогда
			ТекстНадписи = ТекстНадписи + ?(ПустаяСтрока(ТекстНадписи), "", ", ") + НСтр("ru = '%1'");
			ТекстНадписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				ТекстНадписи, СтруктураНадписи.ВалютаДокумента);
		КонецЕсли;
	КонецЕсли;
		
	БезНДС = (СтруктураНадписи.Свойство("ДокументБезНДС") И СтруктураНадписи.ДокументБезНДС)
			ИЛИ  СтруктураНадписи.Свойство("НДСНеВыделять") И СтруктураНадписи.НДСНеВыделять;

	// Включение НДС в стоимость
	Если СтруктураНадписи.Свойство("НДСВключенВСтоимость") И НЕ БезНДС Тогда
		Если СтруктураНадписи.НДСВключенВСтоимость Тогда
			ТекстНадписи = ТекстНадписи + ?(ПустаяСтрока(ТекстНадписи), "", ", ") + НСтр("ru = 'НДС включен в стоимость'"); 
		КонецЕсли;
	КонецЕсли;
	
	Если ПустаяСтрока(ТекстНадписи) Тогда 
		Если СтруктураНадписи.Свойство("ТипЦен") Тогда
			ТекстНадписи = НСтр("ru = 'Тип цен: <нет> '");
		ИначеЕсли СтруктураНадписи.Свойство("ВалютаДокумента") Тогда
			Если ЗначениеЗаполнено(СтруктураНадписи.ВалютаДокумента) Тогда
				ТекстНадписи = НСтр("ru = 'Валюта: %1'");
				ТекстНадписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ТекстНадписи, ВалютаРегламентированногоУчета);
			Иначе
				ТекстНадписи = НСтр("ru = 'Валюта: <нет> '");
			КонецЕсли;
		ИначеЕсли СтруктураНадписи.Свойство("НДСВключенВСтоимость")
			И НЕ БезНДС Тогда
			ТекстНадписи = НСтр("ru = 'НДС не включен в стоимость'");
		КонецЕсли;
	КонецЕсли;
		
	Возврат ТекстНадписи;

КонецФункции

// Функция возвращает текст надписи счетов доходов и расходов для вывода на форме.
//
// Параметры:
//	СчетДоходов - ПланСчетовСсылка.Хозрасчетный
//	СчетРасходов - ПланСчетовСсылка.Хозрасчетный
//	Субконто - ПланВидовХарактеристикСсылка.ВидыСубконтоХозрасчетные
//
// Возвращаемое значение:
//	Строка
//
Функция СформироватьНадписьСчетаУчетаДоходовИРасходов(СчетДоходов, СчетРасходов, Субконто) Экспорт

	Если ЗначениеЗаполнено(СчетДоходов) Тогда
		ТекстСчетДоходов = БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(СчетДоходов).Код;
	Иначе
		ТекстСчетДоходов = ПредставлениеНезаполненногоЗначения();
	КонецЕсли;
	
	Если ЗначениеЗаполнено(СчетРасходов) Тогда
		ТекстСчетРасходов = БухгалтерскийУчетВызовСервераПовтИсп.ПолучитьСвойстваСчета(СчетРасходов).Код;
	Иначе
		ТекстСчетРасходов = ПредставлениеНезаполненногоЗначения();
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Субконто) Тогда
		ТекстСубконто = Строка(Субконто);
	Иначе
		ТекстСубконто = ПредставлениеНезаполненногоЗначения();
	КонецЕсли;
	
	ТекстНадписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
		"%1, %2 %3", ТекстСчетДоходов, ТекстСчетРасходов, ТекстСубконто);
	
	Возврат ТекстНадписи;

КонецФункции

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СПИСКАМИ

// Функция формирует список доступных способов расчета комиссионного вознаграждения, 
// в зависимости от типа комиссиионного договора
//
Функция СформироватьСписокСпособовРасчетаКомиссионногоВознаграждения(ЭтоКомиссияПоЗакупке) Экспорт

	СписокСпособов = Новый СписокЗначений;
	
	СписокСпособов.Добавить(ПредопределенноеЗначение("Перечисление.СпособыРасчетаКомиссионногоВознаграждения.НеРассчитывается"), НСтр("ru = 'Не рассчитывается'"));
	
	Если ЭтоКомиссияПоЗакупке Тогда
		СписокСпособов.Добавить(ПредопределенноеЗначение("Перечисление.СпособыРасчетаКомиссионногоВознаграждения.ПроцентОтСуммыПродажи"), НСтр("ru = 'Процент от суммы закупки'"));
	Иначе
		СписокСпособов.Добавить(ПредопределенноеЗначение("Перечисление.СпособыРасчетаКомиссионногоВознаграждения.ПроцентОтРазностиСуммПродажиИПоступления"), НСтр("ru = 'Процент от разности сумм продажи и поступления'"));
		СписокСпособов.Добавить(ПредопределенноеЗначение("Перечисление.СпособыРасчетаКомиссионногоВознаграждения.ПроцентОтСуммыПродажи"), НСтр("ru = 'Процент от суммы продажи'"));
	КонецЕсли;

	Возврат СписокСпособов;

КонецФункции // СформироватьСписокСпособовРасчетаКомиссионногоВознаграждения()

////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС ПОЛЯ ВЫБОРА ОРГАНИЗАЦИИ С ОБОСОБЛЕННЫМИ ПОДРАЗДЕЛЕНИЯМИ
//

// Устанавливает значение поля организации.
//
// Параметры:
//	ПолеОрганизация - РеквизитФормы - Реквизит формы, в котором нужно установить значение.
//	Организация - СправочникСсылка.Организации - Организация, для которой нужно установить реквизит.
//	ВключатьОбособленныеПодразделения - Булево - Признак, что нужно включать обособленные подразделения.
//
Процедура УстановитьЗначениеПолеОрганизация(ПолеОрганизация, Организация, ВключатьОбособленныеПодразделения) Экспорт
	
	Ключ = СтрЗаменить(Строка(ВключатьОбособленныеПодразделения) + Организация.УникальныйИдентификатор(), "-", "");
	ПолеОрганизация = Ключ;
	
КонецПроцедуры

// Устанавливает значения выбранных реквизитов при отказе от выбора значения (выборе пустого значения).
//
// Параметры:
//	ПолеОрганизация - РеквизитФормы - Реквизит формы, в котором нужно установить значение.
//	Организация - СправочникСсылка.Организации - Организация, для которой нужно установить реквизит.
//	ВключатьОбособленныеПодразделения - Булево - Признак, что нужно включать обособленные подразделения.
//
Процедура ОбработкаОтменыВыбораОрганизации(ПолеОрганизация, Организация, ВключатьОбособленныеПодразделения) Экспорт
	
	Если ЗначениеЗаполнено(ПолеОрганизация) Тогда 
		Возврат;
	КонецЕсли;
	
	Организация                       = Неопределено;
	ВключатьОбособленныеПодразделения = Ложь;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СТРОКОВЫЕ ФУНКЦИИ

// Капитализирует строку - приводит к принятому в полных предложениях написанию:
// первый символ в верхнем регистре, остальные - без изменения.
// Например:
//  "это тест"      -> "Это тест"
//  "тест Тьюринга" -> "Тест Тьюринга"
//  "/test.txt"     -> "/test.txt"
//
// Параметры:
//  ИсходнаяСтрока - Строка - строка, текст полного предложения.
// 
// Возвращаемое значение:
//  Строка - капитализированная строка.
//
Функция КапитализироватьСтроку(ИсходнаяСтрока) Экспорт
	Возврат ВРег(Лев(ИсходнаяСтрока, 1)) + Сред(ИсходнаяСтрока, 2);
КонецФункции

// Декапитализирует строку - изменяет регистр первого символа с верхнего на нижний.
// первый символ в нижнем регистре, остальные - без изменения.
// Например:
//  "Это тест"      -> "это тест"
//  "тест Тьюринга" -> "тест Тьюринга"
//  "/test.txt"     -> "/test.txt"
//
// Параметры:
//  ИсходнаяСтрока - Строка - строка, текст полного предложения.
// 
// Возвращаемое значение:
//  Строка - декапитализированная строка.
//
Функция ДекапитализироватьСтроку(ИсходнаяСтрока) Экспорт
	Возврат НРег(Лев(ИсходнаяСтрока, 1)) + Сред(ИсходнаяСтрока, 2);
КонецФункции

// Функция возвращает строку, которая содержит только цифры из исходной строки.
//
// Параметры:
//	ИсходнаяСтрока - Строка - Исходная строка.
//
// Возвращаемое значение:
//	Строка - Строка, содержащая только цифры.
//
Функция ОставитьВСтрокеТолькоЦифры(ИсходнаяСтрока) Экспорт
	
	СтрокаРезультат = "";
	
	Для а = 1 По СтрДлина(ИсходнаяСтрока) Цикл
		ТекущийСимвол = Сред(ИсходнаяСтрока, а, 1);
		КодСимвола = КодСимвола(ТекущийСимвол);
		Если КодСимвола >= 48 И КодСимвола <= 57 Тогда
			СтрокаРезультат = СтрокаРезультат + ТекущийСимвол;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрокаРезультат;
	
КонецФункции

// Функция преобразует строку к множественному числу
//
// Параметры: 
//  Слово1 - форма слова в ед числе      ("шкаф")
//  Слово2 - форма слова для числит 2-4  ("шкафа")
//  Слово3 - форма слова для числит 5-10 ("шкафов")
//  ЦелоеЧисло - целое число
//
// Возвращаемое значение:
//  строку - одну из строк в зависимости от параметра ЦелоеЧисло
//
// Описание:
//  Предназначена для формирования "правильной" подписи к числительным
//
Функция ФормаМножественногоЧисла(Слово1, Слово2, Слово3, Знач ЦелоеЧисло) Экспорт
	
	// Изменим знак целого числа, иначе отрицательные числа будут неправильно преобразовываться
	Если ЦелоеЧисло < 0 Тогда
		ЦелоеЧисло = -1 * ЦелоеЧисло;
	КонецЕсли;
	
	Если ЦелоеЧисло <> Цел(ЦелоеЧисло) Тогда 
		// для нецелых чисел - всегда вторая форма
		Возврат Слово2;
	КонецЕсли;
	
	// остаток
	Остаток = ЦелоеЧисло%10;
	Если (ЦелоеЧисло >10) И (ЦелоеЧисло<20) Тогда
		// для второго десятка - всегда третья форма
		Возврат Слово3;
	ИначеЕсли Остаток=1 Тогда
		Возврат Слово1;
	ИначеЕсли (Остаток>1) И (Остаток<5) Тогда
		Возврат Слово2;
	Иначе
		Возврат Слово3;
	КонецЕсли;

КонецФункции

// Склоняет представление месяца.
//
// Параметры:
// 	Период 	     - Дата - дата в месяце, который нужно просклонять.
// 	Падеж        - Число - падеж, в который необходимо просклонять представление объекта.
//                  			1 - Именительный.
//                  			2 - Родительный.
//                  			3 - Дательный.
//                  			4 - Винительный.
//                  			5 - Творительный.
//                  			6 - Предложный.
//  ДобавлятьГод - Булево - признак, что к представлению месяца нужно добавлять 4 цифры года.
//
// Возвращаемое значение:
//   Строка      - представление месяца в нужном падеже.
//
Функция ФормаПадежаМесяца(Период, Падеж, ДобавлятьГод = Истина) Экспорт
	
	Если Падеж = 1 Или Падеж = 4 Тогда
		
		ПредставлениеМесяца = Формат(Период, ?(ДобавлятьГод, "Л=ru; ДФ='ММММ гггг'", "Л=ru; ДФ=ММММ"));
		Возврат ПредставлениеМесяца;
		
	КонецЕсли;
	
	ПредставлениеМесяца = Формат(Период, "Л=ru; ДФ=ММММ");
	НомерМесяца = Месяц(Период);
	
	Если НомерМесяца = 3 Или НомерМесяца = 8 Тогда
		
		СменитьОкончание = Ложь;
		Если Падеж = 3 Тогда
			ОкончаниеПадежа = НСтр("ru = 'у'");
		ИначеЕсли Падеж = 5 Тогда	
			ОкончаниеПадежа = НСтр("ru = 'ом'");
		ИначеЕсли Падеж = 6 Тогда
			ОкончаниеПадежа = НСтр("ru = 'е'");
		Иначе // Падеж = 2
			ОкончаниеПадежа = НСтр("ru = 'а'");
		КонецЕсли;
		
	Иначе
	 
		СменитьОкончание = Истина;
		Если Падеж = 3 Тогда
			ОкончаниеПадежа = НСтр("ru = 'ю'");
		ИначеЕсли Падеж = 5 Тогда	
			ОкончаниеПадежа = НСтр("ru = 'ем'");
		ИначеЕсли Падеж = 6 Тогда
			ОкончаниеПадежа = НСтр("ru = 'е'");
		Иначе // Падеж = 2
			ОкончаниеПадежа = НСтр("ru = 'я'");
		КонецЕсли;
		
	КонецЕсли;
	
	Если СменитьОкончание Тогда
		ПредставлениеМесяца = Лев(ПредставлениеМесяца, СтрДлина(ПредставлениеМесяца) - 1);
	КонецЕсли;
	
	ПредставлениеМесяца = ПредставлениеМесяца + ОкончаниеПадежа
		+ ?(ДобавлятьГод, Символы.НПП + Формат(Период, "Л=ru; ДФ=гггг"), "");
	
	Возврат ПредставлениеМесяца;
	
КонецФункции

Функция ТолькоНулиВСтроке(Строка) Экспорт
	
	ЗначащиеСимволы = СокрЛП(СтрЗаменить(Строка, "0", ""));
	Возврат ПустаяСтрока(ЗначащиеСимволы);
	
КонецФункции

Функция ПривестиСтроку(Строка, ОписаниеТипов) Экспорт
	
	Если ОписаниеТипов.Типы().Количество() <> 1 Тогда
		Значение = Строка;
	ИначеЕсли ОписаниеТипов.СодержитТип(Тип("Строка")) Тогда
		Значение = Строка;
	Иначе
		
		Если ОписаниеТипов.СодержитТип(Тип("Дата")) Тогда
			// Приведение строки в формате "dd.MM.yyyy" к дате платформой не обеспечивается
			Значение = ПривестиСтрокуКДате(Строка);
		ИначеЕсли ОписаниеТипов.СодержитТип(Тип("Число")) Тогда
			// Используем более гибкое приведение строки к числу, чем обеспечивается платформой.
			// Символ "=" считаем допустимым десятичным разделителем.
			Значение = СтроковыеФункцииКлиентСервер.СтрокаВЧисло(СтрЗаменить(Строка, "=", "."));
		КонецЕсли;
	
		Если Значение = Неопределено Тогда
			Значение = Строка;
		КонецЕсли;
		
	КонецЕсли;
		
	Возврат ОписаниеТипов.ПривестиЗначение(Значение);
	
КонецФункции

// Приводит к дате строку в формате к дате дату в формате "dd.MM.yyyy" 
Функция ПривестиСтрокуКДате(Строка) Экспорт
	
	Если ПустаяСтрока(Строка) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ЭлементыДаты = СтрРазделить(Строка, ".");
	Если ЭлементыДаты.Количество() <> 3 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	День  = ЭлементыДаты[0];
	Месяц = ЭлементыДаты[1];
	Год   = ЭлементыДаты[2];
	
	Если СтрДлина(Год) = 2 Тогда
		// Преобразование выполняем самое простое. Это поведение может не соответствовать поведению платформы.
		Год = "20" + Год;
	КонецЕсли;
	
	Попытка
		Возврат Дата(Год, Месяц, День);
	Исключение
		Возврат Неопределено;
	КонецПопытки;
	
КонецФункции

// Возвращает строковое представление предмета или массива предметов.
//
// Параметры:
//  Предмет - Строка - Параметры прописи предмета в представлении.
//  СигнатураПредмета - Строка - Подстрока, идентифицирующая начало строкового представления предмета.
//  ПервыйПредметСписка - Произвольный - Ссылка на первый предмет из списка, который будет выведен в представлении.
//  КоличествоПредметов - Число - Количество ссылок на предметы в списке.
//  ФорматнаяСтрока - Строка - Строка, определяющая параметры форматирования представления.
//
// Возвращаемое значение:
//  Строка - представление списка предметов.
//
Функция ПредставлениеСсылкиПредмета(Предмет, СигнатураПредмета, ПервыйПредметСписка, КоличествоПредметов, ФорматнаяСтрока = Неопределено) Экспорт
	
	Результат = "";
	
	Если Не ЗначениеЗаполнено(Предмет) Или Не ЗначениеЗаполнено(СигнатураПредмета)
		Или Не ЗначениеЗаполнено(ПервыйПредметСписка) Или Не ЗначениеЗаполнено(КоличествоПредметов) Тогда
		
		Возврат Результат;
		
	КонецЕсли;
	
	Если КоличествоПредметов = 1 Тогда
		Возврат Строка(ПервыйПредметСписка);
	КонецЕсли;
	
	Если ФорматнаяСтрока = Неопределено Тогда
		ФорматнаяСтрока  = "Л = ru_RU; ЧДЦ=0";
	КонецЕсли;
	
	ПрописьЧисла   = ЧислоПрописью(КоличествоПредметов, ФорматнаяСтрока, Предмет);
	ИндексПредмета = СтрНайти(ПрописьЧисла, СигнатураПредмета);
	ТекстПредметы = Строка(КоличествоПредметов) + " "
		+ Сред(ПрописьЧисла, ИндексПредмета, СтрДлина(ПрописьЧисла)- ИндексПредмета - 3);
		
	Результат = СтрШаблон(
		НСтр("ru = '%1 (%2 и еще %3)'"),
		ТекстПредметы, 
		Строка(ПервыйПредметСписка),
		КоличествоПредметов - 1);
		
	Возврат Результат;
	
КонецФункции

// Возвращает строковое представление списка, при этом последний элемент отделен союзом, а остальные - пунктуационным разделителем.
// Например: "пурпурную, лиловую, зеленую и лимонную", "правый и левый" или "первая, вторая или четвертая"
//
// Параметры:
//  Список       - Массив, ФиксированныйМассив - представления элементов списка или элементы списка.
//                 При вызове с клиента следует иметь в виду, что представления элементов не всех типов могут быть получены на клиенте
//  Союз         - Строка - нелокализованная строка "И", "ИЛИ" для стандартных союзов; локализованная строка с разделителями слов для остальных
//  Разделитель  - Строка - разделитель элементов списка, кроме последнего
// 
// Возвращаемое значение:
//  Строка - представление списка
//
Функция ПредставлениеСписка(Список, Союз = "И", Разделитель = ",") Экспорт
	
	Если Не ЗначениеЗаполнено(Список) Тогда
		Возврат "";
	КонецЕсли;
	
	Если Список.Количество() = 1 Тогда
		Возврат Список[0];
	КонецЕсли;
	
	Если ВРег(Союз) = "И" Тогда
		ПредставлениеСоюза = НСтр("ru = ' и '");
	ИначеЕсли ВРег(Союз) = "ИЛИ" Тогда
		ПредставлениеСоюза = НСтр("ru = ' или '");
	Иначе
		ПредставлениеСоюза = Союз;
	КонецЕсли;
	
	ЭлементыЧерезЗапятую = ОбщегоНазначенияКлиентСервер.СкопироватьМассив(Список);
	ЭлементыЧерезЗапятую.Удалить(ЭлементыЧерезЗапятую.ВГраница());
	
	Если Разделитель = "," Тогда
		ПредставлениеРазделителя = НСтр("ru = ', '");
	Иначе
		ПредставлениеРазделителя = Разделитель;
	КонецЕсли;
	
	ЭлементыЧерезСоюз = Новый Массив;
	ЭлементыЧерезСоюз.Добавить(СтрСоединить(ЭлементыЧерезЗапятую, ПредставлениеРазделителя));
	ЭлементыЧерезСоюз.Добавить(Список[Список.ВГраница()]);
	
	Возврат СтрСоединить(ЭлементыЧерезСоюз, ПредставлениеСоюза);
	
КонецФункции

// Возвращает строковое представление месяца.
//
// Параметры:
//   НомерМесяца - Число - Номер месяца от 1 до 12.
//
// Возвращаемое значение:
//   Строка
//
Функция ПредставлениеМесяца(НомерМесяца) Экспорт
	
	ПредставлениеМесяца = "";
	
	Если НомерМесяца > 0 И НомерМесяца < 13 Тогда
		ПредставлениеМесяца = Формат(Дата(2, НомерМесяца, 1), НСтр("ru = 'ДФ=ММММ'"));
	КонецЕсли;
	
	Возврат ПредставлениеМесяца;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ОПИСАНИЕ МЕТАДАННЫХ

Функция ПолноеИмяРеквизита(ИмяРеквизита, ИмяТабличнойЧасти = "") Экспорт
	
	ПолноеИмяРеквизита = ИмяРеквизита;
	Если Не ПустаяСтрока(ИмяТабличнойЧасти) Тогда
		ПолноеИмяРеквизита = ИмяТабличнойЧасти + "." + ПолноеИмяРеквизита;
	КонецЕсли;
	
	Возврат ПолноеИмяРеквизита;
	
КонецФункции

Функция РазложитьПолноеИмяРеквизита(ПолноеИмяРеквизита) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Реквизит",       ПолноеИмяРеквизита);
	Результат.Вставить("ТабличнаяЧасть", "");
	
	ЭлементыИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмяРеквизита, ".", Истина);
	Если ЭлементыИмени.Количество() = 2 Тогда
		Результат.ТабличнаяЧасть = ЭлементыИмени[0];
		Результат.Реквизит       = ЭлементыИмени[1];
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ФУНКЦИИ КОНТРОЛЬ КОРРЕКТНОСТИ ВВОДА ИНН и КПП

Процедура ОтобразитьРезультатПроверкиКонтрагентовВФорме(Форма, РезультатПроверкиСуществования = "") Экспорт
	
	// ИНН
	Форма.НадписьПоясненияНекорректногоИНН = Новый ФорматированнаяСтрока(Форма.РезультатПроверкиИНН);
	Форма.Элементы.НадписьПоясненияНекорректногоИНН.Видимость = НЕ ПустаяСтрока(Форма.РезультатПроверкиИНН);
	
	// КПП
	Форма.НадписьПоясненияНекорректногоКПП = Новый ФорматированнаяСтрока(Форма.РезультатПроверкиКПП);
	Форма.Элементы.НадписьПоясненияНекорректногоКПП.Видимость = НЕ ПустаяСтрока(Форма.РезультатПроверкиКПП);
	
	// Дубли и ФНС
	МассивПодстрокДублиФНС = Новый Массив;
	Если НЕ ПустаяСтрока(Форма.РезультатПроверкиНаДубли) Тогда
		МассивПодстрокДублиФНС.Добавить(Форма.РезультатПроверкиНаДубли);
	КонецЕсли;
	Если НЕ ПустаяСтрока(РезультатПроверкиСуществования) Тогда
		Если МассивПодстрокДублиФНС.Количество() > 0 Тогда
			МассивПодстрокДублиФНС.Добавить("    ");
		КонецЕсли;
		МассивПодстрокДублиФНС.Добавить(РезультатПроверкиСуществования);
	КонецЕсли;
	Форма.НадписьПояснениеПроверкиДублейФНС = Новый ФорматированнаяСтрока(МассивПодстрокДублиФНС);
	Форма.Элементы.НадписьПояснениеПроверкиДублейФНС.Видимость = (МассивПодстрокДублиФНС.Количество() > 0);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ФОРМАМИ

// Устанавливает видимость элементов в группе без лишних вызовов сервера.
//
// Параметры:
//  <Группа>  - <ГруппаФормы> - группа, элементам которой надо изменить видимость.
//  <Видимость>  - <Булево>   - устанавливаемое значение видимости.
//
Процедура УстановитьВидимостьГруппы(Группа, Видимость) Экспорт

	Для каждого ЭлементГруппы Из Группа.ПодчиненныеЭлементы Цикл
		Если ТипЗнч(ЭлементГруппы) = Тип("ГруппаФормы") Тогда
			УстановитьВидимостьГруппы(ЭлементГруппы, Видимость);
		Иначе
			ЭлементГруппы.Видимость = Видимость;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Выбирает, нужно ли перед открытием основной формы открывать форму для ожидания.
// Источниками для подписки могут быть только объекты метаданных, у которых указана ФормаСписка по-умолчанию.
//
Процедура ОпределитьФормуСпискаСОжиданием(Источник, ВидФормы, Параметры, ВыбраннаяФорма, ДополнительнаяИнформация, СтандартнаяОбработка) Экспорт
	
	ОбщегоНазначенияБПВызовСервера.ОпределитьФормуСпискаСОжиданием(
		Источник, ВидФормы, Параметры, ВыбраннаяФорма, СтандартнаяОбработка);

КонецПроцедуры

// Возвращает Истина, если при открытии форм списков не требуется показывать форму ожидания.
//
// Возвращаемое значение:
//  Булево - Ложь, если функциональность задействована; Истина, если отключена.
//
Функция ОтключитьОжиданиеПриОткрытииФорм() Экспорт
	
#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	ПараметрЗапускаПриложения = ПараметрыСеанса.ПараметрыКлиентаНаСервере.Получить("ПараметрЗапуска");
#Иначе
	ПараметрЗапускаПриложения = ПараметрЗапуска;
#КонецЕсли
	
	Возврат СтрНайти(ПараметрЗапускаПриложения, "ОтключитьОжиданиеПриОткрытииФорм") > 0;

КонецФункции

// Предсказывает, ожидается ли, что форма, которую сейчас будут открывать, может открываться длительное время.
//
// Длительность открытия формы прогнозируется, исходя из следующих предпосылок:
// 1. В самом начале работы в сеансе предполагается, что требуется кеширование данных.
//    Поэтому первое открытие всегда сопровождается ожиданием.
// 2. Второе открытие любой формы в сеансе зависит от оценки производительности компьютера/сетевого соединения.
//    Если компьютер низкопроизводительный, то ему для "разогрева" требуется больше времени, поэтому вторая открываемая форма
//    тоже будет открываться длительно.
// 3. Для последующих форм, если после начала работы еще не накоплена достаточная статистика, то несколько последующих открытий
//    также могут предваряться отображением формы формы ожидания.
// 4. В дальнейшем внутри сеанса производительность может временно снижаться при вытеснении данных из кеша или при возникновении
//    сторонней нагрузки, замедляющей время открытия форм. Это найдет отражение в статистике открытия форм и следующие
//    открываемые формы снова могут предваряться открытием формы ожидания.
// 5. При этом если конкретная форма открывалась недавно, то предполагается, что данные для нее в кеше сохранились
//    и открытие будет быстрым.
//
// Функция может вызываться как на клиенте, так и на сервере. На клиенте статистика открытий накапливается
// в клиентской переменной ПараметрыПриложения.
// В случае вызова на сервере, анализируется параметр сеанса СтатистикаОткрытияФорм, в который переносятся данные замеров
// из клиентской переменной после после закрытия формы ожидания.
//
// Параметры:
//  ИмяФормы     - Строка - имя формы, для которой анализируется производительность открытия.
//
// Возвращаемое значение:
//   Булево      - Истина - имеются факторы, которые могут привести к медленной работе приложения; иначе Ложь.
//
Функция ОжидаетсяДлительноеОткрытиеФормы(ИмяФормы) Экспорт
	
	#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	СтатистикаОткрытияФорм = ПараметрыСеанса.СтатистикаОткрытияФорм;
	#Иначе
	СтатистикаОткрытияФорм = ПараметрыПриложения["БухгалтерияПредприятия.СтатистикаОткрытияФорм"];
	#КонецЕсли

	Если СтатистикаОткрытияФорм = Неопределено Или СтатистикаОткрытияФорм.Количество() = 0 Тогда
		// Анализ производительности ещё не проводился. Это начало работы в сеансе.
		// Кеширование потребует времени, и формы будут открываться медленно. Поэтому выводим форму ожидания всегда,
		// если функциональность явно не отключена в сеансе.
		Возврат Не ОбщегоНазначенияБПКлиентСервер.ОтключитьОжиданиеПриОткрытииФорм();
		
	ИначеЕсли СтатистикаОткрытияФорм.ОтключитьОжиданиеПриОткрытииФорм Тогда
		
		Возврат Ложь;
		
	КонецЕсли;
	ОткрывавшиесяФормы = СтатистикаОткрытияФорм.ОткрывавшиесяФормы;
	ЗамерыОткрытий = СтатистикаОткрытияФорм.ЗамерыОткрытий;
	ДатаАнализа = ТекущаяУниверсальнаяДатаВМиллисекундах();
	
	ПоследнееОткрытие = ОткрывавшиесяФормы.Найти(ИмяФормы);
	Если ПоследнееОткрытие <> Неопределено Тогда

		ДатаОткрытия = ЗамерыОткрытий[ПоследнееОткрытие].ДатаОткрытия;
		Если ДатаАнализа - ДатаОткрытия <= ПределОжидаемогоВытесненияИзКеша() Тогда
			// Форма недавно открывалась. Повторное открытие будет быстрым.
			Возврат Ложь;

		КонецЕсли;
		
	КонецЕсли;
	
	Если СтатистикаОткрытияФорм.КоличествоОткрытий = 0 Тогда
		// Статистику еще ни разу не записывали с начала сеанса.
		// Ориентируемся на то, является ли данный компьютер медленным по своим аппаратным характеристикам.
		Возврат СтатистикаОткрытияФорм.МедленныйРежимРаботы;
		
	КонецЕсли;
	
	КоличествоОткрытий = ЗамерыОткрытий.Количество();
	Если КоличествоОткрытий = 0 Тогда
		// Это открытие не первой формы за сеанс, но статистики могла устареть и ее очистили.
		// Оптимистично предполагаем, что сейчас откроется быстро, т.к. с базой уже работали и кеши должны быть заполнены.
		Возврат Ложь;
	КонецЕсли;
	
	// Спрогнозируем время открытия текущей формы на основе статистики открытия предыдущих форм.
	// Время открытия форм, которые открывались недавно, учитываем с большим коэффициентом,
	// чем тех, которые открывались давно.
	ВзвешеннаяСумма = 0;
	ВзвешенноеКоличество = 0;
	Для КоэффициентФормы = 1 По КоличествоОткрытий Цикл
		
		Длительность = ЗамерыОткрытий[КоличествоОткрытий - КоэффициентФормы].Длительность;
		ВзвешеннаяСумма = ВзвешеннаяСумма + КоэффициентФормы * Длительность;		
		ВзвешенноеКоличество = ВзвешенноеКоличество + КоэффициентФормы;
		
	КонецЦикла;
	
	Если ВзвешеннаяСумма / ВзвешенноеКоличество <= ПредельноеВремяОткрытияФормы() Тогда
		// Формы на этом компьютере открываются быстро.
		Возврат Ложь;
		
	КонецЕсли;

	Возврат Истина;
	
КонецФункции

// Опередяет набор параметров алгоритма открытия длительных форм.
//
// Параметры:
//  ПараметрыКоманды - ПараметрыВыполненияКоманды - список параметров, с которыми была вызвана команда из интерфейса.
//
// Возвращаемое значение:
//   Структура - параметры алгоритма.
//
Функция ПараметрыОткрытияФормыСОжиданием(ПараметрыКоманды = Неопределено) Экспорт
	
	ПараметрыОткрытия = Новый Структура;
	ПараметрыОткрытия.Вставить("ИмяФормы", "");
	ПараметрыОткрытия.Вставить("Заголовок", "");
	ПараметрыОткрытия.Вставить("ОписаниеОповещенияОЗакрытии");
	ПараметрыОткрытия.Вставить("РежимОткрытияОкна");
	
	// По-умолчанию вызов процедуры, открывающей форму (выбирающей, стоит ли показывать форму ожидания) происходит
	// на клиенте. Однако он может быть осуществлен за счет переопределения формы в подписке на событие
	// ОбработкаПолученияФормы() . В этом случае флаг будет установлен в Истина.
	ПараметрыОткрытия.Вставить("ПереопределенаНаСервере", Ложь);
	
	// Определяет, необходимость для открываемой формы сохранять замер времени открытия средствами
	// подсистемы СтандартныеПодсистемы.ОценкаПроизводительности . Возможны два варианта:
	// * если указана строка, то будет сохранен замер ключевой операции с переданным именем;
	// * если указано значение Истина, то будет начат замер, а имя ключевой операции может быть далее установлено
	//   при открытии длительной формы.
	ПараметрыОткрытия.Вставить("ЗамерПроизводительности");
	
	// Если будет задан обработчик типа ОписаниеОповещения, то вместо самостоятельного открытия формы списка будет вызвано
	// выполнение обработчика.
	ПараметрыОткрытия.Вставить("ОбработчикОткрытияФормы");

	ПараметрыОткрытия.Вставить("Владелец");
	ПараметрыОткрытия.Вставить("Уникальность");
	ПараметрыОткрытия.Вставить("Окно");
	ПараметрыОткрытия.Вставить("НавигационнаяСсылка");
	
	Если ПараметрыКоманды = Неопределено Тогда
		Возврат ПараметрыОткрытия;
	КонецЕсли;
	
	ПараметрыОткрытия.Владелец            = ПараметрыКоманды.Источник;
	ПараметрыОткрытия.Уникальность        = ПараметрыКоманды.Уникальность;
	ПараметрыОткрытия.Окно                = ПараметрыКоманды.Окно;
	ПараметрыОткрытия.НавигационнаяСсылка = ПараметрыКоманды.НавигационнаяСсылка;

	// Используем навигационную ссылку из параметров команды только для заполнения по умолчанию
	// имени открываемой формы.
	Если НЕ ЗначениеЗаполнено(ПараметрыКоманды.НавигационнаяСсылка) Тогда
		Возврат ПараметрыОткрытия;
	КонецЕсли;

	СоставНавигационнойСсылки = СтрРазделить(ПараметрыКоманды.НавигационнаяСсылка, "/");
	Если СоставНавигационнойСсылки.Количество() = 0 Тогда
		Возврат ПараметрыОткрытия;
	КонецЕсли;
	СоставНавигационнойСсылки = СтрРазделить(СоставНавигационнойСсылки[СоставНавигационнойСсылки.ВГраница()], ".");
	Если СоставНавигационнойСсылки.Количество() < 2 Тогда
		Возврат ПараметрыОткрытия;
	КонецЕсли;
	
	// Заполняем имя формы по-умолчанию.
	ИмяФормы = СоставНавигационнойСсылки[0] + "." + СоставНавигационнойСсылки[1];
	ИдентификаторКоманды = ВРег(СоставНавигационнойСсылки[0]);
	Если ИдентификаторКоманды = "ОБЩАЯФОРМА" Или ИдентификаторКоманды = "ОБЩАЯКОМАНДА"
	 Или ИдентификаторКоманды = "COMMONCOMMAND" Или ИдентификаторКоманды = "COMMONFORM" Тогда // по-умочанию предполагаем, что открываем список документов
		ПараметрыОткрытия.ИмяФормы = "Документ." + СоставНавигационнойСсылки[1] + ".ФормаСписка";
	Иначе
		ПараметрыОткрытия.ИмяФормы = ИмяФормы + ".ФормаСписка";
	КонецЕсли;
	
	// Заполняем заголовок формы по-умолчанию из навигационной ссылки, не обращаясь к метаданным.
	// Разбиваем строку пробелами, ориентируясь на заглавные буквы.
	ЗаголовокБезПробелов = СоставНавигационнойСсылки[СоставНавигационнойСсылки.ВГраница()];
	ЗаголовокВНижнемРегистре = НРег(ЗаголовокБезПробелов);
	СловаЗаголовка = Новый Массив;
	ПозицияСимвола = 1;
	НомерСимвола = ПозицияСимвола;
	ВсегоСимволов = СтрДлина(ЗаголовокВНижнемРегистре);
	Пока НомерСимвола < ВсегоСимволов Цикл
		
		НомерСимвола = НомерСимвола + 1;
		Если Сред(ЗаголовокБезПробелов, НомерСимвола, 1) <> Сред(ЗаголовокВНижнемРегистре, НомерСимвола, 1) Тогда
			
			СловоЗаголовка = Сред(ЗаголовокВНижнемРегистре, ПозицияСимвола, НомерСимвола - ПозицияСимвола);
			СловаЗаголовка.Добавить(СловоЗаголовка);
			ПозицияСимвола = НомерСимвола;
			
		КонецЕсли;
		
	КонецЦикла;
	Если ПозицияСимвола = 1 Тогда
		
		ПараметрыОткрытия.Заголовок = ЗаголовокБезПробелов;
		
	Иначе
		
		СловоЗаголовка = Сред(ЗаголовокВНижнемРегистре, ПозицияСимвола, ВсегоСимволов - ПозицияСимвола + 1);
		СловаЗаголовка.Добавить(СловоЗаголовка);
		СловаЗаголовка[0] = ВРег(Лев(СловаЗаголовка[0], 1)) + Сред(СловаЗаголовка[0], 2);
		ПараметрыОткрытия.Заголовок = СтрСоединить(СловаЗаголовка, " ");
		
	КонецЕсли;
	
	Возврат ПараметрыОткрытия;
	
КонецФункции

// Хранит время в миллисекундах, в случае превышении которого при открытии новой формы списка будет сначала открыта
// форма ожидания. Установлено как 4 секунды.
//
Функция ПредельноеВремяОткрытияФормы() Экспорт
	
	Возврат 4000;
	
КонецФункции

// Хранит количество миллисекунд, после которого данные из кеша скорее всего будут вытеснены. Установлено как 20 минут.
//
Функция ПределОжидаемогоВытесненияИзКеша() Экспорт
	
	Возврат 1200000;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЧЕЕ

// Возвращает начало периода даты.
//
// Параметры:
//   Дата - Дата - дата.
//   Периодичность - Перечисление.Периодичность - периодичность.
//
// Возвращаемое значение:
//   Дата - начало периода даты.
//
Функция НачалоПериода(Дата, Периодичность) Экспорт
	
	Если Не ЗначениеЗаполнено(Дата) Или Не ЗначениеЗаполнено(Периодичность) Тогда
		Возврат Дата;
	КонецЕсли;
	
	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год") Тогда
		
		Возврат НачалоГода(Дата);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие") Тогда
		
		НомерМесяца = Месяц(Дата);
		
		Если НомерМесяца < 7 Тогда
			Возврат НачалоГода(Дата);
		Иначе
			Возврат ДобавитьМесяц(НачалоГода(Дата), 6);
		КонецЕсли;
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал") Тогда
		
		Возврат НачалоКвартала(Дата);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Месяц") Тогда
		
		Возврат НачалоМесяца(Дата);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		
		Возврат НачалоНедели(Дата);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада") Тогда
		
		День = 24 * 60 * 60; // Количество секунд в дне
		
		НомерДня = День(Дата);
		
		Если НомерДня <= 10 Тогда
			Возврат НачалоМесяца(Дата);
		ИначеЕсли НомерДня <= 20 Тогда
			Возврат НачалоМесяца(Дата) + 10 * День;
		Иначе
			Возврат НачалоМесяца(Дата) + 20 * День;
		КонецЕсли;
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда
		
		Возврат НачалоДня(Дата);
		
	Иначе
		
		Возврат Дата;
		
	КонецЕсли;
	
КонецФункции

// Возвращает конец периода даты.
//
//
// Параметры:
//   Дата - Дата - дата.
//   Периодичность - Перечисление.Периодичность - периодичность.
//
// Возвращаемое значение:
//   Дата - конец периода даты.
//
Функция КонецПериода(Дата, Периодичность) Экспорт
	
	Если Не ЗначениеЗаполнено(Дата) Или Не ЗначениеЗаполнено(Периодичность) Тогда
		Возврат Дата;
	КонецЕсли;
	
	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год") Тогда
		
		Возврат КонецГода(Дата);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие") Тогда
		
		НомерМесяца = Месяц(Дата);
		Если НомерМесяца < 7 Тогда
			Возврат КонецМесяца(ДобавитьМесяц(НачалоГода(Дата), 5));
		Иначе
			Возврат КонецГода(Дата);
		КонецЕсли;
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал") Тогда
		
		Возврат КонецКвартала(Дата);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Месяц") Тогда
		
		Возврат КонецМесяца(Дата);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		
		Возврат КонецНедели(Дата);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада") Тогда
		
		День = 24 * 60 * 60; // Количество секунд в дне
		
		НомерДня = День(Дата);
		Если НомерДня <= 10 Тогда
			Возврат НачалоМесяца(Дата) + 10 * День - 1;
		ИначеЕсли НомерДня <= 20 Тогда
			Возврат НачалоМесяца(Дата) + 20 * День - 1;
		Иначе
			Возврат КонецМесяца(Дата);
		КонецЕсли;
		
	Иначе
		
		Возврат КонецДня(Дата);
		
	КонецЕсли;
	
КонецФункции

#Область УстаревшийПрограммныйИнтерфейс

// Устарела. Следует использовать ОбщегоНазначения.ОписаниеТипаСтрока
// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
//
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Строка"));

	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);

	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);

КонецФункции // ПолучитьОписаниеТиповСтроки()

// Устарела. Следует использовать ОбщегоНазначения.ОписаниеТипаЧисло
// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
//
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//  ЗнакЧисла				- ДопустимыйЗнак, знак числа
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность, РазрядностьДробнойЧасти = 0, ЗнакЧисла = Неопределено) Экспорт

	Если ЗнакЧисла = Неопределено Тогда
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти);
	Иначе
		КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность, РазрядностьДробнойЧасти, ЗнакЧисла);
	КонецЕсли;

	Возврат Новый ОписаниеТипов("Число", КвалификаторЧисла);

КонецФункции // ПолучитьОписаниеТиповЧисла()

// Устарела. Следует использовать ОбщегоНазначения.ОписаниеТипаДата
// Служебная функция, предназначенная для получения описания типов даты
//
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
//
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));

	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);

	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);

КонецФункции // ПолучитьОписаниеТиповДаты()

// Устарела. Следует использовать ОбщегоНазначенияКлиентСервер.ТекстОшибкиЗаполнения
// Формирует текст сообщения, подставляя значения
// параметров в шаблоны сообщений.
//
// Параметры
//  ВидПоля       - Строка - может принимать значения:
//                  Поле, Колонка, Список
//  ВидСообщения  - Строка - может принимать значения:
//                  Заполнение, Корректность
//  Параметр1     - Строка - имя поля
//  Параметр2     - Строка - номер строки
//  Параметр3     - Строка - имя списка
//  Параметр4     - Строка - текст сообщения о некорректности заполнения
//
// Возвращаемое значение:
//   Строка - текст сообщения
//
Функция ПолучитьТекстСообщения(ВидПоля = "Поле", ВидСообщения = "Заполнение",
	Параметр1 = "", Параметр2 = "",	Параметр3 = "", Параметр4 = "") Экспорт

	ТекстСообщения = "";

	Если ВРег(ВидПоля) = "ПОЛЕ" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Поле ""%1"" не заполнено'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Поле ""%1"" заполнено некорректно.
                           |
                           |%4'");
		КонецЕсли;
	ИначеЕсли ВРег(ВидПоля) = "КОЛОНКА" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Не заполнена колонка ""%1"" в строке %2 списка ""%3""'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Некорректно заполнена колонка ""%1"" в строке %2 списка ""%3"".
                           |
                           |%4'");
		КонецЕсли;
	ИначеЕсли ВРег(ВидПоля) = "СПИСОК" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Не введено ни одной строки в список ""%3""'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Некорректно заполнен список ""%3"".
                           |
                           |%4'");
		КонецЕсли;
	КонецЕсли;

	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(Шаблон, Параметр1, Параметр2, Параметр3, Параметр4);

КонецФункции // ПолучитьТекстСообщения()

#КонецОбласти

// Возвращает дату, смещенную на указанное количество периодов
//
// Параметры:
//   Дата - Дата - исходная дата
//   Периодичность - ПеречислениеСсылка.Периодичность - шаг периода
//   КоличествоПериодов - Число - число периодов, на которые нужно сдвинуть исходную дату
//
// Возвращаемое значение:
//   Дата - дата, смещенная на указанное количество периодов.
//
Функция ДобавитьПериод(Дата, Периодичность, КоличествоПериодов = 1) Экспорт
	
	День = 24 * 60 * 60; // Количество секунд в дне
	
	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год") Тогда
		
		Возврат ДобавитьМесяц(Дата, 12 * КоличествоПериодов);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие") Тогда
		
		Возврат ДобавитьМесяц(Дата, 6 * КоличествоПериодов);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал") Тогда
		
		Возврат ДобавитьМесяц(Дата, 3 * КоличествоПериодов);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Месяц") Тогда
		
		Возврат ДобавитьМесяц(Дата, 1 * КоличествоПериодов);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		
		Возврат Дата + 7 * День * КоличествоПериодов;
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада") Тогда
		
		Возврат Дата + 10 * День * КоличествоПериодов;
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда
		
		Возврат Дата + 1 * День * КоличествоПериодов;
		
	Иначе
		
		Возврат Дата;
		
	КонецЕсли;
	
КонецФункции

// Дополняет URL параметрами (элемент query rfc 3986)
//
// Параметры:
//  URL          - Строка - URL без элементов query и fragment (без символов ? и #)
//  ПараметрыURL - Массив - имена и значения параметров в виде "key=value".
//                          Они будут включены в URL с разделителями &
// 
// Возвращаемое значение:
//  Строка - дополненный URL
//
Функция ДополнитьURLПараметрами(URL, ПараметрыURL) Экспорт
	
	Если Не ЗначениеЗаполнено(ПараметрыURL) Тогда
		Возврат URL;
	КонецЕсли;
	
	ПараметрыURLСтрокой = СтрСоединить(ПараметрыURL, "&");
	Возврат СтрШаблон("%1?%2", URL, ПараметрыURLСтрокой);
	
КонецФункции

// Параметры UTM (Urchin Tracking Module) для материалов на its.1c.ru
// 
// Возвращаемое значение:
//  Массив из Строка - каждый элемент - имя и значение параметра, разделенные символом "="
//
Функция ИТС_ПараметрыUTM() Экспорт
	
	ПараметрыURL = Новый Массив;
	ПараметрыURL.Добавить("utm_medium=prog");
	ПараметрыURL.Добавить("utm_source=bp30");
	Возврат ПараметрыURL;
	
КонецФункции
#Область ПрограммныйИнтерфейс

// Возвращает разницу между двумя датами.
// Аналогично функции языка запросов игнорирует младшие части дат,
// которые меньше, чем параметр Периодичность.
//
// Например:
//	РазностьДат('2019-12-31', '2020-01-01', Перечисления.Периодичность.Год) = 1
//	РазностьДат('2019-08-24', '2020-05-17', Перечисления.Периодичность.Месяц) = 9
//
// Параметры:
//   ДатаНачала - Дата - начальная дата периода
//   ДатаОкончания - Дата - конечная дата периода
//   Периодичность - ПеречислениеСсылка.Периодичность - вариант расчета разности дат.
//
// Возвращаемое значение:
//   Число - количество между двумя датами.
//
Функция РазностьДат(ДатаНачала, ДатаОкончания, Периодичность) Экспорт
	
	Разность = 0;
	
	День = 24 * 60 * 60; // Количество секунд в дне
	
	Если Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Год") Тогда
		Разность = Год(ДатаОкончания) - Год(ДатаНачала);
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Полугодие") Тогда
		Разность =
			?(Месяц(ДатаОкончания) > 6, 2, 1) - ?(Месяц(ДатаНачала) > 6, 2, 1) + 2 * (Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Квартал") Тогда
		Разность = Цел(Месяц(НачалоКвартала(ДатаОкончания)) / 3) - Цел(Месяц(НачалоКвартала(ДатаНачала)) / 3)
			+ 4 * (Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Месяц") Тогда
		Разность = Месяц(ДатаОкончания) - Месяц(ДатаНачала) + 12 * (Год(ДатаОкончания) - Год(ДатаНачала));
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Декада") Тогда
		Разность = Цел((ДатаОкончания - ДатаНачала) / (10 * День));
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.Неделя") Тогда
		Разность =
			Цел((НачалоНедели(ДатаОкончания) - НачалоНедели(ДатаНачала)) / (7 * День));
		
	ИначеЕсли Периодичность = ПредопределенноеЗначение("Перечисление.Периодичность.День") Тогда
		Разность = (ДатаОкончания - ДатаНачала) / День;
		
	КонецЕсли;
	
	Возврат Разность;
	
КонецФункции

Функция СинонимИзИмени(ИмяРеквизита) Экспорт
	
	ДопустимыеАббревиатуры = Новый Массив;
	ДопустимыеАббревиатуры.Добавить("ИНН");
	ДопустимыеАббревиатуры.Добавить("КПП");
	ДопустимыеАббревиатуры.Добавить("НДС");
	
	СловаСинонима = Новый Массив;
	
	УровниИмени = СтрРазделить(ИмяРеквизита, ".", Истина);
	Для каждого УровеньИмени Из УровниИмени Цикл
	
		ИмяВНижнемРегистре = НРег(УровеньИмени);
		
		ДлинаИмени = СтрДлина(УровеньИмени);
		НачалоСлова = 1;
		Для НомерСимвола = 2 По ДлинаИмени Цикл
			
			Если Сред(УровеньИмени, НомерСимвола, 1) = Сред(ИмяВНижнемРегистре, НомерСимвола, 1) Тогда
				Продолжить;
			КонецЕсли;
			
			Если НачалоСлова = 1 Тогда
				
				СловаСинонима.Добавить(Сред(УровеньИмени, НачалоСлова, НомерСимвола - НачалоСлова));
				
			Иначе
				
				СловоСинонима = Сред(ИмяВНижнемРегистре, НачалоСлова, НомерСимвола - НачалоСлова);
				// Аббревиатуры в синонимах полей.
				Если НомерСимвола - НачалоСлова = 1 Тогда
					
					ПроверяемыеСимволы = Сред(УровеньИмени, НомерСимвола - 2);
					Для Каждого Аббревиатура Из ДопустимыеАббревиатуры Цикл
						Если СтрНачинаетсяС(ПроверяемыеСимволы, Аббревиатура) Тогда
							СловаСинонима[СловаСинонима.ВГраница()] = Сред(ПроверяемыеСимволы, 1, СтрДлина(Аббревиатура));
							СловоСинонима = "";
							Прервать;
						КонецЕсли;
					КонецЦикла;
					
				КонецЕсли;
				Если ПустаяСтрока(СловоСинонима) Тогда
					НомерСимвола = НомерСимвола + 1;
				Иначе
					СловаСинонима.Добавить(СловоСинонима);
				КонецЕсли;

			КонецЕсли;
			НачалоСлова = НомерСимвола;
			
		КонецЦикла;
		Если НачалоСлова = 1 Тогда
			СловаСинонима.Добавить(УровеньИмени);
		Иначе
			СловаСинонима.Добавить(Сред(ИмяВНижнемРегистре, НачалоСлова));
		КонецЕсли;
		СловаСинонима.Добавить(".");
		
	КонецЦикла;
	СловаСинонима.Удалить(СловаСинонима.ВГраница());
	
	Возврат КапитализироватьСтроку(СтрСоединить(СловаСинонима, " "));
	
КонецФункции

// Возвращает количество полных (целых) лет между двумя датами.
//
// Например:
//	КоличествоЦелыхЛет('2019-12-31', '2020-01-01') = 0
//
// Параметры:
//   ДатаНачала - Дата - начальная дата периода
//   ДатаОкончания - Дата - конечная дата периода
//
// Возвращаемое значение:
//	Число - количество полных (целых) лет.
//
Функция КоличествоЦелыхЛет(ДатаНачала, ДатаОкончания) Экспорт

	Если НЕ ЗначениеЗаполнено(ДатаНачала)
		ИЛИ НЕ ЗначениеЗаполнено(ДатаОкончания)
		ИЛИ ДатаОкончания <= ДатаНачала Тогда
		Возврат 0;
	КонецЕсли;
	
	Результат = Год(ДатаОкончания) - Год(ДатаНачала);
	
	Месяц1 = Месяц(ДатаНачала);
	Месяц2 = Месяц(ДатаОкончания);
	
	Если Месяц1 > Месяц2 Тогда
		Результат = Результат - 1;
	ИначеЕсли Месяц1 = Месяц2 
		И День(ДатаНачала) > День(ДатаОкончания) Тогда
		Результат = Результат - 1;
	КонецЕсли;

	Возврат Результат;

КонецФункции

// Возвращает количество полных (целых) месяцев между двумя датами.
//
// Например:
//	КоличествоЦелыхМесяцев('2019-08-24', '2020-05-17') = 8
//
// Параметры:
//   ДатаНачала - Дата - начальная дата периода
//   ДатаОкончания - Дата - конечная дата периода
//
// Возвращаемое значение:
//	Число - количество полных (целых) месяцев.
//
Функция КоличествоЦелыхМесяцев(ДатаНачала, ДатаОкончания) Экспорт

	Если НЕ ЗначениеЗаполнено(ДатаНачала)
		ИЛИ НЕ ЗначениеЗаполнено(ДатаОкончания)
		ИЛИ ДатаОкончания <= ДатаНачала Тогда
		Возврат 0;
	КонецЕсли;

	Результат = (Год(ДатаОкончания) - Год(ДатаНачала)) * 12 + (Месяц(ДатаОкончания) - Месяц(ДатаНачала));

	Если День(ДатаНачала) > День(ДатаОкончания) Тогда
		Результат = Результат - 1;
	КонецЕсли;
	
	Возврат Результат;

КонецФункции

// Возвращает номер квартала, которому принадлежит переданная дата.
//
// Параметры:
//   Дата - Дата - дата, для которой необходимо вычислить номер квартала
//
// Возвращаемое значение:
//   Число - номер квартала
//
Функция НомерКвартала(Дата) Экспорт
	
	Возврат Месяц(КонецКвартала(Дата)) / 3;
	
КонецФункции

#КонецОбласти