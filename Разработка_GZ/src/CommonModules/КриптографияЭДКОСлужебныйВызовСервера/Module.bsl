////////////////////////////////////////////////////////////////////////////////
// Подсистема "Криптография".
//  
////////////////////////////////////////////////////////////////////////////////

#Область СлужебныйПрограммныйИнтерфейс

Функция ЭкспортироватьСертификатВBase64(Сертификат) Экспорт
	
	ДанныеСертификата = КриптографияЭДКО.НайтиСертификат(Сертификат);
	Если Не ЗначениеЗаполнено(ДанныеСертификата) Тогда
		Возврат "";
	КонецЕсли;
	
	ДвоичныеДанныеСертификата = ДанныеСертификата.Сертификат;
	
	Возврат Base64Строка(ДвоичныеДанныеСертификата);
	
КонецФункции

Функция ПроверитьСертификат(Сертификат, ПроверятьСрокДействия = Истина) Экспорт
	
	Возврат СервисКриптографии.ПроверитьСертификат(Сертификат);
		
КонецФункции

Процедура СохранитьНайденныеСертификаты(Сертификаты) Экспорт
	
	СертификатыДляСохранения = ПолучитьСохраненныеСертификаты();
	
	Для Каждого Сертификат Из Сертификаты Цикл
		СертификатыДляСохранения.Вставить(
			"Отпечаток_" + Сертификат.Отпечаток,
			Новый Структура("СерийныйНомер, Поставщик", Сертификат.СерийныйНомер, Сертификат.Поставщик));
	КонецЦикла;	
	
	ХранилищеОбщихНастроек.Сохранить("ДокументооборотСКО/Криптография", "Сертификаты", СертификатыДляСохранения);
	
КонецПроцедуры

Функция ПолучитьСохраненныеСертификаты() Экспорт
	
	Сертификаты =  ХранилищеОбщихНастроек.Загрузить("ДокументооборотСКО/Криптография", "Сертификаты");
	Если Не ЗначениеЗаполнено(Сертификаты) Тогда
		Сертификаты = Новый Структура;
	КонецЕсли;
	
	Возврат Сертификаты;
	
КонецФункции

Функция НайтиСертификатыВЗащищенномХранилищеНаСервере(Сертификаты, ВыполнятьПроверку) Экспорт
	
	НайденныеСертификаты = Новый Массив;
	НенайденныеСертификаты = Новый Массив;
	
	Для Каждого Сертификат Из Сертификаты Цикл
		НайденныйСертификат = КриптографияЭДКО.НайтиСертификат(Сертификат, ВыполнятьПроверку);
		Если НайденныйСертификат = Неопределено Тогда
			НенайденныеСертификаты.Добавить(Сертификат);
		Иначе
			НайденныеСертификаты.Добавить(НайденныйСертификат);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Новый Структура("Сертификаты,НенайденныеСертификаты", НайденныеСертификаты, НенайденныеСертификаты);
	
КонецФункции

Функция ПолучитьСертификаты(Знач Хранилище) Экспорт
	
	Если ТипЗнч(Хранилище) <> Тип("Массив") Тогда
		Хранилище = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Хранилище);
	КонецЕсли;
	
	Сертификаты = Новый Массив;
	Для Каждого ЗначениеХранилища Из Хранилище Цикл
		Для Каждого ПолученныйСертификат Из ХранилищеСертификатов.Получить(ПривестиКЕдиномуТипуХранилища(ЗначениеХранилища)) Цикл
			Сертификат = ПреобразоватьФорматСвойствСертификата(ПолученныйСертификат, ЗначениеХранилища);
			Сертификат.Вставить(
				"ПоставщикСтруктура", 
				ОбщегоНазначения.СкопироватьРекурсивно(ПолученныйСертификат.Издатель));
			Сертификат.Вставить(
				"ВладелецСтруктура", 
				ОбщегоНазначения.СкопироватьРекурсивно(ПолученныйСертификат.Субъект));
			Сертификаты.Добавить(Сертификат);
		КонецЦикла;
	КонецЦикла;
	
	Возврат Сертификаты;
	
КонецФункции

Функция ИзвлечьИнформациюОКриптопровайдереПоСертификату(Знач Сертификаты, Знач ПроанализироватьАлгоритм = Ложь) Экспорт
	
	Для Каждого Сертификат Из Сертификаты Цикл
		Сертификат.Вставить("Криптопровайдер", ИзвлечьКриптопровайдер(Сертификат.Сертификат, ПроанализироватьАлгоритм));
		Сертификат.Удалить("Сертификат");
	КонецЦикла;
	
	Возврат Сертификаты;
	
КонецФункции

// Выполняет проверку подписи.
//
// Параметры:
//	Подпись             - ДвоичныеДанные, Строка - подпись, 
//                                которую необходимо проверить, или ее адрес во временном хранилище.
//	ИсходныеДанные      - ДвоичныеДанные, Строка - данные или адрес во временном хранилище.
//	Сертификаты         - Неопределено - извлечь сертификаты из подписи и поместить в параметр,
//                        проверка подписи в этом случае выполняется согласно извлекаемым подписантам.
//                      - Массив - массив двоичных данных сертификатов.
//	Подписанты          - Массив - возвращаемые подписанты при извлечении сертификатов из подписи.
//                        * СерийныйНомер  - Строка - серийный номер сертификата.
//                        * Поставщик      - Строка - издатель сертификата.
//                        * Отпечаток      - Строка - отпечаток сертификата.
//                        * Выполнено      - Булево - если Истина, то проверка подписи была выполнена для подписанта.
//                        * ПодписьВалидна - Булево - результат проверки подписи для подписанта.
//	КомментарийПоОшибке - Строка - может возвращаться причина неудачи проверки подписи.
//
// Возвращаемое значение:
//	Булево - Истина - подпись соответствует владельцам всех сертификатов.
//
Функция ПроверитьПодписьPKCS7(Подпись, ИсходныеДанные, Сертификаты = Неопределено, Подписанты = Неопределено, КомментарийПоОшибке = "") Экспорт
	
	Если ТипЗнч(Подпись) = Тип("ДвоичныеДанные") Тогда
		ДвоичныеДанныеПодписи = Подпись;
	Иначе
		ДвоичныеДанныеПодписи = ПолучитьИзВременногоХранилища(Подпись);
	КонецЕсли;
	
	Если ТипЗнч(ИсходныеДанные) = Тип("ДвоичныеДанные") Тогда
		ДвоичныеДанныеИсходныхДанных = ИсходныеДанные;
	Иначе
		ДвоичныеДанныеИсходныхДанных = ПолучитьИзВременногоХранилища(ИсходныеДанные);
	КонецЕсли;
	
	Если Сертификаты = Неопределено Тогда
		СвойстваКриптосообщения = СервисКриптографии.ПолучитьСвойстваКриптосообщения(ДвоичныеДанныеПодписи);
		
		Сертификаты = ?(СвойстваКриптосообщения.Свойство("Сертификаты"), СвойстваКриптосообщения.Сертификаты, Новый Массив);
		СвойстваСертификатов = Новый Массив;
		Для каждого Сертификат Из Сертификаты Цикл
			СвойстваСертификата = СервисКриптографии.ПолучитьСвойстваСертификата(Сертификат);
			СвойстваСертификатов.Добавить(СвойстваСертификата);
		КонецЦикла;
		
		Подписанты = ?(СвойстваКриптосообщения.Свойство("Подписанты"),
			ОбщегоНазначения.СкопироватьРекурсивно(СвойстваКриптосообщения.Подписанты), Новый Массив);
		Для ИндексПодписанта = 0 По Подписанты.Количество() - 1 Цикл
			Подписанты[ИндексПодписанта] = ОбщегоНазначения.СкопироватьРекурсивно(Подписанты[ИндексПодписанта]);
			Подписанты[ИндексПодписанта].Вставить("Отпечаток", "");
			Подписанты[ИндексПодписанта].Вставить("Выполнено", Ложь);
			Подписанты[ИндексПодписанта].Вставить("ПодписьВалидна", Ложь);
			Подписанты[ИндексПодписанта].Вставить("Сертификат", Неопределено);
			ИздательСтрокой = ПреобразоватьВСтроку(Подписанты[ИндексПодписанта].Издатель);
			Подписанты[ИндексПодписанта].Вставить("Поставщик", ИздательСтрокой); // для совместимости
			
			Для ИндексСертификата = 0 По Сертификаты.Количество() - 1 Цикл
				Если СвойстваСертификатов[ИндексСертификата] <> Неопределено
					И СокрЛП(Подписанты[ИндексПодписанта].СерийныйНомер) = СокрЛП(СвойстваСертификатов[ИндексСертификата].СерийныйНомер)
					И ИздателиИлиСубъектыОдинаковые(Подписанты[ИндексПодписанта].Издатель,
					СвойстваСертификатов[ИндексСертификата].Издатель) Тогда
					
					Подписанты[ИндексПодписанта].Отпечаток = СтрЗаменить(СвойстваСертификатов[ИндексСертификата].Отпечаток, " ", "");
					Подписанты[ИндексПодписанта].Отпечаток = нрег(Подписанты[ИндексПодписанта].Отпечаток);
					Подписанты[ИндексПодписанта].Сертификат = Сертификаты[ИндексСертификата];
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;
		
		// дополнительный поиск на случай отличий написания издателя
		Для ИндексПодписанта = 0 По Подписанты.Количество() - 1 Цикл
			Если НЕ ЗначениеЗаполнено(Подписанты[ИндексПодписанта].Отпечаток) Тогда
				Для ИндексСертификата = 0 По Сертификаты.Количество() - 1 Цикл
					Если СокрЛП(Подписанты[ИндексПодписанта].СерийныйНомер) = СокрЛП(СвойстваСертификатов[ИндексСертификата].СерийныйНомер) Тогда
						Подписанты[ИндексПодписанта].Издатель = СвойстваСертификатов[ИндексСертификата].Издатель;
						Подписанты[ИндексПодписанта].Поставщик = ПреобразоватьВСтроку(Подписанты[ИндексПодписанта].Издатель);
						Подписанты[ИндексПодписанта].Отпечаток = СтрЗаменить(СвойстваСертификатов[ИндексСертификата].Отпечаток, " ", "");
						Подписанты[ИндексПодписанта].Отпечаток = нрег(Подписанты[ИндексПодписанта].Отпечаток);
						Подписанты[ИндексПодписанта].Сертификат = Сертификаты[ИндексСертификата];
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЦикла;
		
		ПодписантыДляПоискаВХранилище = Новый Массив;
		Для ИндексПодписанта = 0 По Подписанты.Количество() - 1 Цикл
			ПодписантыДляПоискаВХранилище.Добавить(Подписанты[ИндексПодписанта]);
		КонецЦикла;
		
		Если ПодписантыДляПоискаВХранилище.Количество() > 0 Тогда
			РезультатыПоиска = НайтиСертификатыВЗащищенномХранилищеНаСервере(ПодписантыДляПоискаВХранилище, Ложь);
			
			Для ИндексПодписанта = 0 По Подписанты.Количество() - 1 Цикл
				Если НЕ ЗначениеЗаполнено(Подписанты[ИндексПодписанта].Отпечаток) Тогда
					Для каждого НайденныйСертификат Из РезультатыПоиска.Сертификаты Цикл
						Если СокрЛП(Подписанты[ИндексПодписанта].СерийныйНомер) = СокрЛП(НайденныйСертификат.СерийныйНомер)
							И ИздателиИлиСубъектыОдинаковые(Подписанты[ИндексПодписанта].Издатель, НайденныйСертификат.Издатель) Тогда
							
							Подписанты[ИндексПодписанта].Отпечаток = СокрЛП(НайденныйСертификат.Отпечаток);
							Подписанты[ИндексПодписанта].Сертификат = НайденныйСертификат.Сертификат;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЦикла;
			
			Для каждого НенайденныйСертификат Из РезультатыПоиска.НенайденныеСертификаты Цикл
				Если ЗначениеЗаполнено(НенайденныйСертификат.Отпечаток) И ЗначениеЗаполнено(НенайденныйСертификат.Сертификат)
					И ПравоДоступа("Изменение", Метаданные.РегистрыСведений.ХранилищеСертификатов) Тогда
					
					ХранилищеСертификатов.Добавить(НенайденныйСертификат.Сертификат, Перечисления.ТипХранилищаСертификатов.СертификатыПолучателей);
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Для ИндексПодписанта = 0 По Подписанты.Количество() - 1 Цикл
			Если НЕ ЗначениеЗаполнено(Подписанты[ИндексПодписанта].Отпечаток) Тогда
				ТекстСообщения = НСтр("ru = 'При проверке подписи не найден сертификат поставщика ""%1"" с серийным номером ""%2"".'");
				КомментарийПоОшибке = СтрШаблон(
					ТекстСообщения,
					Подписанты[ИндексПодписанта].Поставщик,
					Подписанты[ИндексПодписанта].СерийныйНомер);
				Возврат Ложь;
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		Подписанты = Новый Массив;
		Для ИндексСертификата = 0 По Сертификаты.Количество() - 1 Цикл
			ПодписантПоСертификату = Новый Структура;
			ПодписантПоСертификату.Вставить("Выполнено", Ложь);
			ПодписантПоСертификату.Вставить("ПодписьВалидна", Ложь);
			ПодписантПоСертификату.Вставить("Сертификат", Сертификаты[ИндексСертификата]);
			Подписанты.Добавить(ПодписантПоСертификату);
		КонецЦикла;
	КонецЕсли;
	
	Если Подписанты.Количество() = 0 Тогда
		КомментарийПоОшибке = НСтр("ru = 'Отсутствует информация о подписантах, проверка подписи невозможна.'");
		Возврат Ложь;
	КонецЕсли;
	
	ПодписьВалидна = Истина;
	Для ИндексПодписанта = 0 По Подписанты.Количество() - 1 Цикл
		ПараметрыПодписания = Новый Структура("ОтсоединеннаяПодпись, Сертификат", Истина, Подписанты[ИндексПодписанта].Сертификат);
		Подписанты[ИндексПодписанта].ПодписьВалидна =
			СервисКриптографии.ПроверитьПодпись(ДвоичныеДанныеПодписи, ДвоичныеДанныеИсходныхДанных, "CMS", ПараметрыПодписания);
		
		Если Подписанты[ИндексПодписанта].ПодписьВалидна
			И Подписанты[ИндексПодписанта].Свойство("СерийныйНомер")
			И Подписанты[ИндексПодписанта].Свойство("Поставщик")
			И НЕ ПроверитьСертификат(Подписанты[ИндексПодписанта].Сертификат, Ложь) Тогда
			
			КомментарийПоОшибке = СтрШаблон(
				НСтр("ru = 'Невалидный сертификат поставщика ""%1"" с серийным номером ""%2"" при проверке подписи.'"),
				Подписанты[ИндексПодписанта].Поставщик,
				Подписанты[ИндексПодписанта].СерийныйНомер);
			Возврат Ложь;
		КонецЕсли;
		
		Подписанты[ИндексПодписанта].Выполнено = Истина;
		Если НЕ Подписанты[ИндексПодписанта].ПодписьВалидна Тогда
			ПодписьВалидна = Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ПодписьВалидна;
	
КонецФункции

Функция ИзвлечьИнформациюОПодписантахИзJSON(ПодписантыJSON) Экспорт
	
	ЧтениеПодписантовJSON = Новый ЧтениеJSON;
	ЧтениеПодписантовJSON.УстановитьСтроку(ПодписантыJSON);
	
	Подписанты = ПрочитатьJSON(ЧтениеПодписантовJSON);
	Если Подписанты <> Неопределено Тогда
		Если ТипЗнч(Подписанты) = Тип("Структура") Тогда
			Подписанты = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Подписанты); // создаем массив, помещаем туда подписанта
		КонецЕсли;
		
		Для ИндексПодписанта = 0 По Подписанты.Количество() - 1 Цикл
			Подписанты[ИндексПодписанта] = Новый ФиксированнаяСтруктура("СерийныйНомер, Поставщик",
				Подписанты[ИндексПодписанта].serial_number, Подписанты[ИндексПодписанта].issuer);
		КонецЦикла;
		Подписанты = Новый ФиксированныйМассив(Подписанты);
	КонецЕсли;
	
	Возврат Подписанты;
	
КонецФункции

Функция ПреобразоватьВСтроку(Издатель) Экспорт
	
	СтрокаИздателя = "";
	
	Для Каждого Тег Из Издатель Цикл 
		СтрокаИздателя = СтрокаИздателя + ?(СтрокаИздателя = "", "", ",") + Тег.Ключ + "=" + Тег.Значение;
	КонецЦикла;
	
	Возврат СтрокаИздателя;
	
КонецФункции

Функция ИдентификаторСертификата(Знач Сертификат) Экспорт
	
	Если ТипЗнч(Сертификат) = Тип("СертификатКриптографии") ИЛИ Сертификат.Свойство("СерийныйНомер") Тогда
		СерийныйНомер = Сертификат.СерийныйНомер;
		Издатель = Сертификат.Издатель;
	Иначе
		СертификатКриптографии = Новый СертификатКриптографии(Сертификат.Сертификат);
		СерийныйНомер = СертификатКриптографии.СерийныйНомер;
		Издатель = СертификатКриптографии.Издатель;
	КонецЕсли;		
	
	СписокOID = Новый СписокЗначений;
	Для Каждого OID Из Издатель Цикл
		Если Не СтрНачинаетсяС(OID.Ключ, "OID") Тогда
			Продолжить;
		КонецЕсли;
		СписокOID.Добавить(OID.Значение, СтрЗаменить(Сред(OID.Ключ, 4), "_", "."));
	КонецЦикла;
	
	Ключи = СтрРазделить("2.5.4.3,2.5.4.4,2.5.4.6,2.5.4.7,2.5.4.8,2.5.4.10,2.5.4.11,2.5.4.12,2.5.4.42,1.2.840.113549.1.9.1", ",");
	Свойства = Новый СписокЗначений;
	Для Каждого Элемент Из СписокOID Цикл
		Если Ключи.Найти(Элемент.Представление) <> Неопределено Тогда
			Свойства.Добавить(Элемент.Значение, Элемент.Представление);
		КонецЕсли;
	КонецЦикла;
	
	СерийныйНомерСтрока = НРег(СтрЗаменить(СерийныйНомер, " ", ""));
	
	Свойства.СортироватьПоПредставлению(НаправлениеСортировки.Возр);
	
	МассивЗначений = Свойства.ВыгрузитьЗначения();
	
	МассивЗначений.Добавить(СерийныйНомерСтрока);
	
	ИздательИСерийныйНомер = СтрСоединить(МассивЗначений, "#");
	
	Хеширование = Новый ХешированиеДанных(ХешФункция.SHA1);
	Хеширование.Добавить(ИздательИСерийныйНомер);
	
	Возврат НРег(СтрЗаменить(Хеширование.ХешСумма, " ", ""));	
	
КонецФункции

// Возвращает свойства криптосообщения в формате PKCS #7 в соответствии с https://tools.ietf.org/html/rfc2315.
//
// Параметры:
//   Криптосообщение - ДвоичныеДанные, Строка - файл (двоичные данные, адрес во временном хранилище или строка Base64
//                                              при Настройки.ЭтоСтрокаBase64 = Истина) в формате PKCS #7.
//   Настройки - Неопределено - настройки по умолчанию.
//             - Структура:
//     ПрочитатьПодписанныеДанные          - Булево - по умолчанию Истина, для типа SignedData возвращать Содержимое.
//     ПрочитатьИздателяИСерийныйНомер     - Булево - по умолчанию Истина, для типа SignedData в Подписанты возвращать
//                                                    Идентификатор, Издатель, СерийныйНомер, Сертификат,
//                                                    для типа EnvelopedData в Получатели возвращать Идентификатор, Издатель,
//                                                    СерийныйНомер.
//     ПрочитатьАлгоритмПубличногоКлюча    - Булево - по умолчанию Ложь, для типа EnvelopedData в Получатели возвращать
//                                                    АлгоритмПубличногоКлюча.
//     ЭтоЭлектроннаяПодписьВМоделиСервиса - Булево - по умолчанию Истина, влияет на имя события при записи в журнал регистрации.
//     ЭтоСтрокаBase64                     - Булево - по умолчанию Ложь, при Истина Криптосообщение задает строку Base64.
//     ВозвращатьИсключения                - Булево - по умолчанию Истина, генерировать исключения при неверной структуре данных.
//
// Возвращаемое значение:
//   Структура - свойства криптосообщения.
//    Общие свойства:
//    * Тип - Строка - Unknown - файл неподдерживаемого формат, EnvelopedData - зашифрованные данные, SignedData - подпись.
//    * Размер - Число - размер файла в байтах.
//    
//    Свойства для типа SignedData:
//    * Подписанты - Массив - подписанты сообщения.
//       ** Идентификатор - Строка - идентификатор сертификата
//       ** Издатель - Структура - издатель сертификата
//           *** OID<X1>_<X2>_..._<XN>, где X<i> - это компонента идентификатора OID
//       ** СерийныйНомер - ДвоичныеДанные - серийный номер сертификата
//       ** Сертификат - ДвоичныеДанные - файл сертификата
//       ** АлгоритмХеширования - Строка - название алгоритма или OID нераспознанного алгоритма.
//       ** АлгоритмПодписи - Строка - "GOST R 34.10-2001", "GOST R 34.10-2012-256", "GOST R 34.10-2012-512"
//                                     или OID нераспознанного алгоритма.
//    * Сертификаты - Массив - файлы сертификатов.
//    * СпискиОтзываСертификатов - Массив - файлы списков отзыва сертификатов.
//    * Содержимое - ДвоичныеДанные - подписанные данные для прикрепленной подписи.
//
//    Свойства для типа EnvelopedData:
//    * Получатели - Массив - получатели зашифрованного сообщения.
//       ** Идентификатор - Строка - идентификатор сертификата
//       ** Издатель - Структура - издатель сертификата
//           *** OID<X1>_<X2>_..._<XN>, где X<i> - это компонента идентификатора OID
//       ** СерийныйНомер - ДвоичныеДанные - серийный номер сертификата
//       ** АлгоритмПубличногоКлюча - Строка - "GOST R 34.10-2001", "GOST R 34.10-2012-256", "GOST R 34.10-2012-512"
//                                             или OID нераспознанного алгоритма, возвращается при задании
//                                             Настройки.ПрочитатьАлгоритмПубличногоКлюча = Истина
//
Функция ПолучитьСвойстваКриптосообщения(Знач Криптосообщение, Настройки = Неопределено) Экспорт
	
	НастройкиВызова = Новый Структура;
	НастройкиВызова.Вставить("ПрочитатьПодписанныеДанные", 			Истина);
	НастройкиВызова.Вставить("ПрочитатьИздателяИСерийныйНомер", 	Истина);
	НастройкиВызова.Вставить("ПрочитатьАлгоритмПубличногоКлюча", 	Ложь);
	НастройкиВызова.Вставить("ЭтоЭлектроннаяПодписьВМоделиСервиса", Истина);
	НастройкиВызова.Вставить("ЭтоСтрокаBase64", 					Ложь);
	НастройкиВызова.Вставить("ВозвращатьИсключения", 				Истина);
	Если Настройки <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(НастройкиВызова, Настройки);
	КонецЕсли;
	
	СвойстваКриптосообщения = Новый Структура;
	СвойстваКриптосообщения.Вставить("Тип", "Unknown");
	
	Если НастройкиВызова.ЭтоСтрокаBase64 Тогда
		Криптосообщение = Base64Значение(Криптосообщение);
	ИначеЕсли ТипЗнч(Криптосообщение) = Тип("Строка") И ЭтоАдресВременногоХранилища(Криптосообщение) Тогда
		Криптосообщение = ПолучитьИзВременногоХранилища(Криптосообщение);
	КонецЕсли;
	СвойстваКриптосообщения.Вставить("Размер", Криптосообщение.Размер());
	
	Если Не ЗначениеЗаполнено(СвойстваКриптосообщения.Размер) Тогда
		Возврат СвойстваКриптосообщения;
	КонецЕсли;
	
	ЧтениеДанных = Новый ЧтениеДанных(Криптосообщение);
	Попытка
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер); // contentType
		Если Свойства.РазмерБлока > 100 ИЛИ Свойства.РазмерБлока = 0 Тогда // Защита от считывания лишних данных
			ЧтениеДанных.Закрыть();
			Возврат СвойстваКриптосообщения;
		КонецЕсли;
		
		Тип = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства);
		
		// PKCS #7: EnvelopedData https://tools.ietf.org/html/rfc2315#section-10.1
		Если Тип = "1.2.840.113549.1.7.3" Тогда
			СвойстваКриптосообщения = ПрочитатьEnvelopedData(ЧтениеДанных, СвойстваКриптосообщения, НастройкиВызова);
			
		// PKCS #7: SignedData https://tools.ietf.org/html/rfc2315#section-9.1	
		ИначеЕсли Тип = "1.2.840.113549.1.7.2" Тогда
			СвойстваКриптосообщения = ПрочитатьSignedData(ЧтениеДанных, СвойстваКриптосообщения, НастройкиВызова);
		КонецЕсли;
	Исключение
		ИмяСобытия = ?(НастройкиВызова.ЭтоЭлектроннаяПодписьВМоделиСервиса,
			НСтр("ru = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение PKCS7'", ОбщегоНазначения.КодОсновногоЯзыка()),
			НСтр("ru = 'Сервис криптографии.Чтение PKCS7'", ОбщегоНазначения.КодОсновногоЯзыка()));
		ЗаписьЖурналаРегистрации(
			ИмяСобытия,
			УровеньЖурналаРегистрации.Ошибка,,,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Если НастройкиВызова.ВозвращатьИсключения Тогда
			ВызватьИсключение;
		КонецЕсли;
	КонецПопытки;
	ЧтениеДанных.Закрыть();
	
	Возврат СвойстваКриптосообщения;
	
КонецФункции

// Возвращает отдельные свойства сертификата в формате X.509 в соответствие с https://tools.ietf.org/html/rfc5280.
//
// Параметры:
//   ДанныеСертификата - ДвоичныеДанные, Строка - файл (двоичные данные, адрес во временном хранилище или строка Base64
//                                                при Настройки.ЭтоСтрокаBase64 = Истина) в формате X.509.
//   Настройки - Неопределено - настройки по умолчанию.
//             - Структура:
//     ЭтоЭлектроннаяПодписьВМоделиСервиса - Булево - по умолчанию Истина, влияет на имя события при записи в журнал регистрации.
//     ЭтоСтрокаBase64                     - Булево - по умолчанию Ложь, при Истина ДанныеСертификата задает строку Base64.
//     ВозможенФорматBase64                - Булево - по умолчанию Ложь, при Истина двоичные данные в ДанныеСертификата
//                                                    могут быть в формате Base64, в том числе с заголовками сертификата,
//                                                    корректность чтения определяется по прочитанному алгоритму
//     ВозвращатьИсключения                - Булево - по умолчанию Истина, генерировать исключения при неверной структуре данных.
//
// Возвращаемое значение:
//   Структура - свойства криптосообщения.
//     Размер                       - Число          - размер файла в байтах.
//     Версия                       - Число          - версия формата сертификата, 0 - v1, 1 - v2, 2 - v3.
//     СерийныйНомер                - ДвоичныеДанные - серийный номер сертификата.
//     АлгоритмПубличногоКлюча      - Строка         - "GOST R 34.10-2001", "GOST R 34.10-2012-256",
//                                                     "GOST R 34.10-2012-512" или OID нераспознанного алгоритма.
//     ИдентификаторКлючаСубъекта   - Строка или Неопределено - хеш SHA-1 публичного ключа.
//     ИдентификаторКлючаУЦ         - Строка или Неопределено - хеш SHA-1 публичного ключа удостоверяющего центра.
//     ТипКриптопровайдераВладельца - Перечисления.ТипыКриптоПровайдеров или Неопределено - определяет
//                                                     Перечисления.ТипыКриптоПровайдеров.CryptoPro и
//                                                     Перечисления.ТипыКриптоПровайдеров.VipNet.
//
Функция ПолучитьСвойстваСертификата(Знач ДанныеСертификата, Настройки = Неопределено) Экспорт
	
	НастройкиВызова = Новый Структура;
	НастройкиВызова.Вставить("ЭтоЭлектроннаяПодписьВМоделиСервиса", Истина);
	НастройкиВызова.Вставить("ЭтоСтрокаBase64", 					Ложь);
	НастройкиВызова.Вставить("ВозможенФорматBase64", 				Ложь);
	НастройкиВызова.Вставить("ВозвращатьИсключения", 				Истина);
	Если Настройки <> Неопределено Тогда
		ЗаполнитьЗначенияСвойств(НастройкиВызова, Настройки);
	КонецЕсли;
	
	СвойстваСертификата = Новый Структура;
	СвойстваСертификата.Вставить("Размер", 					0);
	СвойстваСертификата.Вставить("Версия", 					0);
	СвойстваСертификата.Вставить("СерийныйНомер", 			0);
	СвойстваСертификата.Вставить("АлгоритмПубличногоКлюча", "");
	СвойстваСертификата.Вставить("ИдентификаторКлючаСубъекта", 		Неопределено);
	СвойстваСертификата.Вставить("ИдентификаторКлючаУЦ", 			Неопределено);
	СвойстваСертификата.Вставить("ТипКриптопровайдераВладельца", 	Неопределено);
	
	Если НастройкиВызова.ЭтоСтрокаBase64 Тогда
		ДанныеСертификата = Base64Значение(ДанныеСертификата);
	ИначеЕсли ТипЗнч(ДанныеСертификата) = Тип("Строка") И ЭтоАдресВременногоХранилища(ДанныеСертификата) Тогда
		ДанныеСертификата = ПолучитьИзВременногоХранилища(ДанныеСертификата);
	КонецЕсли;
	
	СвойстваСертификата.Размер = ДанныеСертификата.Размер();
	
	Если НастройкиВызова.ВозможенФорматBase64 И СвойстваСертификата.Размер < 65536 Тогда
		НастройкиВызова.ЭтоСтрокаBase64 		= Ложь;
		НастройкиВызова.ВозможенФорматBase64 	= Ложь;
		СвойстваСертификата = ПолучитьСвойстваСертификата(ДанныеСертификата, НастройкиВызова);
		
		Если НЕ ЗначениеЗаполнено(СвойстваСертификата.АлгоритмПубличногоКлюча) Тогда
			ОбъектЧтениеДанных = Новый ЧтениеДанных(ДанныеСертификата, "windows-1251");
			Попытка
				ТекстСертификата = ОбъектЧтениеДанных.ПрочитатьСимволы();
			Исключение
				ИмяСобытия = ?(НастройкиВызова.ЭтоЭлектроннаяПодписьВМоделиСервиса,
					НСтр("ru = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение сертификата'", ОбщегоНазначения.КодОсновногоЯзыка()),
					НСтр("ru = 'Сервис криптографии.Чтение сертификата'", ОбщегоНазначения.КодОсновногоЯзыка()));
				ЗаписьЖурналаРегистрации(
					ИмяСобытия,
					УровеньЖурналаРегистрации.Ошибка,,,
					ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				Если НастройкиВызова.ВозвращатьИсключения Тогда
					ВызватьИсключение;
				КонецЕсли;
			КонецПопытки;
			ОбъектЧтениеДанных.Закрыть();
			
			ТекстСертификата = СокрЛП(ТекстСертификата);
			Если СтрНачинаетсяС(ТекстСертификата, "-----BEGIN CERTIFICATE-----")
				И СтрЗаканчиваетсяНа(ТекстСертификата, "-----END CERTIFICATE-----") Тогда
				ДлинаТекстаСертификата = СтрДлина(ТекстСертификата);
				ТекстСертификата = Сред(ТекстСертификата, 28, ДлинаТекстаСертификата - 52);
				ТекстСертификата = СокрЛП(ТекстСертификата);
			КонецЕсли;
			
			НастройкиВызова.ЭтоСтрокаBase64 		= Истина;
			НастройкиВызова.ВозможенФорматBase64 	= Ложь;
			СвойстваСертификата = ПолучитьСвойстваСертификата(ТекстСертификата, НастройкиВызова);
		КонецЕсли;
		
		Возврат СвойстваСертификата;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СвойстваСертификата.Размер) Тогда
		Возврат СвойстваСертификата;
	КонецЕсли;
	
	ОбъектЧтениеДанных = Новый ЧтениеДанных(ДанныеСертификата);
	Попытка
		// https://tools.ietf.org/html/rfc5280#section-4
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // Certificate ::= SEQUENCE...
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // TBSCertificate ::= SEQUENCE...
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 2 Тогда
			Если СвойстваБлока.Класс <> "CONTEXT-SPECIFIC" ИЛИ СвойстваБлока.Тег <> 0 Тогда // version [0] EXPLICIT Version DEFAULT v1
				ОбъектЧтениеДанных.Закрыть();
				Возврат СвойстваСертификата;
			КонецЕсли;
			
			СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		КонецЕсли;
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 2 Тогда // Version ::= INTEGER {v1(0), v2(1), v3(2)}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		ВерсияСертификата = ПрочитатьЦелоеЧисло(ОбъектЧтениеДанных, СвойстваБлока);
		Если ВерсияСертификата < 0 ИЛИ ВерсияСертификата > 2 Тогда
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		СвойстваСертификата.Версия = ВерсияСертификата;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		СвойстваСертификата.СерийныйНомер = ПрочитатьДвоичныеДанные(ОбъектЧтениеДанных,
			СвойстваБлока); // serialNumber CertificateSerialNumber ::= INTEGER
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // signature AlgorithmIdentifier = SEQUENCE {...}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // issuer RDNSequence ::= SEQUENCE {...}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // validity Validity ::= SEQUENCE {...}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // subject RDNSequence ::= SEQUENCE {...}
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // subjectPublicKeyInfo SubjectPublicKeyInfo ::= SEQUENCE...
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		КонецБлока = СвойстваБлока.РазмерБлока + ОбъектЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда // algorithm AlgorithmIdentifier = SEQUENCE...
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		
		АлгоритмПубличногоКлюча = ПрочитатьAlgorithmIdentifier(ОбъектЧтениеДанных, СвойстваСертификата, СвойстваБлока, Истина);
		Если АлгоритмПубличногоКлюча = Неопределено Тогда
			ОбъектЧтениеДанных.Закрыть();
			Возврат СвойстваСертификата;
		КонецЕсли;
		СвойстваСертификата.АлгоритмПубличногоКлюча = АлгоритмПубличногоКлюча;
		ПропуститьБлок(ОбъектЧтениеДанных, КонецБлока - ОбъектЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 1 Тогда
			// issuerUniqueID IMPLICIT UniqueIdentifier OPTIONAL
			ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
			СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		КонецЕсли;
		
		Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 2 Тогда
			// subjectUniqueID IMPLICIT UniqueIdentifier OPTIONAL
			ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
			СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
		КонецЕсли;
		
		Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 3 Тогда
			// extensions EXPLICIT Extensions OPTIONAL
			СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
			Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда
				ОбъектЧтениеДанных.Закрыть();
				Возврат СвойстваСертификата;
			КонецЕсли;
			
			ТипКриптопровайдераВладельцаНайден 	= Ложь;
			ИдентификаторКлючаУЦНайден 			= Ложь;
			ИдентификаторКлючаСубъектаНайден 	= Ложь;
			Пока Истина Цикл
				СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
				Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 16 Тогда
					ОбъектЧтениеДанных.Закрыть();
					Возврат СвойстваСертификата;
				КонецЕсли;
				
				КонецБлока = СвойстваБлока.РазмерБлока + ОбъектЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
				
				СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
				Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 6 Тогда // algorithm OBJECT IDENTIFIER
					ОбъектЧтениеДанных.Закрыть();
					Возврат СвойстваСертификата;
				КонецЕсли;
				ИдентификаторРасширения = ПрочитатьОбъектныйИдентификатор(ОбъектЧтениеДанных, СвойстваБлока);
				Если ИдентификаторРасширения = "1.2.643.100.111" Тогда
					СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
					Если СвойстваБлока.Класс = "UNIVERSAL" И СвойстваБлока.Тег = 1 Тогда
						ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
						СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
					КонецЕсли;
					
					Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 4 Тогда
						ОбъектЧтениеДанных.Закрыть();
						Возврат СвойстваСертификата;
					КонецЕсли;
					
					СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
					Если СвойстваБлока.Класс = "UNIVERSAL" И СвойстваБлока.Тег = 12 Тогда
						ИмяКриптопровайдера = ПрочитатьСтроку(ОбъектЧтениеДанных, СвойстваБлока);
						ИмяКриптопровайдера = нрег(ИмяКриптопровайдера);
						Если СтрНайти(ИмяКриптопровайдера, "cryptopro") > 0 ИЛИ СтрНайти(ИмяКриптопровайдера, "криптопро") > 0 Тогда
							СвойстваСертификата.ТипКриптопровайдераВладельца = Перечисления.ТипыКриптоПровайдеров.CryptoPro;
						ИначеЕсли СтрНайти(ИмяКриптопровайдера, "vipnet") > 0 ИЛИ СтрНайти(ИмяКриптопровайдера, "випнет") > 0 Тогда
							СвойстваСертификата.ТипКриптопровайдераВладельца = Перечисления.ТипыКриптоПровайдеров.VipNet;
						КонецЕсли;
					КонецЕсли;
					ТипКриптопровайдераВладельцаНайден = Истина;
					
				ИначеЕсли ИдентификаторРасширения = "2.5.29.35" Тогда
					СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
					Если СвойстваБлока.Класс = "UNIVERSAL" И СвойстваБлока.Тег = 1 Тогда
						ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
						СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
					КонецЕсли;
					
					Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 4 Тогда
						ОбъектЧтениеДанных.Закрыть();
						Возврат СвойстваСертификата;
					КонецЕсли;
					
					СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
					Если СвойстваБлока.Класс = "UNIVERSAL" И СвойстваБлока.Тег = 16 Тогда
						СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
						Буфер = ОбъектЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(СвойстваБлока.РазмерБлока);
						СвойстваСертификата.ИдентификаторКлючаУЦ = ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(Буфер);
					КонецЕсли;
					ИдентификаторКлючаУЦНайден = Истина;
					
				ИначеЕсли ИдентификаторРасширения = "2.5.29.14" Тогда
					СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
					Если СвойстваБлока.Класс = "UNIVERSAL" И СвойстваБлока.Тег = 1 Тогда
						ПропуститьБлок(ОбъектЧтениеДанных, СвойстваБлока.РазмерБлока);
						СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
					КонецЕсли;
					
					Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 4 Тогда
						ОбъектЧтениеДанных.Закрыть();
						Возврат СвойстваСертификата;
					КонецЕсли;
					
					СвойстваБлока = ПрочитатьСвойстваБлока(ОбъектЧтениеДанных, СвойстваСертификата.Размер);
					Если СвойстваБлока.Класс <> "UNIVERSAL" ИЛИ СвойстваБлока.Тег <> 4 Тогда
						ОбъектЧтениеДанных.Закрыть();
						Возврат СвойстваСертификата;
					КонецЕсли;
					
					Буфер = ОбъектЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(СвойстваБлока.РазмерБлока);
					СвойстваСертификата.ИдентификаторКлючаСубъекта = ПолучитьДвоичныеДанныеИзБуфераДвоичныхДанных(Буфер);
					ИдентификаторКлючаСубъектаНайден = Истина;
				КонецЕсли;
				
				Если ТипКриптопровайдераВладельцаНайден И ИдентификаторКлючаУЦНайден И ИдентификаторКлючаСубъектаНайден Тогда
					ОбъектЧтениеДанных.Закрыть();
					Возврат СвойстваСертификата;
				КонецЕсли;
				ПропуститьБлок(ОбъектЧтениеДанных, КонецБлока - ОбъектЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
			КонецЦикла;
		КонецЕсли;
	Исключение
		ИмяСобытия = ?(НастройкиВызова.ЭтоЭлектроннаяПодписьВМоделиСервиса,
			НСтр("ru = 'Электронная подпись в модели сервиса.Сервис криптографии.Чтение сертификата'", ОбщегоНазначения.КодОсновногоЯзыка()),
			НСтр("ru = 'Сервис криптографии.Чтение сертификата'", ОбщегоНазначения.КодОсновногоЯзыка()));
		ЗаписьЖурналаРегистрации(
			ИмяСобытия,
			УровеньЖурналаРегистрации.Ошибка,,,
			ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
		Если НастройкиВызова.ВозвращатьИсключения Тогда
			ВызватьИсключение;
		КонецЕсли;
	КонецПопытки;
	ОбъектЧтениеДанных.Закрыть();
	
	Возврат СвойстваСертификата;
	
КонецФункции

Функция УстановитьСертификаты(Сертификаты) Экспорт
	
	Ошибки = Новый Массив;
	Для Каждого Сертификат ИЗ Сертификаты Цикл
		Попытка
			ХранилищеСертификатов.Добавить(
				Сертификат.Сертификат, 
				ПривестиКЕдиномуТипуХранилища(Сертификат.Хранилище.Хранилище));
		Исключение
			Ошибка = Новый Структура;
			Ошибка.Вставить("Сертификат", Сертификат);
			ОШибка.Вставить("Ошибка", КриптографияЭДКОСлужебныйКлиентСервер.ОшибкаУстановкиСертификатаСервисомКриптографии(ИнформацияОбОшибке()));
			Ошибки.Добавить(Ошибка);
		КонецПопытки;
	КонецЦикла;
	
	Возврат Ошибки;
	
КонецФункции

Функция ПреобразоватьФорматСвойствСертификата(ИсходныйСертификат, Хранилище)
	
	Сертификат = Новый Структура;
	Сертификат.Вставить("Наименование", ИсходныйСертификат.Наименование);
	Сертификат.Вставить("Версия", ИсходныйСертификат.Версия);
	Сертификат.Вставить("СерийныйНомер", НРег(ИсходныйСертификат.СерийныйНомер));
	Сертификат.Вставить("Поставщик", ПреобразоватьВСтроку(ИсходныйСертификат.Издатель));
	Сертификат.Вставить("Владелец", ПреобразоватьВСтроку(ИсходныйСертификат.Субъект));
	Сертификат.Вставить("Отпечаток", СтрЗаменить(НРег(ИсходныйСертификат.Отпечаток), " ", ""));
	Сертификат.Вставить("ИспользоватьДляПодписи", ИсходныйСертификат.ИспользоватьДляПодписи);
	Сертификат.Вставить("ИспользоватьДляШифрования", ИсходныйСертификат.ИспользоватьДляШифрования);
	Сертификат.Вставить("ДействителенС", МестноеВремя(ИсходныйСертификат.ДатаНачала, ЧасовойПоясСеанса()));
	Сертификат.Вставить("ДействителенПо", МестноеВремя(ИсходныйСертификат.ДатаОкончания, ЧасовойПоясСеанса()));
	Сертификат.Вставить("Хранилище", Новый Структура("Хранилище, ЭтоЛокальноеХранилище", ВРег(Хранилище), Ложь));

	Возврат Сертификат;
	
КонецФункции

Функция ПреобразоватьСертификатыНаСервере(Json) Экспорт
	
	Сертификаты = Новый Массив;
	СвойстваСертификатов = ОбщегоНазначенияЭДКОСлужебныйВызовСервера.JsonВСтруктура(Json); // FIX: , "valid_from, valid_to");
	Для Каждого СвойстваСертификата Из СвойстваСертификатов Цикл
		Сертификат = Новый Структура;
		Сертификат.Вставить("Наименование", ПолучитьНаименованиеСертификата(СвойстваСертификата.subject));
		Сертификат.Вставить("Версия", СвойстваСертификата.version);
		Сертификат.Вставить("СерийныйНомер", СвойстваСертификата.serial_number);
		Сертификат.Вставить("ПоставщикСтруктура", Новый ФиксированнаяСтруктура(ПреобразоватьМассивOIDВСтруктуру(СвойстваСертификата.issuer)));
		Сертификат.Вставить("ВладелецСтруктура", Новый ФиксированнаяСтруктура(ПреобразоватьМассивOIDВСтруктуру(СвойстваСертификата.subject)));
		Сертификат.Вставить("Поставщик", ПреобразоватьСтруктуруВСтроку(Сертификат.ПоставщикСтруктура));
		Сертификат.Вставить("Владелец", ПреобразоватьСтруктуруВСтроку(Сертификат.ВладелецСтруктура));
		Сертификат.Вставить("Отпечаток", СтрЗаменить(СвойстваСертификата.thumbprint, " ", ""));
		Сертификат.Вставить("ИспользоватьДляПодписи", СвойстваСертификата.sign_allowed);
		Сертификат.Вставить("ИспользоватьДляШифрования", СвойстваСертификата.crypt_allowed);
		
		// FIX: 
		Сертификат.Вставить("ДействителенС", МестноеВремя(XMLЗначение(Тип("Дата"), СтрЗаменить(СвойстваСертификата.valid_from, ".", "-")), ЧасовойПоясСеанса()));
		Сертификат.Вставить("ДействителенПо", МестноеВремя(XMLЗначение(Тип("Дата"), СтрЗаменить(СвойстваСертификата.valid_to, ".", "-")), ЧасовойПоясСеанса()));
				
		Сертификат.Вставить("Хранилище", Новый Структура("Хранилище, ЭтоЛокальноеХранилище", ВРег(СвойстваСертификата.storage), Истина));
		
		Сертификаты.Добавить(Сертификат);
	КонецЦикла;
	
	Возврат Сертификаты;
	
КонецФункции

Функция ИспользованиеКриптосервисаВозможно() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);	
	Возврат Константы.ИспользоватьЭлектроннуюПодписьВМоделиСервиса.Получить();
	
КонецФункции

Функция ПодписиСертификатовДокументооборотаВJSON(ОтпечатокСертификата = Неопределено) Экспорт
	
	МассивПодписей = ПодписиСертификатовДокументооборота(ОтпечатокСертификата);
	Если МассивПодписей.Количество() = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат ОбщегоНазначенияЭДКОСлужебныйВызовСервера.СтруктураВJson(МассивПодписей);
	
КонецФункции

Функция ПодписиСертификатовДокументооборота(ОтпечатокСертификата = Неопределено) Экспорт
	
	Запрос = Новый Запрос(
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ
		|	ПодписиСертификатовДокументооборота.ОтпечатокСертификата КАК ОтпечатокСертификата,
		|	ПодписиСертификатовДокументооборота.Данные КАК Данные
		|ИЗ
		|	РегистрСведений.ПодписиСертификатовДокументооборота КАК ПодписиСертификатовДокументооборота"
		+ ?(ОтпечатокСертификата = Неопределено, "", "
		|ГДЕ
		|	ПодписиСертификатовДокументооборота.ОтпечатокСертификата = &ОтпечатокСертификата"));
	
	Если ОтпечатокСертификата <> Неопределено Тогда
		Запрос.УстановитьПараметр("ОтпечатокСертификата", нрег(ОтпечатокСертификата));
	КонецЕсли;
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Результат = Новый Массив;
	Пока Выборка.Следующий() Цикл
		ДвоичныеДанныеПодписи = Выборка.Данные.Получить();
		ДанныеПодписи64 = Base64Строка(ДвоичныеДанныеПодписи);
		ДанныеПодписи64 = СтрЗаменить(ДанныеПодписи64, Символы.ВК, "");
		ДанныеПодписи64 = СтрЗаменить(ДанныеПодписи64, Символы.ПС, "");
		
		ПодписьСертификатаДокументооборота = Новый Структура;
		ПодписьСертификатаДокументооборота.Вставить("thumbprint", 	Выборка.ОтпечатокСертификата);
		ПодписьСертификатаДокументооборота.Вставить("signature", 	ДанныеПодписи64);
		Результат.Добавить(ПодписьСертификатаДокументооборота);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

// Извлекает информацию о типе криптопровайдера (программе) и возвращает его криптопровайдер по умолчанию
Функция ИзвлечьКриптопровайдер(Сертификат, ПроанализироватьАлгоритм = Ложь)
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла("cer");
	Сертификат.Записать(ИмяВременногоФайла);
	
	Байты = ПрочитатьФайлВМассив(ИмяВременногоФайла);
	
	БайтыСигнатурыПоиска = Новый Массив; // Ищем OID 1.2.643.100.111
	БайтыСигнатурыПоиска.Добавить(6);
	БайтыСигнатурыПоиска.Добавить(5);
	БайтыСигнатурыПоиска.Добавить(42);
	БайтыСигнатурыПоиска.Добавить(133);
	БайтыСигнатурыПоиска.Добавить(3);
	БайтыСигнатурыПоиска.Добавить(100);
	БайтыСигнатурыПоиска.Добавить(111);
	
	Индекс = 0;
	ИндексНачалаСигнатуры = 0;
	СигнатураНайдена = Ложь;
	Для Каждого Байт Из Байты Цикл
		Если Байт = БайтыСигнатурыПоиска[0] Тогда
			СигнатураНайдена = Истина;
			Для Индекс2 = 1 По 6 Цикл
				Если Байты[Индекс2 + Индекс] <> БайтыСигнатурыПоиска[Индекс2] Тогда
					СигнатураНайдена = Ложь;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если СигнатураНайдена Тогда
				ИндексНачалаСигнатуры = Индекс;
				Прервать;
			КонецЕсли;
		КонецЕсли;
		Индекс = Индекс + 1;
	КонецЦикла;
	
	Криптопровайдер = "";
	Если СигнатураНайдена Тогда
		КоличествоБайтПодТекст = Байты[ИндексНачалаСигнатуры + БайтыСигнатурыПоиска.Количество() + 1];
		НачалоТекста = ИндексНачалаСигнатуры + БайтыСигнатурыПоиска.Количество() + 4;
		
		БайтыДляЗаписи = Новый Массив;
		Для Индекс = НачалоТекста По НачалоТекста + КоличествоБайтПодТекст - 3 Цикл
			БайтыДляЗаписи.Добавить(Байты[Индекс]);
		КонецЦикла;
		
		ИмяФайла = ПолучитьИмяВременногоФайла("txt");
		ЗаписатьФайлИзМассива(ИмяФайла, БайтыДляЗаписи);
		
		ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, "utf-8");
		Криптопровайдер = ЧтениеТекста.Прочитать();
		ЧтениеТекста.Закрыть();
		
		ОперацииСФайламиЭДКО.УдалитьВременныйФайл(ИмяФайла);
	КонецЕсли;
	ОперацииСФайламиЭДКО.УдалитьВременныйФайл(ИмяВременногоФайла);
	
	Если СтрНайти(НРег(Криптопровайдер), "cryptopro") ИЛИ СтрНайти(НРег(Криптопровайдер), "криптопро") Тогда
		Криптопровайдер = КриптографияЭДКОКлиентСервер.КриптопровайдерCryptoPro();
	ИначеЕсли СтрНайти(НРег(Криптопровайдер), "vipnet") ИЛИ СтрНайти(НРег(Криптопровайдер), "випнет") Тогда
		Криптопровайдер = КриптографияЭДКОКлиентСервер.КриптопровайдерViPNet();
	Иначе
		Криптопровайдер = Неопределено;
	КонецЕсли;
	
	Если ПроанализироватьАлгоритм И Криптопровайдер <> Неопределено Тогда
		Настройки = Новый Структура;
		Настройки.Вставить("ЭтоЭлектроннаяПодписьВМоделиСервиса", 	Ложь);
		Настройки.Вставить("ЭтоСтрокаBase64", 						Ложь);
		Настройки.Вставить("ВозможенФорматBase64", 					Ложь);
		Настройки.Вставить("ВозвращатьИсключения", 					Ложь);
		СвойстваСертификата = КриптографияЭДКОСлужебныйВызовСервера.ПолучитьСвойстваСертификата(
			Сертификат, Настройки);
		
		ПутьМодуляКриптографии = ?(ОбщегоНазначения.ЭтоLinuxКлиент(),
			ЭлектронныйДокументооборотСКонтролирующимиОрганамиКлиентСервер.ПутьМодуляКриптографии(), "");
		СвойстваКриптопровайдера = КриптографияЭДКОКлиентСервер.СвойстваКриптопровайдераПоУмолчанию(
			Криптопровайдер.ТипКриптопровайдера,
			СвойстваСертификата.АлгоритмПубличногоКлюча,
			ПутьМодуляКриптографии);
		Если ЗначениеЗаполнено(СвойстваКриптопровайдера.Имя) Тогда
			Криптопровайдер = СвойстваКриптопровайдера;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Криптопровайдер;
	
КонецФункции

Функция ПрочитатьФайлВМассив(ИмяФайла)
	
	Результат = Новый Массив;
	
	ЧтениеТекста = Новый ЧтениеТекста(ИмяФайла, "ISO-8859-1", Символы.ПС, Символы.ПС);
	
	Пока Истина Цикл
		СимволТекста = ЧтениеТекста.Прочитать(1);
		Если СимволТекста = Неопределено Тогда
			Прервать;
		КонецЕсли;
		КодСимволаТекста = КодСимвола(СимволТекста);
		
		Результат.Добавить(КодСимволаТекста);
	КонецЦикла;
	ЧтениеТекста.Закрыть();
	
	Возврат Результат;
	
КонецФункции

Процедура ЗаписатьФайлИзМассива(ИмяФайла, Массив)
	
	ЗаписьТекста = Новый ЗаписьТекста(ИмяФайла, "ISO-8859-1", Символы.ПС,, Символы.ПС);
	
	Для ИндексВМассиве = 0 По Массив.ВГраница() Цикл
		СимволИзМассива = Символ(Массив[ИндексВМассиве]);
		ЗаписьТекста.Записать(СимволИзМассива);
	КонецЦикла;
	ЗаписьТекста.Закрыть();
	
КонецПроцедуры

Процедура ЗаписатьСобытиеВЖурнал(Имя, Уровень = "Ошибка", Комментарий) Экспорт
	
	Уровни = Новый Соответствие;
	Уровни.Вставить("Информация", 		УровеньЖурналаРегистрации.Информация);
	Уровни.Вставить("Ошибка", 			УровеньЖурналаРегистрации.Ошибка);
	Уровни.Вставить("Предупреждение", 	УровеньЖурналаРегистрации.Предупреждение);
	Уровни.Вставить("Примечание", 		УровеньЖурналаРегистрации.Примечание);
	
	УровеньЖР = Уровни.Получить(Уровень);
	
	ЗаписьЖурналаРегистрации(Имя, УровеньЖР,,, Комментарий);
	
КонецПроцедуры

Функция ПривестиКЕдиномуТипуХранилища(Знач ТипХранилища)
	
	СоответствиеТиповХранилищ = Новый Соответствие;
	СоответствиеТиповХранилищ.Вставить("MY", Перечисления.ТипХранилищаСертификатов.ПерсональныеСертификаты);
	СоответствиеТиповХранилищ.Вставить("ADDRESSBOOK", Перечисления.ТипХранилищаСертификатов.СертификатыПолучателей);
	СоответствиеТиповХранилищ.Вставить("CA", Перечисления.ТипХранилищаСертификатов.СертификатыУдостоверяющихЦентров);
	СоответствиеТиповХранилищ.Вставить("ROOT", Перечисления.ТипХранилищаСертификатов.КорневыеСертификаты);
	
	Если ТипЗнч(ТипХранилища) = Тип("Строка") Тогда		
		Возврат СоответствиеТиповХранилищ.Получить(ВРег(ТипХранилища));
	ИначеЕсли ТипЗнч(ТипХранилища) = Тип("ПеречислениеСсылка.ТипХранилищаСертификатов") Тогда
		Возврат ТипХранилища;	
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ТипХранилища;
	
КонецФункции

Функция ИздателиИлиСубъектыОдинаковые(ИздательИлиСубъект1, ИздательИлиСубъект2)
	
	Для каждого ЭлементИздателяИлиСубъекта1 Из ИздательИлиСубъект1 Цикл
		ЗначениеЭлементаИздателяИлиСубъекта2 = Неопределено;
		Если ЗначениеЗаполнено(ЭлементИздателяИлиСубъекта1.Значение)
			И ИздательИлиСубъект2.Свойство(ЭлементИздателяИлиСубъекта1.Ключ, ЗначениеЭлементаИздателяИлиСубъекта2)
			И ЗначениеЗаполнено(ЗначениеЭлементаИздателяИлиСубъекта2)
			И СокрЛП(ЭлементИздателяИлиСубъекта1.Значение) <> СокрЛП(ЗначениеЭлементаИздателяИлиСубъекта2) Тогда
			
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

#Область ФункцииЧтенияPKCS7

Функция ПрочитатьEnvelopedData(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер); 
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	Версия = ПрочитатьЦелоеЧисло(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	
	СвойстваКриптосообщения.Вставить("Получатели", ПрочитатьRecipientInfos(ЧтениеДанных, СвойстваКриптосообщения, Настройки));
	СвойстваКриптосообщения.Вставить("Тип", "EnvelopedData");
	
	Возврат СвойстваКриптосообщения;

КонецФункции

Функция ПрочитатьSignedData(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер); 
	ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	Версия = ПрочитатьЦелоеЧисло(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	
	// DigestAlgorithmIdentifiers
	ПропуститьБлок(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер).РазмерБлока);
	
	Если Настройки.ПрочитатьПодписанныеДанные Тогда
		СвойстваКриптосообщения.Вставить("Содержимое", ПрочитатьContentInfo(ЧтениеДанных, СвойстваКриптосообщения));
	Иначе
		СвойстваПоследовательности = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		ПропуститьБлок(ЧтениеДанных, СвойстваПоследовательности.РазмерБлока);
	КонецЕсли;
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	СвойстваКриптосообщения.Вставить("Сертификаты", ПрочитатьCertificates(ЧтениеДанных, СвойстваКриптосообщения, Свойства));
	СвойстваКриптосообщения.Вставить("СпискиОтзываСертификатов", ПрочитатьCertificateRevocationLists(ЧтениеДанных, СвойстваКриптосообщения, Свойства));
	СвойстваКриптосообщения.Вставить("Подписанты", ПрочитатьSignerInfos(ЧтениеДанных, СвойстваКриптосообщения, Свойства, Настройки));
	СвойстваКриптосообщения.Вставить("Тип", "SignedData");
	
	Возврат СвойстваКриптосообщения;
	
КонецФункции

Функция ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения, Свойства = Неопределено, ПроверитьТип = Ложь)
	
	Если Свойства = Неопределено Тогда
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецЕсли;
	КонецБлока = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	Если ПроверитьТип И (Свойства.Класс <> "UNIVERSAL" ИЛИ Свойства.Тег <> 6) Тогда // algorithm OBJECT IDENTIFIER
		Возврат Неопределено;
	КонецЕсли;
	ИдентификаторАлгоритма = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства);
	
	ПропуститьБлок(ЧтениеДанных, КонецБлока - ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
	
	ОбъектныеИдентификаторы = Новый Соответствие;
	ОбъектныеИдентификаторы.Вставить("1.2.643.2.2.9", "GOST R 34.11-94");
	ОбъектныеИдентификаторы.Вставить("1.2.643.2.2.19", "GOST R 34.10-2001");
	
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.1.1", "GOST R 34.10-2012-256");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.1.2", "GOST R 34.10-2012-512");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.2.2", "GOST R 34.11-2012-256");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.2.3", "GOST R 34.11-2012-512");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.3.2", "GOST R 34.10-2012-256 + GOST R 34.11-2012-256");
	ОбъектныеИдентификаторы.Вставить("1.2.643.7.1.1.3.3", "GOST R 34.10-2012-512 + GOST R 34.11-2012-512");
	
	Идентификатор = ОбъектныеИдентификаторы.Получить(ИдентификаторАлгоритма);
	Если Идентификатор = Неопределено Тогда
		Идентификатор = ИдентификаторАлгоритма;
	КонецЕсли;
	
	Возврат Идентификатор;
	
КонецФункции

Функция ПрочитатьIssuerAndSerialNumber(ЧтениеДанных, СвойстваКриптосообщения, КонецБлока)
	
	Издатель = Новый Структура;
	
	// https://tools.ietf.org/html/rfc5652#section-10.2.4
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	Граница = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	
	Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		Идентификатор = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства);
		
		Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		Значение = ПрочитатьСтроку(ЧтениеДанных, Свойства);
		
		Издатель.Вставить("OID" + СтрЗаменить(Идентификатор, ".", "_"), Значение);
	КонецЦикла;
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	ИздательСерийныйНомер = Новый Структура;
	ИздательСерийныйНомер.Вставить("СерийныйНомер", ПрочитатьДвоичныеДанные(ЧтениеДанных, Свойства));
	ИздательСерийныйНомер.Вставить("Издатель", Издатель);
	ИздательСерийныйНомер.Вставить("Идентификатор", ИдентификаторСертификата(ИздательСерийныйНомер));
	
	ПропуститьБлок(ЧтениеДанных, КонецБлока - ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
	
	Возврат ИздательСерийныйНомер;
	
КонецФункции

Функция ПрочитатьRecipientInfos(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	Получатели = Новый Массив;
		
	СвойстваНабора = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	Граница = СвойстваНабора.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	
	Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл
		Получатели.Добавить(ПрочитатьRecipientInfo(ЧтениеДанных, СвойстваКриптосообщения, Настройки));
	КонецЦикла;
	
	Возврат Получатели;
	
КонецФункции

Функция ПрочитатьRecipientInfo(ЧтениеДанных, СвойстваКриптосообщения, Настройки)
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецБлокаRecipientInfo = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Версия = ПрочитатьЦелоеЧисло(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Получатель = ПрочитатьIssuerAndSerialNumber(
			ЧтениеДанных,
			СвойстваКриптосообщения,
			Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
		
	Иначе
		ПропуститьБлок(ЧтениеДанных, Свойства.РазмерБлока);
		Получатель = Новый Структура;
	КонецЕсли;
	
	Если Настройки.ПрочитатьАлгоритмПубличногоКлюча Тогда
		Получатель.Вставить("АлгоритмПубличногоКлюча", ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения));
	КонецЕсли;
	ПропуститьБлок(ЧтениеДанных, КонецБлокаRecipientInfo - ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
	
	Возврат Получатель;
	
КонецФункции

Функция ПрочитатьContentInfo(ЧтениеДанных, СвойстваКриптосообщения)
	
	Содержимое = Base64Значение("");
	
	СвойстваПоследовательности = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	Если СвойстваПоследовательности.РазмерБлока > 11 Тогда
		Тип = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
		ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
		Содержимое = ПрочитатьДвоичныеДанные(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	Иначе
		ПропуститьБлок(ЧтениеДанных, СвойстваПоследовательности.РазмерБлока);
	КонецЕсли;
	
	Возврат Содержимое;
	
КонецФункции

Функция ПрочитатьSignerInfos(ЧтениеДанных, СвойстваКриптосообщения, СвойстваНабора, Настройки)
	
	СертификатыСИдентификаторами = Новый Соответствие;
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Для Каждого Сертификат Из СвойстваКриптосообщения.Сертификаты Цикл
			СертификатыСИдентификаторами.Вставить(ИдентификаторСертификата(Новый Структура("Сертификат", Сертификат)), Сертификат);
		КонецЦикла;
	КонецЕсли;

	Подписанты = Новый Массив;
	
	Граница = СвойстваНабора.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	
	Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл
		Подписанты.Добавить(ПрочитатьSignerInfo(ЧтениеДанных, СвойстваКриптосообщения, СертификатыСИдентификаторами, Настройки));
	КонецЦикла;
	
	Возврат Подписанты;
	
КонецФункции

Функция ПрочитатьSignerInfo(ЧтениеДанных, СвойстваКриптосообщения, СертификатыСИдентификаторами, Настройки)
	
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецБлокаSignerInfo = Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Версия = ПрочитатьЦелоеЧисло(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	Свойства = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	Подписант = Новый Структура;
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		ИздательСерийныйНомер = ПрочитатьIssuerAndSerialNumber(
			ЧтениеДанных, СвойстваКриптосообщения, Свойства.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция());
		
		Подписант.Вставить("Сертификат", ИздательСерийныйНомер);
		
		Сертификат = СертификатыСИдентификаторами.Получить(Подписант.Сертификат.Идентификатор);
		Если ЗначениеЗаполнено(Сертификат) Тогда
			Подписант.Сертификат.Вставить("Сертификат", Сертификат);
		КонецЕсли;
		
	Иначе
		ПропуститьБлок(ЧтениеДанных, Свойства.РазмерБлока);
	КонецЕсли;
	
	Подписант.Вставить("АлгоритмХеширования", ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения));
	
	ПодписанныеАтрибуты = ПрочитатьAuthenticatedAttributes(ЧтениеДанных, СвойстваКриптосообщения, Свойства, Настройки);
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Подписант.Вставить("ПодписанныеАтрибуты", ПодписанныеАтрибуты);
	КонецЕсли;
	
	Подписант.Вставить("АлгоритмПодписи", ПрочитатьAlgorithmIdentifier(ЧтениеДанных, СвойстваКриптосообщения, Свойства));
	Подпись = ПрочитатьДвоичныеДанные(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
	
	НеподписанныеАтрибуты = ПрочитатьUnauthenticatedAttributes(ЧтениеДанных, СвойстваКриптосообщения, Свойства);
	Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
		Подписант.Вставить("НеподписанныеАтрибуты", НеподписанныеАтрибуты);
	КонецЕсли;
	
	Возврат Подписант;
	
КонецФункции

Функция ПрочитатьCertificates(ЧтениеДанных, СвойстваКриптосообщения, СвойстваБлока)
	
	Граница = СвойстваБлока.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();

	Сертификаты = Новый Массив;
	
	// certificates [0] IMPLICIT ExtendedCertificatesAndCertificates OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 0 Тогда
		Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл 
			Сертификат = ПрочитатьДвоичныеДанные(ЧтениеДанных, СвойстваБлока);
			Сертификаты.Добавить(Сертификат);
		КонецЦикла;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецЕсли;
	
	Возврат Сертификаты;
	
КонецФункции

Функция ПрочитатьCertificateRevocationLists(ЧтениеДанных, СвойстваКриптосообщения, СвойстваБлока)
	
	Граница = СвойстваБлока.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();

	СпискиОтзываСертификатов = Новый Массив;
	
	// crls  [1] IMPLICIT CertificateRevocationLists OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 1 Тогда
		Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < Граница Цикл 
			СписокОтзываСертификатов = ПрочитатьДвоичныеДанные(ЧтениеДанных, СвойстваБлока);
			СпискиОтзываСертификатов.Добавить(СписокОтзываСертификатов);
		КонецЦикла;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецЕсли;
	
	Возврат СпискиОтзываСертификатов;
	
КонецФункции

Функция ПрочитатьAuthenticatedAttributes(ЧтениеДанных, СвойстваКриптосообщения, СвойстваБлока, Настройки)
	
	ПодписанныеАтрибуты = Новый Структура;
	СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	// authenticatedAttributes [0] IMPLICIT Attributes OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 0 Тогда
		ГраницаБлока = СвойстваБлока.РазмерБлока + ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
		Если Настройки.ПрочитатьИздателяИСерийныйНомер Тогда
			Пока ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() < ГраницаБлока Цикл
				СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
				КонецБлока = ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() + СвойстваБлока.РазмерБлока;
				Идентификатор = ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер));
				Если Идентификатор = "1.2.840.113549.1.9.5" Тогда // signingTime
					ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
					ПодписанныеАтрибуты.Вставить(
						"ВремяПодписания", 
						ПрочитатьДату(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер))); 
				Иначе
					ПропуститьДо(ЧтениеДанных, КонецБлока);
				КонецЕсли;
			КонецЦикла;
			
		Иначе
			ПропуститьДо(ЧтениеДанных, ГраницаБлока);
		КонецЕсли;
		
		СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	КонецЕсли;
	
	Возврат ПодписанныеАтрибуты;
	
КонецФункции

Функция ПрочитатьUnauthenticatedAttributes(ЧтениеДанных, СвойстваКриптосообщения, СвойстваБлока)
	
	НеподписанныеАтрибуты = Новый Структура;
	
	Если ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция() >= СвойстваКриптосообщения.Размер Тогда
		Возврат НеподписанныеАтрибуты;
	КонецЕсли;
	
	СвойстваБлока = ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер);
	
	// unauthenticatedAttributes [1] IMPLICIT Attributes OPTIONAL
	Если СвойстваБлока.Класс = "CONTEXT-SPECIFIC" И СвойстваБлока.Тег = 1 Тогда
		ПропуститьБлок(ЧтениеДанных, ПрочитатьСвойстваБлока(ЧтениеДанных, СвойстваКриптосообщения.Размер).РазмерБлока);
	КонецЕсли;
	
	Возврат НеподписанныеАтрибуты;
	
КонецФункции

#КонецОбласти

#Область БазовыеФункцииЧтенияASN1

Функция ПрочитатьДату(ЧтениеДанных, Свойства)
	
	Если Свойства.Тег = 23 Тогда // UTCTime https://www.obj-sys.com/asn1tutorial/node15.html
		Возврат Дата("20" + Сред(ПрочитатьСтроку(ЧтениеДанных, Свойства), 1, 12));
	Иначе
		Возврат '0001-01-01';	
	КонецЕсли;
	
КонецФункции
	
Функция ПрочитатьДвоичныеДанные(ЧтениеДанных, Свойства)
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Поток = Новый ПотокВПамяти(Буфер);
	
	Возврат Поток.ЗакрытьИПолучитьДвоичныеДанные();
	
КонецФункции

Функция ПрочитатьСтроку(ЧтениеДанных, Свойства)
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Поток = Новый ПотокВПамяти(Буфер);
	
	Если Свойства.Тег = 30 Тогда // BMPString
		Кодировка = "utf-16";	
	ИначеЕсли Свойства.Тег = 28 Тогда // UniversalString
		Кодировка = "utf-32";
	Иначе
		Кодировка = "utf-8";	
	КонецЕсли;
	
	ЧтениеТекста = Новый ЧтениеТекста(Поток, Кодировка);
	Строка = ЧтениеТекста.Прочитать();
	ЧтениеТекста.Закрыть();
	Поток.Закрыть();
	
	// Дополнительная защита от ошибок сериализации из-за нечитаемых символов
	Возврат ОбщегоНазначенияЭДКОКлиентСервер.ЗаменитьНечитаемыеСимволы(Строка);
	
КонецФункции

Функция ПрочитатьЦелоеЧисло(ЧтениеДанных, Свойства)
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Значение = 0;
	Для Каждого Байт Из Буфер Цикл
		Значение = Значение * 256 + Байт;
	КонецЦикла;
	
	Возврат Значение;
	
КонецФункции

Функция ПрочитатьОбъектныйИдентификатор(ЧтениеДанных, Свойства)
	
	ОбъектныйИдентификатор = Новый Массив;
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(Свойства.РазмерБлока);
	Если Буфер[0] < 40 Тогда
		SID1 = 0;
	ИначеЕсли Буфер[0] < 80 Тогда
		SID1 = 1;
	Иначе
		SID1 = 2;
	КонецЕсли;
	ОбъектныйИдентификатор.Добавить(Формат(SID1, "ЧРГ=; ЧГ="));
	
	// SID2
	ОбъектныйИдентификатор.Добавить(Буфер[0] - SID1 * 40);
	
	// Остальные SID
	Для Индекс = 1 По Буфер.Размер - 1 Цикл
		ОбъектныйИдентификатор.Добавить(Формат(ПрочитатьСоставляющуюОбъектногоИдентификатора(Буфер, Индекс), "ЧРГ=; ЧГ="));
	КонецЦикла;
	
	Возврат СтрСоединить(ОбъектныйИдентификатор, ".");
		
КонецФункции

Функция ПрочитатьСоставляющуюОбъектногоИдентификатора(Буфер, ТекущийБайт)
	
	МаскаЗначащиеБиты = 127; // 0111 1111
	МаскаСтаршийБит = 128;   // 1000 0000
	
	Множители = Новый Массив;	
	Пока Истина Цикл
		Байт = Буфер[ТекущийБайт];
		ДлинныйРазмер = Булево(ОперацияПобитовоеИ(Буфер[ТекущийБайт], МаскаСтаршийБит));
	 	Если ДлинныйРазмер Тогда
			Множители.Добавить(ОперацияПобитовоеИ(Буфер[ТекущийБайт], МаскаЗначащиеБиты))
		Иначе
			Множители.Добавить(Байт);
			Прервать;
		КонецЕсли;
		
		ТекущийБайт = ТекущийБайт + 1;
		Если ТекущийБайт > Буфер.Размер Тогда
			ВызватьИсключение("Ошибка разбора OID");
		КонецЕсли;
	КонецЦикла;
	
	Результат = 0;
	Для Индекс = 0 По Множители.ВГраница() Цикл
		Показатель = Множители.ВГраница() - Индекс;
		Результат = Результат + Множители[Индекс] * Pow(128, Показатель);
	КонецЦикла;

	Возврат Результат;
	
КонецФункции

Функция ПолучитьНаименованиеСертификата(МассивOID)
	
	Наименование = "";
	
	Для Каждого ЭлементOID Из МассивOID Цикл
		Если ЭлементOID.oid = "OID2_5_4_3" Тогда
			Наименование = ОбщегоНазначенияЭДКОКлиентСервер.ЗаменитьНечитаемыеСимволы(ЭлементOID.value);
			Возврат Наименование;
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ЭлементOID Из МассивOID Цикл
		Если ЭлементOID.oid = "CN" Тогда
			Наименование = ОбщегоНазначенияЭДКОКлиентСервер.ЗаменитьНечитаемыеСимволы(ЭлементOID.value);
			Возврат Наименование;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Наименование;
	
КонецФункции

Функция ПреобразоватьМассивOIDВСтруктуру(МассивOID)
	
	СоответствиеOID = СоответствиеOIDИмя();
	
	Результат = Новый Структура;
	
	Для Каждого ЭлементOID Из МассивOID Цикл
		Если СтрНачинаетсяС(ЭлементOID.oid, "OID") Тогда
			OID = СоответствиеOID.Получить(Сред(ЭлементOID.oid, 4));
			Если OID = Неопределено Тогда
				OID = ЭлементOID.oid;
			КонецЕсли;
			Результат.Вставить(OID, ОбщегоНазначенияЭДКОКлиентСервер.ЗаменитьНечитаемыеСимволы(ЭлементOID.value));
		КонецЕсли;
	КонецЦикла;
	
	МассивИмен = Новый Массив;
	Для каждого ЭлементСоответствия Из СоответствиеOID Цикл
		МассивИмен.Добавить(ЭлементСоответствия.Значение);
	КонецЦикла;
	
	Для каждого ЭлементOID Из МассивOID Цикл
		Если НЕ СтрНачинаетсяС(ЭлементOID.oid, "OID") Тогда
			ИмяЭлемента = СокрЛП(ЭлементOID.oid);
			ИндексИмени = МассивИмен.Найти(ИмяЭлемента);
			Если ИндексИмени = Неопределено Тогда
				ИмяЭлемента = ВРег(ИмяЭлемента);
				ИндексИмени = МассивИмен.Найти(ИмяЭлемента);
			КонецЕсли;
			Если ИндексИмени <> Неопределено Тогда
				ИмяЭлемента = МассивИмен[ИндексИмени];
				Если НЕ Результат.Свойство(ИмяЭлемента) Тогда
					Результат.Вставить(ИмяЭлемента, ОбщегоНазначенияЭДКОКлиентСервер.ЗаменитьНечитаемыеСимволы(ЭлементOID.value));
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ПреобразоватьСтруктуруВСтроку(Структура)
	
	Компоненты = Новый Массив;
	Для Каждого КлючЗначение Из Структура Цикл
		Компоненты.Добавить(СтрШаблон("%1=%2", КлючЗначение.Ключ, КлючЗначение.Значение));
	КонецЦикла;
	
	Возврат СтрСоединить(Компоненты, ",");
	
КонецФункции

Функция СоответствиеOIDИмя()
	
	СоответствиеOID = Новый Соответствие;
	СоответствиеOID.Вставить("2_5_4_3", "CN"); // commonName
	СоответствиеOID.Вставить("2_5_4_6", "C"); // countryName
	СоответствиеOID.Вставить("2_5_4_8", "ST"); // stateOrProvinceName
	СоответствиеOID.Вставить("2_5_4_7", "L"); // localityName
	СоответствиеOID.Вставить("2_5_4_9", "STREET"); // streetAddress
	СоответствиеOID.Вставить("2_5_4_10", "O"); // organizationName
	СоответствиеOID.Вставить("2_5_4_11", "OU"); // organizationUnitName
	СоответствиеOID.Вставить("2_5_4_12", "T"); // title
	СоответствиеOID.Вставить("1_2_643_100_1", "OGRN"); // ОГРН
	СоответствиеOID.Вставить("1_2_643_100_5", "OGRNIP"); // ОГРНИП
	СоответствиеOID.Вставить("1_2_643_100_3", "SNILS"); // СНИЛС
	СоответствиеOID.Вставить("1_2_643_3_131_1_1", "INN"); // ИНН
	СоответствиеOID.Вставить("1_2_840_113549_1_9_1", "E"); // emailAddress	
	СоответствиеOID.Вставить("2_5_4_4", "SN"); // surname
	СоответствиеOID.Вставить("2_5_4_42", "GN"); // givenName
	
	Возврат СоответствиеOID;
	
КонецФункции

Функция ЭтоОблачныйСертификат(Сертификат) Экспорт

	Если ЭлектроннаяПодписьВМоделиСервиса.ИспользованиеВозможно() Тогда
		Попытка
			СервисКриптографии.ПолучитьНастройкиПолученияВременныхПаролей(Сертификат.Идентификатор);
			Возврат Истина;
		Исключение
			ТекстИсключения = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
			Если СтрНайти(ТекстИсключения, "InvalidCertificateIdError") Тогда
				Возврат Ложь;
			Иначе
				Возврат Неопределено;
			КонецЕсли;
		КонецПопытки;
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
КонецФункции

Функция КлассТегаБлока(Байт)

	МаскаКлассБлока = 192; // 1100 0000	
	Класс = ОперацияПобитовоеИ(Байт, МаскаКлассБлока);
	
	Если Класс = 0 Тогда
		Возврат "UNIVERSAL";
	ИначеЕсли Класс = 192 Тогда
		Возврат "PRIVATE";
	ИначеЕсли Класс = 64 Тогда
		Возврат "APPLICATION";
	Иначе
		Возврат "CONTEXT-SPECIFIC";
	КонецЕсли;

КонецФункции

Функция ТегБлока(Байт)
	
	МаскаТег = 31; // 0001 1111
	Возврат ОперацияПобитовоеИ(Байт, МаскаТег);

КонецФункции

Функция ПрочитатьСвойстваБлока(ЧтениеДанных, РазмерДанных)
	
	Свойства = Новый Структура;
	
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(1);

	МаскаЗначащиеБиты = 127; // 0111 1111
	МаскаСтаршийБит = 128;   // 1000 0000
	
	Свойства.Вставить("Класс", КлассТегаБлока(Буфер[0]));
	Свойства.Вставить("Тег", ТегБлока(Буфер[0]));
		
	// Прочитать размер блока
	Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(1);
	Если Буфер[0] = 128 Тогда // Используется потоковый способ кодирования, т.е. размер блока не указан (окончание блока 00 00)
		РазмерБлока = -1;
	Иначе
		ДлинныйРазмер = Булево(ОперацияПобитовоеИ(Буфер[0], МаскаСтаршийБит));
		Если ДлинныйРазмер Тогда
			КоличествоБайтовПодРазмер = ОперацияПобитовоеИ(Буфер[0], МаскаЗначащиеБиты);
			Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(КоличествоБайтовПодРазмер);
			РазмерБлока = 0;
			Для Каждого Байт Из Буфер Цикл
				РазмерБлока = РазмерБлока * 256 + Байт;
				
				Если РазмерБлока > РазмерДанных Тогда
					ВызватьИсключение("Размер блока превышает размер файла");
				КонецЕсли;
			КонецЦикла;
		Иначе
			РазмерБлока = ОперацияПобитовоеИ(Буфер[0], МаскаЗначащиеБиты);	
		КонецЕсли;
	КонецЕсли;
	
	Если РазмерБлока > РазмерДанных Тогда
		ВызватьИсключение("Размер блока превышает размер файла");
	КонецЕсли;
	
	Свойства.Вставить("РазмерБлока", РазмерБлока);
	
	Возврат Свойства;
	
КонецФункции

Процедура ПропуститьБлок(ЧтениеДанных, СколькоБайт)
	
	Если СколькоБайт = -1 Тогда
		МаксимальнаяДлинаВЗаголовке = 8192;
		НомерБайта = 1;
		Пока Истина Цикл
			Пока Истина Цикл
				Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(1);
				Если Буфер.Размер = 0 ИЛИ НомерБайта > МаксимальнаяДлинаВЗаголовке Тогда
					Возврат;
				КонецЕсли;
				НомерБайта = НомерБайта + 1;
				Если Буфер[0] = 0 Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Буфер = ЧтениеДанных.ПрочитатьВБуферДвоичныхДанных(1);
			Если Буфер.Размер = 0 ИЛИ НомерБайта > МаксимальнаяДлинаВЗаголовке Тогда
				Возврат;
			КонецЕсли;
			НомерБайта = НомерБайта + 1;
			Если Буфер[0] = 0 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		
	Иначе
		ЧтениеДанных.Пропустить(СколькоБайт);
	КонецЕсли;
	
КонецПроцедуры

Процедура ПропуститьДо(ЧтениеДанных, Граница)
	
	ТекущаяПозиция = ЧтениеДанных.ИсходныйПоток().ТекущаяПозиция();
	Если ТекущаяПозиция >= Граница Тогда
		Возврат;
	КонецЕсли;
	
	ЧтениеДанных.Пропустить(Граница - ТекущаяПозиция);
	
КонецПроцедуры

Функция ОперацияПобитовоеИ(Байт1, Байт2)
	
	Буфер1 = БуферИзБайта(Байт1);
	Буфер2 = БуферИзБайта(Байт2);
	Буфер1.ЗаписатьПобитовоеИ(0, Буфер2);
	
	Возврат Буфер1[0];
	
КонецФункции

Функция БуферИзБайта(Байт)
	
	Буфер = Новый БуферДвоичныхДанных(1);
	Буфер[0] = Байт;
	
	Возврат Буфер;
	
КонецФункции

#КонецОбласти

#КонецОбласти
